<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>docker模块的使用</title>
      <link href="/2025/docker-mo-kuai-de-shi-yong/"/>
      <url>/2025/docker-mo-kuai-de-shi-yong/</url>
      
        <content type="html"><![CDATA[<p>创建docker客户端</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">import</span> docker<span class="token comment" spellcheck="true"># 创建 Docker 客户端</span>client <span class="token operator">=</span> docker<span class="token punctuation">.</span>from_env<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">#client = docker.DockerClient(base_url="tcp://192.168.137.129:2375")</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="镜像管理"><a href="#镜像管理" class="headerlink" title="镜像管理"></a>镜像管理</h3><p>列出所有镜像</p><pre class="line-numbers language-python"><code class="language-python">images <span class="token operator">=</span> client<span class="token punctuation">.</span>images<span class="token punctuation">.</span>list<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">for</span> image <span class="token keyword">in</span> images<span class="token punctuation">:</span>    dics <span class="token operator">=</span> json<span class="token punctuation">.</span>loads<span class="token punctuation">(</span>json<span class="token punctuation">.</span>dumps<span class="token punctuation">(</span>image<span class="token punctuation">.</span>attrs<span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span>dics<span class="token punctuation">[</span><span class="token string">'RepoTags'</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>查看镜像信息</p><pre class="line-numbers language-python"><code class="language-python">images <span class="token operator">=</span> client<span class="token punctuation">.</span>images<span class="token punctuation">.</span>list<span class="token punctuation">(</span><span class="token punctuation">)</span>image_json <span class="token operator">=</span> <span class="token punctuation">[</span>json<span class="token punctuation">.</span>dumps<span class="token punctuation">(</span>image<span class="token punctuation">.</span>attrs<span class="token punctuation">)</span> <span class="token keyword">for</span> image <span class="token keyword">in</span> images<span class="token punctuation">]</span><span class="token keyword">for</span> img <span class="token keyword">in</span> image_json<span class="token punctuation">:</span>    <span class="token keyword">print</span><span class="token punctuation">(</span>img<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><strong>方法</strong></p><p>通过镜像 ID 或镜像名称来移除镜像</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">remove_image</span><span class="token punctuation">(</span>image_name_or_id<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">try</span><span class="token punctuation">:</span>        <span class="token comment" spellcheck="true"># 移除镜像</span>        client<span class="token punctuation">.</span>images<span class="token punctuation">.</span>remove<span class="token punctuation">(</span>image_name_or_id<span class="token punctuation">)</span>        <span class="token keyword">print</span><span class="token punctuation">(</span>f<span class="token string">"Image '{image_name_or_id}' removed successfully."</span><span class="token punctuation">)</span>    <span class="token keyword">except</span> docker<span class="token punctuation">.</span>errors<span class="token punctuation">.</span>ImageNotFound<span class="token punctuation">:</span>        <span class="token keyword">print</span><span class="token punctuation">(</span>f<span class="token string">"Image '{image_name_or_id}' not found."</span><span class="token punctuation">)</span>    <span class="token keyword">except</span> docker<span class="token punctuation">.</span>errors<span class="token punctuation">.</span>APIError <span class="token keyword">as</span> e<span class="token punctuation">:</span>        <span class="token keyword">print</span><span class="token punctuation">(</span>f<span class="token string">"Error removing image '{image_name_or_id}': {e}"</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>删除所有未使用的镜像（即悬空镜像）</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">prune_unused_images</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">try</span><span class="token punctuation">:</span>        client<span class="token punctuation">.</span>images<span class="token punctuation">.</span>prune<span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"Unused images pruned successfully."</span><span class="token punctuation">)</span>    <span class="token keyword">except</span> docker<span class="token punctuation">.</span>errors<span class="token punctuation">.</span>APIError <span class="token keyword">as</span> e<span class="token punctuation">:</span>        <span class="token keyword">print</span><span class="token punctuation">(</span>f<span class="token string">"Error pruning unused images: {e}"</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>构建镜像</p><pre class="line-numbers language-python"><code class="language-python">build_args <span class="token operator">=</span> <span class="token punctuation">{</span>    <span class="token string">'URL'</span><span class="token punctuation">:</span> <span class="token string">'https://mirrors.aliyun.com/postgresql/source'</span><span class="token punctuation">,</span>    <span class="token string">'PGVERSION'</span><span class="token punctuation">:</span> <span class="token string">'15.10'</span><span class="token punctuation">}</span>logs<span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token keyword">try</span><span class="token punctuation">:</span>    image<span class="token punctuation">,</span> logs <span class="token operator">=</span> client<span class="token punctuation">.</span>images<span class="token punctuation">.</span>build<span class="token punctuation">(</span>        path<span class="token operator">=</span>BASE_DIR <span class="token operator">+</span> <span class="token string">'/scripts'</span><span class="token punctuation">,</span>        tag<span class="token operator">=</span><span class="token string">'postgresql:15.10'</span><span class="token punctuation">,</span>        buildargs<span class="token operator">=</span>build_args<span class="token punctuation">,</span>        rm<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">,</span>    <span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span>logs<span class="token punctuation">)</span><span class="token keyword">except</span> docker<span class="token punctuation">.</span>errors<span class="token punctuation">.</span>DockerException <span class="token keyword">as</span> e<span class="token punctuation">:</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'Error building image:'</span><span class="token punctuation">,</span> e<span class="token punctuation">)</span><span class="token keyword">finally</span><span class="token punctuation">:</span>    <span class="token comment" spellcheck="true"># 遍历日志输出</span>    <span class="token keyword">for</span> line <span class="token keyword">in</span> logs<span class="token punctuation">:</span>        <span class="token keyword">if</span> <span class="token string">'stream'</span> <span class="token keyword">in</span> line<span class="token punctuation">:</span>            stream <span class="token operator">=</span> line<span class="token punctuation">[</span><span class="token string">'stream'</span><span class="token punctuation">]</span><span class="token punctuation">.</span>strip<span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true"># 去掉可能的前后空格</span>            <span class="token keyword">if</span> stream<span class="token punctuation">:</span>  <span class="token comment" spellcheck="true"># 只有非空内容才打印</span>                <span class="token keyword">print</span><span class="token punctuation">(</span>stream<span class="token punctuation">)</span>        <span class="token keyword">elif</span> <span class="token string">'error'</span> <span class="token keyword">in</span> line<span class="token punctuation">:</span>            <span class="token keyword">print</span><span class="token punctuation">(</span>f<span class="token string">"Error: {line['error']}"</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true"># 如果有错误，打印错误信息</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="容器管理"><a href="#容器管理" class="headerlink" title="容器管理"></a>容器管理</h3><p>创建并启动容器</p><pre class="line-numbers language-python"><code class="language-python">container <span class="token operator">=</span> client<span class="token punctuation">.</span>containers<span class="token punctuation">.</span>run<span class="token punctuation">(</span><span class="token string">'alpine'</span><span class="token punctuation">,</span> <span class="token string">'echo hello world'</span><span class="token punctuation">,</span> detach<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>container<span class="token punctuation">.</span>logs<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true"># 获取容器的日志输出</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>列出所有容器</p><pre class="line-numbers language-python"><code class="language-python">containers <span class="token operator">=</span> client<span class="token punctuation">.</span>containers<span class="token punctuation">.</span>list<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">for</span> container <span class="token keyword">in</span> containers<span class="token punctuation">:</span>    <span class="token keyword">print</span><span class="token punctuation">(</span>container<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p> 获取所有容器（包括停止的容器）</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">get_all_containers</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">try</span><span class="token punctuation">:</span>        <span class="token comment" spellcheck="true"># 获取所有容器的信息，包含正在运行和已停止的容器</span>        containers <span class="token operator">=</span> client<span class="token punctuation">.</span>containers<span class="token punctuation">.</span>list<span class="token punctuation">(</span>all<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">)</span>        <span class="token comment" spellcheck="true"># 将每个容器信息格式化为 JSON</span>        containers_json <span class="token operator">=</span> <span class="token punctuation">[</span>json<span class="token punctuation">.</span>dumps<span class="token punctuation">(</span>container<span class="token punctuation">.</span>attrs<span class="token punctuation">)</span> <span class="token keyword">for</span> container <span class="token keyword">in</span> containers<span class="token punctuation">]</span>        <span class="token comment" spellcheck="true"># 输出容器的 JSON 信息</span>        <span class="token keyword">for</span> container_info <span class="token keyword">in</span> containers_json<span class="token punctuation">:</span>            <span class="token keyword">print</span><span class="token punctuation">(</span>container_info<span class="token punctuation">)</span>    <span class="token keyword">except</span> docker<span class="token punctuation">.</span>errors<span class="token punctuation">.</span>APIError <span class="token keyword">as</span> e<span class="token punctuation">:</span>        <span class="token keyword">print</span><span class="token punctuation">(</span>f<span class="token string">"Error retrieving container list: {e}"</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>查看容器的详细信息</p><pre class="line-numbers language-python"><code class="language-python">container <span class="token operator">=</span> client<span class="token punctuation">.</span>containers<span class="token punctuation">.</span>get<span class="token punctuation">(</span><span class="token string">'postgresql_16.61'</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true"># 获取指定容器</span><span class="token keyword">print</span><span class="token punctuation">(</span>container<span class="token punctuation">.</span>attrs<span class="token punctuation">)</span>  <span class="token comment" spellcheck="true"># 获取容器的详细信息</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>停止容器</p><pre class="line-numbers language-python"><code class="language-python">container<span class="token punctuation">.</span>stop<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>删除容器</p><pre class="line-numbers language-python"><code class="language-python">container<span class="token punctuation">.</span>remove<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="容器网络"><a href="#容器网络" class="headerlink" title="容器网络"></a>容器网络</h3><p>列出所有网络</p><pre class="line-numbers language-python"><code class="language-python">networks <span class="token operator">=</span> client<span class="token punctuation">.</span>networks<span class="token punctuation">.</span>list<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">for</span> network <span class="token keyword">in</span> networks<span class="token punctuation">:</span>    <span class="token keyword">print</span><span class="token punctuation">(</span>network<span class="token punctuation">.</span>name<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>创建网络</p><pre class="line-numbers language-python"><code class="language-python">network <span class="token operator">=</span> client<span class="token punctuation">.</span>networks<span class="token punctuation">.</span>create<span class="token punctuation">(</span><span class="token string">'my_network'</span><span class="token punctuation">,</span> driver<span class="token operator">=</span><span class="token string">'bridge'</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>创建自定义网络</p><pre class="line-numbers language-python"><code class="language-python"><span class="token comment" spellcheck="true"># 定义网络名称</span>network_name <span class="token operator">=</span> <span class="token string">"postgrenetwork"</span><span class="token comment" spellcheck="true"># 尝试获取网络</span><span class="token keyword">try</span><span class="token punctuation">:</span>    <span class="token comment" spellcheck="true"># 查找指定名称的网络</span>    network <span class="token operator">=</span> client<span class="token punctuation">.</span>networks<span class="token punctuation">.</span>get<span class="token punctuation">(</span>network_name<span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span>f<span class="token string">"Network '{network_name}' already exists."</span><span class="token punctuation">)</span><span class="token keyword">except</span> NotFound<span class="token punctuation">:</span>    <span class="token comment" spellcheck="true"># 如果网络不存在，则创建该网络</span>    <span class="token keyword">print</span><span class="token punctuation">(</span>f<span class="token string">"Network '{network_name}' does not exist. Creating..."</span><span class="token punctuation">)</span>    network <span class="token operator">=</span> client<span class="token punctuation">.</span>networks<span class="token punctuation">.</span>create<span class="token punctuation">(</span>        network_name<span class="token punctuation">,</span>        driver<span class="token operator">=</span><span class="token string">"bridge"</span><span class="token punctuation">,</span>        ipam<span class="token operator">=</span>docker<span class="token punctuation">.</span>types<span class="token punctuation">.</span>IPAMConfig<span class="token punctuation">(</span>            pool_configs<span class="token operator">=</span><span class="token punctuation">[</span>docker<span class="token punctuation">.</span>types<span class="token punctuation">.</span>IPAMPool<span class="token punctuation">(</span>subnet<span class="token operator">=</span><span class="token string">"172.19.1.0/24"</span><span class="token punctuation">)</span><span class="token punctuation">]</span>        <span class="token punctuation">)</span>    <span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span>f<span class="token string">"Network '{network_name}' created successfully."</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>获取所有容器 IP</p><pre class="line-numbers language-python"><code class="language-python">containers <span class="token operator">=</span> client<span class="token punctuation">.</span>containers<span class="token punctuation">.</span>list<span class="token punctuation">(</span>all<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 获取每个容器的 IP 地址</span>ip_address_list <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token keyword">for</span> container <span class="token keyword">in</span> containers<span class="token punctuation">:</span>    <span class="token comment" spellcheck="true"># 获取容器的网络信息</span>    networks <span class="token operator">=</span> container<span class="token punctuation">.</span>attrs<span class="token punctuation">.</span>get<span class="token punctuation">(</span><span class="token string">'NetworkSettings'</span><span class="token punctuation">,</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span>get<span class="token punctuation">(</span><span class="token string">'Networks'</span><span class="token punctuation">,</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span>    <span class="token comment" spellcheck="true"># 遍历所有网络，打印每个容器的 IP 地址</span>    <span class="token keyword">for</span> network_name<span class="token punctuation">,</span> network_info <span class="token keyword">in</span> networks<span class="token punctuation">.</span>items<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        ip_address <span class="token operator">=</span> network_info<span class="token punctuation">.</span>get<span class="token punctuation">(</span><span class="token string">'IPAddress'</span><span class="token punctuation">)</span>        ip_address_list<span class="token punctuation">.</span>append<span class="token punctuation">(</span>ip_address<span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>ip_address_list<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="容器日志"><a href="#容器日志" class="headerlink" title="容器日志"></a>容器日志</h3><p>查看日志</p><pre class="line-numbers language-python"><code class="language-python">container <span class="token operator">=</span> client<span class="token punctuation">.</span>containers<span class="token punctuation">.</span>get<span class="token punctuation">(</span><span class="token string">'container_id_or_name'</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>container<span class="token punctuation">.</span>logs<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="执行命令"><a href="#执行命令" class="headerlink" title="执行命令"></a>执行命令</h3><pre class="line-numbers language-python"><code class="language-python"><span class="token comment" spellcheck="true"># 获取已经存在的容器</span>container_name <span class="token operator">=</span> <span class="token string">"postgresql_16.6"</span><span class="token keyword">try</span><span class="token punctuation">:</span>    container <span class="token operator">=</span> client<span class="token punctuation">.</span>containers<span class="token punctuation">.</span>get<span class="token punctuation">(</span>container_name<span class="token punctuation">)</span>    exec_command <span class="token operator">=</span> container<span class="token punctuation">.</span>exec_run<span class="token punctuation">(</span><span class="token string">"echo 'Hello!'"</span><span class="token punctuation">)</span>    <span class="token comment" spellcheck="true"># 执行命令并获取结果</span>    output <span class="token operator">=</span> exec_command<span class="token punctuation">.</span>output<span class="token punctuation">.</span>decode<span class="token punctuation">(</span><span class="token string">"utf-8"</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true"># 获取输出结果并解码</span>    <span class="token keyword">print</span><span class="token punctuation">(</span>output<span class="token punctuation">)</span>    <span class="token comment" spellcheck="true"># 如果需要执行更多复杂的 shell 命令（例如获取 shell 会话），你可以使用类似以下的命令</span>    exec_command <span class="token operator">=</span> container<span class="token punctuation">.</span>exec_run<span class="token punctuation">(</span><span class="token string">"pg_ctl start"</span><span class="token punctuation">)</span>    output <span class="token operator">=</span> exec_command<span class="token punctuation">.</span>output<span class="token punctuation">.</span>decode<span class="token punctuation">(</span><span class="token string">"utf-8"</span><span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span>output<span class="token punctuation">)</span><span class="token keyword">except</span> docker<span class="token punctuation">.</span>errors<span class="token punctuation">.</span>NotFound<span class="token punctuation">:</span>    <span class="token keyword">print</span><span class="token punctuation">(</span>f<span class="token string">"Container {container_name} not found!"</span><span class="token punctuation">)</span><span class="token keyword">except</span> Exception <span class="token keyword">as</span> e<span class="token punctuation">:</span>    <span class="token keyword">print</span><span class="token punctuation">(</span>f<span class="token string">"An error occurred: {e}"</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> postgresql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> postgresql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>在POSTGRESQL中创建和刷新物化视图</title>
      <link href="/2024/zai-postgresql-zhong-chuang-jian-he-shua-xin-wu-hua-shi-tu/"/>
      <url>/2024/zai-postgresql-zhong-chuang-jian-he-shua-xin-wu-hua-shi-tu/</url>
      
        <content type="html"><![CDATA[<p>“物化视图”是一个数据库对象，它存储预先计算的数据库查询的结果，并可以根据需要轻松刷新该结果。物化视图是几乎所有高级数据库系统的一个组成部分。当然，PostgreSQL 还提供对物化视图的支持，并为最终用户提供强大的工具来处理更耗时的请求。</p><span id="more"></span><p>现在的主要问题是：有哪些陷阱，以及如何利用物化视图？让我们深入了解一下。</p><h2 id="创建物化视图"><a href="#创建物化视图" class="headerlink" title="创建物化视图"></a><strong>创建物化视图</strong></h2><p>在我们真正查看物化视图并弄清楚它们是如何工作之前，我们必须导入一些示例数据，我们可以将其用作计算的基础：</p><pre class="line-numbers language-sql"><code class="language-sql">demo<span class="token operator">=</span><span class="token comment" spellcheck="true"># CREATE TABLE t_demo (grp int, data numeric);</span><span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span>demo<span class="token operator">=</span><span class="token comment" spellcheck="true"># INSERT INTO t_demo SELECT 1, random()</span>       <span class="token keyword">FROM</span> generate_series<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">5000000</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">INSERT</span> <span class="token number">0</span> <span class="token number">5000000</span>demo<span class="token operator">=</span><span class="token comment" spellcheck="true"># INSERT INTO t_demo SELECT 2, random()</span>       <span class="token keyword">FROM</span> generate_series<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">5000000</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">INSERT</span> <span class="token number">0</span> <span class="token number">5000000</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="要在-PostgreSQL-中创建物化视图，我们可以使用以下语法规范："><a href="#要在-PostgreSQL-中创建物化视图，我们可以使用以下语法规范：" class="headerlink" title="要在 PostgreSQL 中创建物化视图，我们可以使用以下语法规范："></a>要在 PostgreSQL 中创建物化视图，我们可以使用以下语法规范：</h3><pre class="line-numbers language-sql"><code class="language-sql">demo<span class="token operator">=</span><span class="token comment" spellcheck="true"># h CREATE MATERIALIZED VIEW</span>Command:   <span class="token keyword">CREATE</span> MATERIALIZED <span class="token keyword">VIEW</span>Description: define <span class="token number">a</span> new materialized <span class="token keyword">view</span>Syntax:<span class="token keyword">CREATE</span> MATERIALIZED <span class="token keyword">VIEW</span> <span class="token punctuation">[</span> <span class="token keyword">IF</span> <span class="token operator">NOT</span> <span class="token keyword">EXISTS</span> <span class="token punctuation">]</span> table_name     <span class="token punctuation">[</span> <span class="token punctuation">(</span>column_name <span class="token punctuation">[</span><span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">]</span> <span class="token punctuation">)</span> <span class="token punctuation">]</span>     <span class="token punctuation">[</span> <span class="token keyword">USING</span> method <span class="token punctuation">]</span>     <span class="token punctuation">[</span> <span class="token keyword">WITH</span> <span class="token punctuation">(</span> storage_parameter <span class="token punctuation">[</span><span class="token operator">=</span> <span class="token keyword">value</span><span class="token punctuation">]</span> <span class="token punctuation">[</span><span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">]</span> <span class="token punctuation">)</span> <span class="token punctuation">]</span>     <span class="token punctuation">[</span> <span class="token keyword">TABLESPACE</span> tablespace_name <span class="token punctuation">]</span>     <span class="token keyword">AS</span> query     <span class="token punctuation">[</span> <span class="token keyword">WITH</span> <span class="token punctuation">[</span> <span class="token keyword">NO</span> <span class="token punctuation">]</span> <span class="token keyword">DATA</span> <span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>基本上，物化视图有一个名称、一些参数，并且基于查询。</p><h3 id="这是物化视图的示例："><a href="#这是物化视图的示例：" class="headerlink" title="这是物化视图的示例："></a>这是物化视图的示例：</h3><pre class="line-numbers language-sql"><code class="language-sql">demo<span class="token operator">=</span><span class="token comment" spellcheck="true"># CREATE MATERIALIZED VIEW mat_view AS</span>           <span class="token keyword">SELECT</span>   grp<span class="token punctuation">,</span> <span class="token function">avg</span><span class="token punctuation">(</span><span class="token keyword">data</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">count</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">)</span>           <span class="token keyword">FROM</span>     t_demo           <span class="token keyword">GROUP</span> <span class="token keyword">BY</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token keyword">SELECT</span> <span class="token number">2</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这里真正需要注意的是物化视图与基础表相比的大小：</p><pre class="line-numbers language-sql"><code class="language-sql">demo<span class="token operator">=</span><span class="token comment" spellcheck="true"># d+</span>List <span class="token keyword">of</span> relations<span class="token keyword">Schema</span> <span class="token operator">|</span> Name     <span class="token operator">|</span> <span class="token keyword">Type</span>              <span class="token operator">|</span> Owner <span class="token operator">|</span> Persistence <span class="token operator">|</span> Size   <span class="token operator">|</span> Description<span class="token comment" spellcheck="true">-------+----------+-------------------+-------+-------------+--------+-------------</span><span class="token keyword">public</span> <span class="token operator">|</span> mat_view <span class="token operator">|</span> materialized <span class="token keyword">view</span> <span class="token operator">|</span> hs    <span class="token operator">|</span> permanent   <span class="token operator">|</span> <span class="token number">16</span> kB  <span class="token operator">|</span><span class="token keyword">public</span> <span class="token operator">|</span> t_demo   <span class="token operator">|</span> <span class="token keyword">table</span>             <span class="token operator">|</span> hs    <span class="token operator">|</span> permanent   <span class="token operator">|</span> <span class="token number">423</span> MB <span class="token operator">|</span><span class="token punctuation">(</span><span class="token number">2</span> <span class="token keyword">rows</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>423 MB 与 16 KB 是一个真正的区别。如果你想查询物化视图，你可以像查询普通的 PostgreSQL 表一样进行：</p><pre class="line-numbers language-sql"><code class="language-sql">demo<span class="token operator">=</span><span class="token comment" spellcheck="true"># SELECT * FROM mat_view;</span> grp <span class="token operator">|</span>       avg       <span class="token operator">|</span>  count  <span class="token comment" spellcheck="true">-----+--------------------------+---------</span>   <span class="token number">1</span> <span class="token operator">|</span> <span class="token number">0.500091604165533141153</span>  <span class="token operator">|</span> <span class="token number">5000000</span>   <span class="token number">2</span> <span class="token operator">|</span> <span class="token number">0.499893365960709086730</span>  <span class="token operator">|</span> <span class="token number">5000000</span><span class="token punctuation">(</span><span class="token number">2</span> <span class="token keyword">rows</span><span class="token punctuation">)</span>demo<span class="token operator">=</span><span class="token comment" spellcheck="true"># explain SELECT * FROM mat_view;</span>                      QUERY <span class="token keyword">PLAN</span>                      <span class="token comment" spellcheck="true">-------------------------------------------------------------</span> Seq Scan <span class="token keyword">on</span> mat_view  <span class="token punctuation">(</span>cost<span class="token operator">=</span><span class="token number">0.00</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token number">21.30</span> <span class="token keyword">rows</span><span class="token operator">=</span><span class="token number">1130</span> width<span class="token operator">=</span><span class="token number">44</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token number">1</span> <span class="token keyword">row</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>查看执行计划（<code>explain</code>）可以看出普通表和物化视图没有区别。我们可以简单的查询一下数据。<br>此时，唯一次优的是查询优化器的估计（= 1130 行）。不过，这很容易解决。</p><h3 id="该过程与任何其他表相同："><a href="#该过程与任何其他表相同：" class="headerlink" title="该过程与任何其他表相同："></a>该过程与任何其他表相同：</h3><pre class="line-numbers language-sql"><code class="language-sql">demo<span class="token operator">=</span><span class="token comment" spellcheck="true"># ANALYZE;</span><span class="token keyword">ANALYZE</span>demo<span class="token operator">=</span><span class="token comment" spellcheck="true"># explain SELECT * FROM mat_view;</span>                      QUERY <span class="token keyword">PLAN</span> <span class="token comment" spellcheck="true">---------------------------------------------------------</span>  Seq Scan <span class="token keyword">on</span> mat_view <span class="token punctuation">(</span>cost<span class="token operator">=</span><span class="token number">0.00</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token number">1.02</span> <span class="token keyword">rows</span><span class="token operator">=</span><span class="token number">2</span> width<span class="token operator">=</span><span class="token number">26</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token number">1</span> <span class="token keyword">row</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>ANALYZE</code> 重新创建了新的优化器统计信息并很好地修复了估计。如果您想了解更多<code>ANALYZE</code> 一般信息，我们推荐我们关于<a href="https://www.cybertec-postgresql.com/en/postgresql-analyze-and-optimizer-statistics/">PostgreSQL 优化器统计信息</a>和<a href="https://www.cybertec-postgresql.com/en/tuning-autovacuum-postgresql/">autovacuum</a>的文章。 Autovacuum 还能够重新创建优化器统计信息。</p><h3 id="创建物化视图……使用……"><a href="#创建物化视图……使用……" class="headerlink" title="创建物化视图……使用……"></a><strong>创建物化视图……使用……</strong></h3><p>然而，还有更多。 PostgreSQL 提供了一些与该领域相关的附加重要功能。这些特征之一是该<code>USING</code>条款。这样做的目的是什么？目前，PostgreSQL 仅支持一种存储格式（堆）。然而，在未来，我们希望看到更多的存储格式，例如<a href="https://www.cybertec-postgresql.com/en/zheap-reinvented-postgresql-storage/">zheap</a>或<a href="https://github.com/greenplum-db/postgres/tree/zedstore">zedstore</a>。</p><p>其想法<code>USING</code>是能够为给定的要求选择最佳的存储格式。目前，堆是默认格式，这完全没问题。</p><h3 id="创建物化视图……用……"><a href="#创建物化视图……用……" class="headerlink" title="创建物化视图……用……"></a><strong>创建物化视图……用……</strong></h3><p>-子句与<a href="https://www.postgresql.org/docs/current/sql-createtable.html">CREATE TABLE</a><code>WITH</code>中的相同。它允许您定义存储参数，例如自动清理行为等。<code>FILLFACTOR</code></p><h3 id="这是一个例子："><a href="#这是一个例子：" class="headerlink" title="这是一个例子："></a>这是一个例子：</h3><pre class="line-numbers language-sql"><code class="language-sql">demo<span class="token operator">=</span><span class="token comment" spellcheck="true"># CREATE MATERIALIZED VIEW mat_view_2 </span>           <span class="token keyword">WITH</span> <span class="token punctuation">(</span>autovacuum_enabled <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">)</span> <span class="token keyword">AS</span>            <span class="token keyword">SELECT</span>   grp<span class="token punctuation">,</span> <span class="token function">avg</span><span class="token punctuation">(</span><span class="token keyword">data</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">count</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">)</span>            <span class="token keyword">FROM</span>     t_demo            <span class="token keyword">GROUP</span> <span class="token keyword">BY</span> <span class="token number">1</span><span class="token punctuation">;</span>           <span class="token keyword">SELECT</span> <span class="token number">2</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>一般来说，物化视图的存储方式与表一样，因此只需遵循与创建标准表时相同的建议即可。</p><h3 id="创建物化视图……表空间……"><a href="#创建物化视图……表空间……" class="headerlink" title="创建物化视图……表空间……"></a><strong>创建物化视图……表空间……</strong></h3><p>对于关键字也是如此<code>TABLESPACE</code>。在默认设置中，物化视图将存储在默认表空间中<code>$PGDATA</code>：</p><pre class="line-numbers language-sql"><code class="language-sql">demo<span class="token operator">=</span><span class="token comment" spellcheck="true"># SHOW data_directory;</span><span class="token operator">&amp;</span>nbsp<span class="token punctuation">;</span> data_directory <span class="token comment" spellcheck="true">------------------</span><span class="token operator">&amp;</span>nbsp<span class="token punctuation">;</span><span class="token operator">/</span>Users<span class="token operator">/</span>hs<span class="token comment" spellcheck="true">//db13</span><span class="token punctuation">(</span><span class="token number">1</span> <span class="token keyword">row</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>SHOW</code>是找出它在哪里的简单方法。如果您想了解有关表空间的更多信息，请考虑查看我们有关<a href="https://www.cybertec-postgresql.com/en/postgresql-tablespaces-its-not-so-scary/">PostgreSQL 中的表空间</a>的博客文章。</p><h3 id="创建物化视图……有数据与无数据……"><a href="#创建物化视图……有数据与无数据……" class="headerlink" title="创建物化视图……有数据与无数据……"></a><strong>创建物化视图……有数据与无数据……</strong></h3><p>默认情况下，物化视图以包含结果的方式创建。但是，如果该对象是使用该<code>NO DATA</code>选项创建的，则它是空的。仅创建定义。</p><p>必须意识到这样一个事实：在这种情况下，只有刷新视图以包含数据后才能查询视图。我们还没有看到该选项在<a href="https://www.cybertec-postgresql.com/en/services/postgresql-support/">数据库支持</a><code>NO DATA</code>中使用得太频繁。仍然值得一提的是，这个选项确实存在。</p><h2 id="修改-POSTGRESQL-中的物化视图"><a href="#修改-POSTGRESQL-中的物化视图" class="headerlink" title="修改 POSTGRESQL 中的物化视图"></a><strong>修改 POSTGRESQL 中的物化视图</strong></h2><p>有时，稍后必须修改物化视图。一个经典的例子是重命名视图的列而不重新创建它。</p><h3 id="我们看一下视图的定义："><a href="#我们看一下视图的定义：" class="headerlink" title="我们看一下视图的定义："></a>我们看一下视图的定义：</h3><pre class="line-numbers language-sql"><code class="language-sql">demo<span class="token operator">=</span><span class="token comment" spellcheck="true"># d mat_view</span>     Materialized <span class="token keyword">view</span> <span class="token string">'public.mat_view'</span> <span class="token keyword">Column</span> <span class="token operator">|</span><span class="token operator">&amp;</span>nbsp<span class="token punctuation">;</span> <span class="token keyword">Type</span> <span class="token operator">&amp;</span>nbsp<span class="token punctuation">;</span> <span class="token operator">|</span> Collation <span class="token operator">|</span> Nullable <span class="token operator">|</span> <span class="token keyword">Default</span><span class="token comment" spellcheck="true">--------+---------+-----------+----------+---------</span> grp    <span class="token operator">|</span> <span class="token keyword">integer</span> <span class="token operator">|</span> <span class="token operator">&amp;</span>nbsp<span class="token punctuation">;</span> <span class="token operator">&amp;</span>nbsp<span class="token punctuation">;</span>     <span class="token operator">&amp;</span>nbsp<span class="token punctuation">;</span> <span class="token operator">|</span><span class="token operator">&amp;</span>nbsp<span class="token punctuation">;</span> <span class="token operator">&amp;</span>nbsp<span class="token punctuation">;</span>     <span class="token operator">&amp;</span>nbsp<span class="token punctuation">;</span> <span class="token operator">|</span> avg    <span class="token operator">|</span> <span class="token keyword">numeric</span> <span class="token operator">|</span> <span class="token operator">&amp;</span>nbsp<span class="token punctuation">;</span>     <span class="token operator">&amp;</span>nbsp<span class="token punctuation">;</span> <span class="token operator">&amp;</span>nbsp<span class="token punctuation">;</span> <span class="token operator">|</span><span class="token operator">&amp;</span>nbsp<span class="token punctuation">;</span> <span class="token operator">&amp;</span>nbsp<span class="token punctuation">;</span>     <span class="token operator">&amp;</span>nbsp<span class="token punctuation">;</span> <span class="token operator">|</span> count<span class="token operator">&amp;</span>nbsp<span class="token punctuation">;</span> <span class="token operator">|</span> <span class="token keyword">bigint</span><span class="token operator">&amp;</span>nbsp<span class="token punctuation">;</span> <span class="token operator">|</span> <span class="token operator">&amp;</span>nbsp<span class="token punctuation">;</span> <span class="token operator">&amp;</span>nbsp<span class="token punctuation">;</span>     <span class="token operator">&amp;</span>nbsp<span class="token punctuation">;</span> <span class="token operator">|</span><span class="token operator">&amp;</span>nbsp<span class="token punctuation">;</span> <span class="token operator">&amp;</span>nbsp<span class="token punctuation">;</span>     <span class="token operator">&amp;</span>nbsp<span class="token punctuation">;</span> <span class="token operator">|</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>修改物化视图是使用<code>ALTER MATERIALIZED VIEW</code>命令完成的，该命令是促进各种更改的强大工具。</p><h3 id="语法与ALTER-TABLE您可以做的非常相似："><a href="#语法与ALTER-TABLE您可以做的非常相似：" class="headerlink" title="语法与ALTER TABLE您可以做的非常相似："></a>语法与<code>ALTER TABLE</code>您可以做的非常相似：</h3><pre class="line-numbers language-sql"><code class="language-sql">demo<span class="token operator">=</span><span class="token comment" spellcheck="true"># h ALTER MATERIALIZED VIEW</span>Command: <span class="token keyword">ALTER</span> MATERIALIZED <span class="token keyword">VIEW</span>Description: change the definition <span class="token keyword">of</span> <span class="token number">a</span> materialized <span class="token keyword">view</span>Syntax:<span class="token keyword">ALTER</span> MATERIALIZED <span class="token keyword">VIEW</span> <span class="token punctuation">[</span> <span class="token keyword">IF</span> <span class="token keyword">EXISTS</span> <span class="token punctuation">]</span> name     <span class="token keyword">action</span> <span class="token punctuation">[</span><span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">]</span><span class="token keyword">ALTER</span> MATERIALIZED <span class="token keyword">VIEW</span> name     DEPENDS <span class="token keyword">ON</span> EXTENSION extension_name<span class="token keyword">ALTER</span> MATERIALIZED <span class="token keyword">VIEW</span> <span class="token punctuation">[</span> <span class="token keyword">IF</span> <span class="token keyword">EXISTS</span> <span class="token punctuation">]</span> name     <span class="token keyword">RENAME</span> <span class="token punctuation">[</span> <span class="token keyword">COLUMN</span> <span class="token punctuation">]</span> column_name <span class="token keyword">TO</span> new_column_name<span class="token keyword">ALTER</span> MATERIALIZED <span class="token keyword">VIEW</span> <span class="token punctuation">[</span> <span class="token keyword">IF</span> <span class="token keyword">EXISTS</span> <span class="token punctuation">]</span> name     <span class="token keyword">RENAME</span> <span class="token keyword">TO</span> new_name<span class="token keyword">ALTER</span> MATERIALIZED <span class="token keyword">VIEW</span> <span class="token punctuation">[</span> <span class="token keyword">IF</span> <span class="token keyword">EXISTS</span> <span class="token punctuation">]</span> name     <span class="token keyword">SET</span> <span class="token keyword">SCHEMA</span> new_schema<span class="token keyword">ALTER</span> MATERIALIZED <span class="token keyword">VIEW</span> <span class="token keyword">ALL</span> <span class="token operator">IN</span> <span class="token keyword">TABLESPACE</span> name     <span class="token punctuation">[</span> OWNED <span class="token keyword">BY</span> role_name <span class="token punctuation">[</span><span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">]</span> <span class="token punctuation">]</span>     <span class="token keyword">SET</span> <span class="token keyword">TABLESPACE</span> new_tablespace <span class="token punctuation">[</span> NOWAIT <span class="token punctuation">]</span><span class="token keyword">where</span> <span class="token keyword">action</span> <span class="token operator">is</span> one <span class="token keyword">of</span>:     <span class="token keyword">ALTER</span> <span class="token punctuation">[</span> <span class="token keyword">COLUMN</span> <span class="token punctuation">]</span> column_name <span class="token keyword">SET</span> <span class="token keyword">STATISTICS</span> <span class="token keyword">integer</span>     <span class="token keyword">ALTER</span> <span class="token punctuation">[</span> <span class="token keyword">COLUMN</span> <span class="token punctuation">]</span> column_name <span class="token keyword">SET</span>          <span class="token punctuation">(</span> attribute_option <span class="token operator">=</span> <span class="token keyword">value</span> <span class="token punctuation">[</span><span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">]</span> <span class="token punctuation">)</span>     <span class="token keyword">ALTER</span> <span class="token punctuation">[</span> <span class="token keyword">COLUMN</span> <span class="token punctuation">]</span> column_name RESET <span class="token punctuation">(</span> attribute_option <span class="token punctuation">[</span><span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">]</span> <span class="token punctuation">)</span>     <span class="token keyword">ALTER</span> <span class="token punctuation">[</span> <span class="token keyword">COLUMN</span> <span class="token punctuation">]</span> column_name <span class="token keyword">SET</span> STORAGE          { PLAIN <span class="token operator">|</span> EXTERNAL <span class="token operator">|</span> <span class="token keyword">EXTENDED</span> <span class="token operator">|</span> MAIN }     CLUSTER <span class="token keyword">ON</span> index_name     <span class="token keyword">SET</span> WITHOUT CLUSTER     <span class="token keyword">SET</span> <span class="token punctuation">(</span> storage_parameter <span class="token punctuation">[</span><span class="token operator">=</span> <span class="token keyword">value</span><span class="token punctuation">]</span> <span class="token punctuation">[</span><span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">]</span> <span class="token punctuation">)</span>     RESET <span class="token punctuation">(</span> storage_parameter <span class="token punctuation">[</span><span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">]</span> <span class="token punctuation">)</span>     OWNER <span class="token keyword">TO</span> { new_owner <span class="token operator">|</span> <span class="token keyword">CURRENT_USER</span> <span class="token operator">|</span> <span class="token keyword">SESSION_USER</span> }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这里值得注意的是，您还可以执行诸如<code>CLUSTER</code>（=索引组织）、<code>SET STATISTICS</code>（=为PostgreSQL优化器调整直方图大小）等操作。该过程与普通表相同。</p><h3 id="现在，让我们尝试一下并重命名一列："><a href="#现在，让我们尝试一下并重命名一列：" class="headerlink" title="现在，让我们尝试一下并重命名一列："></a>现在，让我们尝试一下并重命名一列：</h3><pre class="line-numbers language-sql"><code class="language-sql">demo<span class="token operator">=</span><span class="token comment" spellcheck="true"># ALTER MATERIALIZED VIEW mat_view </span>     <span class="token keyword">RENAME</span> <span class="token keyword">COLUMN</span> avg <span class="token keyword">TO</span> average<span class="token punctuation">;</span><span class="token keyword">ALTER</span> MATERIALIZED <span class="token keyword">VIEW</span>demo<span class="token operator">=</span><span class="token comment" spellcheck="true"># d mat_view</span>     Materialized <span class="token keyword">view</span> <span class="token string">'public.mat_view'</span> <span class="token keyword">Column</span>  <span class="token operator">|</span>  <span class="token keyword">Type</span>   <span class="token operator">|</span> Collation <span class="token operator">|</span> Nullable <span class="token operator">|</span> <span class="token keyword">Default</span><span class="token comment" spellcheck="true">---------+---------+-----------+----------+---------</span> grp  <span class="token operator">|</span> <span class="token keyword">integer</span> <span class="token operator">|</span>           <span class="token operator">|</span>        <span class="token operator">|</span> average <span class="token operator">|</span> <span class="token keyword">numeric</span> <span class="token operator">|</span>           <span class="token operator">|</span>        <span class="token operator">|</span> count   <span class="token operator">|</span> <span class="token keyword">bigint</span>  <span class="token operator">|</span>           <span class="token operator">|</span>         <span class="token operator">|</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="在我们继续刷新之前，我想将您的注意力集中在索引上："><a href="#在我们继续刷新之前，我想将您的注意力集中在索引上：" class="headerlink" title="在我们继续刷新之前，我想将您的注意力集中在索引上："></a>在我们继续刷新之前，我想将您的注意力集中在索引上：</h3><pre class="line-numbers language-sql"><code class="language-sql">demo<span class="token operator">=</span><span class="token comment" spellcheck="true"># CREATE INDEX idx_average ON mat_view (average);</span><span class="token keyword">CREATE</span> <span class="token keyword">INDEX</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>为物化视图建立索引以确保快速查询是一个好主意。同样，存在与表相同的规则。简单地索引不同的条目，并在读取物化视图时提供良好的选择性。</p><h2 id="刷新物化视图"><a href="#刷新物化视图" class="headerlink" title="刷新物化视图"></a><strong>刷新物化视图</strong></h2><p>物化视图包含查询结果的快照。它不会定期更新，除非用户强制 PostgreSQL 这样做。在 Oracle 中，物化视图支持稍微复杂一些。希望 PostgreSQL 很快就能在这个领域迎头赶上。</p><p>然而，目前 PostgreSQL 中的物化视图必须刷新。</p><h3 id="使用命令手动刷新REFRESH-MATERIALIZED-VIEW："><a href="#使用命令手动刷新REFRESH-MATERIALIZED-VIEW：" class="headerlink" title="使用命令手动刷新REFRESH MATERIALIZED VIEW："></a>使用命令手动刷新<code>REFRESH MATERIALIZED VIEW</code>：</h3><pre class="line-numbers language-sql"><code class="language-sql">demo<span class="token operator">=</span><span class="token comment" spellcheck="true"># h REFRESH MATERIALIZED VIEW</span>Command: REFRESH MATERIALIZED <span class="token keyword">VIEW</span>Description: replace the contents <span class="token keyword">of</span> <span class="token number">a</span> materialized <span class="token keyword">view</span>Syntax:REFRESH MATERIALIZED <span class="token keyword">VIEW</span> <span class="token punctuation">[</span> CONCURRENTLY <span class="token punctuation">]</span> name    <span class="token punctuation">[</span> <span class="token keyword">WITH</span> <span class="token punctuation">[</span> <span class="token keyword">NO</span> <span class="token punctuation">]</span> <span class="token keyword">DATA</span> <span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="运行刷新很简单："><a href="#运行刷新很简单：" class="headerlink" title="运行刷新很简单："></a>运行刷新很简单：</h3><pre class="line-numbers language-sql"><code class="language-sql">demo<span class="token operator">=</span><span class="token comment" spellcheck="true"># REFRESH MATERIALIZED VIEW mat_view;</span>REFRESH MATERIALIZED <span class="token keyword">VIEW</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>PostgreSQL 知道必须重新执行哪个查询才能刷新物化视图的内容。只有一个缺点：PostgreSQL 必须在刷新时锁定对象，这意味着刷新时没有人可以访问它。</p><h2 id="同时刷新物化视图"><a href="#同时刷新物化视图" class="headerlink" title="同时刷新物化视图"></a><strong>同时刷新物化视图</strong></h2><p>有时，容忍锁定的物化视图根本就是不可接受的。在这种情况下，需要并发更新。然而，有一个问题：</p><pre class="line-numbers language-sql"><code class="language-sql">demo<span class="token operator">=</span><span class="token comment" spellcheck="true"># REFRESH MATERIALIZED VIEW CONCURRENTLY mat_view;</span>ERROR:  cannot refresh materialized <span class="token keyword">view</span> <span class="token string">'public.mat_view'</span> concurrentlyHINT:  <span class="token keyword">Create</span> <span class="token number">a</span> <span class="token keyword">unique</span> <span class="token keyword">index</span> <span class="token keyword">with</span> <span class="token keyword">no</span> <span class="token keyword">WHERE</span> clause <span class="token keyword">on</span> one <span class="token operator">or</span> more <span class="token keyword">columns</span> <span class="token keyword">of</span> the materialized <span class="token keyword">view</span><span class="token punctuation">.</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>物化视图需要一个独特的列来支持并发刷新。</p><h3 id="这意味着您必须确定“主键”并创建唯一索引："><a href="#这意味着您必须确定“主键”并创建唯一索引：" class="headerlink" title="这意味着您必须确定“主键”并创建唯一索引："></a>这意味着您必须确定“主键”并创建唯一索引：</h3><pre class="line-numbers language-sql"><code class="language-sql">demo<span class="token operator">=</span><span class="token comment" spellcheck="true"># CREATE UNIQUE INDEX idx_grp ON mat_view (grp);</span><span class="token keyword">CREATE</span> <span class="token keyword">INDEX</span>demo<span class="token operator">=</span><span class="token comment" spellcheck="true"># REFRESH MATERIALIZED VIEW CONCURRENTLY mat_view;</span>REFRESH MATERIALIZED <span class="token keyword">VIEW</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>您需要小心一点并<strong>确保表不会膨胀</strong>。从技术上讲，它是一个<code>DELETE / INSERT</code>，容易导致表膨胀。确保制定适当的<a href="https://www.cybertec-postgresql.com/en/reasons-why-vacuum-wont-remove-dead-rows/"><code>VACUUM</code>政策</a>。</p><h2 id="最后-…"><a href="#最后-…" class="headerlink" title="最后 …"></a><strong>最后 …</strong></h2><p>物化视图是大多数数据库（包括 PostgreSQL）的一个重要功能。它们可以帮助加速大型计算 - 或者至少缓存它们。</p><p>如果您想确保<a href="https://www.cybertec-postgresql.com/en/pg_timetable-asynchronous-chain-execution/">您的物化视图是最新的</a>，并且想立即阅读有关 PostgreSQL 的更多信息，请查看我们关于 pg_timetable 的博客，该博客向您展示了如何在 PostgreSQL 中安排作业。为什么<a href="https://www.cybertec-postgresql.com/en/products/pg_timetable/">pg_timetable</a>如此有用？我们的调度程序确保相同的作业不会重叠，并且如果相同的作业已经在运行，它们就不会再次执行。如果工作时间较长，这一点非常重要 - 特别是如果您想使用物化视图。</p>]]></content>
      
      
      <categories>
          
          <category> postgresql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> postgresql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>POSTGRESQL：PostgreSQL 后端架构概述</title>
      <link href="/2023/postgresql-hou-duan-jia-gou-gai-shu/"/>
      <url>/2023/postgresql-hou-duan-jia-gou-gai-shu/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h3 id="1-简介"><a href="#1-简介" class="headerlink" title="1. 简介"></a>1. 简介</h3><p>PostgreSQL 后端是一个从主进程派生出来的进程集合，称为<code>Postmaster</code>. 每个分叉进程在后端都有不同的角色和职责。本文描述了为我们今天所知的 PostgreSQL 系统提供支持的核心后端进程的职责。PostgreSQL后端整体架构如下图所示：</p><p><img src="/medias/image/pg-arch-1024x908.png" alt="img"></p><p>Postmaster 是第一个启动的进程，它控制所有后端进程，负责接受和关闭数据库连接。在启动时，postmaster 会分叉几个后端进程，这些进程旨在处理后端任务的不同方面，我们将在本博客中介绍这些任务。当用户发起与 PostgreSQL 数据库的连接时，客户端进程将向 Postmaster 主进程发送一条身份验证消息。Postmaster主进程根据配置的认证方式对用户进行认证，只有用户认证通过后才会分叉一个新的会话为该用户提供服务。</p><h3 id="2-BgWriter（后台写入器）进程"><a href="#2-BgWriter（后台写入器）进程" class="headerlink" title="2. BgWriter（后台写入器）进程"></a>2. BgWriter（后台写入器）进程</h3><p>BgWriter进程是将共享内存中的脏页写入磁盘的进程。它有两个作用：一是定期将内存缓冲区中的脏数据刷新到磁盘，以减少查询过程中的阻塞；另一个是PG需要在常规检查点期间将所有脏页写出到磁盘。通过 BgWriter 提前写出一些脏页，可以减少设置检查点（数据库恢复技术的一种）时要执行的 IO 操作，从而使系统的 IO 负载趋于稳定。BgWriter 是 PostgreSQL v8.0 之后添加的一个进程，它在<code>postgresql.conf</code>有一个专门的部分配置其行为。</p><pre class="line-numbers language-properties"><code class="language-properties"><span class="token comment" spellcheck="true"># - Background Writer -</span><span class="token comment" spellcheck="true">#bgwriter_delay = 200ms                 # 10-10000ms between rounds</span><span class="token comment" spellcheck="true">#bgwriter_lru_maxpages = 100            # max buffers written/round, 0 disables</span><span class="token comment" spellcheck="true">#bgwriter_lru_multiplier = 2.0          # 0-10.0 multiplier on buffers scanned/round</span><span class="token comment" spellcheck="true">#bgwriter_flush_after = 512kB           # measured in pages, 0 disables</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><strong>bgwriter_delay</strong>：<br>后台writer进程中连续两次flush数据之间的时间间隔。默认值为200，单位为毫秒。</li><li><strong>bgwriter_lru_maxpages</strong>：<br>后台writer进程一次写入的最大数据量。默认值为 100，以缓冲区为单位。如果脏数据量小于该值，则写操作全部由后台writer进程完成；反之，如果大于该值，则较大部分将由服务器进程进程完成。当该值设置为0时，表示禁用后台writer写入进程，完全由服务器进程完成；当设置为-1时，表示所有脏数据都是由后台writer完成的。（这里不包括检查点操作）</li><li><strong>bgwriter_lru_multiplier</strong>：<br>该参数表示每次写入磁盘的数据块数量，当然该值必须小于bgwriter_lru_maxpages。如果设置太小，则需要写入的脏数据量大于每次写入的数据量，因此剩余需要写入磁盘的工作需要由服务器进程进程来完成，这会降低性能；如果该值配置太大，则写入的脏数据量会超过当时所需的缓冲区数量，方便以后再次申请缓冲区工作，同时可能会出现IO浪费。该参数的默认值为2.0。</li><li><strong>bgwriter_flush_after</strong>：<br>当数据页大小达到 bgwriter_flush_after 时触发 BgWriter，默认为 512KB。</li></ul><h3 id="3-WalWriter进程"><a href="#3-WalWriter进程" class="headerlink" title="3. WalWriter进程"></a>3. WalWriter进程</h3><p>Write Ahead Log（也叫Xlog）的核心思想是，数据文件的修改必须发生在这些修改已经被记录在日志中之后，即先写入日志，再写入数据。使用这种机制可以避免频繁向磁盘写入数据，并且可以减少磁盘I/O。数据库可以在数据库重新启动后使用这些 WAL 日志来恢复数据库。WalWriter Process 是一个后端进程，负责确保 WAL 文件正确写入磁盘，其行为可通过<code>postgresql.conf</code>中如下参数进行配置：</p><pre class="line-numbers language-properties"><code class="language-properties"><span class="token comment" spellcheck="true">#------------------------------------------------------------------------------</span><span class="token comment" spellcheck="true"># WRITE-AHEAD LOG</span><span class="token comment" spellcheck="true">#------------------------------------------------------------------------------</span><span class="token comment" spellcheck="true"># - Settings -</span><span class="token attr-name">wal_level</span> <span class="token punctuation">=</span> <span class="token attr-value">logical                     # minimal, replica, or logical</span><span class="token comment" spellcheck="true">                                        # (change requires restart)</span><span class="token comment" spellcheck="true">#fsync = on                             # flush data to disk for crash safety</span><span class="token comment" spellcheck="true">                                        # (turning this off can cause</span><span class="token comment" spellcheck="true">                                        # unrecoverable data corruption)</span><span class="token comment" spellcheck="true">#synchronous_commit = on                # synchronization level;</span><span class="token comment" spellcheck="true">                                        # off, local, remote_write, remote_apply, or on</span><span class="token comment" spellcheck="true">#wal_sync_method = fsync                # the default is the first option</span><span class="token comment" spellcheck="true">                                        # supported by the operating system:</span><span class="token comment" spellcheck="true">                                        #   open_datasync</span><span class="token comment" spellcheck="true">                                        #   fdatasync (default on Linux)</span><span class="token comment" spellcheck="true">                                        #   fsync</span><span class="token comment" spellcheck="true">                                        #   fsync_writethrough</span><span class="token comment" spellcheck="true">                                        #   open_sync</span><span class="token comment" spellcheck="true">#full_page_writes = on                  # recover from partial page writes</span><span class="token comment" spellcheck="true">#wal_compression = off                  # enable compression of full-page writes</span><span class="token comment" spellcheck="true">#wal_log_hints = off                    # also do full page writes of non-critical updates</span><span class="token comment" spellcheck="true">                                        # (change requires restart)</span><span class="token comment" spellcheck="true">#wal_init_zero = on                     # zero-fill new WAL files</span><span class="token comment" spellcheck="true">#wal_recycle = on                       # recycle WAL files</span><span class="token comment" spellcheck="true">#wal_buffers = -1                       # min 32kB, -1 sets based on shared_buffers</span><span class="token comment" spellcheck="true">                                        # (change requires restart)</span><span class="token comment" spellcheck="true">#wal_writer_delay = 200ms               # 1-10000 milliseconds</span><span class="token comment" spellcheck="true">#wal_writer_flush_after = 1MB           # measured in pages, 0 disables</span><span class="token comment" spellcheck="true">#commit_delay = 0                       # range 0-100000, in microseconds</span><span class="token comment" spellcheck="true">#commit_siblings = 5                    # range 1-1000</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><strong>wal_level</strong>：<br>控制 wal 存储级别。wal_level 决定写入 WAL 的信息量。默认值为<code>replica</code>，它添加 WAL 归档信息并包含只读服务器（流式复制）所需的信息。也可以设置为<code>minimal</code>，仅写入从崩溃或立即关闭中恢复所需的信息。设置为<code>Logical</code>允许在逻辑解码场景中完成 WAL 流。</li><li><strong>fsync</strong>：<br>该参数直接控制日志是否先写入磁盘。默认值为ON，这意味着系统应通过发出<code>wal_sync_method</code>所设置的 fsync命令来确保更改确实刷新到磁盘。虽然关闭 fsync 通常会带来性能优势，但在发生电源故障或系统崩溃时，这可能会导致不可恢复的数据损坏。因此，只有当您可以轻松地从外部数据重新创建整个数据库时，才建议关闭 fsync。</li><li><strong>synchronous_commit</strong>：<br>该参数配置系统是否等待WAL完成后再​​将状态信息返回给用户事务。默认值为ON，表示必须等待WAL完成后才返回事务状态信息；配置OFF可以更快的反馈事务状态。</li><li><strong>wal_sync_method</strong>：<br>该参数控制WAL写入磁盘的fsync方法。默认值为 fsync。可用值包括open_datasync、fdatasync、fsync_writethrough和open_sync。</li><li><strong>full_page_writes</strong>：<br>指示是否将整个页写入WAL。</li><li><strong>wal_buffers</strong>：<br>用于存储 WAL 数据的内存空间量。系统默认值为64K。该参数还受到<code>wal_writer_delay</code>和<code>commit_delay</code>两个参数的影响。</li><li><strong>wal_writer_delay</strong>：<br>WalWriter进程的写入间隔。默认值为 200 毫秒。如果时间太长，可能会导致WAL缓冲区内存不足；如果时间太短，会导致WAL不断写入，增加磁盘I/O负担。</li><li><strong>wal_writer_flush_after</strong>：<br>当脏数据超过此阈值时，将被刷新到磁盘。</li><li><strong>commit_delay</strong>：<br>表示提交的数据存储到WAL缓冲区的时间。默认值为0毫秒，表示无延迟；当设置为非零值时，事务在执行commit后不会立即写入WAL，但仍然保存在WAL缓冲区中，等待WalWriter进程定期写入磁盘。</li><li><strong>commit_siblings</strong>：<br>当事务发出commit请求时，如果数据库中的事务数量大于commit_siblings的值，则该事务会等待一段时间（commit_delay值）；否则，事务直接写入WAL。系统默认值为5，该参数也决定了commit_delay 的有效性。</li></ul><h3 id="4-PgArch进程"><a href="#4-PgArch进程" class="headerlink" title="4.PgArch进程"></a>4.PgArch进程</h3><p>与Oracle数据库中的ARCH归档过程类似，不同的是ARCH对redo log进行归档，而PgArch对WAL日志进行归档。这是需要的，因为 WAL 日志将被回收。也就是说，过去的WAL日志会被新生成的WAL日志覆盖。PgArch 进程负责在 WAL 日志被覆盖之前对其进行备份。从8.x版本开始，这些WAL日志可以用于PITR（Point-In-Time-Recovery），它将数据库状态恢复到某个时间段的某个状态。PgArch 在<code>postgresql.conf</code>还有一个专门的部分来配置其行为。</p><pre class="line-numbers language-properties"><code class="language-properties"><span class="token comment" spellcheck="true"># - Archiving -</span><span class="token comment" spellcheck="true">#archive_mode = off             # enables archiving; off, on, or always</span><span class="token comment" spellcheck="true">                                # (change requires restart)</span><span class="token comment" spellcheck="true">#archive_command = ''           # command to use to archive a logfile segment</span><span class="token comment" spellcheck="true">                                # placeholders: %p = path of file to archive</span><span class="token comment" spellcheck="true">                                #               %f = file name only</span><span class="token comment" spellcheck="true">                                # e.g. 'test ! -f /mnt/server/archivedir/%f &amp;&amp; cp %p /mnt/server/archivedir/%f'</span><span class="token comment" spellcheck="true">#archive_timeout = 0            # force a logfile segment switch after this</span><span class="token comment" spellcheck="true">                                # number of seconds; 0 disables</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><strong>archive_mode</strong>：</li></ul><p>表示是否执行归档操作；可以设置为（关）、（开）或（始终），默认值为关。</p><ul><li><strong>archive_command</strong>：</li></ul><p>管理员设置的用于归档WAL日志的命令。归档命令中，预定义变量“%p”用于指代需要归档的WAL全路径文件名，“%f”表示不带路径的文件名（这里的路径是相对于当前的路径）工作目录）。<code>archive_command</code>当每个WAL段文件被归档时，将执行指定的命令。如果archive命令返回0，PostgreSQL就认为文件归档成功，然后删除或回收WAL段文件。如果返回非零值，PostgreSQL将认为该文件未成功归档，并会定期重试，直到成功。</p><ul><li><strong>archive_timeout</strong>：</li></ul><p>表示存档期限。当超过该参数设置的时间时，WAL段被强制切换。默认值为 0（功能禁用）。</p><h3 id="5-autovacuum进程"><a href="#5-autovacuum进程" class="headerlink" title="5. autovacuum进程"></a>5. autovacuum进程</h3><p>在PostgreSQL数据库中，对数据执行UPDATE或DELETE操作后，数据库不会立即删除旧版本的数据。相反，数据将被 PostgreSQL 的多版本机制标记为已删除。如果这些旧版本的数据正在被其他事务访问，则有必要暂时保留它们。提交事务后，不再需要旧版本的数据（死元组），因此数据库需要清理它们以腾出空间。该任务由AutoVacuum进程执行，与AutoVacuum进程相关的参数也在postgresql.conf中。</p><pre class="line-numbers language-properties"><code class="language-properties"><span class="token comment" spellcheck="true">#------------------------------------------------------------------------------</span><span class="token comment" spellcheck="true"># AUTOVACUUM</span><span class="token comment" spellcheck="true">#------------------------------------------------------------------------------</span><span class="token comment" spellcheck="true">#autovacuum = on                        # Enable autovacuum subprocess?  'on'</span><span class="token comment" spellcheck="true">                                        # requires track_counts to also be on.</span><span class="token comment" spellcheck="true">#log_autovacuum_min_duration = -1       # -1 disables, 0 logs all actions and</span><span class="token comment" spellcheck="true">                                        # their durations, > 0 logs only</span><span class="token comment" spellcheck="true">                                        # actions running at least this number</span><span class="token comment" spellcheck="true">                                        # of milliseconds.</span><span class="token comment" spellcheck="true">#autovacuum_max_workers = 3             # max number of autovacuum subprocesses</span><span class="token comment" spellcheck="true">                                        # (change requires restart)</span><span class="token comment" spellcheck="true">#autovacuum_naptime = 1min              # time between autovacuum runs</span><span class="token comment" spellcheck="true">#autovacuum_vacuum_threshold = 50       # min number of row updates before</span><span class="token comment" spellcheck="true">                                        # vacuum</span><span class="token comment" spellcheck="true">#autovacuum_analyze_threshold = 50      # min number of row updates before</span><span class="token comment" spellcheck="true">                                        # analyze</span><span class="token comment" spellcheck="true">#autovacuum_vacuum_scale_factor = 0.2   # fraction of table size before vacuum</span><span class="token comment" spellcheck="true">#autovacuum_analyze_scale_factor = 0.1  # fraction of table size before analyze</span><span class="token comment" spellcheck="true">#autovacuum_freeze_max_age = 200000000  # maximum XID age before forced vacuum</span><span class="token comment" spellcheck="true">                                        # (change requires restart)</span><span class="token comment" spellcheck="true">#autovacuum_multixact_freeze_max_age = 400000000        # maximum multixact age</span><span class="token comment" spellcheck="true">                                        # before forced vacuum</span><span class="token comment" spellcheck="true">                                        # (change requires restart)</span><span class="token comment" spellcheck="true">#autovacuum_vacuum_cost_delay = 2ms     # default vacuum cost delay for</span><span class="token comment" spellcheck="true">                                        # autovacuum, in milliseconds;</span><span class="token comment" spellcheck="true">                                        # -1 means use vacuum_cost_delay</span><span class="token comment" spellcheck="true">#autovacuum_vacuum_cost_limit = -1      # default vacuum cost limit for</span><span class="token comment" spellcheck="true">                                        # autovacuum, -1 means use</span><span class="token comment" spellcheck="true">                                        # vacuum_cost_limit</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><strong>autovacuum</strong>：<br>是否自动启动自动真空过程，默认值为打开。</li><li><strong>log_autovacuum_min_duration</strong>：<br>该参数记录autovacuum的执行时间。当autovaccum的执行时间超过<code>log_autovacuum_min_duration</code>参数的设置时，该事件将被记录在日志中。默认为“-1”，表示不记录。</li><li><strong>autovacuum_max_workers</strong>：<br>设置 autovacuum 子进程的最大数量。</li><li><strong>autovacuum_naptime</strong>：<br>设置两个 autovacuum 进程之间的间隔时间。</li><li><strong>autovacuum_vacuum_threshold</strong>和<strong>autovacuum_analyze_threshold</strong>：<br>设置表上更新元组数量的阈值，如果元组更新数量超过这些值，则需要分别进行vacuum和分析。</li><li><strong>autovacuum_vacuum_scale_factor</strong>和<strong>autovacuum_analyze_scale_factor</strong>：<br>设置表大小的缩放因子。</li><li><strong>autovacuum_freeze_max_age</strong>：<br>设置需要强制清理数据库的事务ID上限。</li><li><strong>autovacuum_vacuum_cost_delay</strong>：<br>当autovacuum进程即将执行时，评估vacuum执行成本。如果超过了设定的值<code>autovacuum_vacuum_cost_limit</code>，就会有该参数设定的延迟<code>autovacuum_vacuum_cost_delay</code>。如果值为-1，则表示使用<code>vacuum_cost_delay</code>值代替。默认值为 20 毫秒。</li><li><strong>autovacuum_vacuum_cost_limit</strong>：该值是autovacuum进程的评估阈值。默认值为-1，表示使用“vacuum_cost_limit”值。如果 autovacuum 进程执行期间评估的成本超过<code>autovacuum_vacuum_cost_limit</code>，autovacuum 进程将休眠。</li></ul><h3 id="6-统计收集器"><a href="#6-统计收集器" class="headerlink" title="6. 统计收集器"></a>6. 统计收集器</h3><p>Stat Collector是PostgreSQL数据库的统计信息收集器。它收集数据库运行过程中的统计信息，例如表的增删改查次数、数据块的数量、索引的变化等。收集统计信息主要是为了查询优化器做出正确的判断，选择最佳的执行计划。<code>postgresql.conf</code>文件中统计收集器相关参数如下：</p><pre class="line-numbers language-properties"><code class="language-properties"><span class="token comment" spellcheck="true">#------------------------------------------------------------------------------</span><span class="token comment" spellcheck="true"># STATISTICS</span><span class="token comment" spellcheck="true">#------------------------------------------------------------------------------</span><span class="token comment" spellcheck="true"># - Query and Index Statistics Collector -</span><span class="token comment" spellcheck="true">#track_activities = on</span><span class="token comment" spellcheck="true">#track_counts = on</span><span class="token comment" spellcheck="true">#track_io_timing = off</span><span class="token comment" spellcheck="true">#track_functions = none                 # none, pl, all</span><span class="token comment" spellcheck="true">#track_activity_query_size = 1024       # (change requires restart)</span><span class="token comment" spellcheck="true">#stats_temp_directory = 'pg_stat_tmp'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><strong>track_activities</strong>：<br>是否开启会话中当前执行命令的统计信息收集功能。该参数仅对超级用户和会话所有者可见。默认值是打开的。</li><li><strong>track_counts</strong>：<br>是否开启数据库活动统计信息收集功能。由于AutoVacuum自动清理过程中选择了要清理的数据库，需要数据库统计信息，因此该参数默认值为on。</li><li><strong>track_io_timing</strong>：<br>定时调用数据块I/O，默认为off，因为设置为on状态会重复调用数据库时间，这给数据库增加了很多开销。只有超级用户可以设置。</li><li><strong>track_functions</strong>：<br>是否开启函数调用次数和耗时统计。</li><li><strong>track_activity_query_size</strong>：<br>设置用于跟踪每个活动会话当前执行的命令的字节数。默认值为1024，只有在数据库启动后才能设置。</li><li><strong>stats_temp_directory</strong>：<br>统计信息的临时存储路径。该路径可以是相对路径或绝对路径。默认参数是pg_stat_tmp。该参数只能在 postgresql.conf 文件或服务器命令行中修改。</li></ul><h3 id="7-检查点进程"><a href="#7-检查点进程" class="headerlink" title="7. 检查点进程"></a>7. 检查点进程</h3><p>检查点是系统设置的一系列事务点。设置检查点可以保证检查点之前的WAL日志信息刷新到磁盘。如果发生崩溃，崩溃恢复过程会查看最新的检查点记录，以确定日志中的点（称为重做记录），从该点开始 REDO 操作。postgresql.conf文件中的相关参数为：</p><pre class="line-numbers language-properties"><code class="language-properties"><span class="token comment" spellcheck="true"># - Checkpoints -</span><span class="token comment" spellcheck="true">#checkpoint_timeout = 5min              # range 30s-1d</span><span class="token attr-name">max_wal_size</span> <span class="token punctuation">=</span> <span class="token attr-value">1GB</span><span class="token attr-name">min_wal_size</span> <span class="token punctuation">=</span> <span class="token attr-value">80MB</span><span class="token comment" spellcheck="true">#checkpoint_completion_target = 0.5     # checkpoint target duration, 0.0 - 1.0</span><span class="token comment" spellcheck="true">#checkpoint_flush_after = 256kB         # measured in pages, 0 disables</span><span class="token comment" spellcheck="true">#checkpoint_warning = 30s               # 0 disables</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><strong>checkpoint_timeout</strong>：<br>该参数配置执行检查点的周期。默认值为 5 分钟。</li><li><strong>max_wal_size</strong>：<br>此参数设置检查点发生之前的最大 WAL 大小，默认为 1GB。</li><li><strong>min_wal_size</strong>：<br>此参数设置为将来使用而回收的 WAL 文件数量的最小值。</li><li><strong>checkpoint_completion_target</strong>：<br>为了避免大量页面写入淹没 I/O 系统，在检查点期间写入脏缓冲区会分散在一段时间内。该周期由<code>checkpoint_completion_target</code>控制，它作为检查点间隔的一部分给出。</li><li><strong>checkpoint_flush_after</strong>：<br>此参数允许强制操作系统在可配置的字节数后将检查点写入的页面刷新到磁盘。否则，这些页面可能会保留在操作系统的页面缓存中。默认值为 256kB。</li><li><strong>checkpoint_warning</strong>：<br>检查点是昂贵的操作。该参数配置每个检查点之间的阈值，如果检查点发生的时间间隔太近<code>checkpoint_warning</code>，系统将在服务器日志中输出警告，建议用户增加<code>max_wal_size</code>。</li></ul><h3 id="8-共享内存和本地内存"><a href="#8-共享内存和本地内存" class="headerlink" title="8. 共享内存和本地内存"></a>8. 共享内存和本地内存</h3><p>PostgreSQL服务器启动时，会分配一块共享内存作为数据块的缓冲区，以提高读写能力。共享内存中还存在WAL日志缓冲区和CLOG缓冲区。一些全局信息如进程信息、锁信息、全局统计信息等都存储在共享内存中。</p><p>除了共享内存之外，后台服务还会分配一些本地内存来临时存储不需要全局存储的数据。这些内存缓冲区主要包括以下几类：</p><ul><li>临时缓冲区：用于访问临时表的本地缓冲区。</li><li>work_mem：在使用临时磁盘文件之前，内存中排序操作和哈希表使用的内存缓冲。</li><li>maintenance_work_mem：维护操作（例如vacuum、创建索引、添加外键等）使用的内存缓冲区。</li></ul><h3 id="9-总结"><a href="#9-总结" class="headerlink" title="9. 总结"></a>9. 总结</h3><p>本博客概述了我们今天所看到的 PostgreSQL 核心后端进程，它们是数据库性能调优的基础。可以更改许多参数来影响这些后端进程的行为，从而使数据库性能更好、更安全、更快。这将是未来的一个话题。</p><p>本文转自：<a href="https://www.highgo.ca/2020/06/18/an-overview-of-postgresql-backend-architecture/">https://www.highgo.ca/2020/06/18/an-overview-of-postgresql-backend-architecture/</a></p>]]></content>
      
      
      <categories>
          
          <category> postgresql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> postgresql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>TLS：TCP连接管理</title>
      <link href="/2023/tcp-lian-jie-guan-li/"/>
      <url>/2023/tcp-lian-jie-guan-li/</url>
      
        <content type="html"><![CDATA[<p>TCP是一种面向连接的的单播协议。在发送数据之前，通信双方必须在彼此之间建立一条连接。TCP服务模型是一个字节流。TCP必须检测并修补所有在IP层（或下面的层）产生的丢包、重复以及错误等数据传输问题。</p><h4 id="TCP连接的建立和终止"><a href="#TCP连接的建立和终止" class="headerlink" title="TCP连接的建立和终止"></a>TCP连接的建立和终止</h4><p>一个TCP连接由一对端点或套接字构成，其中通信的每一端都由一对唯一的IP地址和端口号所标识。一个TCP连接通常分为3个阶段：启动、数据传输和退出。下图显示了一个典型的TCP连接的建立和关闭过程（不包含数据传输）。</p><p><img src="/medias/image/image-20230418212623713.png" alt="image-20230418212623713"></p><p>为了建立一个TCP连接，需要完成以下步骤：</p><ol><li>客户端发送一个 <code>SYN</code> 报文段，并指明自己想要连接的端口号和它的客户端初始序列号 <code>K</code>。客户端发送的这个 <code>SYN</code> 报文段称作段1。</li><li>服务端也发送自己的 <code>SYN</code> 报文段作为响应，并包含了它的初始序列号 <code>L</code>。该段称为段2。同时为了确认客户端的 <code>SYN</code>，服务端将其包含的<code>K</code> 数值加1后作为返回的 <code>ACK</code> 值。因此，每发送一个 <code>SYN</code>，序列号就会自动加1。这样出现丢包的情况，该 <code>SYN</code> 段将会重传。</li><li>为了确认服务器的 <code>SYN</code>，客户端将 <code>L</code> 的数值加1后作为返回的 <code>ACK</code> 数值。这称为段3。</li></ol><p>连接如何关闭：</p><ol><li>连接的主动者发送一个 <code>FIN</code> 段指明接收者希望看到的自己当前的序列号 <code>M</code>。</li><li>连接的被动关闭者将 <code>M</code> 的值加1作为相应的 <code>ACK</code> 值，以表明它已经成功接收到主动关闭者发送的 <code>FIN</code>。此时，上层的应用程序会被告知连接的另一端已经提出了关闭操作。接着，被动关闭者将身份转变为主动关闭者，并发送自己的 <code>FIN</code>。该报文段的序列号为 <code>N</code>。</li><li>为了完成连接的关闭，最后发送的报文段还包含一个 <code>ACK</code> 用于确认上一个 <code>FIN</code>。值得注意的是，如果出现 <code>FIN</code> 丢失的情况，那么发送方将重新传输直到接收到一个 <code>ACK</code> 确认为止。</li></ol>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>POSTGRESQL中的热更新以获得更好的性能</title>
      <link href="/2023/postgresql-zhong-de-re-geng-xin-yi-huo-de-geng-hao-de-xing-neng/"/>
      <url>/2023/postgresql-zhong-de-re-geng-xin-yi-huo-de-geng-hao-de-xing-neng/</url>
      
        <content type="html"><![CDATA[<p>热门更新并不是新功能。它们于 2007 年由<a href="https://git.postgresql.org/gitweb/?p=postgresql.git;a=commit;h=282d2a03dd30804b01f8042f640d638c2ee76604"> 282d2a03dd</a>提交引入，并首次出现在 PostgreSQL 8.3 中。</p><p>由于 PostgreSQL 文档没有涵盖 HOT（尽管源代码树中有<a href="https://git.postgresql.org/gitweb/?p=postgresql.git;a=blob;f=src/backend/access/heap/README.HOT">README.HOT</a>），因此它并没有像应有的那样广为人知：本文解释了这个概念，展示了 HOT 的实际应用并给出了调优建议。</p><h2 id="什么是HOT？"><a href="#什么是HOT？" class="headerlink" title="什么是HOT？"></a>什么是HOT？</h2><p>HOT 是<code>Heap Only Tuple</code>的缩写（这是一个比<a href="https://www.postgresql.org/message-id/1163112297.3634.570.camel%40silverbirch.site">Overflow Update CHaining</a>更好的缩写）。该功能克服了 PostgreSQL 处理<code>UPDATE</code>的一些低效率问题。</p><h2 id="PostgreSQL-UPDATE实现的问题"><a href="#PostgreSQL-UPDATE实现的问题" class="headerlink" title="PostgreSQL UPDATE实现的问题"></a>PostgreSQL <code>UPDATE</code>实现的问题</h2><p>PostgreSQL 通过在表中保留旧版本的表行来实现多版本化 - 添加<code>UPDATE</code>该行的新行版本（“tuple”）并将旧版本标记为无效。</p><p>在很多方面，PostgreSQL中的更新与删除后跟插入没有太大区别。</p><p><img src="/medias/image/update_not_HOT_Zeichenfl%C3%A4che-1-168865670440244.png" alt="正常更新"></p><p>这有很多优点：</p><ul><li>无需额外的存储区域保留旧行版本</li><li><code>ROLLBACK</code>无需撤消任何操作，而且速度非常快</li><li>修改多行的事务不存在溢出问题</li></ul><p>但它也有一些缺点：</p><ul><li>旧的、过时的（“死的”）元组最终必须从表中删除（<code>VACUUM</code>）</li><li>大量更新的表可能因死元组而变得“臃肿”</li><li>即便没有修改索引属性，每次更新都需要添加新的索引条目，并且修改索引比修改表要昂贵得多（必须维护顺序）</li></ul><p>从本质上讲，<code>UPDATE</code>繁重的工作负载对 PostgreSQL 来说是一个挑战。这是HOT更新可以提供帮助的领域。从 PostgreSQL v12 开始，我们可以扩展 PostgreSQL 来<a href="https://www.postgresql.org/docs/current/tableam.html">定义持久表的替代方法</a>。目前<a href="https://www.cybertec-postgresql.com/en/postgresql-zheap-current-status/">zheap</a>正在进行中，应该是一个能够更好地处理<code>UPDATE</code>繁重工作负载的实现。</p><h2 id="一个UPDATE例子"><a href="#一个UPDATE例子" class="headerlink" title="一个UPDATE例子"></a>一个<code>UPDATE</code>例子</h2><p>让我们创建一个包含 235 行的简单表：</p><pre class="line-numbers language-sql"><code class="language-sql"><span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> mytable <span class="token punctuation">(</span>   id  <span class="token keyword">integer</span> <span class="token keyword">PRIMARY</span> <span class="token keyword">KEY</span><span class="token punctuation">,</span>   val <span class="token keyword">integer</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span><span class="token punctuation">)</span> <span class="token keyword">WITH</span> <span class="token punctuation">(</span>autovacuum_enabled <span class="token operator">=</span> <span class="token keyword">off</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> mytable<span class="token keyword">SELECT</span> <span class="token operator">*</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token keyword">FROM</span> generate_series<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">235</span><span class="token punctuation">)</span> <span class="token keyword">AS</span> n<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>该表的长度略多于 1 个 8KB 块。让我们看看每个表行的物理地址<code>ctid</code>（或 “当前元组 ID”）：</p><pre class="line-numbers language-sql"><code class="language-sql"><span class="token keyword">SELECT</span> ctid<span class="token punctuation">,</span> id<span class="token punctuation">,</span> val<span class="token keyword">FROM</span> mytable<span class="token punctuation">;</span>   ctid   <span class="token operator">|</span> id  <span class="token operator">|</span> val <span class="token comment" spellcheck="true">---------+-----+-----</span> <span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span>   <span class="token operator">|</span>   <span class="token number">1</span> <span class="token operator">|</span>   <span class="token number">0</span> <span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">)</span>   <span class="token operator">|</span>   <span class="token number">2</span> <span class="token operator">|</span>   <span class="token number">0</span> <span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">)</span>   <span class="token operator">|</span>   <span class="token number">3</span> <span class="token operator">|</span>   <span class="token number">0</span> <span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">)</span>   <span class="token operator">|</span>   <span class="token number">4</span> <span class="token operator">|</span>   <span class="token number">0</span> <span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">)</span>   <span class="token operator">|</span>   <span class="token number">5</span> <span class="token operator">|</span>   <span class="token number">0</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">224</span><span class="token punctuation">)</span> <span class="token operator">|</span> <span class="token number">224</span> <span class="token operator">|</span>   <span class="token number">0</span> <span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">225</span><span class="token punctuation">)</span> <span class="token operator">|</span> <span class="token number">225</span> <span class="token operator">|</span>   <span class="token number">0</span> <span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">226</span><span class="token punctuation">)</span> <span class="token operator">|</span> <span class="token number">226</span> <span class="token operator">|</span>   <span class="token number">0</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span>   <span class="token operator">|</span> <span class="token number">227</span> <span class="token operator">|</span>   <span class="token number">0</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">)</span>   <span class="token operator">|</span> <span class="token number">228</span> <span class="token operator">|</span>   <span class="token number">0</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">)</span>   <span class="token operator">|</span> <span class="token number">229</span> <span class="token operator">|</span>   <span class="token number">0</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">)</span>   <span class="token operator">|</span> <span class="token number">230</span> <span class="token operator">|</span>   <span class="token number">0</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">)</span>   <span class="token operator">|</span> <span class="token number">231</span> <span class="token operator">|</span>   <span class="token number">0</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">)</span>   <span class="token operator">|</span> <span class="token number">232</span> <span class="token operator">|</span>   <span class="token number">0</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">7</span><span class="token punctuation">)</span>   <span class="token operator">|</span> <span class="token number">233</span> <span class="token operator">|</span>   <span class="token number">0</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">8</span><span class="token punctuation">)</span>   <span class="token operator">|</span> <span class="token number">234</span> <span class="token operator">|</span>   <span class="token number">0</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">9</span><span class="token punctuation">)</span>   <span class="token operator">|</span> <span class="token number">235</span> <span class="token operator">|</span>   <span class="token number">0</span><span class="token punctuation">(</span><span class="token number">235</span> <span class="token keyword">rows</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>ctid</code>它由两部分组成：从 0 开始的“块编号”和从 1 开始的“行指针”（块内的元组编号）。因此，前226 行填充块 0，最后 9 行填充块1中。</p><p>让我们运行一个<code>UPDATE</code>：</p><pre class="line-numbers language-sql"><code class="language-sql"><span class="token keyword">UPDATE</span> mytable<span class="token keyword">SET</span> val <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token keyword">WHERE</span> id <span class="token operator">=</span> <span class="token number">42</span><span class="token punctuation">;</span> <span class="token keyword">SELECT</span> ctid<span class="token punctuation">,</span> id<span class="token punctuation">,</span> val<span class="token keyword">FROM</span> mytable<span class="token keyword">WHERE</span> id <span class="token operator">=</span> <span class="token number">42</span><span class="token punctuation">;</span>   ctid  <span class="token operator">|</span> id <span class="token operator">|</span> val <span class="token comment" spellcheck="true">--------+----+-----</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">10</span><span class="token punctuation">)</span> <span class="token operator">|</span> <span class="token number">42</span> <span class="token operator">|</span>  <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">(</span><span class="token number">1</span> <span class="token keyword">row</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>新的行版本已添加到块 1，该块仍然有可用空间。</p><h2 id="HOT更新的工作原理"><a href="#HOT更新的工作原理" class="headerlink" title="HOT更新的工作原理"></a>HOT更新的工作原理</h2><p>为了理解 HOT，让我们回顾一下<a href="https://www.postgresql.org/docs/current/storage-page-layout.html">PostgreSQL 中表页的布局</a>：</p><p>“行指针”数组存储在页面的开头，每个指针都指向一个实际的元组。这种间接引用允许PostgreSQL在不改变外部外观的情况下在内部重新组织页面。</p><p><strong>仅堆元组是一种不从表块外部引用的元组</strong>。相反，“转发地址”(其行指针号)存储在旧的行版本中:</p><p><img src="/medias/image/update_HOT_Zeichenfl%C3%A4che-1-168865670723446.png" alt="热门更新"></p><p>仅当该行的新版本和旧版本位于同一块中时才有效。该行的外部地址（原始行指针）保持不变。要访问仅限堆的元组，PostgreSQL 必须遵循块内的“HOT链”。</p><h2 id="HOT更新的优点"><a href="#HOT更新的优点" class="headerlink" title="HOT更新的优点"></a>HOT更新的优点</h2><p>HOT更新有两个主要优点：</p><ul><li><p><strong>PostgreSQL不需要修改索引</strong>。由于元组的外部地址保持不变，原始的索引项仍然可以使用。索引扫描沿着HOT链查找适当的元组。</p></li><li><p><strong>死元组可以在不需要VACUUM的情况下删除</strong>。如果一行上有多个HOT更新，HOT链会变长。现在，任何处理区块并检测到带</p><p>有死亡元组(即使是SELECT!)的HOT链的后端都会尝试锁定并重新组织区块，删除中间元组。这是可能的，因为外部没有对这些元组的</p><p>引用。这大大减少了需要大量更新的工作负载对VACUUM的需求。</p></li></ul><h2 id="HOT更新的要求"><a href="#HOT更新的要求" class="headerlink" title="HOT更新的要求"></a>HOT更新的要求</h2><p>使用HOT更新有两个条件：</p><ul><li>包含更新行的数据块中<strong>必须有足够的空间</strong></li><li><strong>任何被修改的列上都没有定义索引</strong></li></ul><p>第二个条件并不明显，是该特性实现所需要的。</p><h2 id="在表上使用fillfactor来获取HOT更新"><a href="#在表上使用fillfactor来获取HOT更新" class="headerlink" title="在表上使用fillfactor来获取HOT更新"></a>在表上使用<code>fillfactor</code>来获取HOT更新</h2><p>您可以确保满足上面的第二个条件，但是如何确保表块中有足够的可用空间？为此，我们有存储参数<code>fillfactor</code>。它是一个介于 10 和 </p><p>100 之间的值，决定了<code>INSERT</code> 填充表块的百分比。如果选择小于默认100的值，则可以确保每个表块中有足够的空间用于HOT更新。</p><p><code>fillfactor</code>的最佳值取决于平均行的大小（较大的行需要较低的值）和工作负载。</p><p><code>fillfactor</code>请注意，对现有表的设置不会重新排列数据，它只会应用于将来表的<code>INSERT</code>。但您可以使用<code>VACUUM (FULL)</code>或<code>CLUSTER</code>重写该表，这将重新设置<code>fillfactor</code>。</p><p>有一个简单的方法可以查看您的设置是否有效以及是否获得HOT更新：</p><pre class="line-numbers language-sql"><code class="language-sql"><span class="token keyword">SELECT</span> n_tup_upd<span class="token punctuation">,</span> n_tup_hot_upd<span class="token keyword">FROM</span> pg_stat_user_tables<span class="token keyword">WHERE</span> schemaname <span class="token operator">=</span> <span class="token string">'myschema'</span><span class="token operator">AND</span> relname <span class="token operator">=</span> <span class="token string">'mytable'</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>这将显示自上次调用函数<code>pg_stat_reset()</code>以来的累计计数。</p><p>检查<code>n_tup_hot_upd</code>(HOT更新计数)的增长速度是否与<code>n_tup_upd</code>(更新计数)的增长速度相同，以查看是否获得了所需的HOT更新。</p><h2 id="HOT更新示例"><a href="#HOT更新示例" class="headerlink" title="HOT更新示例"></a>HOT更新示例</h2><p>让我们更改表的 <code>fillfactor</code>并重复上面的实验：</p><pre class="line-numbers language-sql"><code class="language-sql"><span class="token keyword">TRUNCATE</span> mytable<span class="token punctuation">;</span> <span class="token keyword">ALTER</span> <span class="token keyword">TABLE</span> mytable <span class="token keyword">SET</span> <span class="token punctuation">(</span><span class="token keyword">fillfactor</span> <span class="token operator">=</span> <span class="token number">70</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> mytable<span class="token keyword">SELECT</span> <span class="token operator">*</span><span class="token punctuation">,</span> <span class="token number">0</span> <span class="token keyword">FROM</span> generate_series<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">235</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token keyword">SELECT</span> ctid<span class="token punctuation">,</span> id<span class="token punctuation">,</span> val<span class="token keyword">FROM</span> mytable<span class="token punctuation">;</span>   ctid   <span class="token operator">|</span> id  <span class="token operator">|</span> val <span class="token comment" spellcheck="true">---------+-----+-----</span> <span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span>   <span class="token operator">|</span>   <span class="token number">1</span> <span class="token operator">|</span>   <span class="token number">0</span> <span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">)</span>   <span class="token operator">|</span>   <span class="token number">2</span> <span class="token operator">|</span>   <span class="token number">0</span> <span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">)</span>   <span class="token operator">|</span>   <span class="token number">3</span> <span class="token operator">|</span>   <span class="token number">0</span> <span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">)</span>   <span class="token operator">|</span>   <span class="token number">4</span> <span class="token operator">|</span>   <span class="token number">0</span> <span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">)</span>   <span class="token operator">|</span>   <span class="token number">5</span> <span class="token operator">|</span>   <span class="token number">0</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">156</span><span class="token punctuation">)</span> <span class="token operator">|</span> <span class="token number">156</span> <span class="token operator">|</span>   <span class="token number">0</span> <span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">157</span><span class="token punctuation">)</span> <span class="token operator">|</span> <span class="token number">157</span> <span class="token operator">|</span>   <span class="token number">0</span> <span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">158</span><span class="token punctuation">)</span> <span class="token operator">|</span> <span class="token number">158</span> <span class="token operator">|</span>   <span class="token number">0</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span>   <span class="token operator">|</span> <span class="token number">159</span> <span class="token operator">|</span>   <span class="token number">0</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">)</span>   <span class="token operator">|</span> <span class="token number">160</span> <span class="token operator">|</span>   <span class="token number">0</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">)</span>   <span class="token operator">|</span> <span class="token number">161</span> <span class="token operator">|</span>   <span class="token number">0</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">75</span><span class="token punctuation">)</span>  <span class="token operator">|</span> <span class="token number">233</span> <span class="token operator">|</span>   <span class="token number">0</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">76</span><span class="token punctuation">)</span>  <span class="token operator">|</span> <span class="token number">234</span> <span class="token operator">|</span>   <span class="token number">0</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">77</span><span class="token punctuation">)</span>  <span class="token operator">|</span> <span class="token number">235</span> <span class="token operator">|</span>   <span class="token number">0</span><span class="token punctuation">(</span><span class="token number">235</span> <span class="token keyword">rows</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这次块 0 中的元组较少，并且仍然有一些空间是空闲的。</p><p>让我们<code>UPDATE</code>再次运行一下，看看这次的样子：</p><pre class="line-numbers language-sql"><code class="language-sql"><span class="token keyword">UPDATE</span> mytable<span class="token keyword">SET</span> val <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token keyword">WHERE</span> id <span class="token operator">=</span> <span class="token number">42</span><span class="token punctuation">;</span> <span class="token keyword">SELECT</span> ctid<span class="token punctuation">,</span> id<span class="token punctuation">,</span> val<span class="token keyword">FROM</span> mytable<span class="token keyword">WHERE</span> id <span class="token operator">=</span> <span class="token number">42</span><span class="token punctuation">;</span>   ctid   <span class="token operator">|</span> id <span class="token operator">|</span> val <span class="token comment" spellcheck="true">---------+----+-----</span> <span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">159</span><span class="token punctuation">)</span> <span class="token operator">|</span> <span class="token number">42</span> <span class="token operator">|</span>  <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">(</span><span class="token number">1</span> <span class="token keyword">row</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>更新的行被写入0块，并且是HOT更新。</p><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>HOT更新使PostgreSQL能够处理具有多次更新的工作负载的一个特性。</p><p>在更新繁重的工作负载中，避免对更新的列建立索引并将fillfactor设置为小于100。</p>]]></content>
      
      
      <categories>
          
          <category> postgresql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> postgresql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>POSTGRESQL：什么是检查点？</title>
      <link href="/2023/postgresql-shi-me-shi-jian-cha-dian/"/>
      <url>/2023/postgresql-shi-me-shi-jian-cha-dian/</url>
      
        <content type="html"><![CDATA[<p>检查点是PostgreSQL的核心概念。然而，许多人并不知道它们到底是什么，也不知道如何调整检查点以达到最高效率。这篇文章将解释检查点和检查点调优，并希望你对这些重要的数据库内部机制有所启发。</p><h2 id="PostgreSQL如何写入数据"><a href="#PostgreSQL如何写入数据" class="headerlink" title="PostgreSQL如何写入数据"></a>PostgreSQL如何写入数据</h2><p>在我们更详细地讨论检查点之前，了解 PostgreSQL 如何写入数据非常重要。我们看一下下面的图片：</p><p><img src="/medias/image/checkpoint_Zeichenfl%C3%A4che-1-168865652657132.png" alt="img"></p><p>最重要的是，我们必须假设崩溃随时可能发生。为什么这是相关的？好吧，我们想确保你的数据库永远不会被损坏。结果是我们无法直接向数据文件写入数据。为什么呢？假设我们要向数据文件写入“1234”。如果我们在“12”之后崩溃了呢？结果将是表中的某一行出错。也许索引项会丢失，等等——我们必须不惜一切代价防止这种情况发生。</p><p>因此，需要一种更复杂的写数据方法。它是如何工作的？PostgreSQL做的第一件事是将数据发送到WAL(预写日志)。WAL就像一个偏执的包含二进制更改的顺序磁带。如果添加了一行，WAL可能包含一条记录，表明数据文件中的一行必须被更改，它可能包含一些更改索引条目的指令，可能需要写入一个额外的块等等。它只是包含一个更改流。</p><p>一旦数据被发送到WAL，PostgreSQL将对共享缓冲区中块的缓存版本进行更改。请注意，数据仍然不在数据文件中。我们现在有了WAL条目以及对共享缓冲区的更改。如果一个读请求进来，它无论如何都不会到达数据文件——因为数据在缓存中找到了。</p><p>在某些时候，这些修改过的内存页会由 <code>background writer</code> 写入磁盘。重要的是，数据可能被乱序写入，这不是问题。记住，如果用户想要读取数据，PostgreSQL会在向操作系统请求数据块之前检查共享缓冲区。因此，脏块的写入顺序并不重要。甚至可以稍晚一点写入数据，以增加在一次I/O请求中向磁盘发送多个更改的几率。</p><h2 id="摆脱-WAL"><a href="#摆脱-WAL" class="headerlink" title="摆脱 WAL"></a>摆脱 WAL</h2><p>但是，我们不能无限期地将数据写入 WAL。在某些时候，空间必须被回收，这正是检查点的好处。</p><p><img src="/medias/image/checkpoint2_Zeichenfl%C3%A4che-1-168865653150034.png" alt="PostgreSQL 检查点"></p><p>检查点的目的是确保在某个点之前创建的所有脏缓冲区都发送到磁盘，以便可以回收到该点的 WAL。PostgreSQL 的方法是启动一个检查点进程，将那些丢失的更改写入磁盘。但是，此过程不会尽快将数据发送到磁盘。原因是我们希望使 I/O 曲线变平以保证稳定的响应时间。</p><p>控制检查点传播的参数是</p><pre class="line-numbers language-sql"><code class="language-sql">test<span class="token operator">=</span><span class="token comment" spellcheck="true"># SHOW checkpoint_completion_target;</span>checkpoint_completion_target<span class="token comment" spellcheck="true">------------------------------</span><span class="token number">0.5</span><span class="token punctuation">(</span><span class="token number">1</span> <span class="token keyword">row</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>其理念是在下一个检查点开始之前，检查点已经完成了一半。实际上，0.7 - 0.9 的值似乎是大多数工作负载的最佳选择，请随意尝试。</p><blockquote><p>在 PostgreSQL 14 中，此参数很可能不再存在。硬编码值将为 0.9，这将使用户更容易使用。</p></blockquote><p>下一个重要问题是：检查点何时真正启动？有一些参数可以控制此行为：</p><pre class="line-numbers language-sql"><code class="language-sql">test<span class="token operator">=</span><span class="token comment" spellcheck="true"># SHOW checkpoint_timeout;</span>checkpoint_timeout<span class="token comment" spellcheck="true">--------------------</span>5min<span class="token punctuation">(</span><span class="token number">1</span> <span class="token keyword">row</span><span class="token punctuation">)</span>test<span class="token operator">=</span><span class="token comment" spellcheck="true"># SHOW max_wal_size;</span>max_wal_size<span class="token comment" spellcheck="true">--------------</span>1GB<span class="token punctuation">(</span><span class="token number">1</span> <span class="token keyword">row</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如果系统负载较低，检查点会在一段时间后发生。默认值为 5 分钟。但是，我们建议增加该值以优化写入性能。</p><blockquote><p>请随意更改这些值。它们会影响性能，但不会以任何方式危及您的数据。除了性能之外，任何数据都不会面临风险。</p></blockquote><p><code>max_wal_size</code> 有点棘手：首先，这是一个软限制，而不是硬限制。WAL 的数量可以超过这个数量。该参数的想法是告诉 PostgreSQL 它可能积累多少 WAL，并相应地调整检查点。一般规则是：增加该值将导致更多的空间消耗，但同时会提高写入性能。</p><p>那么为什么不将 <code>max_wal_size</code> 设置为无穷大呢？第一个原因很明显：您将需要大量空间。然而，还有更多——以防数据库崩溃，PostgreSQL 必须重复自上一个检查点以来的所有更改。换句话说，崩溃后，您的数据库可能需要更长的时间才能恢复，因为自上一个检查点以来累积了大量的 WAL。从好的方面来说，如果检查点距离增加，性能确实会提高，但是可以做和实现是有限的。在某些时候，投入更多的存储空间来解决问题并不会再改变任何事情。</p><p><code>background writer</code> 会将一些脏块写入磁盘。然而，在许多情况下，检查点进程本身会完成更多的工作。因此，更多地关注检查点而不是优化<code>background writer</code> 是有意义的。</p><h2 id="min-wal-size"><a href="#min-wal-size" class="headerlink" title="min_wal_size"></a>min_wal_size</h2><p>人们经常询问 <code>min_wal_size</code>  和  <code>max_wal_size</code> 的含义，关于这两个参数有很多混淆，让我来解释一下这是怎么回事。如前所述，PostgreSQL会自己调整检查点距离。它试图将WAL保持在 <code>max_wal_size</code> 以下。但是，如果您的系统处于空闲状态，PostgreSQL将再次逐渐减少WAL的数量，直到  <code>min_wal_size</code>。这不是一个快速的过程，它是逐渐发生的，需要很长一段时间。</p><p>让我们假设一个简单的场景来说明这种情况。假设您有一个系统，在工作日处于繁重的写负载下，但在周末空闲。因此，周五下午，WAL的大小很大。然而，在这个周末PostgreSQL会逐渐减少WAL的大小。当星期一再次开始加载时，那些丢失的WAL文件将被重新创建(这可能是一个性能方面的问题)。</p><p>因此，与 <code>max_wal_size</code> 相比，最好不要将 <code>min_wal_size</code> 设置得太低，这样再次加载时可以减少创建新的WAL文件的需要。</p><h2 id="最后-…"><a href="#最后-…" class="headerlink" title="最后 …"></a>最后 …</h2><p>检查点是一个重要的主题，它们对于实现良好的性能至关重要。</p>]]></content>
      
      
      <categories>
          
          <category> postgresql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> postgresql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2023/postgresql-zhong-de-lian-jie-ce-lue-he-xing-neng/"/>
      <url>/2023/postgresql-zhong-de-lian-jie-ce-lue-he-xing-neng/</url>
      
        <content type="html"><![CDATA[<h1 id="PostgreSQL-连接策略详解：如何选择最佳策略以优化查询性能"><a href="#PostgreSQL-连接策略详解：如何选择最佳策略以优化查询性能" class="headerlink" title="PostgreSQL 连接策略详解：如何选择最佳策略以优化查询性能"></a>PostgreSQL 连接策略详解：如何选择最佳策略以优化查询性能</h1><p>在 PostgreSQL 中，连接操作是查询性能的关键因素之一。PostgreSQL 提供了三种不同的连接策略：<strong>Nested Loop Join</strong>、<strong>Hash Join</strong> 和 <strong>Merge Join</strong>。如果选择了错误的连接策略，查询性能可能会受到显著影响。本文将详细介绍这三种连接策略的工作原理、适用场景、如何通过索引优化它们，以及如何调整查询以选择最佳策略。</p><hr><h2 id="连接策略的术语"><a href="#连接策略的术语" class="headerlink" title="连接策略的术语"></a>连接策略的术语</h2><h3 id="表（Table）"><a href="#表（Table）" class="headerlink" title="表（Table）"></a>表（Table）</h3><p>在连接操作中，表可以是基表（物理表）或任何计划节点的结果。例如，在以下查询中：</p><pre class="line-numbers language-sql"><code class="language-sql"><span class="token keyword">SELECT</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token keyword">FROM</span> <span class="token number">a</span>   <span class="token keyword">JOIN</span> <span class="token punctuation">(</span><span class="token number">b</span> <span class="token keyword">LEFT</span> <span class="token keyword">JOIN</span> <span class="token number">c</span> <span class="token keyword">ON</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span>      <span class="token keyword">ON</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>表 <code>a</code> 是基表，而 <code>b</code> 和 <code>c</code> 的连接结果是一个派生表。</p><h3 id="内表与外表（Inner-Table-vs-Outer-Table）"><a href="#内表与外表（Inner-Table-vs-Outer-Table）" class="headerlink" title="内表与外表（Inner Table vs. Outer Table）"></a>内表与外表（Inner Table vs. Outer Table）</h3><p>在连接操作中，PostgreSQL 会将一个表作为外表（Outer Table），另一个表作为内表（Inner Table）。例如：</p><pre class="line-numbers language-sql"><code class="language-sql"><span class="token keyword">EXPLAIN</span> <span class="token punctuation">(</span>COSTS <span class="token keyword">OFF</span><span class="token punctuation">)</span><span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> <span class="token number">a</span> <span class="token keyword">JOIN</span> <span class="token number">b</span> <span class="token keyword">USING</span> <span class="token punctuation">(</span>id<span class="token punctuation">)</span><span class="token punctuation">;</span>          QUERY <span class="token keyword">PLAN</span>         <span class="token comment" spellcheck="true">----------------------------</span> <span class="token keyword">Hash</span> <span class="token keyword">Join</span>   <span class="token keyword">Hash</span> Cond: <span class="token punctuation">(</span><span class="token number">a</span><span class="token punctuation">.</span>id <span class="token operator">=</span> <span class="token number">b</span><span class="token punctuation">.</span>id<span class="token punctuation">)</span>   <span class="token operator">-</span><span class="token operator">></span>  Seq Scan <span class="token keyword">on</span> <span class="token number">a</span>   <span class="token operator">-</span><span class="token operator">></span>  <span class="token keyword">Hash</span>         <span class="token operator">-</span><span class="token operator">></span>  Seq Scan <span class="token keyword">on</span> <span class="token number">b</span><span class="token punctuation">(</span><span class="token number">5</span> <span class="token keyword">rows</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在这个例子中，<code>a</code> 是外表，<code>b</code> 是内表。</p><h3 id="连接条件与连接键（Join-Condition-vs-Join-Key）"><a href="#连接条件与连接键（Join-Condition-vs-Join-Key）" class="headerlink" title="连接条件与连接键（Join Condition vs. Join Key）"></a>连接条件与连接键（Join Condition vs. Join Key）</h3><p>连接条件用于过滤笛卡尔积中的无效组合。如果连接条件的形式为：</p><pre class="line-numbers language-sql"><code class="language-sql"><span class="token number">a</span><span class="token punctuation">.</span>col1 <span class="token operator">&lt;</span>operator<span class="token operator">></span> <span class="token number">b</span><span class="token punctuation">.</span>col2 <span class="token punctuation">[</span><span class="token operator">AND</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>则 <code>a.col1</code> 和 <code>b.col2</code> 被称为连接键。</p><hr><h2 id="三种连接策略详解"><a href="#三种连接策略详解" class="headerlink" title="三种连接策略详解"></a>三种连接策略详解</h2><h3 id="1-Nested-Loop-Join（嵌套循环连接）"><a href="#1-Nested-Loop-Join（嵌套循环连接）" class="headerlink" title="1. Nested Loop Join（嵌套循环连接）"></a>1. Nested Loop Join（嵌套循环连接）</h3><h4 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h4><ul><li>PostgreSQL 顺序扫描外表，对于每一行，再顺序扫描内表以查找匹配的行。</li><li>这是一种简单且通用的连接策略。</li></ul><h4 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h4><ul><li>当外表非常小（例如只有几行）时，嵌套循环连接非常高效。</li><li>它是 OLTP（在线事务处理）工作负载中的常见选择，尤其是在数据模型规范化的情况下。</li><li>如果连接条件中不包含 <code>=</code> 操作符，嵌套循环连接是唯一可用的策略。</li></ul><h4 id="优化建议"><a href="#优化建议" class="headerlink" title="优化建议"></a>优化建议</h4><ul><li><strong>索引支持</strong>：在内表的连接键上创建索引可以显著加速嵌套循环连接。</li><li><strong>限制</strong>：如果外表很大，嵌套循环连接的性能会急剧下降。</li></ul><hr><h3 id="2-Hash-Join（哈希连接）"><a href="#2-Hash-Join（哈希连接）" class="headerlink" title="2. Hash Join（哈希连接）"></a>2. Hash Join（哈希连接）</h3><h4 id="工作原理-1"><a href="#工作原理-1" class="headerlink" title="工作原理"></a>工作原理</h4><ul><li>PostgreSQL 首先扫描内表并构建一个哈希表，哈希键由连接条件中使用 <code>=</code> 操作符的列组成。</li><li>然后扫描外表，并对每一行在哈希表中查找匹配的行。</li></ul><h4 id="适用场景-1"><a href="#适用场景-1" class="headerlink" title="适用场景"></a>适用场景</h4><ul><li>当两个表都较大，且哈希表可以完全放入 <code>work_mem</code> 时，哈希连接是最佳选择。</li><li>如果哈希表无法完全放入内存，PostgreSQL 会将其分批写入磁盘，导致性能下降。</li></ul><h4 id="优化建议-1"><a href="#优化建议-1" class="headerlink" title="优化建议"></a>优化建议</h4><ul><li><strong>索引支持</strong>：哈希连接通常不需要索引支持，因为它依赖于哈希表。</li><li><strong>内存配置</strong>：确保 <code>work_mem</code> 足够大，以避免哈希表被写入磁盘。</li></ul><hr><h3 id="3-Merge-Join（合并连接）"><a href="#3-Merge-Join（合并连接）" class="headerlink" title="3. Merge Join（合并连接）"></a>3. Merge Join（合并连接）</h3><h4 id="工作原理-2"><a href="#工作原理-2" class="headerlink" title="工作原理"></a>工作原理</h4><ul><li>PostgreSQL 使用 <code>=</code> 操作符的连接条件对两个表进行排序。</li><li>然后通过迭代两个排序列表来查找匹配的行。</li></ul><h4 id="适用场景-2"><a href="#适用场景-2" class="headerlink" title="适用场景"></a>适用场景</h4><ul><li>当两个表都非常大，且哈希表无法放入 <code>work_mem</code> 时，合并连接是最佳选择。</li><li>合并连接要求连接键是可排序的数据类型。</li></ul><h4 id="优化建议-2"><a href="#优化建议-2" class="headerlink" title="优化建议"></a>优化建议</h4><ul><li><strong>索引支持</strong>：在连接键上创建索引可以加速排序操作。</li><li><strong>仅索引扫描</strong>：如果索引包含查询所需的所有列，可以进一步加速合并连接。</li></ul><hr><h2 id="连接策略对比"><a href="#连接策略对比" class="headerlink" title="连接策略对比"></a>连接策略对比</h2><table><thead><tr><th align="left"></th><th align="left">Nested Loop Join</th><th align="left">Hash Join</th><th align="left">Merge Join</th></tr></thead><tbody><tr><td align="left"><strong>算法</strong></td><td align="left">对每个外表行扫描内表</td><td align="left">构建哈希表并探测</td><td align="left">对表排序并合并</td></tr><tr><td align="left"><strong>有帮助的索引</strong></td><td align="left">内表连接键上的索引</td><td align="left">无</td><td align="left">两个表连接键上的索引</td></tr><tr><td align="left"><strong>适用场景</strong></td><td align="left">外表很小</td><td align="left">哈希表可放入 <code>work_mem</code></td><td align="left">两个表都很大</td></tr></tbody></table><hr><h2 id="连接策略对查询性能的影响"><a href="#连接策略对查询性能的影响" class="headerlink" title="连接策略对查询性能的影响"></a>连接策略对查询性能的影响</h2><p>选择错误的连接策略可能导致性能问题：</p><ul><li><strong>低估行数</strong>：优化器可能错误地选择嵌套循环连接，导致内表被频繁扫描。</li><li><strong>高估行数</strong>：优化器可能错误地选择哈希连接或合并连接，导致不必要的全表扫描。</li></ul><p>这些问题通常源于行数估计错误。因此，优化查询的关键是确保统计信息的准确性。</p><hr><h2 id="如何让-PostgreSQL-选择正确的连接策略"><a href="#如何让-PostgreSQL-选择正确的连接策略" class="headerlink" title="如何让 PostgreSQL 选择正确的连接策略"></a>如何让 PostgreSQL 选择正确的连接策略</h2><h3 id="1-禁用特定连接策略"><a href="#1-禁用特定连接策略" class="headerlink" title="1. 禁用特定连接策略"></a>1. 禁用特定连接策略</h3><p>可以通过以下命令临时禁用某些连接策略，以测试不同策略的性能：</p><pre class="line-numbers language-sql"><code class="language-sql"><span class="token keyword">SET</span> enable_hashjoin <span class="token operator">=</span> <span class="token keyword">off</span><span class="token punctuation">;</span><span class="token keyword">SET</span> enable_mergejoin <span class="token operator">=</span> <span class="token keyword">off</span><span class="token punctuation">;</span><span class="token keyword">SET</span> enable_nestloop <span class="token operator">=</span> <span class="token keyword">off</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="2-优化统计信息"><a href="#2-优化统计信息" class="headerlink" title="2. 优化统计信息"></a>2. 优化统计信息</h3><ul><li>使用 <code>ANALYZE</code> 更新表的统计信息。</li><li>增加 <code>default_statistics_target</code> 以提高统计信息的准确性。</li></ul><h3 id="3-调整内存配置"><a href="#3-调整内存配置" class="headerlink" title="3. 调整内存配置"></a>3. 调整内存配置</h3><ul><li>增加 <code>work_mem</code> 以支持更大的哈希表。</li><li>调整 <code>random_page_cost</code>、<code>effective_cache_size</code> 和 <code>effective_io_concurrency</code> 以反映硬件性能。</li></ul><h3 id="4-使用仅索引扫描"><a href="#4-使用仅索引扫描" class="headerlink" title="4. 使用仅索引扫描"></a>4. 使用仅索引扫描</h3><ul><li>在连接键上创建包含所有查询列的索引（使用 <code>INCLUDE</code> 子句）。</li><li>确保表被频繁清理以支持仅索引扫描。</li></ul><hr><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>理解 PostgreSQL 的三种连接策略（Nested Loop Join、Hash Join 和 Merge Join）是优化查询性能的关键。通过合理配置统计信息、内存参数和索引，可以显著提升查询性能。如果遇到性能问题，建议逐步分析执行计划，调整连接策略，并结合硬件资源进行优化。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>HOT_STANDBY_FEEDBACK到底做了什么</title>
      <link href="/2023/hot-standby-feedback-dao-di-zuo-liao-shi-me/"/>
      <url>/2023/hot-standby-feedback-dao-di-zuo-liao-shi-me/</url>
      
        <content type="html"><![CDATA[<p>许多使用 PostgreSQL 流复制的人可能想知道 postgresql.conf 中的 <code>hot_standby_feedback</code> 参数的真正作用是什么。</p><h2 id="VACUUM-在-PostgreSQL-中做什么"><a href="#VACUUM-在-PostgreSQL-中做什么" class="headerlink" title="VACUUM 在 PostgreSQL 中做什么"></a>VACUUM 在 PostgreSQL 中做什么</h2><p>VACUUM 是 PostgreSQL 中的一个重要命令，它的目标是清除任何人不再需要的死行。这个想法是当新数据进入时重用表内的空间。重要的是：VACUUM 的目的是重用表内的空间 - 这并不一定意味着关系会收缩。另外：请记住，VACUUM 只能清除死行，如果 PostgreSQL 服务器上运行的其他事务不再需要它们。</p><p>考虑下图：</p><p><img src="/medias/image/vacuum_cleanup-01-scaled.jpg" alt="PostgreSQL VACUUM 和表膨胀"></p><p>正如您所看到的，我们这里有两个连接。左侧的第一个连接正在运行一个冗长的 SELECT 语句。现在请记住：SQL 语句基本上会“冻结”其数据视图。在 SQL 语句中，世界不会“改变”——查询将始终看到相同的数据集，而不管同时进行的更改如何。理解这一点非常重要。</p><p>我们来看看第二个事务。它将删除一些数据并提交。自然出现的问题是：PostgreSQL什么时候才能真正从磁盘中删除这一行？DELETE 本身无法真正从磁盘中清除该行，因为可能仍然存在 ROLLBACK 而不是 COMMIT。换句话说，DELETE 时不得删除行。PostgreSQL 只能将当前事务标记为死亡。正如您所看到的，其他事务可能仍然能够看到那些已删除的行。</p><p>然而，即使 COMMIT 也无权真正清除该行。请记住：左侧的事务仍然可以看到死行，因为 SELECT 语句在运行时不会更改其快照。因此，COMMIT 还为时过早，无法清除该行。</p><p>这就是 VACUUM 进入场景的时候。VACUUM 用于清理行，任何其他事务都无法再看到这些行。在我的图像中，正在进行两个 VACUUM 操作。第一个还无法清除死行，因为它仍然被左侧事务看到。然而，第二个 VACUUM 可以清理该行，因为它不再被读取事务使用。因此，在单个服务器上，情况非常清楚。VACUUM 可以清除不再出现的行。</p><h2 id="PostgreSQL-中的复制冲突"><a href="#PostgreSQL-中的复制冲突" class="headerlink" title="PostgreSQL 中的复制冲突"></a>PostgreSQL 中的复制冲突</h2><p>主备场景下会发生什么？情况稍微复杂一些，因为主数据库如何知道备用数据库之一正在发生某些奇怪的事务？</p><p>这是显示典型场景的图像：</p><p><img src="/medias/image/hot_standby_feedback-01-VACUUM-NEU-17150833881603.jpg" alt="热备反馈真空"></p><p>在这种情况下，备库上的 SELECT 语句将运行几分钟。同时，对主库进行更改（更新、删除等），这还是没问题的。请记住：DELETE 并没有真正删除该行，它只是将其标记为死行，但它仍然对其他事务可见，这些事务允许看到死行。如果允许主服务器上的VACUUM 真正从磁盘中删除行，情况就会变得很严重。VACUUM 可以这样做，因为它不知道备用设备上的某个人仍然需要该行，结果是复制冲突。默认情况下，复制冲突会在 30 秒后解决：</p><blockquote><p>ERROR: canceling statement due to conflict with recovery<br>Detail: User query might have needed to see row versions that must be removed</p></blockquote><p>如果您曾经看到过这样的消息，这正是我们在这里讨论的问题类型。</p><h2 id="hot-standby-feedback可以防止复制冲突"><a href="#hot-standby-feedback可以防止复制冲突" class="headerlink" title="hot_standby_feedback可以防止复制冲突"></a>hot_standby_feedback可以防止复制冲突</h2><p>为了解决此类问题，我们可以指导备用数据库定期通知主数据库有关备用数据库上运行的最旧事务的信息。如果主数据库知道备用数据库上的旧事务，它可以使 VACUUM 保留行，直到备用数据库完成为止。</p><p>这正是<a href="https://www.postgresql.org/docs/11/static/runtime-config-replication.html">hot_standby_feedback</a>的作用。从备用数据库的角度来看，它可以防止过早删除行。这个想法是通知主数据库有关备用数据库上最旧的事务 ID 的信息，以便VACUUM 可以延迟对某些行的清理操作。</p><p>好处是显而易见的：hot_standby_feedback将大大减少复制冲突的数量。然而，也有缺点：请记住，VACUUM 会延迟其清理操作。如果备用数据库从不终止查询，则可能会导致主数据库上的表膨胀，从长远来看这可能是危险的。</p>]]></content>
      
      
      <categories>
          
          <category> postgresql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> postgresql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>POSTGRESQL索引：索引扫描、位图扫描、顺序扫描（基础）</title>
      <link href="/2023/postgresql-suo-yin-suo-yin-sao-miao-wei-tu-sao-miao-shun-xu-sao-miao-ji-chu/"/>
      <url>/2023/postgresql-suo-yin-suo-yin-sao-miao-wei-tu-sao-miao-shun-xu-sao-miao-ji-chu/</url>
      
        <content type="html"><![CDATA[<p>很多人询问PostgreSQL 中的<a href="https://www.postgresql.org/docs/15/using-explain.html">索引扫描</a>。本博客旨在对该主题进行基本介绍。许多人不知道优化器在处理单个查询时会做什么。我决定展示如何访问表并给出示例。让我们开始使用 PostgreSQL 索引。</p><p>索引是良好性能的支柱。如果没有正确的索引，您的 PostgreSQL 数据库可能会陷入困境，最终用户可能会抱怨查询速度慢和响应时间差。因此，了解 PostgreSQL 在查询单个列时做出哪些选择是有意义的。</p><h2 id="在-PostgreSQL-中准备一些演示数据"><a href="#在-PostgreSQL-中准备一些演示数据" class="headerlink" title="在 PostgreSQL 中准备一些演示数据"></a><strong>在 PostgreSQL 中准备一些演示数据</strong></h2><p>为了向您展示事情是如何运作的，我们可以使用一个表：</p><pre class="line-numbers language-bash"><code class="language-bash">test<span class="token operator">=</span><span class="token comment" spellcheck="true"># CREATE TABLE sampletable (x numeric);</span>CREATE TABLE<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>如果您的表几乎为空，您将永远不会看到索引扫描，因为查询索引可能会产生太大的开销 - 直接扫描表并丢弃与查询不匹配的任何行会更便宜。</p><p>因此，为了演示索引的实际工作原理，我们可以向之前创建的表中添加 1000 万个随机行：</p><pre class="line-numbers language-bash"><code class="language-bash">test<span class="token operator">=</span><span class="token comment" spellcheck="true"># INSERT INTO sampletable</span>         SELECT random<span class="token punctuation">(</span><span class="token punctuation">)</span> * 10000         FROM generate_series<span class="token punctuation">(</span>1, 10000000<span class="token punctuation">)</span><span class="token punctuation">;</span>INSERT 0 10000000<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>然后创建索引：</p><pre class="line-numbers language-bash"><code class="language-bash">test<span class="token operator">=</span><span class="token comment" spellcheck="true"># CREATE INDEX idx_x ON sampletable(x);</span>CREATE INDEX<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>加载如此多的数据后，最好创建优化器统计信息，以防 autovacuum 尚未跟上。PostgreSQL 优化器需要这些统计信息来决定是否使用索引：</p><pre class="line-numbers language-bash"><code class="language-bash">test<span class="token operator">=</span><span class="token comment" spellcheck="true"># ANALYZE ; </span>ANALYZE<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>在 PostgreSQL 中，btree 使用 Lehman-Yao 高并发 btree（将在后面的博客中更详细地介绍）。</p><p><img src="/medias/image/02_PostgreSQL-Complete-B-tree-168865667503438.jpg" alt="postgresql 索引 B 树"></p><p><img src="/medias/image/01_PostgreSQL-B-tree-168865667653040.jpg" alt="postgresql 索引 B 树"></p><h2 id="在-PostgreSQL-中选择一小部分数据"><a href="#在-PostgreSQL-中选择一小部分数据" class="headerlink" title="在 PostgreSQL 中选择一小部分数据"></a><strong>在 PostgreSQL 中选择一小部分数据</strong></h2><p>当只选择一小部分行时，PostgreSQL 可以直接询问索引。在这种情况下，它甚至可以使用“仅索引扫描”，因为所需的所有列实际上已经在索引中：</p><pre class="line-numbers language-bash"><code class="language-bash">test<span class="token operator">=</span><span class="token comment" spellcheck="true"># explain SELECT * FROM sampletable WHERE x = 42353;</span>                               QUERY PLAN-----------------------------------------------------------------------Index Only Scan using idx_x on sampletable <span class="token punctuation">(</span>cost<span class="token operator">=</span>0.43<span class="token punctuation">..</span>8.45 rows<span class="token operator">=</span>1 width<span class="token operator">=</span>11<span class="token punctuation">)</span>      Index Cond: <span class="token punctuation">(</span>x <span class="token operator">=</span> <span class="token string">'42353'</span>::numeric<span class="token punctuation">)</span><span class="token punctuation">(</span>2 rows<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>使用索引仅选择少数行将非常高效。但是，如果选择更多数据，则扫描索引和表的成本会太高。</p><h2 id="PostgreSQL-索引：从-PostgreSQL-的表中选择大量数据"><a href="#PostgreSQL-索引：从-PostgreSQL-的表中选择大量数据" class="headerlink" title="PostgreSQL 索引：从 PostgreSQL 的表中选择大量数据"></a><strong>PostgreSQL 索引：从 PostgreSQL 的表中选择大量数据</strong></h2><p>但是，如果您从表中选择大量数据，PostgreSQL 将回退到顺序扫描。在这种情况下，读取整个表并仅过滤掉几行是最好的方法。</p><p>下面是它的工作原理：</p><pre class="line-numbers language-bash"><code class="language-bash">test<span class="token operator">=</span><span class="token comment" spellcheck="true"># explain SELECT * FROM sampletable WHERE x &lt; 42353;</span>                            QUERY PLAN---------------------------------------------------------------Seq Scan on sampletable <span class="token punctuation">(</span>cost<span class="token operator">=</span>0.00<span class="token punctuation">..</span>179054.03 rows<span class="token operator">=</span>9999922 width<span class="token operator">=</span>11<span class="token punctuation">)</span>    Filter: <span class="token punctuation">(</span>x <span class="token operator">&lt;</span> <span class="token string">'42353'</span>::numeric<span class="token punctuation">)</span><span class="token punctuation">(</span>2 rows<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>PostgreSQL 将过滤掉那些不必要的行并只返回其余的。在这种情况下，这确实是最理想的做法。因此，顺序扫描并不总是不好——在某些用例中，顺序扫描实际上是完美的。</p><p>不过：请记住，过于频繁地顺序扫描大型表在某些时候会造成损害。</p><h2 id="PostgreSQL：利用位图扫描"><a href="#PostgreSQL：利用位图扫描" class="headerlink" title="PostgreSQL：利用位图扫描"></a><strong>PostgreSQL：利用位图扫描</strong></h2><p>如果你只选择了少量的行，PostgreSQL将决定索引扫描——如果你选择了大多数行，PostgreSQL将决定完全读取表。但是，如果索引扫描读取的数据太多，导致效率低下，而顺序扫描读取的数据太少，该怎么办？该问题的解决方案是使用位图扫描。位图扫描背后的思想是，一个块在扫描期间只使用一次。如果您想使用多个索引来扫描单个表，它也非常有用。</p><p>发生的情况如下：</p><pre class="line-numbers language-bash"><code class="language-bash">test<span class="token operator">=</span><span class="token comment" spellcheck="true"># explain SELECT * FROM sampletable WHERE x &lt; 423;</span>                                    QUERY PLAN----------------------------------------------------------------------------Bitmap Heap Scan on sampletable <span class="token punctuation">(</span>cost<span class="token operator">=</span>9313.62<span class="token punctuation">..</span>68396.35 rows<span class="token operator">=</span>402218 width<span class="token operator">=</span>11<span class="token punctuation">)</span>       Recheck Cond: <span class="token punctuation">(</span>x <span class="token operator">&lt;</span> <span class="token string">'423'</span>::numeric<span class="token punctuation">)</span>       -<span class="token operator">></span> Bitmap Index Scan on idx_x <span class="token punctuation">(</span>cost<span class="token operator">=</span>0.00<span class="token punctuation">..</span>9213.07 rows<span class="token operator">=</span>402218 width<span class="token operator">=</span>0<span class="token punctuation">)</span>          Index Cond: <span class="token punctuation">(</span>x <span class="token operator">&lt;</span> <span class="token string">'423'</span>::numeric<span class="token punctuation">)</span><span class="token punctuation">(</span>4 rows<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>PostgreSQL将首先扫描索引，并在扫描结束时编译所需的行/块。然后PostgreSQL将获取这个列表并转到表中真正获取这些行。这种机制的美妙之处在于，即使你使用了多个索引，这种机制也可以正常工作。</p><blockquote><p>因此，位图扫描对性能有很大贡献。</p></blockquote><p><img src="/medias/image/03_PostgreSQL-Bitmap-scan-168865667947542.jpg" alt="postgresql 位图扫描"></p>]]></content>
      
      
      <categories>
          
          <category> postgresql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> postgresql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>理解PostgreSQL中的Bloat和VACUUM</title>
      <link href="/2023/li-jie-postgresql-zhong-de-bloat-he-vacuum/"/>
      <url>/2023/li-jie-postgresql-zhong-de-bloat-he-vacuum/</url>
      
        <content type="html"><![CDATA[<p>与其他RDBMS相比，PostgreSQL中MVCC的实现是不同的和特殊的。PostgreSQL中的MVCC控制哪些元组可以通过版本控制对事务可见。</p><span id="more"></span><h3 id="PostgreSQL中的版本控制是什么"><a href="#PostgreSQL中的版本控制是什么" class="headerlink" title="PostgreSQL中的版本控制是什么?"></a>PostgreSQL中的版本控制是什么?</h3><p>让我们考虑Oracle或MySQL数据库的情况。对行执行<code>DELETE</code>或<code>UPDATE</code>时会发生什么?您可以看到在全局UNDO段中维护的UNDO记录。此UNDO段包含一行的过去映像，以帮助数据库实现一致性。例如，如果有一个旧事务依赖于被删除的行，那么该行可能仍然是可见的，因为过去的映像仍然在UNDO中维护。如果您是一名Oracle DBA，正在阅读这篇文章，您可能很快就会想起ORA-01555快照太旧的错误。这个错误意味着—您可能有一个较小的undo_retention段，或者没有一个巨大的UNDO段，可以保留现有或旧事务所需的所有过去的映像(版本)。</p><p>使用PostgreSQL时，你可能不必担心这个问题。</p><h3 id="那么PostgreSQL如何管理UNDO呢"><a href="#那么PostgreSQL如何管理UNDO呢" class="headerlink" title="那么PostgreSQL如何管理UNDO呢?"></a>那么PostgreSQL如何管理UNDO呢?</h3><p>简单来说，PostgreSQL在它自己的表中同时维护一行的过去映像和最新映像。意思是在每个表中维护UNDO。这是通过版本控制完成的。现在，我们可能会得到一个提示，PostgreSQL表的每一行都有一个版本号，这是绝对正确的。为了理解这些版本是如何在每个表中维护的，你应该理解PostgreSQL中表的隐藏列(特别是<code>xmin</code>)。</p><h3 id="了解表的隐藏列"><a href="#了解表的隐藏列" class="headerlink" title="了解表的隐藏列"></a>了解表的隐藏列</h3><p>当您描述一个表时，您将只看到您已添加的列，就像您在下面的日志中看到的那样。</p><pre class="line-numbers language-bash"><code class="language-bash">percona<span class="token operator">=</span><span class="token comment" spellcheck="true"># \d scott.employee</span>                                          Table <span class="token string">"scott.employee"</span>  Column  <span class="token operator">|</span>          Type          <span class="token operator">|</span> Collation <span class="token operator">|</span> Nullable <span class="token operator">|</span>                    Default                     ----------+------------------------+-----------+----------+------------------------------------------------ emp_id   <span class="token operator">|</span> integer                <span class="token operator">|</span>           <span class="token operator">|</span> not null <span class="token operator">|</span> nextval<span class="token punctuation">(</span><span class="token string">'scott.employee_emp_id_seq'</span>::regclass<span class="token punctuation">)</span> emp_name <span class="token operator">|</span> character varying<span class="token punctuation">(</span>100<span class="token punctuation">)</span> <span class="token operator">|</span>           <span class="token operator">|</span>          <span class="token operator">|</span>  dept_id  <span class="token operator">|</span> integer                <span class="token operator">|</span>           <span class="token operator">|</span>          <span class="token operator">|</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>但是，如果查看<code>pg_attribute</code>中表的所有列，应该会看到几个隐藏的列，如下面的日志所示。</p><pre class="line-numbers language-bash"><code class="language-bash">percona<span class="token operator">=</span><span class="token comment" spellcheck="true"># SELECT attname, format_type (atttypid, atttypmod)</span>FROM pg_attributeWHERE attrelid::regclass::text<span class="token operator">=</span><span class="token string">'scott.employee'</span>ORDER BY attnum<span class="token punctuation">;</span> attname  <span class="token operator">|</span>      format_type       ----------+------------------------ tableoid <span class="token operator">|</span> oid cmax     <span class="token operator">|</span> cid xmax     <span class="token operator">|</span> xid cmin     <span class="token operator">|</span> cid xmin     <span class="token operator">|</span> xid ctid     <span class="token operator">|</span> tid emp_id   <span class="token operator">|</span> integer emp_name <span class="token operator">|</span> character varying<span class="token punctuation">(</span>100<span class="token punctuation">)</span> dept_id  <span class="token operator">|</span> integer<span class="token punctuation">(</span>9 rows<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>让我们详细了解这些隐藏的列。</p><p><strong>tableoid</strong>：包含本行所在表的<code>OID</code>。用于从继承层次结构中选择的查询。<br>关于表继承的更多细节可以在这里找到:<a href="https://www.postgresql.org/docs/10/static/ddl-inherit.html">https://www.postgresql.org/docs/10/static/ddl-inherit.html</a></p><p><strong>xmin</strong>：该行版本插入事务的事务ID(xid)。在更新时，插入一个新的行版本。让我们看看下面的日志，以更好地理解<code>xmin</code>。</p><pre class="line-numbers language-bash"><code class="language-bash">percona<span class="token operator">=</span><span class="token comment" spellcheck="true"># select txid_current();</span> txid_current --------------          646<span class="token punctuation">(</span>1 row<span class="token punctuation">)</span> percona<span class="token operator">=</span><span class="token comment" spellcheck="true"># INSERT into scott.employee VALUES (9,'avi',9);</span>INSERT 0 1percona<span class="token operator">=</span><span class="token comment" spellcheck="true"># select xmin,xmax,cmin,cmax,* from scott.employee where emp_id = 9;</span> xmin <span class="token operator">|</span> xmax <span class="token operator">|</span> cmin <span class="token operator">|</span> cmax <span class="token operator">|</span> emp_id <span class="token operator">|</span> emp_name <span class="token operator">|</span> dept_id ------+------+------+------+--------+----------+---------  647 <span class="token operator">|</span>    0 <span class="token operator">|</span>    0 <span class="token operator">|</span>    0 <span class="token operator">|</span>      9 <span class="token operator">|</span> avi      <span class="token operator">|</span>       9<span class="token punctuation">(</span>1 row<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>INSERT</code>语句获得了事务ID 647。因此，该记录的<code>xmin</code>值为647。这意味着在ID 647之前开始的任何事务ID都不能看到这一行。换句话说，已经运行txid小于647的事务无法看到txid 647插入的行。</p><p>对于上面的示例，您现在应该理解每个元组都有一个<code>xmin</code>，该<code>xmin</code>被分配了插入它的<code>txid</code>。</p><p>注意：行为可能会根据您选择的隔离级别而改变，稍后将在另一篇博客文章中讨论。</p><p><strong>xmax</strong>：如果不是已删除的行版本，则该值为0。在提交<code>DELETE</code>之前，行版本的<code>xmax</code>更改为发出<code>DELETE</code>的事务的ID。让我们观察下面的日志来更好地理解这一点。</p><p><strong>在终端A</strong>：我们打开一个事务并删除一行而不提交它。</p><pre class="line-numbers language-bash"><code class="language-bash">percona<span class="token operator">=</span><span class="token comment" spellcheck="true"># BEGIN;</span>BEGINpercona<span class="token operator">=</span><span class="token comment" spellcheck="true"># select txid_current();</span> txid_current --------------          655<span class="token punctuation">(</span>1 row<span class="token punctuation">)</span>percona<span class="token operator">=</span><span class="token comment" spellcheck="true"># DELETE from scott.employee where emp_id = 10;</span>DELETE 1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>在终端B上</strong>：观察删除(尚未提交)前后的<code>xmax</code>值。</p><pre class="line-numbers language-bash"><code class="language-bash">Before the Delete------------------percona<span class="token operator">=</span><span class="token comment" spellcheck="true"># select xmin,xmax,cmin,cmax,* from scott.employee where emp_id = 10;</span> xmin <span class="token operator">|</span> xmax <span class="token operator">|</span> cmin <span class="token operator">|</span> cmax <span class="token operator">|</span> emp_id <span class="token operator">|</span> emp_name <span class="token operator">|</span> dept_id ------+------+------+------+--------+----------+---------  649 <span class="token operator">|</span>    0 <span class="token operator">|</span>    0 <span class="token operator">|</span>    0 <span class="token operator">|</span>     10 <span class="token operator">|</span> avi      <span class="token operator">|</span>      10After the Delete------------------percona<span class="token operator">=</span><span class="token comment" spellcheck="true"># select xmin,xmax,cmin,cmax,* from scott.employee where emp_id = 10;</span> xmin <span class="token operator">|</span> xmax <span class="token operator">|</span> cmin <span class="token operator">|</span> cmax <span class="token operator">|</span> emp_id <span class="token operator">|</span> emp_name <span class="token operator">|</span> dept_id ------+------+------+------+--------+----------+---------  649 <span class="token operator">|</span>  655 <span class="token operator">|</span>    0 <span class="token operator">|</span>    0 <span class="token operator">|</span>     10 <span class="token operator">|</span> avi      <span class="token operator">|</span>      10<span class="token punctuation">(</span>1 row<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>正如您在上面的日志中看到的，<code>xmax</code>值更改为发出删除操作的事务ID。如果您发出了<code>ROLLBACK</code>命令，或者事务中止了，那么<code>xmax</code>仍然保留在试图删除它的事务ID上(在本例中是655)。</p><p>现在我们已经理解了隐藏列<code>xmin</code>和<code>xmax</code>，让我们来观察在PostgreSQL中执行<code>DELETE</code>或<code>UPDATE</code>之后会发生什么。如前所述，通过PostgreSQL中每个表的隐藏列，我们了解到每个表中维护了多个版本的行。让我们看看下面的例子来更好地理解这一点。</p><p>我们将向表中插入10条记录：<code>scott.employee</code></p><pre class="line-numbers language-bash"><code class="language-bash">percona<span class="token operator">=</span><span class="token comment" spellcheck="true"># INSERT into scott.employee VALUES (generate_series(1,10),'avi',1);</span>INSERT 0 10<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>现在，让我们从表中删除5条记录。</p><pre class="line-numbers language-bash"><code class="language-bash">percona<span class="token operator">=</span><span class="token comment" spellcheck="true"># DELETE from scott.employee where emp_id > 5;</span>DELETE 5percona<span class="token operator">=</span><span class="token comment" spellcheck="true"># select count(*) from scott.employee;</span> count -------     5<span class="token punctuation">(</span>1 row<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>现在，当您在<code>DELETE</code>之后检查计数时，您将看不到已被删除的记录。要查看表中存在但不可见的任何行版本，我们有一个名为<code>pageinspect</code>的扩展。<code>pageinspect</code>模块提供了一些函数，允许你在较低的级别上检查数据库页面的内容，这对于调试很有用。让我们创建这个扩展来查看已删除的旧行版本。</p><pre class="line-numbers language-bash"><code class="language-bash">percona<span class="token operator">=</span><span class="token comment" spellcheck="true"># CREATE EXTENSION pageinspect;</span>CREATE EXTENSION percona<span class="token operator">=</span><span class="token comment" spellcheck="true"># SELECT t_xmin, t_xmax, tuple_data_split('scott.employee'::regclass, t_data, t_infomask, t_infomask2, t_bits) FROM heap_page_items(get_raw_page('scott.employee', 0));</span> t_xmin <span class="token operator">|</span> t_xmax <span class="token operator">|</span>              tuple_data_split               --------+--------+---------------------------------------------    668 <span class="token operator">|</span>      0 <span class="token operator">|</span> <span class="token punctuation">{</span><span class="token string">"\\x01000000"</span>,<span class="token string">"\\x09617669"</span>,<span class="token string">"\\x01000000"</span><span class="token punctuation">}</span>    668 <span class="token operator">|</span>      0 <span class="token operator">|</span> <span class="token punctuation">{</span><span class="token string">"\\x02000000"</span>,<span class="token string">"\\x09617669"</span>,<span class="token string">"\\x01000000"</span><span class="token punctuation">}</span>    668 <span class="token operator">|</span>      0 <span class="token operator">|</span> <span class="token punctuation">{</span><span class="token string">"\\x03000000"</span>,<span class="token string">"\\x09617669"</span>,<span class="token string">"\\x01000000"</span><span class="token punctuation">}</span>    668 <span class="token operator">|</span>      0 <span class="token operator">|</span> <span class="token punctuation">{</span><span class="token string">"\\x04000000"</span>,<span class="token string">"\\x09617669"</span>,<span class="token string">"\\x01000000"</span><span class="token punctuation">}</span>    668 <span class="token operator">|</span>      0 <span class="token operator">|</span> <span class="token punctuation">{</span><span class="token string">"\\x05000000"</span>,<span class="token string">"\\x09617669"</span>,<span class="token string">"\\x01000000"</span><span class="token punctuation">}</span>    668 <span class="token operator">|</span>    669 <span class="token operator">|</span> <span class="token punctuation">{</span><span class="token string">"\\x06000000"</span>,<span class="token string">"\\x09617669"</span>,<span class="token string">"\\x01000000"</span><span class="token punctuation">}</span>    668 <span class="token operator">|</span>    669 <span class="token operator">|</span> <span class="token punctuation">{</span><span class="token string">"\\x07000000"</span>,<span class="token string">"\\x09617669"</span>,<span class="token string">"\\x01000000"</span><span class="token punctuation">}</span>    668 <span class="token operator">|</span>    669 <span class="token operator">|</span> <span class="token punctuation">{</span><span class="token string">"\\x08000000"</span>,<span class="token string">"\\x09617669"</span>,<span class="token string">"\\x01000000"</span><span class="token punctuation">}</span>    668 <span class="token operator">|</span>    669 <span class="token operator">|</span> <span class="token punctuation">{</span><span class="token string">"\\x09000000"</span>,<span class="token string">"\\x09617669"</span>,<span class="token string">"\\x01000000"</span><span class="token punctuation">}</span>    668 <span class="token operator">|</span>    669 <span class="token operator">|</span> <span class="token punctuation">{</span><span class="token string">"\\x0a000000"</span>,<span class="token string">"\\x09617669"</span>,<span class="token string">"\\x01000000"</span><span class="token punctuation">}</span><span class="token punctuation">(</span>10 rows<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>现在，即使从表中删除了5条记录，我们仍然可以在表中看到10条记录。此外，您可以在这里观察到<code>t_xmax</code>被设置为删除它们的事务ID。这些已删除的记录保留在同一个表中，以便为仍在访问它们的任何旧事务提供服务。</p><p>我们将在下面的日志中看看<code>UPDATE</code>会做什么。</p><pre class="line-numbers language-bash"><code class="language-bash">percona<span class="token operator">=</span><span class="token comment" spellcheck="true"># DROP TABLE scott.employee ;</span>DROP TABLEpercona<span class="token operator">=</span><span class="token comment" spellcheck="true"># CREATE TABLE scott.employee (emp_id INT, emp_name VARCHAR(100), dept_id INT);</span>CREATE TABLEpercona<span class="token operator">=</span><span class="token comment" spellcheck="true"># INSERT into scott.employee VALUES (generate_series(1,10),'avi',1);</span>INSERT 0 10percona<span class="token operator">=</span><span class="token comment" spellcheck="true"># UPDATE scott.employee SET emp_name = 'avii';</span>UPDATE 10percona<span class="token operator">=</span><span class="token comment" spellcheck="true"># SELECT t_xmin, t_xmax, tuple_data_split('scott.employee'::regclass, t_data, t_infomask, t_infomask2, t_bits) FROM heap_page_items(get_raw_page('scott.employee', 0));</span> t_xmin <span class="token operator">|</span> t_xmax <span class="token operator">|</span>               tuple_data_split                --------+--------+-----------------------------------------------    672 <span class="token operator">|</span>    673 <span class="token operator">|</span> <span class="token punctuation">{</span><span class="token string">"\\x01000000"</span>,<span class="token string">"\\x09617669"</span>,<span class="token string">"\\x01000000"</span><span class="token punctuation">}</span>    672 <span class="token operator">|</span>    673 <span class="token operator">|</span> <span class="token punctuation">{</span><span class="token string">"\\x02000000"</span>,<span class="token string">"\\x09617669"</span>,<span class="token string">"\\x01000000"</span><span class="token punctuation">}</span>    672 <span class="token operator">|</span>    673 <span class="token operator">|</span> <span class="token punctuation">{</span><span class="token string">"\\x03000000"</span>,<span class="token string">"\\x09617669"</span>,<span class="token string">"\\x01000000"</span><span class="token punctuation">}</span>    672 <span class="token operator">|</span>    673 <span class="token operator">|</span> <span class="token punctuation">{</span><span class="token string">"\\x04000000"</span>,<span class="token string">"\\x09617669"</span>,<span class="token string">"\\x01000000"</span><span class="token punctuation">}</span>    672 <span class="token operator">|</span>    673 <span class="token operator">|</span> <span class="token punctuation">{</span><span class="token string">"\\x05000000"</span>,<span class="token string">"\\x09617669"</span>,<span class="token string">"\\x01000000"</span><span class="token punctuation">}</span>    672 <span class="token operator">|</span>    673 <span class="token operator">|</span> <span class="token punctuation">{</span><span class="token string">"\\x06000000"</span>,<span class="token string">"\\x09617669"</span>,<span class="token string">"\\x01000000"</span><span class="token punctuation">}</span>    672 <span class="token operator">|</span>    673 <span class="token operator">|</span> <span class="token punctuation">{</span><span class="token string">"\\x07000000"</span>,<span class="token string">"\\x09617669"</span>,<span class="token string">"\\x01000000"</span><span class="token punctuation">}</span>    672 <span class="token operator">|</span>    673 <span class="token operator">|</span> <span class="token punctuation">{</span><span class="token string">"\\x08000000"</span>,<span class="token string">"\\x09617669"</span>,<span class="token string">"\\x01000000"</span><span class="token punctuation">}</span>    672 <span class="token operator">|</span>    673 <span class="token operator">|</span> <span class="token punctuation">{</span><span class="token string">"\\x09000000"</span>,<span class="token string">"\\x09617669"</span>,<span class="token string">"\\x01000000"</span><span class="token punctuation">}</span>    672 <span class="token operator">|</span>    673 <span class="token operator">|</span> <span class="token punctuation">{</span><span class="token string">"\\x0a000000"</span>,<span class="token string">"\\x09617669"</span>,<span class="token string">"\\x01000000"</span><span class="token punctuation">}</span>    673 <span class="token operator">|</span>      0 <span class="token operator">|</span> <span class="token punctuation">{</span><span class="token string">"\\x01000000"</span>,<span class="token string">"\\x0b61766969"</span>,<span class="token string">"\\x01000000"</span><span class="token punctuation">}</span>    673 <span class="token operator">|</span>      0 <span class="token operator">|</span> <span class="token punctuation">{</span><span class="token string">"\\x02000000"</span>,<span class="token string">"\\x0b61766969"</span>,<span class="token string">"\\x01000000"</span><span class="token punctuation">}</span>    673 <span class="token operator">|</span>      0 <span class="token operator">|</span> <span class="token punctuation">{</span><span class="token string">"\\x03000000"</span>,<span class="token string">"\\x0b61766969"</span>,<span class="token string">"\\x01000000"</span><span class="token punctuation">}</span>    673 <span class="token operator">|</span>      0 <span class="token operator">|</span> <span class="token punctuation">{</span><span class="token string">"\\x04000000"</span>,<span class="token string">"\\x0b61766969"</span>,<span class="token string">"\\x01000000"</span><span class="token punctuation">}</span>    673 <span class="token operator">|</span>      0 <span class="token operator">|</span> <span class="token punctuation">{</span><span class="token string">"\\x05000000"</span>,<span class="token string">"\\x0b61766969"</span>,<span class="token string">"\\x01000000"</span><span class="token punctuation">}</span>    673 <span class="token operator">|</span>      0 <span class="token operator">|</span> <span class="token punctuation">{</span><span class="token string">"\\x06000000"</span>,<span class="token string">"\\x0b61766969"</span>,<span class="token string">"\\x01000000"</span><span class="token punctuation">}</span>    673 <span class="token operator">|</span>      0 <span class="token operator">|</span> <span class="token punctuation">{</span><span class="token string">"\\x07000000"</span>,<span class="token string">"\\x0b61766969"</span>,<span class="token string">"\\x01000000"</span><span class="token punctuation">}</span>    673 <span class="token operator">|</span>      0 <span class="token operator">|</span> <span class="token punctuation">{</span><span class="token string">"\\x08000000"</span>,<span class="token string">"\\x0b61766969"</span>,<span class="token string">"\\x01000000"</span><span class="token punctuation">}</span>    673 <span class="token operator">|</span>      0 <span class="token operator">|</span> <span class="token punctuation">{</span><span class="token string">"\\x09000000"</span>,<span class="token string">"\\x0b61766969"</span>,<span class="token string">"\\x01000000"</span><span class="token punctuation">}</span>    673 <span class="token operator">|</span>      0 <span class="token operator">|</span> <span class="token punctuation">{</span><span class="token string">"\\x0a000000"</span>,<span class="token string">"\\x0b61766969"</span>,<span class="token string">"\\x01000000"</span><span class="token punctuation">}</span><span class="token punctuation">(</span>20 rows<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>PostgreSQL中的<code>UPDATE</code>将执行插入和删除操作。因此，所有被更新的记录都被删除并插入新值。删除的记录<code>t_xmax</code>值非零。</p><p>前面的事务可能需要<code>t_xmax</code>值为非零的记录，以确保基于适当隔离级别的一致性。</p><p>我们讨论了<code>xmin</code>和<code>xmax</code>。这些隐藏列<code>cmin</code>和<code>cmax</code>是什么?</p><p><strong>cmax</strong>：删除事务中的命令标识符或零。(根据文件)。然而，<code>cmin</code>和<code>cmax</code>始终与PostgreSQL源代码相同。</p><p><strong>cmin</strong>：插入事务中的命令标识符。您可以在下面的日志中看到3条以0开头的插入语句的<code>cmin</code>。</p><p>查看下面的日志，了解<code>cmin</code>和<code>cmax</code>值如何通过事务中的插入和删除而改变。</p><pre class="line-numbers language-bash"><code class="language-bash">On Terminal A---------------percona<span class="token operator">=</span><span class="token comment" spellcheck="true"># BEGIN;</span>BEGINpercona<span class="token operator">=</span><span class="token comment" spellcheck="true"># INSERT into scott.employee VALUES (1,'avi',2);</span>INSERT 0 1percona<span class="token operator">=</span><span class="token comment" spellcheck="true"># INSERT into scott.employee VALUES (2,'avi',2);</span>INSERT 0 1percona<span class="token operator">=</span><span class="token comment" spellcheck="true"># INSERT into scott.employee VALUES (3,'avi',2);</span>INSERT 0 1percona<span class="token operator">=</span><span class="token comment" spellcheck="true"># INSERT into scott.employee VALUES (4,'avi',2);</span>INSERT 0 1percona<span class="token operator">=</span><span class="token comment" spellcheck="true"># INSERT into scott.employee VALUES (5,'avi',2);</span>INSERT 0 1percona<span class="token operator">=</span><span class="token comment" spellcheck="true"># INSERT into scott.employee VALUES (6,'avi',2);</span>INSERT 0 1percona<span class="token operator">=</span><span class="token comment" spellcheck="true"># INSERT into scott.employee VALUES (7,'avi',2);</span>INSERT 0 1percona<span class="token operator">=</span><span class="token comment" spellcheck="true"># INSERT into scott.employee VALUES (8,'avi',2);</span>INSERT 0 1percona<span class="token operator">=</span><span class="token comment" spellcheck="true"># COMMIT;</span>COMMITpercona<span class="token operator">=</span><span class="token comment" spellcheck="true"># select xmin,xmax,cmin,cmax,* from scott.employee;</span> xmin <span class="token operator">|</span> xmax <span class="token operator">|</span> cmin <span class="token operator">|</span> cmax <span class="token operator">|</span> emp_id <span class="token operator">|</span> emp_name <span class="token operator">|</span> dept_id ------+------+------+------+--------+----------+---------  644 <span class="token operator">|</span>    0 <span class="token operator">|</span>    0 <span class="token operator">|</span>    0 <span class="token operator">|</span>      1 <span class="token operator">|</span> avi      <span class="token operator">|</span>       2  644 <span class="token operator">|</span>    0 <span class="token operator">|</span>    1 <span class="token operator">|</span>    1 <span class="token operator">|</span>      2 <span class="token operator">|</span> avi      <span class="token operator">|</span>       2  644 <span class="token operator">|</span>    0 <span class="token operator">|</span>    2 <span class="token operator">|</span>    2 <span class="token operator">|</span>      3 <span class="token operator">|</span> avi      <span class="token operator">|</span>       2  644 <span class="token operator">|</span>    0 <span class="token operator">|</span>    3 <span class="token operator">|</span>    3 <span class="token operator">|</span>      4 <span class="token operator">|</span> avi      <span class="token operator">|</span>       2  644 <span class="token operator">|</span>    0 <span class="token operator">|</span>    4 <span class="token operator">|</span>    4 <span class="token operator">|</span>      5 <span class="token operator">|</span> avi      <span class="token operator">|</span>       2  644 <span class="token operator">|</span>    0 <span class="token operator">|</span>    5 <span class="token operator">|</span>    5 <span class="token operator">|</span>      6 <span class="token operator">|</span> avi      <span class="token operator">|</span>       2  644 <span class="token operator">|</span>    0 <span class="token operator">|</span>    6 <span class="token operator">|</span>    6 <span class="token operator">|</span>      7 <span class="token operator">|</span> avi      <span class="token operator">|</span>       2  644 <span class="token operator">|</span>    0 <span class="token operator">|</span>    7 <span class="token operator">|</span>    7 <span class="token operator">|</span>      8 <span class="token operator">|</span> avi      <span class="token operator">|</span>       2<span class="token punctuation">(</span>8 rows<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如果观察上面的输出日志，可以看到<code>cmin</code>和<code>cmax</code>值在每次插入时都在增加。</p><p>现在让我们从终端A中删除3条记录，并观察<code>COMMIT</code>之前这些值在终端B中是如何出现的。</p><pre class="line-numbers language-bash"><code class="language-bash">On Terminal A--------------- percona<span class="token operator">=</span><span class="token comment" spellcheck="true"># BEGIN;</span>BEGINpercona<span class="token operator">=</span><span class="token comment" spellcheck="true"># DELETE from scott.employee where emp_id = 4;</span>DELETE 1percona<span class="token operator">=</span><span class="token comment" spellcheck="true"># DELETE from scott.employee where emp_id = 5;</span>DELETE 1percona<span class="token operator">=</span><span class="token comment" spellcheck="true"># DELETE from scott.employee where emp_id = 6;</span>DELETE 1 On Terminal B, before issuing COMMIT on Terminal A----------------------------------------------------percona<span class="token operator">=</span><span class="token comment" spellcheck="true"># select xmin,xmax,cmin,cmax,* from scott.employee;</span> xmin <span class="token operator">|</span> xmax <span class="token operator">|</span> cmin <span class="token operator">|</span> cmax <span class="token operator">|</span> emp_id <span class="token operator">|</span> emp_name <span class="token operator">|</span> dept_id ------+------+------+------+--------+----------+---------  644 <span class="token operator">|</span>    0 <span class="token operator">|</span>    0 <span class="token operator">|</span>    0 <span class="token operator">|</span>      1 <span class="token operator">|</span> avi      <span class="token operator">|</span>       2  644 <span class="token operator">|</span>    0 <span class="token operator">|</span>    1 <span class="token operator">|</span>    1 <span class="token operator">|</span>      2 <span class="token operator">|</span> avi      <span class="token operator">|</span>       2  644 <span class="token operator">|</span>    0 <span class="token operator">|</span>    2 <span class="token operator">|</span>    2 <span class="token operator">|</span>      3 <span class="token operator">|</span> avi      <span class="token operator">|</span>       2  644 <span class="token operator">|</span>  645 <span class="token operator">|</span>    0 <span class="token operator">|</span>    0 <span class="token operator">|</span>      4 <span class="token operator">|</span> avi      <span class="token operator">|</span>       2  644 <span class="token operator">|</span>  645 <span class="token operator">|</span>    1 <span class="token operator">|</span>    1 <span class="token operator">|</span>      5 <span class="token operator">|</span> avi      <span class="token operator">|</span>       2  644 <span class="token operator">|</span>  645 <span class="token operator">|</span>    2 <span class="token operator">|</span>    2 <span class="token operator">|</span>      6 <span class="token operator">|</span> avi      <span class="token operator">|</span>       2  644 <span class="token operator">|</span>    0 <span class="token operator">|</span>    6 <span class="token operator">|</span>    6 <span class="token operator">|</span>      7 <span class="token operator">|</span> avi      <span class="token operator">|</span>       2  644 <span class="token operator">|</span>    0 <span class="token operator">|</span>    7 <span class="token operator">|</span>    7 <span class="token operator">|</span>      8 <span class="token operator">|</span> avi      <span class="token operator">|</span>       2<span class="token punctuation">(</span>8 rows<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>现在，在上面的日志中，您可以看到要删除的记录的<code>cmax</code>和<code>cmin</code>值已经从0开始递增。它们的值在删除之前是不同的，正如我们前面看到的那样。即使您<code>ROLLBACK</code>，这些值也保持不变。</p><p>在理解了隐藏的列以及PostgreSQL如何将<code>UNDO</code>维护为多个版本的行之后，下一个问题是:如何从表中清除这个<code>UNDO</code> ?这不是会不断增加表的大小吗?为了更好地理解这一点，我们需要了解PostgreSQL中的<code>VACUUM</code>。</p><h3 id="PostgreSQL中的vacuum"><a href="#PostgreSQL中的vacuum" class="headerlink" title="PostgreSQL中的vacuum"></a>PostgreSQL中的vacuum</h3><p>正如在上面的例子中看到的，每一个这样的记录被删除，但仍然占用一些空间被称为一个<em>死元组</em>。一旦已经运行的事务不再依赖于这些死元组，就不再需要这些死元组了。因此，PostgreSQL在这样的表上运行<code>VACUUM</code>。<code>VACUUM</code>回收这些死元组占用的存储空间。这些死元组所占用的空间可以称为<em>Bloat</em>。<code>VACUUM</code>扫描页面寻找死元组，并将它们标记到自由空间映射(FSM)。除了哈希索引之外，每个关系都有一个FSM存储在一个名为<relation_oid>_fsm的单独文件中。</relation_oid></p><p>这里，<code>relation_oid</code>是在<code>pg_class</code>中可见的关系的<code>oid</code>。</p><pre class="line-numbers language-bash"><code class="language-bash">percona<span class="token operator">=</span><span class="token comment" spellcheck="true"># select oid from pg_class where relname = 'employee';</span>  oid  ------- 24613<span class="token punctuation">(</span>1 row<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在<code>VACUUM</code>时，这个空间不会被回收到磁盘，但可以被将来在该表上的插入重新使用。<code>VACUUM</code>将每个堆(或索引)页上可用的空闲空间存储到<code>FSM</code>文件中。</p><p>运行<code>VACUUM</code>是非阻塞操作。它永远不会在表上引起独占锁。这意味着<code>VACUUM</code>可以在生产中的繁忙事务表上运行，同时有多个事务写入该表。</p><p>如前所述，10条记录的<code>UPDATE</code>生成了10个死元组。让我们看看下面的日志，了解在<code>VACUUM</code>之后这些死元组发生了什么。</p><pre class="line-numbers language-bash"><code class="language-bash">percona<span class="token operator">=</span><span class="token comment" spellcheck="true"># VACUUM scott.employee ;</span>VACUUMpercona<span class="token operator">=</span><span class="token comment" spellcheck="true"># SELECT t_xmin, t_xmax, tuple_data_split('scott.employee'::regclass, t_data, t_infomask, t_infomask2, t_bits) FROM heap_page_items(get_raw_page('scott.employee', 0));</span> t_xmin <span class="token operator">|</span> t_xmax <span class="token operator">|</span>               tuple_data_split                --------+--------+-----------------------------------------------        <span class="token operator">|</span>        <span class="token operator">|</span>         <span class="token operator">|</span>        <span class="token operator">|</span>         <span class="token operator">|</span>        <span class="token operator">|</span>         <span class="token operator">|</span>        <span class="token operator">|</span>         <span class="token operator">|</span>        <span class="token operator">|</span>         <span class="token operator">|</span>        <span class="token operator">|</span>         <span class="token operator">|</span>        <span class="token operator">|</span>         <span class="token operator">|</span>        <span class="token operator">|</span>         <span class="token operator">|</span>        <span class="token operator">|</span>         <span class="token operator">|</span>        <span class="token operator">|</span>     673 <span class="token operator">|</span>      0 <span class="token operator">|</span> <span class="token punctuation">{</span><span class="token string">"\\x01000000"</span>,<span class="token string">"\\x0b61766969"</span>,<span class="token string">"\\x01000000"</span><span class="token punctuation">}</span>    673 <span class="token operator">|</span>      0 <span class="token operator">|</span> <span class="token punctuation">{</span><span class="token string">"\\x02000000"</span>,<span class="token string">"\\x0b61766969"</span>,<span class="token string">"\\x01000000"</span><span class="token punctuation">}</span>    673 <span class="token operator">|</span>      0 <span class="token operator">|</span> <span class="token punctuation">{</span><span class="token string">"\\x03000000"</span>,<span class="token string">"\\x0b61766969"</span>,<span class="token string">"\\x01000000"</span><span class="token punctuation">}</span>    673 <span class="token operator">|</span>      0 <span class="token operator">|</span> <span class="token punctuation">{</span><span class="token string">"\\x04000000"</span>,<span class="token string">"\\x0b61766969"</span>,<span class="token string">"\\x01000000"</span><span class="token punctuation">}</span>    673 <span class="token operator">|</span>      0 <span class="token operator">|</span> <span class="token punctuation">{</span><span class="token string">"\\x05000000"</span>,<span class="token string">"\\x0b61766969"</span>,<span class="token string">"\\x01000000"</span><span class="token punctuation">}</span>    673 <span class="token operator">|</span>      0 <span class="token operator">|</span> <span class="token punctuation">{</span><span class="token string">"\\x06000000"</span>,<span class="token string">"\\x0b61766969"</span>,<span class="token string">"\\x01000000"</span><span class="token punctuation">}</span>    673 <span class="token operator">|</span>      0 <span class="token operator">|</span> <span class="token punctuation">{</span><span class="token string">"\\x07000000"</span>,<span class="token string">"\\x0b61766969"</span>,<span class="token string">"\\x01000000"</span><span class="token punctuation">}</span>    673 <span class="token operator">|</span>      0 <span class="token operator">|</span> <span class="token punctuation">{</span><span class="token string">"\\x08000000"</span>,<span class="token string">"\\x0b61766969"</span>,<span class="token string">"\\x01000000"</span><span class="token punctuation">}</span>    673 <span class="token operator">|</span>      0 <span class="token operator">|</span> <span class="token punctuation">{</span><span class="token string">"\\x09000000"</span>,<span class="token string">"\\x0b61766969"</span>,<span class="token string">"\\x01000000"</span><span class="token punctuation">}</span>    673 <span class="token operator">|</span>      0 <span class="token operator">|</span> <span class="token punctuation">{</span><span class="token string">"\\x0a000000"</span>,<span class="token string">"\\x0b61766969"</span>,<span class="token string">"\\x01000000"</span><span class="token punctuation">}</span><span class="token punctuation">(</span>20 rows<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在上面的日志中，您可能会注意到已删除的元组，并且空间可供重用。但是，在<code>VACUUM</code>之后，这个空间不会被回收到文件系统中。只有将来的插入才能使用这个空间。</p><p><code>VACUUM</code>还有一个额外的任务。在过去插入并成功提交的所有行都被标记为冻结，这表明它们对所有当前和未来的事务都可见。我们将在未来的博客文章“PostgreSQL中的事务ID封装”中详细讨论这个问题。</p><p><code>VACUUM</code>通常不会将空间回收到文件系统，除非死亡元组超出了高水位标志。</p><p>让我们考虑下面的示例，看看<code>VACUUM</code>何时可以将空间释放到文件系统。</p><p>创建一个表并插入一些示例记录。记录在磁盘上根据主键索引进行物理排序。</p><pre class="line-numbers language-bash"><code class="language-bash">percona<span class="token operator">=</span><span class="token comment" spellcheck="true"># CREATE TABLE scott.employee (emp_id int PRIMARY KEY, name varchar(20), dept_id int);</span>CREATE TABLEpercona<span class="token operator">=</span><span class="token comment" spellcheck="true"># INSERT INTO scott.employee VALUES (generate_series(1,1000), 'avi', 1);</span>INSERT 0 1000<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>现在，在表上运行<code>ANALYZE</code>以更新其统计信息，并查看在上述插入之后分配给表的页面数量。</p><pre class="line-numbers language-bash"><code class="language-bash">percona<span class="token operator">=</span><span class="token comment" spellcheck="true"># ANALYZE scott.employee ;</span>ANALYZEpercona<span class="token operator">=</span><span class="token comment" spellcheck="true"># select relpages, relpages*8192 as total_bytes, pg_relation_size('scott.employee') as relsize </span>FROM pg_class WHERE relname <span class="token operator">=</span> <span class="token string">'employee'</span><span class="token punctuation">;</span>relpages <span class="token operator">|</span> total_bytes <span class="token operator">|</span> relsize ---------+-------------+---------6        <span class="token operator">|</span> 49152       <span class="token operator">|</span> 49152<span class="token punctuation">(</span>1 row<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>现在让我们看看当删除带有emp_id &gt; 500的行时<code>VACUUM</code>的行为</p><pre class="line-numbers language-bash"><code class="language-bash">percona<span class="token operator">=</span><span class="token comment" spellcheck="true"># DELETE from scott.employee where emp_id > 500;</span>DELETE 500percona<span class="token operator">=</span><span class="token comment" spellcheck="true"># VACUUM ANALYZE scott.employee ;</span>VACUUMpercona<span class="token operator">=</span><span class="token comment" spellcheck="true"># select relpages, relpages*8192 as total_bytes, pg_relation_size('scott.employee') as relsize </span>FROM pg_class WHERE relname <span class="token operator">=</span> <span class="token string">'employee'</span><span class="token punctuation">;</span>relpages <span class="token operator">|</span> total_bytes <span class="token operator">|</span> relsize ---------+-------------+---------3        <span class="token operator">|</span> 24576       <span class="token operator">|</span> 24576<span class="token punctuation">(</span>1 row<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在上面的日志中，您可以看到<code>VACUUM</code>回收了文件系统的一半空间。在此之前，它占用了6个页面(每个页面8KB或设置参数为block_size)。在<code>VACUUM</code>之后，它向文件系统释放了3个页面。</p><p>现在，让我们重复相同的练习，删除emp_id &lt; 500的行</p><pre class="line-numbers language-bash"><code class="language-bash">percona<span class="token operator">=</span><span class="token comment" spellcheck="true"># DELETE from scott.employee ;</span>DELETE 500percona<span class="token operator">=</span><span class="token comment" spellcheck="true"># INSERT INTO scott.employee VALUES (generate_series(1,1000), 'avi', 1);</span>INSERT 0 1000percona<span class="token operator">=</span><span class="token comment" spellcheck="true"># DELETE from scott.employee where emp_id &lt; 500;</span>DELETE 499percona<span class="token operator">=</span><span class="token comment" spellcheck="true"># VACUUM ANALYZE scott.employee ;</span>VACUUMpercona<span class="token operator">=</span><span class="token comment" spellcheck="true"># select relpages, relpages*8192 as total_bytes, pg_relation_size('scott.employee') as relsize </span>FROM pg_class WHERE relname <span class="token operator">=</span> <span class="token string">'employee'</span><span class="token punctuation">;</span> relpages <span class="token operator">|</span> total_bytes <span class="token operator">|</span> relsize ----------+-------------+---------        6 <span class="token operator">|</span>       49152 <span class="token operator">|</span>   49152<span class="token punctuation">(</span>1 row<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在上面的示例中，可以看到在从表中删除一半记录后，页面数仍然保持不变。这意味着<code>VACUUM</code>这次没有向文件系统释放空间。</p><p>正如前面所解释的，如果在高水位标记之后没有更多活动元组的页面，则可以通过<code>VACUUM</code>将后续页面刷新到磁盘。在第一种情况下，第三页之后没有活动元组是可以理解的。因此，第4、5和6页已被刷新到磁盘。</p><p>但是，如果在删除emp_id &lt; 500的所有记录的场景中，您需要将空间回收到文件系统中，则可以运行<code>VACUUM FULL</code>。<code>VACUUM FULL</code>重新构建整个表并将空间回收到磁盘。</p><pre class="line-numbers language-bash"><code class="language-bash">percona<span class="token operator">=</span><span class="token comment" spellcheck="true"># VACUUM FULL scott.employee ;</span>VACUUMpercona<span class="token operator">=</span><span class="token comment" spellcheck="true"># VACUUM ANALYZE scott.employee ;</span>VACUUMpercona<span class="token operator">=</span><span class="token comment" spellcheck="true"># select relpages, relpages*8192 as total_bytes, pg_relation_size('scott.employee') as relsize </span>FROM pg_class WHERE relname <span class="token operator">=</span> <span class="token string">'employee'</span><span class="token punctuation">;</span> relpages <span class="token operator">|</span> total_bytes <span class="token operator">|</span> relsize ----------+-------------+---------        3 <span class="token operator">|</span>       24576 <span class="token operator">|</span>   24576<span class="token punctuation">(</span>1 row<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>请注意，真空充分不是一个在线操作。这是一个阻塞操作。在进行<code>VACUUM FULL</code>时，不能从表中读取或写入。我们将在以后的博客文章中讨论在不阻塞的情况下在线重建表的方法。</p>]]></content>
      
      
      <categories>
          
          <category> postgresql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> postgresql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>flask+postgresql+bootstrap实现检索系统</title>
      <link href="/2023/flask-postgresql-bootstrap-shi-xian-jian-suo-xi-tong/"/>
      <url>/2023/flask-postgresql-bootstrap-shi-xian-jian-suo-xi-tong/</url>
      
        <content type="html"><![CDATA[<p>一个检索系统</p><span id="more"></span><p>直接上代码：</p><p>index.html</p><pre class="line-numbers language-html"><code class="language-html"><span class="token doctype">&lt;!DOCTYPE html></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>html</span> <span class="token attr-name">lang</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>en<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>head</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">charset</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>UTF-8<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>title</span><span class="token punctuation">></span></span>搜索引擎<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>title</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>head</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>viewport<span class="token punctuation">"</span></span> <span class="token attr-name">content</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>width<span class="token punctuation">=</span>device-width, initial-scale<span class="token punctuation">=</span>1<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>link</span> <span class="token attr-name">href</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>{{ url_for(<span class="token punctuation">'</span>static<span class="token punctuation">'</span>, filename<span class="token punctuation">=</span><span class="token punctuation">'</span>css/bootstrap.min.css<span class="token punctuation">'</span>) }}<span class="token punctuation">"</span></span> <span class="token attr-name">rel</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>stylesheet<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>{{ url_for(<span class="token punctuation">'</span>static<span class="token punctuation">'</span>, filename<span class="token punctuation">=</span><span class="token punctuation">'</span>js/jquery.min.js<span class="token punctuation">'</span>) }}<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token script language-javascript"></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>{{ url_for(<span class="token punctuation">'</span>static<span class="token punctuation">'</span>, filename<span class="token punctuation">=</span><span class="token punctuation">'</span>js/bootstrap.min.js<span class="token punctuation">'</span>) }}<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token script language-javascript"></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>body</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>container<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>content<span class="token punctuation">"</span></span><span class="token style-attr language-css"><span class="token attr-name"> <span class="token attr-name">style</span></span><span class="token punctuation">="</span><span class="token attr-value"><span class="token property">background-color</span><span class="token punctuation">:</span><span class="token hexcode">#EEEEEE</span><span class="token punctuation">;</span><span class="token property">height</span><span class="token punctuation">:</span><span class="token number">200</span>px<span class="token punctuation">;</span><span class="token property">text-align</span><span class="token punctuation">:</span>center<span class="token punctuation">;</span><span class="token property">line-height</span><span class="token punctuation">:</span><span class="token number">200</span>px</span><span class="token punctuation">"</span></span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>a</span> <span class="token attr-name">href</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>/<span class="token punctuation">"</span></span><span class="token style-attr language-css"><span class="token attr-name"> <span class="token attr-name">style</span></span><span class="token punctuation">="</span><span class="token attr-value"><span class="token property">text-decoration</span><span class="token punctuation">:</span>none<span class="token punctuation">;</span><span class="token property">color</span><span class="token punctuation">:</span>green<span class="token punctuation">;</span></span><span class="token punctuation">"</span></span> <span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token style-attr language-css"><span class="token attr-name"> <span class="token attr-name">style</span></span><span class="token punctuation">="</span><span class="token attr-value"><span class="token property">font-size</span><span class="token punctuation">:</span><span class="token number">200%</span></span><span class="token punctuation">"</span></span><span class="token punctuation">></span></span>搜索引擎<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>a</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">></span></span><span class="token script language-javascript">        window<span class="token punctuation">.</span>onload <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token function">$</span><span class="token punctuation">(</span><span class="token string">"#loading"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">hide</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token punctuation">;</span>         <span class="token comment" spellcheck="true">// 发送文字</span>         <span class="token keyword">function</span> <span class="token function">send_txt</span><span class="token punctuation">(</span>txt<span class="token punctuation">)</span><span class="token punctuation">{</span>            $<span class="token punctuation">.</span><span class="token function">ajax</span><span class="token punctuation">(</span><span class="token punctuation">{</span>                url<span class="token punctuation">:</span> <span class="token string">"/search"</span><span class="token punctuation">,</span>                contentType<span class="token punctuation">:</span> <span class="token string">"POST"</span><span class="token punctuation">,</span>                data<span class="token punctuation">:</span> <span class="token punctuation">{</span><span class="token string">"filter"</span><span class="token punctuation">:</span> txt<span class="token punctuation">}</span><span class="token punctuation">,</span>                success<span class="token punctuation">:</span><span class="token keyword">function</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">{</span>                    <span class="token function">$</span><span class="token punctuation">(</span><span class="token string">"#table"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">html</span><span class="token punctuation">(</span><span class="token string">''</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token keyword">var</span> lsts <span class="token operator">=</span> data<span class="token punctuation">[</span><span class="token string">'lsts'</span><span class="token punctuation">]</span><span class="token punctuation">;</span>                    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">var</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> lsts<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                        <span class="token function">$</span><span class="token punctuation">(</span><span class="token string">"#table"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span><span class="token string">'&lt;tr>&lt;td>'</span><span class="token operator">+</span> lsts<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token string">'actresses'</span><span class="token punctuation">]</span> <span class="token operator">+</span><span class="token string">'&lt;br/>&lt;/td>&lt;/tr>'</span><span class="token punctuation">)</span>                    <span class="token punctuation">}</span>                <span class="token punctuation">}</span><span class="token punctuation">,</span>                error<span class="token punctuation">:</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"执行失败了..."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>         <span class="token comment" spellcheck="true">// 上传图片</span>         <span class="token keyword">function</span> <span class="token function">upload_image</span><span class="token punctuation">(</span>file<span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token function">$</span><span class="token punctuation">(</span><span class="token string">"#loading"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">show</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">var</span> formData <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">FormData</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            formData<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span><span class="token string">'file'</span><span class="token punctuation">,</span> file<span class="token punctuation">)</span>            $<span class="token punctuation">.</span><span class="token function">ajax</span><span class="token punctuation">(</span><span class="token punctuation">{</span>                type<span class="token punctuation">:</span> <span class="token string">'POST'</span><span class="token punctuation">,</span>                url<span class="token punctuation">:</span> <span class="token string">'/upload_image'</span><span class="token punctuation">,</span>                data<span class="token punctuation">:</span> formData<span class="token punctuation">,</span>                cache<span class="token punctuation">:</span> <span class="token boolean">false</span><span class="token punctuation">,</span>       <span class="token comment" spellcheck="true">//上传文件无需缓存</span>                <span class="token keyword">async</span><span class="token punctuation">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>                processData<span class="token punctuation">:</span> <span class="token boolean">false</span><span class="token punctuation">,</span> <span class="token comment" spellcheck="true">//用于对data参数进行序列化处理 这里必须false</span>                contentType<span class="token punctuation">:</span> <span class="token boolean">false</span><span class="token punctuation">,</span> <span class="token comment" spellcheck="true">//必须</span>                success<span class="token punctuation">:</span><span class="token keyword">function</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">{</span>                    <span class="token function">$</span><span class="token punctuation">(</span><span class="token string">"#loading"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">hide</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token function">$</span><span class="token punctuation">(</span><span class="token string">"#table"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">html</span><span class="token punctuation">(</span><span class="token string">''</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token keyword">var</span> lsts <span class="token operator">=</span> data<span class="token punctuation">[</span><span class="token string">'lsts'</span><span class="token punctuation">]</span><span class="token punctuation">;</span>                    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">var</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> lsts<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                        <span class="token function">$</span><span class="token punctuation">(</span><span class="token string">"#table"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span><span class="token string">'&lt;tr>&lt;td>'</span><span class="token operator">+</span> lsts<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token string">'actresses'</span><span class="token punctuation">]</span> <span class="token operator">+</span><span class="token string">'&lt;br/>&lt;/td>&lt;/tr>'</span><span class="token punctuation">)</span>                    <span class="token punctuation">}</span>                <span class="token punctuation">}</span><span class="token punctuation">,</span>                error<span class="token punctuation">:</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"执行失败了..."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        document<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">'paste'</span><span class="token punctuation">,</span> <span class="token punctuation">(</span>event<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token punctuation">(</span>event<span class="token punctuation">.</span>clipboardData <span class="token operator">&amp;&amp;</span> event<span class="token punctuation">.</span>clipboardData<span class="token punctuation">.</span>items<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">return</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">var</span> file <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>            <span class="token keyword">var</span> paste <span class="token operator">=</span> <span class="token punctuation">(</span>event<span class="token punctuation">.</span>clipboardData <span class="token operator">||</span> window<span class="token punctuation">.</span>clipboardData<span class="token punctuation">)</span><span class="token punctuation">.</span>items<span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>paste <span class="token operator">&amp;&amp;</span> paste<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token function">$</span><span class="token punctuation">(</span><span class="token string">"#filter"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">text</span><span class="token punctuation">(</span><span class="token string">''</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                         <span class="token comment" spellcheck="true">// div赋值方式</span>                <span class="token comment" spellcheck="true">//alert(paste[0].kind);</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>paste<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>kind <span class="token operator">===</span> <span class="token string">'file'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    file <span class="token operator">=</span> paste<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">getAsFile</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token comment" spellcheck="true">// 此时file就是剪切板中的图片文件</span>                    <span class="token function">upload_image</span><span class="token punctuation">(</span>file<span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token comment" spellcheck="true">// 显示图片</span>                    <span class="token keyword">var</span> reader <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">FileReader</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    reader<span class="token punctuation">.</span><span class="token function">readAsDataURL</span><span class="token punctuation">(</span>file<span class="token punctuation">)</span><span class="token punctuation">;</span>                    reader<span class="token punctuation">.</span>onload <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span> <span class="token punctuation">{</span>                        <span class="token keyword">var</span> img <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">createElement</span><span class="token punctuation">(</span><span class="token string">"img"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                        img<span class="token punctuation">.</span>src <span class="token operator">=</span> e<span class="token punctuation">.</span>target<span class="token punctuation">.</span>result<span class="token punctuation">;</span>                        filter<span class="token punctuation">.</span><span class="token function">appendChild</span><span class="token punctuation">(</span>img<span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token comment" spellcheck="true">// 将图片插入div中</span>                    <span class="token punctuation">}</span>                <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>paste<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>kind <span class="token operator">===</span> <span class="token string">'string'</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                    <span class="token keyword">var</span> txt <span class="token operator">=</span> event<span class="token punctuation">.</span>clipboardData<span class="token punctuation">.</span><span class="token function">getData</span><span class="token punctuation">(</span><span class="token string">'Text'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 获取文本内容</span>                    <span class="token function">$</span><span class="token punctuation">(</span><span class="token string">"#filter"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">text</span><span class="token punctuation">(</span>txt<span class="token punctuation">)</span><span class="token punctuation">;</span>                         <span class="token comment" spellcheck="true">// div赋值方式</span>                    <span class="token function">send_txt</span><span class="token punctuation">(</span>txt<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>            event<span class="token punctuation">.</span><span class="token function">preventDefault</span><span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token punctuation">}</span><span class="token punctuation">)</span>    </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>container<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>filter<span class="token punctuation">"</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>form-control<span class="token punctuation">"</span></span> <span class="token attr-name">contenteditable</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>true<span class="token punctuation">"</span></span> <span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>loading<span class="token punctuation">"</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>container mt-3<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>                图片识别中，请稍等...                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>spinner-grow text-muted<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>spinner-grow text-primary<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>spinner-grow text-success<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>spinner-grow text-info<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>spinner-grow text-warning<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>spinner-grow text-danger<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>spinner-grow text-secondary<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>spinner-grow text-dark<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>spinner-grow text-light<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>table</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>table<span class="token punctuation">"</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>table table-hover<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>table</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">></span></span><span class="token script language-javascript">    <span class="token function">$</span><span class="token punctuation">(</span><span class="token string">"#filter"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">on</span><span class="token punctuation">(</span><span class="token string">"input propertychange"</span><span class="token punctuation">,</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//console.log($(this).val()); // 针对input标签</span>        <span class="token comment" spellcheck="true">//console.log($(this).text()); // 针对div标签</span>        <span class="token comment" spellcheck="true">//console.log($(this));</span>        <span class="token function">send_txt</span><span class="token punctuation">(</span><span class="token function">$</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">text</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>body</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>html</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>index.py</p><pre class="line-numbers language-python"><code class="language-python"><span class="token comment" spellcheck="true"># -*- coding: utf-8 -*-</span><span class="token keyword">import</span> psycopg2<span class="token punctuation">,</span> os<span class="token punctuation">,</span> easyocr<span class="token keyword">from</span> flask <span class="token keyword">import</span> Flask<span class="token punctuation">,</span> request<span class="token punctuation">,</span> redirect<span class="token punctuation">,</span> render_template<span class="token punctuation">,</span> jsonify<span class="token keyword">from</span> werkzeug<span class="token punctuation">.</span>utils <span class="token keyword">import</span> secure_filenameapp <span class="token operator">=</span> Flask<span class="token punctuation">(</span>__name__<span class="token punctuation">)</span>app<span class="token punctuation">.</span>config<span class="token punctuation">[</span><span class="token string">'UPLOAD_FOLDER'</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">'uploads/'</span>@app<span class="token punctuation">.</span>route<span class="token punctuation">(</span><span class="token string">'/'</span><span class="token punctuation">)</span><span class="token keyword">def</span> <span class="token function">index</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">return</span> render_template<span class="token punctuation">(</span><span class="token string">'index.html'</span><span class="token punctuation">)</span><span class="token keyword">def</span> <span class="token function">ocr_txt</span><span class="token punctuation">(</span>filename<span class="token punctuation">)</span><span class="token punctuation">:</span>    reader <span class="token operator">=</span> easyocr<span class="token punctuation">.</span>Reader<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token string">'ch_sim'</span><span class="token punctuation">,</span> <span class="token string">'en'</span><span class="token punctuation">]</span><span class="token punctuation">)</span>    result <span class="token operator">=</span> reader<span class="token punctuation">.</span>readtext<span class="token punctuation">(</span>filename<span class="token punctuation">)</span>    filter <span class="token operator">=</span> <span class="token string">' '</span><span class="token punctuation">.</span>join<span class="token punctuation">(</span><span class="token punctuation">[</span>i<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token keyword">for</span> i <span class="token keyword">in</span> result<span class="token punctuation">]</span><span class="token punctuation">)</span>    lsts <span class="token operator">=</span> getContent<span class="token punctuation">(</span>filter<span class="token punctuation">)</span>    <span class="token keyword">return</span> lsts<span class="token keyword">def</span> <span class="token function">getContent</span><span class="token punctuation">(</span>filter<span class="token punctuation">)</span><span class="token punctuation">:</span>    conn <span class="token operator">=</span> psycopg2<span class="token punctuation">.</span>connect<span class="token punctuation">(</span>host<span class="token operator">=</span><span class="token string">"192.168.137.129"</span><span class="token punctuation">,</span> port<span class="token operator">=</span><span class="token string">"1921"</span><span class="token punctuation">,</span> database<span class="token operator">=</span><span class="token string">"postgres"</span><span class="token punctuation">,</span> user<span class="token operator">=</span><span class="token string">"pg10"</span><span class="token punctuation">,</span> password<span class="token operator">=</span><span class="token string">"123456"</span><span class="token punctuation">,</span> <span class="token punctuation">)</span>    cur <span class="token operator">=</span> conn<span class="token punctuation">.</span>cursor<span class="token punctuation">(</span><span class="token punctuation">)</span>    sql <span class="token operator">=</span> <span class="token string">"select actresses,actresses &lt;-> '%s' similarity from r18_info where language='en' order by 2 limit 10"</span> <span class="token operator">%</span> filter    <span class="token keyword">print</span><span class="token punctuation">(</span>sql<span class="token punctuation">)</span>    cur<span class="token punctuation">.</span>execute<span class="token punctuation">(</span>sql<span class="token punctuation">)</span>    rows <span class="token operator">=</span> cur<span class="token punctuation">.</span>fetchall<span class="token punctuation">(</span><span class="token punctuation">)</span>    lsts<span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">]</span>    <span class="token keyword">for</span> i<span class="token punctuation">,</span> row <span class="token keyword">in</span> enumerate<span class="token punctuation">(</span>rows<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        dics <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>        dics<span class="token punctuation">[</span><span class="token string">'actresses'</span><span class="token punctuation">]</span> <span class="token operator">=</span> row<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>        lsts<span class="token punctuation">.</span>append<span class="token punctuation">(</span>dics<span class="token punctuation">)</span>    cur<span class="token punctuation">.</span>close<span class="token punctuation">(</span><span class="token punctuation">)</span>    conn<span class="token punctuation">.</span>close<span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token keyword">return</span> lsts@app<span class="token punctuation">.</span>route<span class="token punctuation">(</span><span class="token string">'/upload_image'</span><span class="token punctuation">,</span> methods<span class="token operator">=</span><span class="token punctuation">[</span><span class="token string">'GET'</span><span class="token punctuation">,</span> <span class="token string">'POST'</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token keyword">def</span> <span class="token function">upload_file</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">if</span> request<span class="token punctuation">.</span>method <span class="token operator">==</span> <span class="token string">'POST'</span><span class="token punctuation">:</span>        <span class="token keyword">if</span> <span class="token string">'file'</span> <span class="token operator">not</span> <span class="token keyword">in</span> request<span class="token punctuation">.</span>files<span class="token punctuation">:</span>            <span class="token keyword">return</span> redirect<span class="token punctuation">(</span>request<span class="token punctuation">.</span>url<span class="token punctuation">)</span>        file <span class="token operator">=</span> request<span class="token punctuation">.</span>files<span class="token punctuation">[</span><span class="token string">'file'</span><span class="token punctuation">]</span>        filename <span class="token operator">=</span> secure_filename<span class="token punctuation">(</span>file<span class="token punctuation">.</span>filename<span class="token punctuation">)</span>        file<span class="token punctuation">.</span>save<span class="token punctuation">(</span>os<span class="token punctuation">.</span>path<span class="token punctuation">.</span>join<span class="token punctuation">(</span>app<span class="token punctuation">.</span>config<span class="token punctuation">[</span><span class="token string">'UPLOAD_FOLDER'</span><span class="token punctuation">]</span><span class="token punctuation">,</span> filename<span class="token punctuation">)</span><span class="token punctuation">)</span>        lsts <span class="token operator">=</span> ocr_txt<span class="token punctuation">(</span>os<span class="token punctuation">.</span>path<span class="token punctuation">.</span>join<span class="token punctuation">(</span>app<span class="token punctuation">.</span>config<span class="token punctuation">[</span><span class="token string">'UPLOAD_FOLDER'</span><span class="token punctuation">]</span><span class="token punctuation">,</span> filename<span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> jsonify<span class="token punctuation">(</span>lsts<span class="token operator">=</span>lsts<span class="token punctuation">)</span>    <span class="token keyword">return</span> <span class="token string">''</span>@app<span class="token punctuation">.</span>route<span class="token punctuation">(</span><span class="token string">'/search'</span><span class="token punctuation">,</span> methods<span class="token operator">=</span><span class="token punctuation">[</span><span class="token string">'GET'</span><span class="token punctuation">,</span> <span class="token string">'POST'</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token keyword">def</span> <span class="token function">search</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    filter <span class="token operator">=</span> request<span class="token punctuation">.</span>values<span class="token punctuation">.</span>get<span class="token punctuation">(</span><span class="token string">'filter'</span><span class="token punctuation">,</span> <span class="token string">''</span><span class="token punctuation">)</span>    lsts <span class="token operator">=</span> getContent<span class="token punctuation">(</span>filter<span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span>lsts<span class="token punctuation">)</span>    <span class="token keyword">return</span> jsonify<span class="token punctuation">(</span>lsts<span class="token operator">=</span>lsts<span class="token punctuation">)</span><span class="token keyword">if</span> __name__ <span class="token operator">==</span> <span class="token string">'__main__'</span><span class="token punctuation">:</span>    app<span class="token punctuation">.</span>run<span class="token punctuation">(</span>host<span class="token operator">=</span><span class="token string">'0.0.0.0'</span><span class="token punctuation">,</span>port<span class="token operator">=</span><span class="token number">9090</span><span class="token punctuation">,</span>debug<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> flask </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PostgreSQL服务器架构</title>
      <link href="/2023/postgresql-fu-wu-qi-jia-gou/"/>
      <url>/2023/postgresql-fu-wu-qi-jia-gou/</url>
      
        <content type="html"><![CDATA[<p>PostgreSQL 集群启动时会启动几个进程。这些进程管理相当多的文件 I/O，管理其他进程，并处理内存分配和许多其他工作。在本文中，我们将重点关注进程及其角色、内存管理以及它们如何协同工作。我们将再次从列出的进程开始。</p><span id="more"></span><p>[TOC]</p><p>还没有客户端连接到任何数据库：</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token punctuation">[</span>root@MyCentOS ~<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># ps f -U postgres</span> PID TTY STAT TIME COMMAND 1918 tty1 S 0:00 /usr/local/pgsql/bin/postgres 1920 ? Ss 0:00 \_ postgres: checkpointer process  1921 ? Ss 0:00 \_ postgres: writer process  1922 ? Ss 0:00 \_ postgres: wal writer process  1923 ? Ss 0:00 \_ postgres: autovacuum launcher process  1924 ? Ss 0:00 \_ postgres: stats collector process<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="从守护进程开始"><a href="#从守护进程开始" class="headerlink" title="从守护进程开始"></a>从守护进程开始</h2><p>我们启动PostgreSQL时启动的第一个进程是<code>/usr/local/pgsql/bin/postgres</code>。这个进程有很多职责，例如执行恢复、初始化共享数据结构/内存空间，以及启动强制和可选进程。这些进程也称为实用程序进程，包括<code>bgwriter</code>、<code>checkpointer</code>、<code>autovacuum launcher</code>、<code>log writer</code>、<code>stats collector</code> 进程等。守护进程还监听连接请求，接收来自客户端的连接请求，并为客户端生成服务器进程。很明显，守护进程本身是一个强制进程，用户连接到数据库时应该运行它。</p><p>让我们关注用户连接‑发布‑命令场景，其他部分应该就位。下图向您展示了守护进程如何接收连接请求并启动（分叉）后端进程的过程。后端进程将在身份验证成功后开始处理来自该客户端的请求：</p><p><img src="/medias/image/image-20230211204819519.png"></p><p>对所有连接请求重复该过程（除非我们达到<code>max_connections</code>设置，在这种情况下我们会收到错误）。</p><p>因此，一个活动的服务器，在一段时间后，将拥有服务器启动时存在的进程，以及相当多的服务于客户端连接的进程，如下图所示：</p><p><img src="/medias/image/image-20230211204949864.png" alt="image-20230211204949864"></p><p>一旦用户连接到数据库，用户通常希望读取(SELECT)数据或写入(<code>UPDATE/DELETE/INSERT</code>)数据，更不用说更改表结构、添加索引等。例如，用户登录 Amazon 并搜索最新的 iPad、其价格和可用性。这听起来很简单。假设最简单（难以置信的简单）表结构，这个搜索将成为查询：</p><pre class="line-numbers language-sql"><code class="language-sql"><span class="token keyword">SELECT</span> price<span class="token punctuation">,</span> available_count <span class="token keyword">FROM</span> product_tbl <span class="token keyword">WHERE</span> product <span class="token operator">=</span> <span class="token string">'iPad'</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>然而，当我们考虑到可能有成千上万的用户想要这样做时，事情就变得有点复杂了。前面的查询同时执行了几千次。当数以千计的用户搜索不同的产品时，iPad 就会更改为数以千计的不同产品名称。到目前为止，一切都很好。</p><p>然而，当亚马逊只剩下一台新 iPad 而有数百名用户试图将其添加到他们的购物车时会发生什么？变得非常棘手，对吧？也就是说，对于数据库，许多用户试图写入同一条记录：</p><pre class="line-numbers language-sql"><code class="language-sql"><span class="token keyword">UPDATE</span> product_tbl <span class="token keyword">SET</span> available_count <span class="token operator">=</span><span class="token number">0</span> <span class="token keyword">WHERE</span> product <span class="token operator">=</span> <span class="token string">'iPad'</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>考虑到这些可能性后，让我们继续了解其余的 PostgreSQL 进程和内存管理。</p><h3 id="了解共享缓冲区"><a href="#了解共享缓冲区" class="headerlink" title="了解共享缓冲区"></a>了解共享缓冲区</h3><p>当有成千上万的用户试图向许多不同的表读取/写入数据时，从目录/文件中读取（我们在安装 PostgreSQL 并创建一个包含几个表的数据库时看到的）将导致非常糟糕的非可扩展的系统。读取和写入将导致搜索许多文件，打开这些文件，使用fseek()查找特定数据记录，锁定，编辑和解锁。</p><p>为了使其更具可扩展性和更快，引入了共享缓冲区（内存区域）的概念。现在，后端进程不再读取文件和写入文件，而是处理缓冲区或 RAM，性能有了显着提高。要分配的内存量由postgresql.conf中的 <code>shared_buffers</code> 参数决定。这个固定大小的共享内存块是在服务器启动时分配的。不仅仅是这个内存块负责改善响应时间，操作系统缓存也有助于保持大量数据随时可用。这两个缓存共同导致物理读写的实际数量和容量显着减少。除了这两个级别的缓存之外，还可以有磁盘控制器缓存、磁盘驱动器缓存等。底线是这些缓存通过减少必要的物理 I/O 来提高性能。</p><p>当大量数据从缓冲区刷新到磁盘时，还存在与巨大缓存相关的风险，例如 I/O 峰值。让我们只考虑一个简单的SELECT语句可能采用的可能路径，仅考虑共享缓冲区缓存和操作系统缓存。</p><p>进程将检查的第一件事是它想要的数据是否在数据库缓冲区缓存中可用。如果它在数据库缓冲区缓存中不可用，则会向操作系统发出请求以获取特定文件/块。操作系统缓存有可能已经有文件/块并将其传递给数据库缓存。在这两种情况下，都避免了物理 I/O。只有当数据不存在于这些缓存（或其他缓存）中时，用户初始化的读/写才会真正导致物理 I/O。这三种可能性如下图所示：</p><p><img src="/medias/image/image-20230211205436690.png" alt="image-20230211205436690"></p><p>很明显，大多数用户驱动的数据获取和写入将通过缓冲区发生。例外情况是与通常读取和写入的数据相比缓冲区很小的数据库。即使在每秒事务数非常高的情况下，如果这些事务主要使用相同的数据集，物理 I/O 也会受到限制。只有当不同的事务从文件系统中真正不同的区域访问数据时，才会出现频繁的缓冲区刷新到磁盘和从磁盘读取的问题。</p><p>即使在用户对表数据进行大量更改并发出提交的情况下，也可能不会立即导致对底层数据文件的写入。这可能只会导致确保预写日志(WAL)文件同步使用 WAL 缓冲区。</p><p>WAL 是确保持久性(D)以及在某种程度上确保事务的 ACID 属性的原子性(A)的关键组件。然而，首先让我们继续看缓冲区，看看用户更改的数据最终是如何到达数据文件的。</p><h3 id="检查缓冲区缓存"><a href="#检查缓冲区缓存" class="headerlink" title="检查缓冲区缓存"></a>检查缓冲区缓存</h3><p>PostgreSQL 提供了一个扩展来查看缓冲区缓存中的内容。它的安装方式与我们之前所做的类似。登录psql，创建两个数据库：</p><pre class="line-numbers language-sql"><code class="language-sql"><span class="token keyword">CREATE</span> <span class="token keyword">DATABASE</span> test<span class="token punctuation">;</span><span class="token keyword">CREATE</span> <span class="token keyword">DATABASE</span> mydb<span class="token punctuation">;</span><span class="token keyword">CREATE</span> EXTENSION pg_buffercache<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>让我们连接到测试数据库并查看缓冲区缓存中存在的内容：</p><pre class="line-numbers language-sql"><code class="language-sql"><span class="token punctuation">[</span>postgres<span class="token variable">@MyCentOS</span> extension<span class="token punctuation">]</span>$ psql <span class="token operator">-</span><span class="token number">d</span> test<span class="token keyword">Type</span> <span class="token string">"help"</span> <span class="token keyword">for</span> help<span class="token punctuation">.</span>test<span class="token operator">=</span><span class="token comment" spellcheck="true"># CREATE EXTENSION pg_buffercache;</span><span class="token keyword">CREATE</span> EXTENSIONtest<span class="token operator">=</span><span class="token comment" spellcheck="true"># SELECT DISTINCT reldatabase FROM pg_buffercache;</span> reldatabase<span class="token comment" spellcheck="true">-------------</span>       <span class="token number">13214</span>           <span class="token number">0</span>       <span class="token number">16420</span><span class="token punctuation">(</span><span class="token number">4</span> <span class="token keyword">rows</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>所以，我们在缓存中有两个数据库的一部分。带0的记录表示尚未使用的缓冲区：</p><pre class="line-numbers language-sql"><code class="language-sql">test<span class="token operator">=</span><span class="token comment" spellcheck="true"># \! oid2name</span><span class="token keyword">All</span> <span class="token keyword">databases</span>:    Oid  <span class="token keyword">Database</span> Name  <span class="token keyword">Tablespace</span><span class="token comment" spellcheck="true">----------------------------------</span>  <span class="token number">16421</span>           mydb  pg_default  <span class="token number">13214</span>       postgres  pg_default  <span class="token number">13213</span>      template0  pg_default      <span class="token number">1</span>      template1  pg_default  <span class="token number">16420</span>           test  pg_default<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这些是测试数据库（我们连接到的）和postgres数据库。</p><p>我们可以将其与其他几个视图联系起来以获得更好的画面：</p><pre class="line-numbers language-sql"><code class="language-sql"><span class="token keyword">SELECT</span><span class="token number">c</span><span class="token punctuation">.</span>relname<span class="token punctuation">,</span><span class="token function">count</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">)</span> <span class="token keyword">AS</span> buffers<span class="token keyword">FROM</span> pg_class <span class="token number">c</span><span class="token keyword">JOIN</span> pg_buffercache <span class="token number">b</span><span class="token keyword">ON</span> <span class="token number">b</span><span class="token punctuation">.</span>relfilenode<span class="token operator">=</span><span class="token number">c</span><span class="token punctuation">.</span>relfilenode<span class="token keyword">INNER</span> <span class="token keyword">JOIN</span> pg_database <span class="token number">d</span><span class="token keyword">ON</span> <span class="token punctuation">(</span><span class="token number">b</span><span class="token punctuation">.</span>reldatabase<span class="token operator">=</span><span class="token number">d</span><span class="token punctuation">.</span>oid <span class="token operator">AND</span> <span class="token number">d</span><span class="token punctuation">.</span>datname<span class="token operator">=</span>current_database<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">GROUP</span> <span class="token keyword">BY</span> <span class="token number">c</span><span class="token punctuation">.</span>relname<span class="token keyword">ORDER</span> <span class="token keyword">BY</span> <span class="token number">2</span> <span class="token keyword">DESC</span><span class="token punctuation">;</span>              relname              <span class="token operator">|</span> buffers<span class="token comment" spellcheck="true">-----------------------------------+---------</span> pg_depend                         <span class="token operator">|</span>      <span class="token number">12</span> pg_depend_reference_index         <span class="token operator">|</span>      <span class="token number">12</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>我们看到它主要是数据字典视图。</p><blockquote><p>有很多数据字典表和视图为我们提供了各种对象、对象类型、权限等信息。它们共同管理集群的簿记活动； pg_class 是这些目录表之一。此表中的一列是 relname。虽然听起来它会存储关系/表名，但它也可以存储其他对象类型的数据。我们应该将它与 relkind 列一起使用。 relkind 列告诉我们记录指的是什么类型的对象。 relkind 中的可能值包括 r（表）、i（索引）、S（序列）、v（视图）等。</p></blockquote><p>让我们从前面的查询中删除relname并稍微修改它：</p><pre class="line-numbers language-sql"><code class="language-sql"><span class="token keyword">SELECT</span><span class="token number">c</span><span class="token punctuation">.</span>relname<span class="token punctuation">,</span><span class="token function">count</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">)</span> <span class="token keyword">AS</span> buffers<span class="token keyword">FROM</span> pg_class <span class="token number">c</span><span class="token keyword">JOIN</span> pg_buffercache <span class="token number">b</span><span class="token keyword">ON</span> <span class="token number">b</span><span class="token punctuation">.</span>relfilenode<span class="token operator">=</span><span class="token number">c</span><span class="token punctuation">.</span>relfilenode<span class="token keyword">JOIN</span> pg_database <span class="token number">d</span><span class="token keyword">ON</span> <span class="token punctuation">(</span><span class="token number">b</span><span class="token punctuation">.</span>reldatabase<span class="token operator">=</span><span class="token number">d</span><span class="token punctuation">.</span>oid <span class="token operator">AND</span> <span class="token number">d</span><span class="token punctuation">.</span>datname<span class="token operator">=</span>current_database<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">WHERE</span> <span class="token number">c</span><span class="token punctuation">.</span>relname <span class="token operator">NOT</span> <span class="token operator">LIKE</span> <span class="token string">'pg%'</span> <span class="token keyword">GROUP</span> <span class="token keyword">BY</span> <span class="token number">c</span><span class="token punctuation">.</span>relname<span class="token keyword">ORDER</span> <span class="token keyword">BY</span> <span class="token number">2</span> <span class="token keyword">DESC</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>我们现在将尝试使用用户创建的表填充缓冲区。我们将首先创建一个表并插入一条记录：</p><pre class="line-numbers language-sql"><code class="language-sql">test<span class="token operator">=</span><span class="token comment" spellcheck="true"># CREATE TABLE emp(id serial, first_name varchar(50));</span><span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span>test<span class="token operator">=</span><span class="token comment" spellcheck="true"># INSERT INTO emp(first_name) VALUES('Jayadeva');</span><span class="token keyword">INSERT</span> <span class="token number">0</span> <span class="token number">1</span>test<span class="token operator">=</span><span class="token comment" spellcheck="true"># SELECT * FROM emp;</span> id <span class="token operator">|</span> first_name<span class="token comment" spellcheck="true">----+------------</span>  <span class="token number">1</span> <span class="token operator">|</span> Jayadeva<span class="token punctuation">(</span><span class="token number">1</span> <span class="token keyword">row</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>serial 关键字指的是自动递增的整数类型。使用此关键字将自动创建一个序列号生成器 (SEQUENCE)，并且列（表 emp 中的 id）将从该序列中填充。有关数字数据类型的更多信息，请参阅 <a href="http://www.postgresql.org/docs/current/static/datatype%E2%80%91numeric.html#datatype%E2%80%91numeric%E2%80%91table%E3%80%82">http://www.postgresql.org/docs/current/static/datatype‑numeric.html#datatype‑numeric‑table。</a></p><p>有关序列的详细信息，请参阅<a href="http://www.postgresql.org/docs/current/static/sql%E2%80%91createsequence.html">http://www.postgresql.org/docs/current/static/sql‑createsequence.html</a> 。</p></blockquote><p>我们可以重复查询以检查缓冲区并检查缓冲区是否包含新创建的表及其序列：</p><pre class="line-numbers language-sql"><code class="language-sql"> relname <span class="token operator">|</span> buffers <span class="token comment" spellcheck="true">------------+---------</span> emp_id_seq <span class="token operator">|</span> <span class="token number">1</span> emp <span class="token operator">|</span> <span class="token number">1</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>让我们稍微修改一下查询：</p><pre class="line-numbers language-sql"><code class="language-sql"><span class="token keyword">SELECT</span><span class="token number">c</span><span class="token punctuation">.</span>relname<span class="token punctuation">,</span><span class="token function">count</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">)</span> <span class="token keyword">AS</span> buffers<span class="token keyword">FROM</span> pg_class <span class="token number">c</span><span class="token keyword">JOIN</span> pg_buffercache <span class="token number">b</span><span class="token keyword">ON</span> <span class="token number">b</span><span class="token punctuation">.</span>relfilenode<span class="token operator">=</span><span class="token number">c</span><span class="token punctuation">.</span>relfilenode<span class="token keyword">JOIN</span> pg_database <span class="token number">d</span><span class="token keyword">ON</span> <span class="token punctuation">(</span><span class="token number">b</span><span class="token punctuation">.</span>reldatabase<span class="token operator">=</span><span class="token number">d</span><span class="token punctuation">.</span>oid <span class="token operator">AND</span> <span class="token number">d</span><span class="token punctuation">.</span>datname<span class="token operator">=</span>current_database<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">WHERE</span> <span class="token number">c</span><span class="token punctuation">.</span>relname <span class="token operator">NOT</span> <span class="token operator">LIKE</span> <span class="token string">'pg%'</span> <span class="token keyword">GROUP</span> <span class="token keyword">BY</span> <span class="token number">c</span><span class="token punctuation">.</span>relname<span class="token keyword">ORDER</span> <span class="token keyword">BY</span> <span class="token number">2</span> <span class="token keyword">DESC</span><span class="token punctuation">;</span>  relname   <span class="token operator">|</span> buffers<span class="token comment" spellcheck="true">------------+---------</span> emp        <span class="token operator">|</span>       <span class="token number">1</span> emp_id_seq <span class="token operator">|</span>       <span class="token number">1</span><span class="token punctuation">(</span><span class="token number">2</span> <span class="token keyword">rows</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>请注意， isdirty标志是f （假）：</p><pre class="line-numbers language-sql"><code class="language-sql"><span class="token keyword">UPDATE</span> emp <span class="token keyword">SET</span> first_name <span class="token operator">=</span><span class="token string">'Newname'</span><span class="token punctuation">;</span><span class="token keyword">UPDATE</span> <span class="token number">1</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>如果我们使用isdirty标志重复查询缓冲区，我们将得到：</p><pre class="line-numbers language-sql"><code class="language-sql"> <span class="token keyword">SELECT</span> <span class="token number">c</span><span class="token punctuation">.</span>relname<span class="token punctuation">,</span><span class="token number">b</span><span class="token punctuation">.</span>isdirty <span class="token keyword">FROM</span> pg_class <span class="token number">c</span> <span class="token keyword">JOIN</span> pg_buffercache <span class="token number">b</span><span class="token keyword">ON</span> <span class="token number">b</span><span class="token punctuation">.</span>relfilenode<span class="token operator">=</span><span class="token number">c</span><span class="token punctuation">.</span>relfilenode <span class="token keyword">JOIN</span> pg_database <span class="token number">d</span><span class="token keyword">ON</span> <span class="token punctuation">(</span><span class="token number">b</span><span class="token punctuation">.</span>reldatabase<span class="token operator">=</span><span class="token number">d</span><span class="token punctuation">.</span>oid <span class="token operator">AND</span> <span class="token number">d</span><span class="token punctuation">.</span>datname<span class="token operator">=</span>current_database<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">WHERE</span> <span class="token number">c</span><span class="token punctuation">.</span>relname <span class="token operator">not</span> <span class="token operator">like</span> <span class="token string">'pg%'</span><span class="token punctuation">;</span>  relname   <span class="token operator">|</span> isdirty<span class="token comment" spellcheck="true">------------+---------</span> emp_id_seq <span class="token operator">|</span> t emp        <span class="token operator">|</span> t<span class="token punctuation">(</span><span class="token number">2</span> <span class="token keyword">rows</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>输出告诉我们缓冲区是脏的。让我们强制检查点：</p><pre class="line-numbers language-sql"><code class="language-sql"><span class="token keyword">CHECKPOINT</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>我们将重复查询：</p><pre class="line-numbers language-sql"><code class="language-sql">test<span class="token operator">=</span><span class="token comment" spellcheck="true"># SELECT</span><span class="token number">c</span><span class="token punctuation">.</span>relname<span class="token punctuation">,</span><span class="token number">b</span><span class="token punctuation">.</span>isdirty<span class="token keyword">FROM</span> pg_class <span class="token number">c</span> <span class="token keyword">JOIN</span> pg_buffercache <span class="token number">b</span><span class="token keyword">ON</span> <span class="token number">b</span><span class="token punctuation">.</span>relfilenode<span class="token operator">=</span><span class="token number">c</span><span class="token punctuation">.</span>relfilenode<span class="token keyword">JOIN</span> pg_database <span class="token number">d</span><span class="token keyword">ON</span> <span class="token punctuation">(</span><span class="token number">b</span><span class="token punctuation">.</span>reldatabase<span class="token operator">=</span><span class="token number">d</span><span class="token punctuation">.</span>oid <span class="token operator">AND</span> <span class="token number">d</span><span class="token punctuation">.</span>datname<span class="token operator">=</span>current_database<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">WHERE</span> <span class="token number">c</span><span class="token punctuation">.</span>relname <span class="token operator">not</span> <span class="token operator">like</span> <span class="token string">'pg%'</span><span class="token punctuation">;</span>  relname   <span class="token operator">|</span> isdirty<span class="token comment" spellcheck="true">------------+---------</span> emp_id_seq <span class="token operator">|</span> <span class="token number">f</span> emp        <span class="token operator">|</span> <span class="token number">f</span><span class="token punctuation">(</span><span class="token number">2</span> <span class="token keyword">rows</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>现在缓冲区不再脏了。</p><h2 id="WAL-和-WAL-writer-进程"><a href="#WAL-和-WAL-writer-进程" class="headerlink" title="WAL 和 WAL writer 进程"></a>WAL 和 WAL writer 进程</h2><p>当我们对数据进行更改时，更改不会立即写入数据文件，如前所述（可能多次）。对缓冲区中的块进行更改，并将这些更改的记录写入 WAL 缓冲区（一旦对数据进行更改）。当更改被提交时，更改被刷新到 WAL 段。</p><p>在pg_xlog目录中，每个 WAL 段的大小为 16 MB：</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token punctuation">[</span>postgres@host1 pg_xlog<span class="token punctuation">]</span>$ <span class="token function">pwd</span>/home/postgres/pg96/data/pg_xlog<span class="token punctuation">[</span>postgres@host1 pg_xlog<span class="token punctuation">]</span>$ <span class="token function">ls</span> -alrttotal 81924drwx------.  2 postgres postgres        6 Jan 14 19:14 archive_status-rw-------.  1 postgres postgres 16777216 Jan 15 16:51 000000010000000000000007-rw-------.  1 postgres postgres 16777216 Jan 15 16:52 000000010000000000000008-rw-------.  1 postgres postgres 16777216 Jan 15 16:54 000000010000000000000009-rw-------.  1 postgres postgres 16777216 Jan 15 16:55 00000001000000000000000Adrwx------.  3 postgres postgres      188 Jan 15 22:48 <span class="token keyword">.</span>drwx------. 19 postgres postgres     4096 Feb 11 22:11 <span class="token punctuation">..</span>-rw-------.  1 postgres postgres 16777216 Feb 11 22:16 000000010000000000000006<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>我们可以使用<code>pg_current_xlog_location</code>函数找出 PostgreSQL 正在写入的段：</p><pre class="line-numbers language-sql"><code class="language-sql"><span class="token punctuation">[</span>postgres<span class="token variable">@host1</span> pg_xlog<span class="token punctuation">]</span>$ psqlpsql <span class="token punctuation">(</span><span class="token number">9.6</span><span class="token punctuation">.</span><span class="token number">24</span><span class="token punctuation">)</span><span class="token keyword">Type</span> <span class="token string">"help"</span> <span class="token keyword">for</span> help<span class="token punctuation">.</span>postgres<span class="token operator">=</span><span class="token comment" spellcheck="true"># SELECT pg_xlogfile_name(pg_current_xlog_location());</span>     pg_xlogfile_name<span class="token comment" spellcheck="true">--------------------------</span> <span class="token number">000000010000000000000006</span><span class="token punctuation">(</span><span class="token number">1</span> <span class="token keyword">row</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>名称不是数字和数字的随机集合。它由三个部分组成，每个部分 8 个字符：</p><p><strong>000000010000000000000006</strong>数字分类如下：</p><ul><li>前 8 位数字标识时间线</li><li>接下来的 8 位数字标识（逻辑） xlog文件</li><li>最后一位代表（物理） xlog文件（Segment）</li></ul><p>每个段包含 8K 块。通常，当一个段被填满时，PostgreSQL 从一个段移动到下一个段，也就是说，所有 16 MB 都被填满。但是，也可以触发开关。</p><p>WAL相关的函数有很多，在归档、恢复等方面很有用。</p><p>例如， pg_switch_xlog移动到下一个事务日志文件，允许当前文件被归档。如果自上次事务日志切换后没有事务日志活动， pg_switch_xlog什么都不做并返回当前正在使用的事务日志文件的起始位置。 WAL 主要是写入而很少读取。读取 WAL 的情况包括：</p><ul><li>恢复（Recovery）</li><li>服务器启动（Server startup）</li><li>复制（Replication）</li></ul><p>让我们来看看 WAL 的几个用途。</p><p><strong>恢复</strong></p><p>这是 WAL 概念的主要目的。在这里，我们指的是恢复已提交但尚未找到数据文件路径的事务。对数据库所做的所有更改都将进入 WAL 段，而不管这些更改是否已反映到数据文件中。事实上，在将更改写入数据文件之前，必须先将更改写入 WAL 文件。 WAL 文件的丢失几乎肯定意味着事务丢失。</p><p><strong>增量备份和时间点恢复</strong></p><p>我们可以拍摄 PostgreSQL 文件系统的快照，然后设置 WAL 归档进程。拍摄的快照不需要是一致的。生成的 WAL 段将继续归档，我们可以使用快照和归档的 WAL 段来执行时间点恢复。在这个过程中，我们恢复文件快照，然后重放 WAL 段直到特定时间点或直到一个事务。</p><p><strong>复制</strong></p><p>WAL 段已用于前面提到的两个目的。从 9.0 版本开始，WAL 段也被用于复制。道理很简单。无论如何，服务器中发生的所有更改都记录在 WAL 段中。为什么不使用这些并为故障转移准备好备用服务器呢？</p><p>WAL 还减少了保证事务提交所需的磁盘写入次数，从而提高了性能。这是因为 WAL 写入是顺序的。如果提交了一些小事务，它们将按顺序出现在日志中。如果数据库在没有 WAL 的情况下工作，事务提交将立即导致将数据写出到所有受事务影响的数据文件。</p><p>现在，我们也来看看与 WAL 相关的几个关键参数。将目录更改为$PGDATA并执行以下命令：</p><pre class="line-numbers language-properties"><code class="language-properties"><span class="token attr-name">[postgres@host1</span> <span class="token attr-value">data]$ grep wal postgresql.conf</span><span class="token comment" spellcheck="true">#wal_level = minimal                    # minimal, replica, or logical</span><span class="token comment" spellcheck="true">#wal_sync_method = fsync                # the default is the first option</span><span class="token comment" spellcheck="true">#wal_compression = off                  # enable compression of full-page writes</span><span class="token comment" spellcheck="true">#wal_log_hints = off                    # also do full page writes of non-critical updates</span><span class="token comment" spellcheck="true">#wal_buffers = -1                       # min 32kB, -1 sets based on shared_buffers</span><span class="token comment" spellcheck="true">#wal_writer_delay = 200ms               # 1-10000 milliseconds</span><span class="token comment" spellcheck="true">#wal_writer_flush_after = 1MB           # measured in pages, 0 disables</span><span class="token comment" spellcheck="true">#max_wal_size = 1GB</span><span class="token comment" spellcheck="true">#min_wal_size = 80MB</span><span class="token comment" spellcheck="true">#max_wal_senders = 0            # max number of walsender processes</span><span class="token comment" spellcheck="true">#wal_keep_segments = 0          # in logfile segments, 16MB each; 0 disables</span><span class="token comment" spellcheck="true">#wal_sender_timeout = 60s       # in milliseconds; 0 disables</span><span class="token comment" spellcheck="true">#wal_receiver_status_interval = 10s     # send replies at least this often</span><span class="token comment" spellcheck="true">#wal_receiver_timeout = 60s             # time that receiver waits for</span><span class="token comment" spellcheck="true">#wal_retrieve_retry_interval = 5s       # time to wait before retrying to</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>wal_level</code> 是一个重要的参数，因为这个设置直接影响我们可以用 WAL 做什么，我们是否可以只将它用于从崩溃中恢复，或者我们也可以将它用于归档以进行时间点恢复，或者我们是否可以使用它来创建备用服务器。此设置确定写入 WAL 的信息量。这是一个枚举类型的值，这意味着它可以有一个可能的值列表。可能的值为<code>minimal</code>、 <code>archive</code>和<code>hot_standby</code>。默认值为<code>minimal</code>，它只写入从崩溃或立即关闭中恢复所需的信息。 archive值添加了 WAL 归档所需的日志记录，而<code>hot_standby</code>进一步添加了在备用服务器上运行只读查询所需的信息。此参数只能在服务器启动时设置。在最低级别，可以安全地跳过一些批量操作的 WAL 日志记录，这可以使操作更快。 minimal WAL 不包含足够的信息来从基本备份和 WAL 日志中重建数据，因此应使用 archive 或<code>hot_standby</code>级别来启用 WAL 归档（<code>archive_mode</code>）和流复制。</p><p>在<code>hot_standby</code>级别，记录与存档相同的信息，以及从 WAL 重建运行事务状态所需的信息。要在备用服务器上启用只读查询，必须在主服务器上将 <code>wal_level</code> 设置为 <code>hot_standby</code> ，并且必须在备用服务器上启用 <code>hot_standby</code> 设置。</p><p>当<code>fsync</code>打开时，PostgreSQL 服务器会尝试确保数据真正刷新到磁盘（还记得不同级别的缓存吗？）。将<code>fsync</code>设置为关闭可能会显着提高性能，但也会带来风险。如果发生电源故障或系统崩溃，这可能会导致无法恢复的数据损坏。在关闭<code>fsync</code>的情况下， <code>wal_sync_method</code>根本不相关。当fsync开启时，我们可以从许多选项中选择一个，例如<code>open_datasync</code>、 <code>fdatasync</code>、 <code>fsync</code>等等；每个都有不同的方法来确保数据被刷新到磁盘。有关这些方法的说明，请访问<a href="http://www.postgresql.org/docs/current/static/runtime-config-wal.html#GUC-WAL-SYNC-METHOD">http://www.postgresql.org/docs/current/static/runtime-config-wal.html#GUC-WAL-SYNC-METHOD</a>.</p><p><code>wal_buffers</code> 内存是为 WAL 缓冲区预留的共享内存量。将此设置为‑1将导致基于 <code>shared_buffers</code> 设置的自动选择。在自动设置中，该值的范围可以从 64 KB 到 16 MB。手动设置时，最小可能值为 32 KB。</p><p>另一个决定是 WAL 编写器应多久将 WAL 刷新到磁盘。我们需要记住的是，这将比检查点频率更频繁。 WAL 刷新间隔由<code>wal_writer_delay</code> 指示。默认值为 200 毫秒。</p><p>还有一些与复制相关的参数，参考流复制章节。</p><h2 id="background-writer进程"><a href="#background-writer进程" class="headerlink" title="background writer进程"></a><strong>background writer</strong>进程</h2><p>后台写入器负责根据算法写入磁盘特定的脏缓冲区，而检查点写入所有脏缓冲区。该过程考虑了共享内存使用数据以及有关最近使用/访问（最近最少使用）哪些块的信息。此过程的主要目标是确保有空闲缓冲区可供使用。相关参数如下：</p><pre class="line-numbers language-properties"><code class="language-properties"><span class="token comment" spellcheck="true">#bgwriter_delay = 200ms                 # 10-10000ms between rounds</span><span class="token comment" spellcheck="true">#bgwriter_lru_maxpages = 100            # 0-1000 max buffers written/round</span><span class="token comment" spellcheck="true">#bgwriter_lru_multiplier = 2.0          # 0-10.0 multiplier on buffers scanned/round</span><span class="token comment" spellcheck="true">#bgwriter_flush_after = 512kB           # measured in pages, 0 disables</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>如我们所见，延迟的默认值为 200 毫秒。此参数指定进程在连续执行之间应等待的时间。 <code>bgwriter_lru_maxpages</code> 参数指定每次迭代中进程将写入的最大缓冲区数。第三个参数也用于计算所需缓冲区的数量。如果此值设置为2并且平均最近需要（缓冲区数）估计为10，脏缓冲区将被清除，直到有 20 个缓冲区可用或直到 <code>bgwriter_lru_maxpages</code> 已被写入。</p><p><code>bgwriter</code>函数在启动子进程完成后立即由 postmaster 启动，或者如果我们正在执行存档恢复，则在恢复开始后立即启动。它一直保持活动状态，直到postmaster命令它终止。可以快速比较提交、检查点和后台编写器，如下图所示：</p><p><img src="/medias/image/image-20230211212514993.png" alt="image-20230211212514993"></p><h2 id="autovacuum-launcher进程"><a href="#autovacuum-launcher进程" class="headerlink" title="autovacuum  launcher进程"></a>autovacuum  <strong>launcher</strong>进程</h2><p>这是一个可选过程。 postgresql中在postgresql.conf有一个参数叫做<code>autovacuum</code> 。 默认值为ON。此过程会根据一些参数自动执行 <code>vacuum</code> 和 <code>analyze</code> 命令。要了解 <code>autovacuum</code>，首先，我们必须了解 <code>vacuum</code>。</p><p>假设我们从表中删除几条记录。 PostgreSQL 不会立即从数据文件中删除已删除的元组，这些被标记为已删除。同理，更新一条记录时，大致相当于一次删除，一次插入，先前版本的记录继续存在于数据文件中。数据库行的每次更新都会生成该行的新版本。原因很简单：可能有活跃的事务，想要看到数据之前的样子。由于此动作，数据文件中将有大量无法使用的空间。一段时间后，这些死记录变得无关紧要，因为没有事务可以查看旧数据。但是，由于空间未标记为可重用，插入和更新（导致插入）发生在数据文件的其他页面中。</p><blockquote><p>PostgreSQL 可以为并发用户提供不同版本的数据。这样做是为了让读不会阻塞写，反之亦然。这是通过称为多版本并发控制(MVCC) 的机制实现的。</p></blockquote><p><code>vacuum</code> 进程将之前删除（或更新）的记录使用的空间标记为可在表中重复使用。有一个 <code>vacuum</code> 命令可以手动执行此操作， <code>vacuum</code> 不会锁定表。</p><p><code>VACUUM FULL</code> 除了将空间标记为可重用外，还会移除已删除或更新的记录并对表数据重新排序，这需要对表进行独占锁定。</p><p>使用带<code>analyze</code> 的 <code>vacuum</code> 选项执行会读取表中的记录并生成查询计划器使用的统计信息。</p><p><code>autovacuum</code> 使 <code>vacuum</code> 进程自动化。建议让 <code>autovacuum</code> 进程清理数据文件，除非有特定原因不这样做。如果一天中的大部分时间数据库负载很重，可以在非高峰时段安排 <code>vacuum</code>。尽管集群中很少或没有删除/更新，但进行例行清理很有用，因为清理会更新规划器使用的数据统计信息。</p><p>更多细节参考：<a href="https://jinlid.github.io/2022/autovacuum-jin-cheng/">https://jinlid.github.io/2022/autovacuum-jin-cheng/</a></p><h2 id="logging进程"><a href="#logging进程" class="headerlink" title="logging进程"></a><strong>logging</strong>进程</h2><p>这是一个可选过程，默认设置为关闭。我们必须将 <code>logging_collector</code> 参数设置为 on 才能启动此过程：</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">cd</span> <span class="token variable">$PGDATA</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>编辑postgresql.conf文件并进行一些更改：</p><pre class="line-numbers language-bash"><code class="language-bash">log_destination <span class="token operator">=</span> <span class="token string">'stderr'</span>logging_collector <span class="token operator">=</span> onlog_directory <span class="token operator">=</span> <span class="token string">'pg_log'</span>log_min_duration_statement <span class="token operator">=</span> 0<span class="token punctuation">[</span>postgres@host1 data<span class="token punctuation">]</span>$ pg_ctl restartwaiting <span class="token keyword">for</span> server to shut down<span class="token punctuation">..</span><span class="token punctuation">..</span> <span class="token keyword">done</span>server stoppedserver starting<span class="token punctuation">[</span>postgres@host1 data<span class="token punctuation">]</span>$ <span class="token function">ps</span> f -U postgres   PID TTY      STAT   TIME COMMAND 36350 pts/0    S      0:00 -bash 36411 pts/0    R+     0:00  \_ <span class="token function">ps</span> f -U postgres 36404 pts/0    S      0:00 /home/postgres/pg96/bin/postgres 36406 ?        Ss     0:00  \_ postgres: checkpointer process 36407 ?        Ss     0:00  \_ postgres: writer process 36408 ?        Ss     0:00  \_ postgres: wal writer process 36409 ?        Ss     0:00  \_ postgres: autovacuum launcher process 36410 ?        Ss     0:00  \_ postgres: stats collector process<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>查看启动的记录器进程。现在，日志记录有很多参数。</p><p>在 PostgreSQL 数据库中记录活动可以深入了解数据库中发生的事情，这是一个应该最大限度利用的实用程序。如果我们转到pg_log目录，我们可以看到生成的日志文件并查看它们。</p><blockquote><p><strong>..</strong></p><p><strong>LOG: database system is ready to accept connections</strong></p><p><strong>LOG: autovacuum launcher started</strong></p><p><strong>..</strong></p></blockquote><p>失败的登录尝试：</p><blockquote><p><strong>FATAL: role “hacker” does not exist</strong></p></blockquote><p>应用程序中的错误：</p><blockquote><p><strong>ERROR: function non_existing_function() does not exist at character</strong> <strong>8</strong></p><p><strong>HINT: No function matches the given name and argument types. You</strong> </p><p><strong>might need to add explicit type casts.</strong></p><p><strong>STATEMENT: select non_existing_function();</strong></p></blockquote><p>如果仔细查看消息，您会注意到第一条消息标记为LOG，第二条消息标记为FATAL，第三条消息标记为ERROR。</p><p>为了分析一段时间内数据库中发生的事情，使用这种标签（严重性级别）非常容易：有多少失败的登录尝试，有多少应用程序错误，等等。严重性级别的完整列表如下表所示：</p><table><thead><tr><th>严重程度</th><th>用途</th></tr></thead><tbody><tr><td>INFO</td><td>提供了用户隐式请求的信息，例如，来自 VACUUM VERBOSE 的输出。</td></tr><tr><td>NOTICE</td><td>这提供了可能对用户有帮助的信息，例如，长标识符的截断通知。</td></tr><tr><td>WARNING</td><td>可能出现的问题提供警告，例如，在事务块外提交。</td></tr><tr><td>ERROR</td><td>这会报告导致当前命令中止的错误。</td></tr><tr><td>LOG</td><td>这会报告管理员感兴趣的信息，例如检查点活动。</td></tr><tr><td>FATAL</td><td>这会报告导致当前会话中止的错误。</td></tr><tr><td>PANIC</td><td>这会报告导致所有数据库会话中止的错误。</td></tr></tbody></table><p>可以在位于<a href="http://www.postgresql.org/docs/current/static/runtime-config-logging.html">http://www.postgresql.org/docs/current/static/runtime-config-logging.html</a> 的 PostgreSQL 文档中找到对参数的描述。</p><p>我们将看到一些有用的选项并继续：</p><pre class="line-numbers language-properties"><code class="language-properties"><span class="token attr-name">log_min_duration_statement&amp;nbsp;</span><span class="token punctuation">=</span><span class="token attr-value">&amp;nbsp;0</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>如果语句至少运行了指定的毫秒数，则此设置会导致记录每个已完成语句的持续时间。默认值为‑1，它禁用记录语句的持续时间。将该值设置为0会导致记录所有语句的持续时间。这种方法，连同使用诸如 <code>pgbadger</code> 之类的工具进行分析，有助于快速跟踪缓慢的查询。但是，在每秒执行数百个查询的系统中，此设置会导致日志文件增长得非常快。因此，最好有一个流程将日志文件移动到另一个位置，在那里可以使用诸如 <code>pgbadger</code>之类的工具来挖掘日志文件并生成用户友好的报告。</p><p><code>log_line_prefix</code> 参数是另一个值得关注的参数。这个参数让我们用格式代码自定义日志语句，以显示有关已执行语句的信息。可以捕获的信息包括哪个用户执行了查询、在哪个数据库、来自哪个主机、执行时间（精确到毫秒）等等。我们可以看到如下值：</p><pre class="line-numbers language-properties"><code class="language-properties"><span class="token attr-name">log_line_prefix</span> <span class="token punctuation">=</span> <span class="token attr-value">'time=%t:db=%d;user=%u '</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>当我们在文件中进行上述设置时，将导致类似于以下的日志条目：</p><blockquote><p><strong>time=2013-11-16 20:10:00 IST:db=;user= LOG: parameter</strong> <strong>“log_line_prefix” changed to “time=%t:db=%d;user=%u “</strong></p><p><strong>time=2013-11-16 20:10:13 IST:db=postgres;user=postgres LOG:</strong> <strong>duration: 183.970 ms statement: select count(*) from myt;</strong></p><p><strong>time=2013-11-16 20:10:17 IST:db=postgres;user=postgres LOG:</strong> <strong>duration: 0.302 ms statement: select now();</strong></p><p><strong>time=2013-11-16 20:10:27 IST:db=postgres;user=postgres LOG:</strong> <strong>duration: 2.346 ms statement: insert into myt values(1);</strong></p></blockquote><p>添加type=%i使前缀看起来像time=%t:db=%d;user=%u type=%i ，这为我们提供了以下输出：</p><blockquote><p><strong>time=2013-11-16 20:28:57 IST:db=postgres;user=postgres type=SELECT</strong> <strong>LOG: duration: 0.151 ms statement: select now();</strong></p><p><strong>time=2013-11-16 20:28:58 IST:db=postgres;user=postgres type=INSERT</strong> <strong>LOG: duration: 3.385 ms statement: insert into myt values(1);</strong></p></blockquote><p><code>log_line_prefix</code> 参数是另一个非常有用的参数，它可以非常详细地启用自定义格式的日志记录。我们可以使用日志文件对数据库中发生的事情进行分析。一些有用的前缀选项如下：</p><table><thead><tr><th>选项</th><th>描述</th></tr></thead><tbody><tr><td>%a</td><td>Application name</td></tr><tr><td>%u</td><td>Username</td></tr><tr><td>%d</td><td>Database name</td></tr><tr><td>%r</td><td>Remote host and port</td></tr><tr><td>%h</td><td>Remote host</td></tr><tr><td>%p</td><td>Process ID</td></tr><tr><td>%t</td><td>Timestamp without milliseconds</td></tr><tr><td>%m</td><td>Timestamp with milliseconds</td></tr><tr><td>%i</td><td>Command tag</td></tr><tr><td>%e</td><td>SQL State error code</td></tr><tr><td>%c</td><td>Session ID</td></tr><tr><td>%l</td><td>Number of log line for that session</td></tr><tr><td>%s</td><td>session start timestamp</td></tr></tbody></table><p>请注意， <code>log_line_prefix</code> 参数不适用于csvlog选项。</p><h2 id="stats-collector进程"><a href="#stats-collector进程" class="headerlink" title="stats collector进程"></a><strong>stats collector进程</strong></h2><p>顾名思义，此过程收集有关数据库的统计信息。这是一个可选过程，默认值为 on。该过程跟踪对磁盘块和单个行项中的表和索引的访问。它还会跟踪表的记录计数，并跟踪 <code>vacuum</code> 和 <code>analyze</code> 操作。重要的是要注意，各个进程在进入空闲状态之前将新的统计计数传输到收集器。因此，许多柜台不会反映飞行中的交易活动。</p><p>数据被记录在一组表中，我们可以通过提供的多个视图访问它。视图以 pg_stat 开头。键入以下命令：</p><pre class="line-numbers language-sql"><code class="language-sql">\<span class="token number">d</span><span class="token operator">&amp;</span>nbsp<span class="token punctuation">;</span><span class="token operator">&amp;</span>nbsp<span class="token punctuation">;</span>pg_stat<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>按两次Tab键将列出所有视图，如以下命令所示：</p><pre class="line-numbers language-sql"><code class="language-sql">postgres<span class="token operator">=</span><span class="token comment" spellcheck="true"># \d pg_stat</span>pg_stat_activity                  pg_statio_all_sequences           pg_statistic                      pg_stat_user_functionspg_stat_all_indexes               pg_statio_all_tables              pg_statistic_relid_att_inh_index  pg_stat_user_indexespg_stat_all_tables                pg_statio_sys_indexes             pg_stat_progress_vacuum           pg_stat_user_tablespg_stat_archiver                  pg_statio_sys_sequences           pg_stat_replication               pg_stat_wal_receiverpg_stat_bgwriter                  pg_statio_sys_tables              pg_stats                          pg_stat_xact_all_tablespg_stat_database                  pg_statio_user_indexes            pg_stat_ssl                       pg_stat_xact_sys_tablespg_stat_database_conflicts        pg_statio_user_sequences          pg_stat_sys_indexes               pg_stat_xact_user_functionspg_statio_all_indexes             pg_statio_user_tables             pg_stat_sys_tables                pg_stat_xact_user_tables<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>我们可以使用\d+知道视图从哪里获取数据：</p><pre class="line-numbers language-sql"><code class="language-sql">postgres<span class="token operator">=</span><span class="token comment" spellcheck="true"># \d+ pg_statio_user_tables</span>           <span class="token keyword">View</span> <span class="token string">"pg_catalog.pg_statio_user_tables"</span>     <span class="token keyword">Column</span>      <span class="token operator">|</span>  <span class="token keyword">Type</span>  <span class="token operator">|</span> Modifiers <span class="token operator">|</span> Storage <span class="token operator">|</span> Description<span class="token comment" spellcheck="true">-----------------+--------+-----------+---------+-------------</span> relid           <span class="token operator">|</span> oid    <span class="token operator">|</span>           <span class="token operator">|</span> plain   <span class="token operator">|</span> schemaname      <span class="token operator">|</span> name   <span class="token operator">|</span>           <span class="token operator">|</span> plain   <span class="token operator">|</span> relname         <span class="token operator">|</span> name   <span class="token operator">|</span>           <span class="token operator">|</span> plain   <span class="token operator">|</span> heap_blks_read  <span class="token operator">|</span> <span class="token keyword">bigint</span> <span class="token operator">|</span>           <span class="token operator">|</span> plain   <span class="token operator">|</span> heap_blks_hit   <span class="token operator">|</span> <span class="token keyword">bigint</span> <span class="token operator">|</span>           <span class="token operator">|</span> plain   <span class="token operator">|</span> idx_blks_read   <span class="token operator">|</span> <span class="token keyword">bigint</span> <span class="token operator">|</span>           <span class="token operator">|</span> plain   <span class="token operator">|</span> idx_blks_hit    <span class="token operator">|</span> <span class="token keyword">bigint</span> <span class="token operator">|</span>           <span class="token operator">|</span> plain   <span class="token operator">|</span> toast_blks_read <span class="token operator">|</span> <span class="token keyword">bigint</span> <span class="token operator">|</span>           <span class="token operator">|</span> plain   <span class="token operator">|</span> toast_blks_hit  <span class="token operator">|</span> <span class="token keyword">bigint</span> <span class="token operator">|</span>           <span class="token operator">|</span> plain   <span class="token operator">|</span> tidx_blks_read  <span class="token operator">|</span> <span class="token keyword">bigint</span> <span class="token operator">|</span>           <span class="token operator">|</span> plain   <span class="token operator">|</span> tidx_blks_hit   <span class="token operator">|</span> <span class="token keyword">bigint</span> <span class="token operator">|</span>           <span class="token operator">|</span> plain   <span class="token operator">|</span><span class="token keyword">View</span> definition: <span class="token keyword">SELECT</span> pg_statio_all_tables<span class="token punctuation">.</span>relid<span class="token punctuation">,</span>    pg_statio_all_tables<span class="token punctuation">.</span>schemaname<span class="token punctuation">,</span>    pg_statio_all_tables<span class="token punctuation">.</span>relname<span class="token punctuation">,</span>    pg_statio_all_tables<span class="token punctuation">.</span>heap_blks_read<span class="token punctuation">,</span>    pg_statio_all_tables<span class="token punctuation">.</span>heap_blks_hit<span class="token punctuation">,</span>    pg_statio_all_tables<span class="token punctuation">.</span>idx_blks_read<span class="token punctuation">,</span>    pg_statio_all_tables<span class="token punctuation">.</span>idx_blks_hit<span class="token punctuation">,</span>    pg_statio_all_tables<span class="token punctuation">.</span>toast_blks_read<span class="token punctuation">,</span>    pg_statio_all_tables<span class="token punctuation">.</span>toast_blks_hit<span class="token punctuation">,</span>    pg_statio_all_tables<span class="token punctuation">.</span>tidx_blks_read<span class="token punctuation">,</span>    pg_statio_all_tables<span class="token punctuation">.</span>tidx_blks_hit   <span class="token keyword">FROM</span> pg_statio_all_tables  <span class="token keyword">WHERE</span> <span class="token punctuation">(</span>pg_statio_all_tables<span class="token punctuation">.</span>schemaname <span class="token operator">&lt;></span> <span class="token keyword">ALL</span> <span class="token punctuation">(</span>ARRAY<span class="token punctuation">[</span><span class="token string">'pg_catalog'</span>::name<span class="token punctuation">,</span> <span class="token string">'information_schema'</span>::name<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">AND</span> pg_statio_all_tables<span class="token punctuation">.</span>schemaname <span class="token operator">!</span><span class="token operator">~</span> <span class="token string">'^pg_toast'</span>::<span class="token keyword">text</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>因此，它是来自 <code>pg_statio_all_tables</code> 视图的数据子集。 <code>pg_statio_all_tables</code> 呢？</p><pre class="line-numbers language-sql"><code class="language-sql">postgres<span class="token operator">=</span><span class="token comment" spellcheck="true"># \d+ pg_statio_all_tables</span>            <span class="token keyword">View</span> <span class="token string">"pg_catalog.pg_statio_all_tables"</span>     <span class="token keyword">Column</span>      <span class="token operator">|</span>  <span class="token keyword">Type</span>  <span class="token operator">|</span> Modifiers <span class="token operator">|</span> Storage <span class="token operator">|</span> Description<span class="token comment" spellcheck="true">-----------------+--------+-----------+---------+-------------</span> relid           <span class="token operator">|</span> oid    <span class="token operator">|</span>           <span class="token operator">|</span> plain   <span class="token operator">|</span> schemaname      <span class="token operator">|</span> name   <span class="token operator">|</span>           <span class="token operator">|</span> plain   <span class="token operator">|</span> relname         <span class="token operator">|</span> name   <span class="token operator">|</span>           <span class="token operator">|</span> plain   <span class="token operator">|</span> heap_blks_read  <span class="token operator">|</span> <span class="token keyword">bigint</span> <span class="token operator">|</span>           <span class="token operator">|</span> plain   <span class="token operator">|</span> heap_blks_hit   <span class="token operator">|</span> <span class="token keyword">bigint</span> <span class="token operator">|</span>           <span class="token operator">|</span> plain   <span class="token operator">|</span> idx_blks_read   <span class="token operator">|</span> <span class="token keyword">bigint</span> <span class="token operator">|</span>           <span class="token operator">|</span> plain   <span class="token operator">|</span> idx_blks_hit    <span class="token operator">|</span> <span class="token keyword">bigint</span> <span class="token operator">|</span>           <span class="token operator">|</span> plain   <span class="token operator">|</span> toast_blks_read <span class="token operator">|</span> <span class="token keyword">bigint</span> <span class="token operator">|</span>           <span class="token operator">|</span> plain   <span class="token operator">|</span> toast_blks_hit  <span class="token operator">|</span> <span class="token keyword">bigint</span> <span class="token operator">|</span>           <span class="token operator">|</span> plain   <span class="token operator">|</span> tidx_blks_read  <span class="token operator">|</span> <span class="token keyword">bigint</span> <span class="token operator">|</span>           <span class="token operator">|</span> plain   <span class="token operator">|</span> tidx_blks_hit   <span class="token operator">|</span> <span class="token keyword">bigint</span> <span class="token operator">|</span>           <span class="token operator">|</span> plain   <span class="token operator">|</span><span class="token keyword">View</span> definition: <span class="token keyword">SELECT</span> <span class="token number">c</span><span class="token punctuation">.</span>oid <span class="token keyword">AS</span> relid<span class="token punctuation">,</span>    n<span class="token punctuation">.</span>nspname <span class="token keyword">AS</span> schemaname<span class="token punctuation">,</span>    <span class="token number">c</span><span class="token punctuation">.</span>relname<span class="token punctuation">,</span>    pg_stat_get_blocks_fetched<span class="token punctuation">(</span><span class="token number">c</span><span class="token punctuation">.</span>oid<span class="token punctuation">)</span> <span class="token operator">-</span> pg_stat_get_blocks_hit<span class="token punctuation">(</span><span class="token number">c</span><span class="token punctuation">.</span>oid<span class="token punctuation">)</span> <span class="token keyword">AS</span> heap_blks_read<span class="token punctuation">,</span>    pg_stat_get_blocks_hit<span class="token punctuation">(</span><span class="token number">c</span><span class="token punctuation">.</span>oid<span class="token punctuation">)</span> <span class="token keyword">AS</span> heap_blks_hit<span class="token punctuation">,</span>    <span class="token function">sum</span><span class="token punctuation">(</span>pg_stat_get_blocks_fetched<span class="token punctuation">(</span>i<span class="token punctuation">.</span>indexrelid<span class="token punctuation">)</span> <span class="token operator">-</span> pg_stat_get_blocks_hit<span class="token punctuation">(</span>i<span class="token punctuation">.</span>indexrelid<span class="token punctuation">)</span><span class="token punctuation">)</span>::<span class="token keyword">bigint</span> <span class="token keyword">AS</span> idx_blks_read<span class="token punctuation">,</span>    <span class="token function">sum</span><span class="token punctuation">(</span>pg_stat_get_blocks_hit<span class="token punctuation">(</span>i<span class="token punctuation">.</span>indexrelid<span class="token punctuation">)</span><span class="token punctuation">)</span>::<span class="token keyword">bigint</span> <span class="token keyword">AS</span> idx_blks_hit<span class="token punctuation">,</span>    pg_stat_get_blocks_fetched<span class="token punctuation">(</span>t<span class="token punctuation">.</span>oid<span class="token punctuation">)</span> <span class="token operator">-</span> pg_stat_get_blocks_hit<span class="token punctuation">(</span>t<span class="token punctuation">.</span>oid<span class="token punctuation">)</span> <span class="token keyword">AS</span> toast_blks_read<span class="token punctuation">,</span>    pg_stat_get_blocks_hit<span class="token punctuation">(</span>t<span class="token punctuation">.</span>oid<span class="token punctuation">)</span> <span class="token keyword">AS</span> toast_blks_hit<span class="token punctuation">,</span>    <span class="token function">sum</span><span class="token punctuation">(</span>pg_stat_get_blocks_fetched<span class="token punctuation">(</span>x<span class="token punctuation">.</span>indexrelid<span class="token punctuation">)</span> <span class="token operator">-</span> pg_stat_get_blocks_hit<span class="token punctuation">(</span>x<span class="token punctuation">.</span>indexrelid<span class="token punctuation">)</span><span class="token punctuation">)</span>::<span class="token keyword">bigint</span> <span class="token keyword">AS</span> tidx_blks_read<span class="token punctuation">,</span>    <span class="token function">sum</span><span class="token punctuation">(</span>pg_stat_get_blocks_hit<span class="token punctuation">(</span>x<span class="token punctuation">.</span>indexrelid<span class="token punctuation">)</span><span class="token punctuation">)</span>::<span class="token keyword">bigint</span> <span class="token keyword">AS</span> tidx_blks_hit   <span class="token keyword">FROM</span> pg_class <span class="token number">c</span>     <span class="token keyword">LEFT</span> <span class="token keyword">JOIN</span> pg_index i <span class="token keyword">ON</span> <span class="token number">c</span><span class="token punctuation">.</span>oid <span class="token operator">=</span> i<span class="token punctuation">.</span>indrelid     <span class="token keyword">LEFT</span> <span class="token keyword">JOIN</span> pg_class t <span class="token keyword">ON</span> <span class="token number">c</span><span class="token punctuation">.</span>reltoastrelid <span class="token operator">=</span> t<span class="token punctuation">.</span>oid     <span class="token keyword">LEFT</span> <span class="token keyword">JOIN</span> pg_index x <span class="token keyword">ON</span> t<span class="token punctuation">.</span>oid <span class="token operator">=</span> x<span class="token punctuation">.</span>indrelid     <span class="token keyword">LEFT</span> <span class="token keyword">JOIN</span> pg_namespace n <span class="token keyword">ON</span> n<span class="token punctuation">.</span>oid <span class="token operator">=</span> <span class="token number">c</span><span class="token punctuation">.</span>relnamespace  <span class="token keyword">WHERE</span> <span class="token number">c</span><span class="token punctuation">.</span>relkind <span class="token operator">=</span> <span class="token keyword">ANY</span> <span class="token punctuation">(</span>ARRAY<span class="token punctuation">[</span><span class="token string">'r'</span>::<span class="token string">"char"</span><span class="token punctuation">,</span> <span class="token string">'t'</span>::<span class="token string">"char"</span><span class="token punctuation">,</span> <span class="token string">'m'</span>::<span class="token string">"char"</span><span class="token punctuation">]</span><span class="token punctuation">)</span>  <span class="token keyword">GROUP</span> <span class="token keyword">BY</span> <span class="token number">c</span><span class="token punctuation">.</span>oid<span class="token punctuation">,</span> n<span class="token punctuation">.</span>nspname<span class="token punctuation">,</span> <span class="token number">c</span><span class="token punctuation">.</span>relname<span class="token punctuation">,</span> t<span class="token punctuation">.</span>oid<span class="token punctuation">,</span> x<span class="token punctuation">.</span>indrelid<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>简而言之，统计信息收集器进程跟踪许多项目，在一些表中更新它们，并且我们在这些表之上构建了视图，以提供关于数据库活动的合理格式良好的输出。跟踪统计视图有助于放大经常访问的表，识别要索引的列，还可以帮助提供有关配置服务器参数（例如 <code>shared_buffers</code> 和其他内存区域）的输入。一些视图(<code>pg_stat_replication</code>)提供了关于复制状态的信息（WAL 发送进程）。</p><p>有一些函数可用于管理统计信息。例如， pg_stat_reset()将当前数据库的所有统计计数器重置为零：</p><pre class="line-numbers language-sql"><code class="language-sql">postgres<span class="token operator">=</span><span class="token comment" spellcheck="true"># SELECT relname, n_tup_ins FROM pg_stat_user_tables;</span>  relname   <span class="token operator">|</span> n_tup_ins<span class="token comment" spellcheck="true">------------+-----------</span> emp <span class="token operator">|</span>      <span class="token number">2</span><span class="token punctuation">(</span><span class="token number">2</span> <span class="token keyword">rows</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>结果是在表emp中插入了2条记录：</p><pre class="line-numbers language-sql"><code class="language-sql">postgres<span class="token operator">=</span><span class="token comment" spellcheck="true"># SELECT pg_stat_reset();</span> pg_stat_reset<span class="token comment" spellcheck="true">---------------</span><span class="token punctuation">(</span><span class="token number">1</span> <span class="token keyword">row</span><span class="token punctuation">)</span>postgres<span class="token operator">=</span><span class="token comment" spellcheck="true"># SELECT relname, n_tup_ins FROM pg_stat_user_tables;</span>  relname   <span class="token operator">|</span> n_tup_ins<span class="token comment" spellcheck="true">------------+-----------</span> emp <span class="token operator">|</span>         <span class="token number">0</span><span class="token punctuation">(</span><span class="token number">2</span> <span class="token keyword">rows</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>计数器已重置为0。我们可以插入一条记录：</p><pre class="line-numbers language-sql"><code class="language-sql">test<span class="token operator">=</span><span class="token comment" spellcheck="true"># INSERT INTO emp(first_name) VALUES ('Scottnew');</span><span class="token keyword">INSERT</span> <span class="token number">0</span> <span class="token number">1</span>test<span class="token operator">=</span><span class="token comment" spellcheck="true"># SELECT relname, n_tup_ins FROM pg_stat_user_tables;</span> relname <span class="token operator">|</span> n_tup_ins <span class="token comment" spellcheck="true">---------+-----------</span> emp     <span class="token operator">|</span> <span class="token number">1</span> dept    <span class="token operator">|</span> <span class="token number">0</span><span class="token punctuation">(</span><span class="token number">2</span> <span class="token keyword">rows</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>计数器已递增。</p><p>对于统计数据收集，也有一组参数。其中一些是默认的值设置为打开，其他设置为关闭。我们将看看其中的一些。</p><p>默认禁用的计数器是： <code>log_statement_stats</code>、<code> log_parser_stats</code>、 <code>log_planner_stats</code>、 <code>log_executor_stats</code>和<code>track_io_timing</code>。</p><p><code>track_activities</code> 、 <code>update_process_title</code>和<code>track_counts</code> 设置是默认启用的设置。</p><p><code>WAL sender</code> 和 <code>WAL receiver</code>这是PostgreSQL最近版本引入的两个进程，主要是为了支持复制进程。 sender进程将WAL发送给standby server，slave端的receiver接收。</p><p>更多统计信息细节参考：<a href="https://jinlid.github.io/2022/stats-collector-jin-cheng/">https://jinlid.github.io/2022/stats-collector-jin-cheng/</a></p><p>到目前为止，我们涵盖了大部分关键进程和一个大内存区域： shared_buffers。然而，我们还有几个重要的内存区域有待讨论。在我们进入下一节之前，让我们这样做。</p><h3 id="使用-work-mem-在内存中排序"><a href="#使用-work-mem-在内存中排序" class="headerlink" title="使用 work_mem 在内存中排序"></a>使用 work_mem 在内存中排序</h3><p>PostgreSQL 使用两个重要参数在会话级别分配和使用内存。我们可以通过在 PostgreSQL 数据目录中执行以下命令来获取它们，如下所示：</p><pre class="line-numbers language-properties"><code class="language-properties"><span class="token attr-name">grep</span> <span class="token attr-value">work postgresql.conf </span><span class="token comment" spellcheck="true">#work_mem = 1MB # min 64kB</span><span class="token comment" spellcheck="true">#maintenance_work_mem = 16MB # min 1MB</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>第一个是<code>work_mem</code>。默认值设置为 1 MB，最小 64 KB。</p><p>这是在切换到临时磁盘文件之前内部排序操作和哈希表要使用的内存量。最后一部分是至关重要的（如果没有分配足够的内存，就会导致物理 I/O），这肯定会导致响应时间激增。所以听起来设置这个相当高会很好。然而，问题是这不是在服务器级别分配的，就像为shared_buffers 所做的那样。</p><p>这是为每个用户分配的。即使在一个查询中，如果有多个并行排序操作，每个排序操作都可能达到此参数设置的最大值。因此，如果我们保留默认的<code>max_connections</code> (100) 并决定将其增加到 32 MB，那么如果许多单独的会话都在进行繁重的排序，我们最终可能会使用超过 3 GB 的内存。</p><p>更好的选择是在我们知道要处理的数据量会很大但仍然需要较短响应时间的情况下在会话级别增加此值：</p><pre class="line-numbers language-sql"><code class="language-sql">postgres<span class="token operator">=</span><span class="token comment" spellcheck="true"># INSERT INTO myt select generate_series (1,1000000);</span>postgres<span class="token operator">=</span><span class="token comment" spellcheck="true"># CREATE TABLE myt (id serial);</span>postgres<span class="token operator">=</span><span class="token comment" spellcheck="true"># SET work_mem = '64kB';</span>postgres<span class="token operator">=</span><span class="token comment" spellcheck="true"># SELECT temp_files, temp_bytes FROM pg_stat_database </span><span class="token keyword">WHERE</span> datname <span class="token operator">=</span> <span class="token string">'postgres'</span><span class="token punctuation">;</span> temp_files <span class="token operator">|</span> temp_bytes <span class="token comment" spellcheck="true">------------+------------</span> <span class="token number">9</span> <span class="token operator">|</span> <span class="token number">284303360</span><span class="token punctuation">(</span><span class="token number">1</span> <span class="token keyword">row</span><span class="token punctuation">)</span>postgres<span class="token operator">=</span><span class="token comment" spellcheck="true"># SELECT * FROM ( SELECT * FROM myt ORDER BY id ) t </span><span class="token keyword">limit</span> <span class="token number">1000</span><span class="token punctuation">;</span> id <span class="token comment" spellcheck="true">-----</span> <span class="token number">1</span>postgres<span class="token operator">=</span><span class="token comment" spellcheck="true"># SELECT temp_files, temp_bytes FROM pg_stat_database </span><span class="token keyword">WHERE</span> datname <span class="token operator">=</span> <span class="token string">'postgres'</span><span class="token punctuation">;</span> temp_files <span class="token operator">|</span> temp_bytes <span class="token comment" spellcheck="true">------------+------------</span> <span class="token number">10</span> <span class="token operator">|</span> <span class="token number">312320000</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>排序操作最终创建了一个临时文件：</p><pre class="line-numbers language-sql"><code class="language-sql">postgres<span class="token operator">=</span><span class="token comment" spellcheck="true"># SHOW work_mem;</span> work_mem <span class="token comment" spellcheck="true">----------</span> 64kB<span class="token punctuation">(</span><span class="token number">1</span> <span class="token keyword">row</span><span class="token punctuation">)</span>postgres<span class="token operator">=</span><span class="token comment" spellcheck="true"># SET work_mem to '1MB';</span><span class="token keyword">SET</span>postgres<span class="token operator">=</span><span class="token comment" spellcheck="true"># SHOW work_mem;</span> work_mem <span class="token comment" spellcheck="true">----------</span> 1MB<span class="token punctuation">(</span><span class="token number">1</span> <span class="token keyword">row</span><span class="token punctuation">)</span>postgres<span class="token operator">=</span><span class="token comment" spellcheck="true"># SELECT * FROM ( SELECT * FROM myt ORDER BY id ) t </span><span class="token keyword">limit</span> <span class="token number">1000</span><span class="token punctuation">;</span> id <span class="token comment" spellcheck="true">-----</span> <span class="token number">1</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>postgres<span class="token operator">=</span><span class="token comment" spellcheck="true"># SELECT temp_files, temp_bytes FROM pg_stat_database </span><span class="token keyword">WHERE</span> datname <span class="token operator">=</span> <span class="token string">'postgres'</span><span class="token punctuation">;</span> temp_files <span class="token operator">|</span> temp_bytes <span class="token comment" spellcheck="true">------------+------------</span> <span class="token number">10</span> <span class="token operator">|</span> <span class="token number">312320000</span><span class="token punctuation">(</span><span class="token number">1</span> <span class="token keyword">row</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>临时文件的数量没有增加。</p><h3 id="使用-maintenance-work-mem-进行维护"><a href="#使用-maintenance-work-mem-进行维护" class="headerlink" title="使用 maintenance_work_mem 进行维护"></a>使用 maintenance_work_mem 进行维护</h3><p>此内存区域由 <code>vacuum</code> 等操作使用。与 <code>work_mem</code> 的情况一样，分配的空间将影响维护活动的完成速度。使用此区域的典型活动包括分析、清理、创建索引、重建索引等。</p><p>显示此值的影响非常简单，如以下命令所示：</p><pre class="line-numbers language-sql"><code class="language-sql">postgres<span class="token operator">=</span><span class="token comment" spellcheck="true"># \timing on</span>Timing <span class="token operator">is</span> <span class="token keyword">on</span><span class="token punctuation">.</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>有一个包含几十万条记录的列表：</p><pre class="line-numbers language-sql"><code class="language-sql">postgres<span class="token operator">=</span><span class="token comment" spellcheck="true"># SELECT pg_size_pretty(pg_table_size('myt'));</span> pg_size_pretty <span class="token comment" spellcheck="true">----------------</span> <span class="token number">69</span> MB<span class="token punctuation">(</span><span class="token number">1</span> <span class="token keyword">row</span><span class="token punctuation">)</span>postgres<span class="token operator">=</span><span class="token comment" spellcheck="true"># SELECT current_database();</span> current_database <span class="token comment" spellcheck="true">------------------</span> postgres<span class="token punctuation">(</span><span class="token number">1</span> <span class="token keyword">row</span><span class="token punctuation">)</span>Time: <span class="token number">1.152</span> mspostgres<span class="token operator">=</span><span class="token comment" spellcheck="true"># SELECT temp_files, temp_bytes FROM pg_stat_database </span><span class="token keyword">WHERE</span> datname <span class="token operator">=</span> <span class="token string">'postgres'</span><span class="token punctuation">;</span> temp_files <span class="token operator">|</span> temp_bytes <span class="token comment" spellcheck="true">------------+------------</span> <span class="token number">4</span> <span class="token operator">|</span> <span class="token number">120143872</span><span class="token punctuation">(</span><span class="token number">1</span> <span class="token keyword">row</span><span class="token punctuation">)</span>Time: <span class="token number">17.547</span> ms<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>截至目前，该数据库中有四个临时文件：</p><pre class="line-numbers language-sql"><code class="language-sql">postgres<span class="token operator">=</span><span class="token comment" spellcheck="true"># CREATE INDEX myindex ON myt(id);</span><span class="token keyword">CREATE</span> <span class="token keyword">INDEX</span>Time: <span class="token number">3477.075</span> mspostgres<span class="token operator">=</span><span class="token comment" spellcheck="true"># SELECT temp_files, temp_bytes FROM pg_stat_database </span><span class="token keyword">WHERE</span> datname <span class="token operator">=</span> <span class="token string">'postgres'</span><span class="token punctuation">;</span> temp_files <span class="token operator">|</span> temp_bytes <span class="token comment" spellcheck="true">------------+------------</span> <span class="token number">5</span> <span class="token operator">|</span> <span class="token number">160186368</span><span class="token punctuation">(</span><span class="token number">1</span> <span class="token keyword">row</span><span class="token punctuation">)</span>Time: <span class="token number">11.900</span> mspostgres<span class="token operator">=</span><span class="token comment" spellcheck="true"># DROP INDEX myindex;</span><span class="token keyword">DROP</span> <span class="token keyword">INDEX</span>Time: <span class="token number">17.686</span> mspostgres<span class="token operator">=</span><span class="token comment" spellcheck="true"># CREATE INDEX myindex on myt(id);</span><span class="token keyword">CREATE</span> <span class="token keyword">INDEX</span>Time: <span class="token number">3213.370</span> mspostgres<span class="token operator">=</span><span class="token comment" spellcheck="true"># SELECT temp_files, temp_bytes FROM pg_stat_database </span><span class="token keyword">WHERE</span> datname <span class="token operator">=</span> <span class="token string">'postgres'</span><span class="token punctuation">;</span> temp_files <span class="token operator">|</span> temp_bytes <span class="token comment" spellcheck="true">------------+------------</span> <span class="token number">6</span> <span class="token operator">|</span> <span class="token number">200228864</span><span class="token punctuation">(</span><span class="token number">1</span> <span class="token keyword">row</span><span class="token punctuation">)</span>Time: <span class="token number">11.433</span> mspostgres<span class="token operator">=</span><span class="token comment" spellcheck="true"># DROP INDEX myindex;</span><span class="token keyword">DROP</span> <span class="token keyword">INDEX</span>Time: <span class="token number">17.625</span> ms<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>每个索引创建都会添加到临时文件的数量中。现在，让我们增加维护工作内存：</p><pre class="line-numbers language-sql"><code class="language-sql">postgres<span class="token operator">=</span><span class="token comment" spellcheck="true"># SET maintenance_work_mem TO '1GB';</span><span class="token keyword">SET</span>Time: <span class="token number">0.359</span> mspostgres<span class="token operator">=</span><span class="token comment" spellcheck="true"># CREATE INDEX myindex ON myt(id);</span><span class="token keyword">CREATE</span> <span class="token keyword">INDEX</span>Time: <span class="token number">2894.212</span> mspostgres<span class="token operator">=</span><span class="token comment" spellcheck="true"># SELECT temp_files, temp_bytes FROM pg_stat_database </span><span class="token keyword">WHERE</span> datname <span class="token operator">=</span> <span class="token string">'postgres'</span><span class="token punctuation">;</span> temp_files <span class="token operator">|</span> temp_bytes <span class="token comment" spellcheck="true">------------+------------</span> <span class="token number">6</span> <span class="token operator">|</span> <span class="token number">200228864</span><span class="token punctuation">(</span><span class="token number">1</span> <span class="token keyword">row</span><span class="token punctuation">)</span>Time: <span class="token number">11.328</span> ms<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>没有更多的临时文件。让我们重置<code>maintenance_work_mem</code>。</p><pre class="line-numbers language-sql"><code class="language-sql">postgres<span class="token operator">=</span><span class="token comment" spellcheck="true"># RESET maintenance_work_mem;</span>RESETTime: <span class="token number">0.425</span> mspostgres<span class="token operator">=</span><span class="token comment" spellcheck="true"># SHOW maintenance_work_mem;</span> maintenance_work_mem <span class="token comment" spellcheck="true">----------------------</span> 16MB<span class="token punctuation">(</span><span class="token number">1</span> <span class="token keyword">row</span><span class="token punctuation">)</span>Time: <span class="token number">0.413</span> ms<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>由于使用<code>pg_restore</code>恢复数据库通常会涉及创建索引，所以建议在使用<code>pg_restore</code>时增加<code>maintenance_work_mem</code>。</p><blockquote><p>pg_restore 实用程序用于从 pg_dump 创建的归档文件中恢复 PostgreSQL 数据库。</p></blockquote><p>这两个设置的默认值已在 PostgreSQL 9.4 版中向上修改。</p><h3 id="了解-effective-cache-size"><a href="#了解-effective-cache-size" class="headerlink" title="了解 effective_cache_size"></a>了解 effective_cache_size</h3><p>这不是分配设置。它不是类似于目前讨论的高速缓存或缓冲区。此设置只是让 PostgreSQL 了解有多少磁盘缓存可用于单个查询。这个区域不是由数据库保留的，而是被优化器用来得出查询执行计划的。</p><p>大多数重要的缓冲区都已涵盖。还有提交日志(CLOG)缓冲区，用于存储已分配事务 ID 的每个事务的提交状态。其他内存区域包括用于跟踪数据页中的可用空间的可用空间映射、用于存储系统目录信息的目录缓存等。</p><p>总而言之，这是运行 PostgreSQL 的系统中不同缓冲区的样子：</p><p><img src="/medias/image/image-20230211220453349.png" alt="image-20230211220453349"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>在本章中，我们介绍了 PostgreSQL 中的重要进程和内存结构。我们还看到了如何有效地使用一些配置设置来捕获有关服务器活动的数据，并使用它来进一步优化数据库性能。</p>]]></content>
      
      
      <categories>
          
          <category> postgresql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> postgresql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2 进程和内存架构</title>
      <link href="/2021/2.jin-cheng-he-nei-cun-jia-gou/"/>
      <url>/2021/2.jin-cheng-he-nei-cun-jia-gou/</url>
      
        <content type="html"><![CDATA[<p>本章总结了PostgreSQL中的进程架构和内存架构，以帮助阅读后续章节。如果您已经熟悉它们，您可以跳过本章。</p><span id="more"></span><p>[TOC]</p><h2 id="2-1-流程架构"><a href="#2-1-流程架构" class="headerlink" title="2.1 流程架构"></a>2.1 流程架构</h2><p>PostgreSQL 是一个多进程架构的客户端/服务器型关系数据库管理系统，运行在单台主机上。</p><p>多个进程协同管理一个数据库集群的集合通常被称为<em>“PostgreSQL 服务器”</em>，它包含以下类型的进程：</p><ul><li>一个<strong>Postgres的服务器进程</strong>是与数据库集群管理的所有进程的父进程。</li><li>每个<strong>后端进程</strong>处理由连接的客户端发出的所有查询和语句。</li><li>各种<strong>后台进程</strong>为数据库管理执行每个特性的进程（例如，VACUUM 和CHECKPOINT 进程）。</li><li>在<strong>复制相关进程中</strong>，它们执行流式复制。详细信息在<a href="http://www.interdb.jp/pg/pgsql11.html">第 11 章</a>中描述。</li><li>在9.3 版本支持的<strong>后台工作进程中</strong>，它可以执行用户实现的任何处理。此处不详述，请参考<a href="http://www.postgresql.org/docs/current/static/bgworker.html">官方文档</a>。</li></ul><p>在以下小节中，将描述前三种类型的过程的详细信息。</p><p><img src="/medias/image/fig-2-01.png" alt="图 2.1 PostgreSQL 进程架构的一个例子"></p><hr><p>该图展示了一个 PostgreSQL 服务器的进程：一个 postgres 服务器进程、两个后端进程、七个后台进程和两个客户端进程。还说明了数据库集群、共享内存和两个客户端进程。</p><h3 id="2-1-1-Postgres-服务器进程"><a href="#2-1-1-Postgres-服务器进程" class="headerlink" title="2.1.1 Postgres 服务器进程"></a>2.1.1 Postgres 服务器进程</h3><p>如上所述，postgres 服务器进程是 PostgreSQL 服务器中所有进程的父进程。在早期版本中，它被称为“postmaster”。</p><p>通过使用<em>start</em>选项执行<a href="http://www.postgresql.org/docs/current/static/app-pg-ctl.html">pg_ctl</a>实用程序，postgres 服务器进程将启动。然后，它在内存中分配一个共享内存区域，启动各种后台进程，必要时启动复制关联进程和后台工作进程，并等待来自客户端的连接请求。每当收到来自客户端的连接请求时，它就会启动一个后端进程。（然后，启动的后端进程处理连接的客户端发出的所有查询）</p><p>一个postgres服务器进程监听一个网络端口，默认端口是5432。虽然同一台主机上可以运行多个PostgreSQL服务器，但是每个服务器之间应该设置监听不同的端口号，例如5432、5433 ， 等等。</p><h3 id="2-1-2-后端流程"><a href="#2-1-2-后端流程" class="headerlink" title="2.1.2 后端流程"></a>2.1.2 后端流程</h3><p>后端进程，也称为<em>postgres</em>，由 postgres 服务器进程启动并处理由一个连接的客户端发出的所有查询。它通过单个 TCP 连接与客户端通信，并在客户端断开连接时终止。</p><p>由于只允许操作一个数据库，因此在连接到 PostgreSQL 服务器时必须明确指定要使用的数据库。</p><p>PostgreSQL 允许多个客户端同时连接；配置参数<a href="http://www.postgresql.org/docs/current/static/runtime-config-connection.html#GUC-MAX-CONNECTIONS">max_connections</a>控制客户端的最大数量（默认为 100）。</p><p>如果WEB应用等很多客户端频繁重复与PostgreSQL服务器的连接和断开连接，会增加建立连接和创建后端进程的成本，因为PostgreSQL没有实现本地连接池功能，这种情况对数据库服务器的性能有负面影响。为了处理这种情况，通常使用池中间件（<a href="https://pgbouncer.github.io/">pgbouncer</a> 或<a href="http://www.pgpool.net/mediawiki/index.php/Main_Page">pgpool-II</a>）。</p><h3 id="2-1-3-后台进程"><a href="#2-1-3-后台进程" class="headerlink" title="2.1.3 后台进程"></a>2.1.3 后台进程</h3><p>表 2.1 显示了后台进程列表。与 postgres 服务器和后端进程相比，无法简单地解释每个功能，因为这些功能取决于各个特定的功能和 PostgreSQL 内部结构。因此，本章仅作介绍，详细信息将在后面的章节中描述。</p><table><thead><tr><th align="left">过程</th><th align="left">描述</th><th align="left">参考</th></tr></thead><tbody><tr><td align="left">background writer</td><td align="left">在这个过程中，共享缓冲池上的脏页被逐渐定期写入持久性存储（例如，HDD、SSD）（在 9.1 或更早版本中，它还负责检查点过程）</td><td align="left"><a href="http://www.interdb.jp/pg/pgsql08.html#_8.6.">第 8.6 节</a></td></tr><tr><td align="left">checkpointer</td><td align="left">在 9.2 或更高版本的此过程中，执行检查点过程</td><td align="left"><a href="http://www.interdb.jp/pg/pgsql08.html#_8.6.">第 8.6</a><a href="http://www.interdb.jp/pg/pgsql09.html#_9.7.">节</a>、<a href="http://www.interdb.jp/pg/pgsql09.html#_9.7.">第 9.7 节</a></td></tr><tr><td align="left">autovacuum launcher</td><td align="left">定期调用 autovacuum-worker 进程进行清理（更准确地说，它请求为 postgres 服务器创建 autovacuum 工作器）</td><td align="left"><a href="http://www.interdb.jp/pg/pgsql06.html#_6.5.">第 6.5 节</a></td></tr><tr><td align="left">WAL writer</td><td align="left">此过程会定期将 WAL 缓冲区上的 WAL 数据写入并刷新到持久存储</td><td align="left"><a href="http://www.interdb.jp/pg/pgsql09.html#_9.9.">第 9.9 节</a></td></tr><tr><td align="left">statistics collector</td><td align="left">在这个过程中，会收集pg_stat_activity、pg_stat_database等统计信息</td><td align="left"><a href="/2022/stats-collector-jin-cheng/">stats collector进程</a></td></tr><tr><td align="left">logging collector (logger)</td><td align="left">此进程将服务器消息写入日志文件</td><td align="left"></td></tr><tr><td align="left">archiver</td><td align="left">此过程执行归档日志记录</td><td align="left"><a href="http://www.interdb.jp/pg/pgsql09.html#_9.10.">第 9.10 节</a></td></tr></tbody></table><p>在以下示例中，一个 postgres 服务器进程（pid 为 9687）、两个后端进程（pid 为 9697 和 9717）以及表 2.1 中列出的几个后台进程正在运行，另请参见图 2.1。</p><pre class="line-numbers language-bash"><code class="language-bash">postgres<span class="token operator">></span> pstree -p 9687-+<span class="token operator">=</span> 00001 root /sbin/launchd \-+- 09687 postgres /usr/local/pgsql/bin/postgres -D /usr/local/pgsql/data   <span class="token operator">|</span>--<span class="token operator">=</span> 09688 postgres postgres: logger process        <span class="token operator">|</span>--<span class="token operator">=</span> 09690 postgres postgres: checkpointer process        <span class="token operator">|</span>--<span class="token operator">=</span> 09691 postgres postgres: writer process        <span class="token operator">|</span>--<span class="token operator">=</span> 09692 postgres postgres: wal writer process        <span class="token operator">|</span>--<span class="token operator">=</span> 09693 postgres postgres: autovacuum launcher process        <span class="token operator">|</span>--<span class="token operator">=</span> 09694 postgres postgres: archiver process        <span class="token operator">|</span>--<span class="token operator">=</span> 09695 postgres postgres: stats collector process        <span class="token operator">|</span>--<span class="token operator">=</span> 09697 postgres postgres: postgres sampledb 192.168.1.100<span class="token punctuation">(</span>54924<span class="token punctuation">)</span> idle     \--<span class="token operator">=</span> 09717 postgres postgres: postgres sampledb 192.168.1.100<span class="token punctuation">(</span>54964<span class="token punctuation">)</span> idle <span class="token keyword">in</span> transaction  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="2-2-内存架构"><a href="#2-2-内存架构" class="headerlink" title="2.2 内存架构"></a>2.2 内存架构</h2><p>PostgreSQL 中的内存架构可以分为两大类：</p><ul><li>本地内存区域 - 由每个后端进程分配供自己使用。</li><li>共享内存区域 - 由 PostgreSQL 服务器的所有进程使用。</li></ul><p>在以下小节中，将简要介绍这些内容。</p><p><img src="/medias/image/fig-2-02.png" alt="图 2.2 PostgreSQL 中的内存架构 "></p><h3 id="2-2-1-本地存储区"><a href="#2-2-1-本地存储区" class="headerlink" title="2.2.1 本地存储区"></a>2.2.1 本地存储区</h3><p>每个后端进程分配一个本地内存区域用于查询处理；每个区域被分成几个子区域——它们的大小是固定的或可变的。表 2.2 列出了主要的子领域。详细信息将在以下章节中描述。</p><table><thead><tr><th align="left">分区</th><th align="left">描述</th><th align="left">参考</th></tr></thead><tbody><tr><td align="left">work_mem</td><td align="left">Executor 使用此区域通过 ORDER BY 和 DISTINCT 操作对元组进行排序，并通过合并连接和哈希连接操作连接表。</td><td align="left"><a href="http://www.interdb.jp/pg/pgsql03.html">第3章</a></td></tr><tr><td align="left">maintenance_work_mem</td><td align="left">某些类型的维护操作（例如，VACUUM、REINDEX）使用此区域。</td><td align="left"><a href="http://www.interdb.jp/pg/pgsql06.html#_6.1.">第 6.1 节</a></td></tr><tr><td align="left">temp_buffers</td><td align="left">Executor 使用这个区域来存储临时表。</td><td align="left"></td></tr></tbody></table><h3 id="2-2-2-共享内存区"><a href="#2-2-2-共享内存区" class="headerlink" title="2.2.2 共享内存区"></a>2.2.2 共享内存区</h3><p>共享内存区域由 PostgreSQL 服务器在启动时分配。该区域也分为几个固定大小的子区域。表 2.3 列出了主要的子领域。详细信息将在以下章节中描述。</p><table><thead><tr><th align="left">分区</th><th align="left">描述</th><th align="left">参考</th></tr></thead><tbody><tr><td align="left">shared buffer</td><td align="left">PostgreSQL 将表和索引中的页面从持久存储加载到这里，并直接对其进行操作。</td><td align="left"><a href="http://www.interdb.jp/pg/pgsql08.html">第8章</a></td></tr><tr><td align="left">WAL buffer</td><td align="left">为确保服务器故障不会丢失数据，PostgreSQL 支持 WAL 机制。WAL 数据（也称为 XLOG 记录）是 PostgreSQL 中的事务日志；WAL缓冲区是WAL数据写入持久化存储之前的缓冲区。</td><td align="left"><a href="http://www.interdb.jp/pg/pgsql09.html">第9章</a></td></tr><tr><td align="left">commit log</td><td align="left">提交日志（CLOG）为并发控制（CC）机制保存所有事务的状态（例如，in_progress、committed、aborted）。</td><td align="left"><a href="http://www.interdb.jp/pg/pgsql05.html#_5.4.">第 5.4 节</a></td></tr></tbody></table><p>除了它们之外，PostgreSQL 还分配了几个区域，如下所示：</p><ul><li>用于各种访问控制机制的子区域。（例如，信号量、轻量级锁、共享和排他锁等）</li><li>各种后台进程的子区域，例如 checkpointer 和 autovacuum。</li><li>事务处理的子区域，例如保存点和两阶段提交。</li></ul>]]></content>
      
      
      <categories>
          
          <category> postgresql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> postgresql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>1 数据库集群、数据库和表</title>
      <link href="/2021/1.shu-ju-ku-ji-qun-shu-ju-ku-he-biao/"/>
      <url>/2021/1.shu-ju-ku-ji-qun-shu-ju-ku-he-biao/</url>
      
        <content type="html"><![CDATA[<p>本章和下一章总结了PostgreSQL的基础知识，以帮助阅读后续章节。</p><span id="more"></span><p>[TOC]</p><p>在本章中，描述了以下主题：</p><ul><li>数据库集群的逻辑结构</li><li>数据库集群的物理结构</li><li>堆表文件的内部布局</li><li>向表中写入和读取数据的方法</li></ul><p>如果您已经熟悉它们，您可以跳过本章。</p><h2 id="1-1-数据库集群的逻辑结构"><a href="#1-1-数据库集群的逻辑结构" class="headerlink" title="1.1 数据库集群的逻辑结构"></a>1.1 数据库集群的逻辑结构</h2><p>一个<strong>数据库集群</strong>是一个集<em>数据库，</em>由PostgreSQL服务器管理。如果您现在第一次听到这个定义，您可能会对此感到疑惑，但是 PostgreSQL 中的术语“数据库集群”<strong>并不</strong>意味着“一组数据库服务器”。PostgreSQL 服务器在单个主机上运行并管理单个数据库集群。</p><p>数据库集群的逻辑结构如图1.1所示。一个<em>数据库</em>是一个集合<em>的数据库对象</em>。在关系数据库理论中，<em>数据库对象</em>是一种用于存储或引用数据的数据结构。一个（堆）<em>表</em>就是一个典型的例子，还有很多，比如索引、序列、视图、函数等等。在 PostgreSQL 中，数据库本身也是数据库对象，在逻辑上彼此分离。所有其他数据库对象（例如，表、索引等）都属于它们各自的数据库。</p><p><img src="/medias/image/fig-1-01.png" alt="图 1.1 数据库集群的逻辑结构"></p><p>PostgreSQL 中的所有数据库对象都由各自的*<em>对象标识符 (OID)*<em>内部管理，它们是无符号的 4 字节整数。根据对象的类型，数据库对象和相应 OID 之间的关系存储在适当的<a href="http://www.postgresql.org/docs/current/static/catalogs.html">系统目录</a>中。例如，数据库和堆表的OID分别存储在</em>pg_database*和</em>pg_class中*，因此您可以通过发出如下查询来找出您想知道的OID：</p><pre class="line-numbers language-sql-monosp"><code class="language-sql-monosp">sampledb =# SELECT datname , oid FROM pg_database WHERE datname = 'sampledb' ;  数据名  |   oid   ----------+-------  sampledb | 16384 ( 1行) sampledb =# SELECT relname , oid FROM pg_class WHERE relname = 'sampletbl' ;   姓名  |   oid   -----------+-------  sampletbl | 18740 （1排）     <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="1-2-数据库集群物理结构"><a href="#1-2-数据库集群物理结构" class="headerlink" title="1.2  数据库集群物理结构"></a>1.2  数据库集群物理结构</h2><p>一个<em>数据库集群</em>基本上是一个称为<strong>基目录的目录</strong>，它包含一些子目录和大量文件。如果您执行<a href="http://www.postgresql.org/docs/current/static/app-initdb.html">initdb</a>实用程序来初始化一个新的数据库集群，则会在指定目录下创建一个基本目录。虽然不是强制性的，但基目录的路径通常设置为环境变量<em>PGDATA</em>。</p><p>图 1.2 显示了 PostgreSQL 中的数据库集群示例。数据库是<em>基</em>子目录下的子目录，每个表和索引（至少）是存储在其所属数据库子目录下的一个文件。还有几个包含特定数据和配置文件的子目录。虽然 PostgreSQL 支持<em>tablespaces</em>，但该术语的含义与其他 RDBMS 不同。PostgreSQL 中的表空间是一个包含基本目录之外的一些数据的目录。</p><p><img src="/medias/image/fig-1-02.png" alt="图 1.2 数据库集群示例"></p><p>在以下小节中，将描述数据库集群的布局、数据库、与表和索引关联的文件以及 PostgreSQL 中的表空间。</p><h3 id="1-2-1-数据库集群布局"><a href="#1-2-1-数据库集群布局" class="headerlink" title="1.2.1 数据库集群布局"></a>1.2.1 数据库集群布局</h3><p>数据库集群的布局在<a href="http://www.postgresql.org/docs/current/static/storage-file-layout.html">官方文档中</a>有描述。部分文档的主要文件和子目录如表1.1所示：</p><p><strong>表1.1 基目录下文件和子目录的布局（来自官方文档）</strong></p><table><thead><tr><th align="left">档案</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">PG_VERSION</td><td align="left">包含 PostgreSQL 主要版本号的文件</td></tr><tr><td align="left">pg_hba.conf</td><td align="left">用于控制 PosgreSQL 客户端身份验证的文件</td></tr><tr><td align="left">pg_ident.conf</td><td align="left">一个控制 PostgreSQL 用户名映射的文件</td></tr><tr><td align="left">postgresql.conf</td><td align="left">设置配置参数的文件</td></tr><tr><td align="left">postgresql.auto.conf</td><td align="left">用于存储在 ALTER SYSTEM（9.4 或更高版本）中设置的配置参数的文件</td></tr><tr><td align="left">postmaster.opts</td><td align="left">记录服务器上次启动时使用的命令行选项的文件</td></tr><tr><td align="left"><strong>子目录</strong></td><td align="left"><strong>描述</strong></td></tr><tr><td align="left">base/</td><td align="left">包含每个数据库子目录的子目录。</td></tr><tr><td align="left">global/</td><td align="left">包含集群范围表的子目录，例如 pg_database 和 pg_control。</td></tr><tr><td align="left">pg_commit_ts/</td><td align="left">包含事务提交时间戳数据的子目录。9.5 或更高版本。</td></tr><tr><td align="left">pg_clog/（9.6 或更早版本）</td><td align="left">包含事务提交状态数据的子目录。它在版本 10 中更名为<em>pg_xact。CLOG</em>将在<a href="http://www.interdb.jp/pg/pgsql05.html#_5.4.">第 5.4 节中</a>描述。</td></tr><tr><td align="left">pg_dynshmem/</td><td align="left">包含动态共享内存子系统使用的文件的子目录。9.4 或更高版本。</td></tr><tr><td align="left">pg_logical/</td><td align="left">包含用于逻辑解码的状态数据的子目录。9.4 或更高版本。</td></tr><tr><td align="left">pg_multixact/</td><td align="left">包含多事务状态数据的子目录（用于共享行锁）</td></tr><tr><td align="left">pg_notify/</td><td align="left">包含 LISTEN/NOTIFY 状态数据的子目录</td></tr><tr><td align="left">pg_repslot/</td><td align="left">包含<a href="http://www.postgresql.org/docs/current/static/warm-standby.html#STREAMING-REPLICATION-SLOTS">复制槽</a> 数据的子目录。9.4 或更高版本。</td></tr><tr><td align="left">pg_serial/</td><td align="left">包含有关已提交的可序列化事务（版本 9.1 或更高版本）的信息的子目录</td></tr><tr><td align="left">pg_snapshots/</td><td align="left">包含导出快照的子目录（版本 9.2 或更高版本）。PostgreSQL 的函数 pg_export_snapshot 在这个子目录中创建一个快照信息文件。</td></tr><tr><td align="left">pg_stat/</td><td align="left">包含统计子系统永久文件的子目录。</td></tr><tr><td align="left">pg_stat_tmp/</td><td align="left">包含统计子系统临时文件的子目录。</td></tr><tr><td align="left">pg_subtrans/</td><td align="left">包含子事务状态数据的子目录</td></tr><tr><td align="left">pg_tblspc/</td><td align="left">包含指向表空间的符号链接的子目录</td></tr><tr><td align="left">pg_twophase/</td><td align="left">包含准备交易的状态文件的子目录</td></tr><tr><td align="left">pg_wal/（版本 10 或更高版本）</td><td align="left">包含 WAL（预写日志）段文件的子目录。它从版本 10 中的<em>pg_xlog</em>重命名。</td></tr><tr><td align="left">pg_xact/（版本 10 或更高版本）</td><td align="left">包含事务提交状态数据的子目录。它在版本 10 中从<em>pg_clog</em>重命名。CLOG 将在<a href="http://www.interdb.jp/pg/pgsql05.html#_5.4.">第 5.4 节中</a>描述。</td></tr><tr><td align="left">pg_xlog/（9.6 或更早版本）</td><td align="left">包含 WAL（预写日志）段文件的子目录。它在版本 10 中更名为<em>pg_wal</em>。</td></tr></tbody></table><h3 id="1-2-2-数据库布局"><a href="#1-2-2-数据库布局" class="headerlink" title="1.2.2 数据库布局"></a>1.2.2 数据库布局</h3><p>数据库是<em>基</em>子目录下的子目录；并且数据库目录名称与相应的 OID 相同。例如，当数据库<em>sampledb</em>的OID为16384时，其子目录名称为16384。</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">cd</span> <span class="token variable">$PGDATA</span>$ <span class="token function">ls</span> -ld base/16384drwx------  213 postgres postgres  7242  8 26 16:33 16384<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="1-2-3-与表和索引相关的文件布局"><a href="#1-2-3-与表和索引相关的文件布局" class="headerlink" title="1.2.3 与表和索引相关的文件布局"></a>1.2.3 与表和索引相关的文件布局</h3><p>每个小于1GB的表或索引是一个单独的文件，存放在它所属的数据库目录下。作为数据库对象的表和索引由单独的 OID 内部管理，而这些数据文件由变量<em>relfilenode 管理</em>。表和索引的relfilenode值基本但<strong>不</strong>总是匹配各自的OID，详细描述如下。</p><p>让我们显示表<em>sampletbl</em>的 OID 和<em>relfilenode</em>：</p><pre class="line-numbers language-sql-monosp"><code class="language-sql-monosp">sampledb=# SELECT relname, oid, relfilenode FROM pg_class WHERE relname = 'sampletbl';  relname  |  oid  | relfilenode-----------+-------+------------- sampletbl | 18740 |       18740 (1 row)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>从上面的结果可以看出，oid 和 relfilenode 的值是相等的。还可以看到表<em>sampletbl</em>的数据文件路径为*’base/16384/18740’*。</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">cd</span> <span class="token variable">$PGDATA</span>$ <span class="token function">ls</span> -la base/16384/18740-rw------- 1 postgres postgres 8192 Apr 21 10:21 base/16384/18740<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>通过发出一些命令（例如，TRUNCATE、REINDEX、CLUSTER）来更改表和索引的 relfilenode 值。例如，如果我们截断表<em>sampletbl</em>，PostgreSQL 会为该表分配一个新的 relfilenode (18812)，删除旧的数据文件 (18740)，并创建一个新的 (18812)。</p><pre class="line-numbers language-sql-monosp"><code class="language-sql-monosp">sampledb=# TRUNCATE sampletbl;TRUNCATE TABLEsampledb=# SELECT relname, oid, relfilenode FROM pg_class WHERE relname = 'sampletbl';  relname  |  oid  | relfilenode-----------+-------+------------- sampletbl | 18740 |       18812 (1 row)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在 9.0 或更高版本中，内置函数<em>pg_relation_filepath</em>很有用，因为该函数返回具有指定 OID 或名称的关系的文件路径名。</p><pre class="line-numbers language-sql-monosp"><code class="language-sql-monosp">sampledb=# SELECT pg_relation_filepath('sampletbl'); pg_relation_filepath ---------------------- base/16384/18812(1 row)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>当表和索引的文件大小超过 1GB 时，PostgreSQL 会创建一个名为 relfilenode.1 的新文件并使用它。如果新文件已填满，将创建下一个名为 relfilenode.2 的新文件，依此类推。</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">cd</span> <span class="token variable">$PGDATA</span>$ <span class="token function">ls</span> -la -h base/16384/19427*-rw------- 1 postgres postgres 1.0G  Apr  21 11:16 data/base/16384/19427-rw------- 1 postgres postgres  45M  Apr  21 11:20 data/base/16384/19427.1<span class="token punctuation">..</span>.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在构建 PostgreSQL 时，可以使用配置选项 –with-segsize 更改表和索引的最大文件大小。</p><p>仔细查看数据库子目录，你会发现每个表都有两个关联的文件，分别以’_fsm’和’_vm’为后缀。那些被称为<strong>空闲空间映射</strong>和<strong>可见性映射</strong>，分别存储空闲空间容量和表文件中每个页面的可见性信息（更多详细信息参见<a href="http://www.interdb.jp/pg/pgsql05.html#_5.3.4.">第 5.3.4</a><a href="http://www.interdb.jp/pg/pgsql06.html#_6.2.">节</a>和<a href="http://www.interdb.jp/pg/pgsql06.html#_6.2.">第 6.2 节</a>）。索引只有单独的可用空间图，没有可见性图。</p><p>一个具体的例子如下所示：</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">cd</span> <span class="token variable">$PGDATA</span>$ <span class="token function">ls</span> -la base/16384/18751*-rw------- 1 postgres postgres  8192 Apr 21 10:21 base/16384/18751-rw------- 1 postgres postgres 24576 Apr 21 10:18 base/16384/18751_fsm-rw------- 1 postgres postgres  8192 Apr 21 10:18 base/16384/18751_vm<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>它们也可以在内部称为每个关系的<strong>分叉</strong>；空闲空间映射是表/索引数据文件的第一个分叉（分叉编号为 1），可见性映射是表数据文件的第二个分叉（分叉编号为 2）。数据文件的fork编号为0。</p><h3 id="1-2-4-表空间"><a href="#1-2-4-表空间" class="headerlink" title="1.2.4 表空间"></a>1.2.4 表空间</h3><p>甲<em>表</em>中PostgreSQL是基本目录之外的附加数据区。该功能已在8.0版本中实现。</p><p>图1.3展示了一个表空间的内部布局，以及与主数据区的关系。</p><p><img src="/medias/image/fig-1-03.png" alt="图 1.3 数据库集群中的一个表空间"></p><p>在您发出<a href="http://www.postgresql.org/docs/current/static/sql-createtablespace.html">CREATE TABLESPACE</a>语句时指定的目录下创建一个表空间，并在该目录下<a href="http://www.postgresql.org/docs/current/static/sql-createtablespace.html">创建</a>特定于版本的子目录（例如，PG_14_202011044）。特定版本的命名方法如下所示。</p><pre><code>PG_'主要版本'_'目录版本号'</code></pre><p>例如，如果您在/home/postgres/tblspc处创建一个表空间new_tblspc，其 oid 为 16386，则会在该表空间下创建一个子目录，例如PG_14_202011044。</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">ls</span> -l /home/postgres/tblspc/total 4drwx------ 2 postgres postgres 4096 Apr 21 10:08 PG_14_202011044<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>表空间目录由来自pg_tblspc子目录的符号链接寻址，链接名称与表空间的 OID 值相同。</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">ls</span> -l <span class="token variable">$PGDATA</span>/pg_tblspc/total 0lrwxrwxrwx 1 postgres postgres 21 Apr 21 10:08 16386 -<span class="token operator">></span> /home/postgres/tblspc<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>如果在表空间下创建新数据库（OID 为 16387），其目录将创建在特定于版本的子目录下。</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">ls</span> -l /home/postgres/tblspc/PG_14_202011044/total 4drwx------ 2 postgres postgres 4096 Apr 21 10:10 16387<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>如果新建表属于基目录下创建的数据库，首先在版本特定的子目录下新建与现有数据库OID同名的目录，然后放置新表文件在创建的目录下。</p><pre class="line-numbers language-sql-monosp"><code class="language-sql-monosp">sampledb=# CREATE TABLE newtbl (.....) TABLESPACE new_tblspc;sampledb=# SELECT pg_relation_filepath('newtbl');             pg_relation_filepath             --------------------------------------------- pg_tblspc/16386/PG_14_202011044/16384/18894<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="1-3-堆表文件的内部布局"><a href="#1-3-堆表文件的内部布局" class="headerlink" title="1.3 堆表文件的内部布局"></a>1.3 堆表文件的内部布局</h2><p>在数据文件内部（堆表和索引，以及空闲空间映射和可见性映射），它被分成固定长度的<strong>页</strong>（或<strong>块</strong>），默认为8192字节（8 KB）。每个文件中的那些页从 0 开始按顺序编号，这些编号称为<strong>块编号</strong>。如果文件已被填满，PostgreSQL 会在文件末尾添加一个新的空页以增加文件大小。</p><p>页面的内部布局取决于数据文件类型。在本节中，将描述表格布局，因为后续章节将需要这些信息。</p><p><img src="/medias/image/fig-1-04.png" alt="图 1.4 堆表文件的页面布局"></p><p>表中的页面包含三种数据，描述如下：</p><ol><li><p><strong>heap tuple(s)</strong> – 堆元组本身就是一个记录数据。它们从页面底部按顺序堆叠。元组的内部结构在<a href="http://www.interdb.jp/pg/pgsql05.html#_5.2.">第5.2节</a>和<a href="http://www.interdb.jp/pg/pgsql09.html">第9章中</a>描述，因为需要PostgreSQL中的并发控制（CC）和WAL知识。</p></li><li><p><strong>行指针（s）</strong> ——行指针有 4 个字节长，并保存一个指向每个堆元组的指针。它也称为<strong>项目指针</strong>。<br>行指针形成一个简单的数组，它起着元组索引的作用。每个索引从 1 开始依次编号，称为<strong>偏移编号</strong>。当一个新的元组被添加到页面时，一个新的行指针也会被推送到数组上以指向新的。</p></li><li><p><strong>标头数据</strong>– 由结构<a href="javascript:void(0)">PageHeaderData</a>定义的标头数据分配在页面的开头。它有 24 字节长，包含有关页面的一般信息。结构的主要变量描述如下。</p></li><li><ul><li><em>pd_lsn</em> – 该变量存储了此页面最后一次更改写入的<em>XLOG</em>记录的 LSN。它是一个 8 字节的无符号整数，与 WAL（Write-Ahead Logging）机制有关。详细信息在<a href="http://www.interdb.jp/pg/pgsql09.html#_9.1.2.">第 9 章</a>中描述。</li><li><em>pd_checksum</em> – 此变量存储此页面的校验和值。（注意这个变量在9.3及以后的版本中是支持的；在早期的版本中，这部分已经存储了页面的timelineId。）</li><li><em>pd_lower, pd_upper</em> – pd_lower 指向行尾指针，pd_upper 指向最新堆元组的开头。</li><li><em>pd_special</em> – 此变量用于索引。在表格内的页面中，它指向页面的末尾。（在索引内页中，它指向特殊空间的开始，即只由索引保存的数据区，根据索引类型如B-tree、GiST、GiN等包含特定数据。）</li></ul></li></ol><p>行指针末尾和最新元组开头之间的空白空间称为<strong>空闲空间</strong>或<strong>空洞</strong>。</p><p>为了标识表中的<strong>元组，</strong>内部使用了*<em>元组标识符 (TID)*<em>。TID 包含一对值：包含元组的页面的</em>块号*，以及指向元组的行指针的</em>偏移量*。其用法的典型示例是索引。请参阅<a href="http://www.interdb.jp/pg/pgsql01.html#_1.4.2.">第 1.4.2 节中的</a>更多详细信息。</p><p>PageHeaderData 结构在<a href="https://github.com/postgres/postgres/blob/master/src/include/storage/bufpage.h">src/include/storage/bufpage.h 中定义</a>。</p><p>在计算机科学领域，这种类型的页面被称为<strong>slotted page</strong>，行指针对应一个<strong>slot array</strong>。</p><p>此外，大小大于约 2 KB（约 8 KB 的 1/4）的堆元组使用称为<strong>TOAST</strong>（超大属性存储技术）的方法进行存储和管理。有关详细信息，请参阅<a href="http://www.postgresql.org/docs/current/static/storage-toast.html">PostgreSQL 文档</a>。</p><h2 id="1-4-编写和读取元组的方法"><a href="#1-4-编写和读取元组的方法" class="headerlink" title="1.4 编写和读取元组的方法"></a>1.4 编写和读取元组的方法</h2><p>在本章的最后，描述了编写和读取堆元组的方法。</p><h3 id="1-4-1-编写堆元组"><a href="#1-4-1-编写堆元组" class="headerlink" title="1.4.1 编写堆元组"></a>1.4.1 编写堆元组</h3><p>假设一个表由一页组成，其中只包含一个堆元组。本页的pd_lower指向第一行指针，行指针和pd_upper都指向第一个堆元组。见图 1.5(a)。</p><p>当插入第二个元组时，它被放置在第一个元组之后。第二行指针被推到第一个行上，它指向第二个元组。pd_lower 更改为指向第二行指针，pd_upper 更改为指向第二个堆元组。见图 1.5(b)。该页内的其他头数据（例如，pd_lsn、pg_checksum、pg_flag）也被重写为适当的值；更多细节在<a href="http://www.interdb.jp/pg/pgsql05.html#_5.3.">第 5.3 节</a>和<a href="http://www.interdb.jp/pg/pgsql09.html">第 9 章</a>中描述。</p><p><img src="/medias/image/fig-1-05.png" alt="图 1.5 编写堆元组"></p><h3 id="1-4-2-读取堆元组"><a href="#1-4-2-读取堆元组" class="headerlink" title="1.4.2 读取堆元组"></a>1.4.2 读取堆元组</h3><p>这里概述了两种典型的访问方法，顺序扫描和 B 树索引扫描：</p><ul><li><strong>顺序扫描</strong>——通过扫描每页中的所有行指针来顺序读取所有页中的所有元组。见图 1.6(a)。</li><li><strong>B 树索引扫描</strong> ——索引文件包含索引元组，每个索引元组由一个索引键和一个指向目标堆元组的 TID 组成。如果找到了带有您要查找的键的索引元组，PostgreSQL 将使用获得的 TID 值读取所需的堆元组。（在B-tree索引中查找索引元组的方法这里不做说明，因为它很常见，这里篇幅有限。参见相关资料。）例如，在图1.6（b）中，TID获得的索引元组的值为’(block = 7, Offset = 2)’。这意味着目标堆元组是表中第 7 页的第 2 个元组，因此 PostgreSQL 可以读取所需的堆元组，而无需在页面中进行不必要的扫描。</li></ul><p><img src="/medias/image/fig-1-06.png" alt="图 1.6 顺序扫描和索引扫描"></p><p> <em>索引内部</em></p><p>本文档不详细解释索引。为了理解它们，我建议阅读下面显示的有价值的帖子：</p><ul><li><a href="https://postgrespro.com/blog/pgsql/3994098">PostgreSQL 中的索引 — 1</a></li><li><a href="https://postgrespro.com/blog/pgsql/4161264">PostgreSQL 中的索引 — 2</a></li><li><a href="https://postgrespro.com/blog/pgsql/4161321">PostgreSQL 中的索引 — 3 (Hash)</a></li><li><a href="https://postgrespro.com/blog/pgsql/4161516">PostgreSQL 中的索引 — 4 (Btree)</a></li><li><a href="https://postgrespro.com/blog/pgsql/4175817">PostgreSQL 中的索引 — 5 (GiST)</a></li><li><a href="https://habr.com/en/company/postgrespro/blog/446624/">PostgreSQL 中的索引 — 6 (SP-GiST)</a></li><li><a href="https://habr.com/en/company/postgrespro/blog/448746/">PostgreSQL 中的索引 — 7 (GIN)</a></li><li><a href="https://habr.com/en/company/postgrespro/blog/452900/">PostgreSQL 中的索引 — 9 (BRIN)</a></li></ul><p>PostgreSQL 还支持 TID-Scan、<a href="https://wiki.postgresql.org/wiki/Bitmap_Indexes">Bitmap-Scan</a>和 Index-Only-Scan。</p><p>TID-Scan 是一种通过使用所需元组的 TID 直接访问元组的方法。例如，要查找表中第 0 页中的第一个元组，请发出以下查询：</p><pre class="line-numbers language-sql-monosp"><code class="language-sql-monosp">sampledb=# SELECT ctid, data FROM sampletbl WHERE ctid = '(0,1)'; ctid  |   data    -------+----------- (0,1) | AAAAAAAAA(1 row)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Index-Only-Scan 将在<a href="http://www.interdb.jp/pg/pgsql07.html">第 7 章</a>详细介绍。</p>]]></content>
      
      
      <categories>
          
          <category> postgresql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> postgresql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>10 基础备份和时间点恢复</title>
      <link href="/2021/10-ji-chu-bei-fen-he-shi-jian-dian-hui-fu/"/>
      <url>/2021/10-ji-chu-bei-fen-he-shi-jian-dian-hui-fu/</url>
      
        <content type="html"><![CDATA[<p>在线数据库备份大致可以分为两类：逻辑备份和物理备份。这两种方法各有优缺点，但逻辑备份的一个缺点是非常耗时，特别是对大型数据库进行备份需要很长时间，而从备份数据恢复到数据库需要更多的时间。相反，可以更快地创建和恢复物理备份，使其成为实际系统中非常重要和有用的特性。</p><p>在PostgreSQL中，从8.0版本开始就有了在线物理完全备份，一个运行的整个数据库集群的快照（即物理备份数据）被称为基本备份。</p><blockquote><p>在7.4或更早的版本中，PostgreSQL只支持逻辑备份（逻辑完整备份和部分备份，以及数据导出）。</p></blockquote><p>时间点恢复（**Point-in-Time Recovery (PITR)**）也从8.0版本开始提供，它是一种使用基本备份和连续归档特性创建的归档日志将数据库集群恢复到任何时间点的功能。例如，即使您犯了一个严重的错误（比如截断所有表），这个特性可以用来将数据库恢复到错误发生之前的状态。</p><p>本章将介绍以下主题:</p><ul><li><p>什么是基本备份</p></li><li><p>PITR如何工作</p></li><li><p>什么是时间线</p></li><li><p>什么是时间线历史文件</p></li></ul><span id="more"></span><p>[TOC]</p><h3 id="10-1-基础备份"><a href="#10-1-基础备份" class="headerlink" title="10.1 基础备份"></a>10.1 基础备份</h3><p>首先，使用底层命令创建基本备份的标准过程如下：</p><p>（1）发出 <code>pg_backup_start</code> 命令（版本14或更早的版本，pg_start_backup）；</p><p>（2）使用您选择的归档命令创建数据库集群的快照；</p><p>（3）发出 <code>pg_backup_stop</code> 命令（版本14或更早的版本，pg_stop_backup）。</p><p>对于数据库系统管理员来说，这个简单的过程很容易使用，因为除了cp命令或类似的归档工具等常用工具外，它不需要任何特殊工具。此外，该过程不需要表锁，所有用户都可以发出查询而不受备份操作的影响。这是相对于其他主要开源RDBMS的巨大优势。</p><p>进行基本备份的一种更简单的方法是使用pg_basebackup实用程序，该实用程序在内部发出上述底层命令。</p><p><img src="/medias/image/fig-10-01.png" alt="图10.1 进行基础备份"></p><p>因为pg_backup_start和pg_backup_stop命令对于理解PITR非常重要，所以我们将在下面的小节中更详细地研究它们。</p><p>pg_backup_start和pg_backup_stop命令定义在：<a href="https://github.com/postgres/postgres/blob/master/src/backend/access/transam/xlogfuncs.c">src/backend/access/transam/xlogfuncs.c</a>。</p><h4 id="10-1-1-pg-backup-start"><a href="#10-1-1-pg-backup-start" class="headerlink" title="10.1.1 pg_backup_start"></a>10.1.1 pg_backup_start</h4><p>pg_backup_start为基本备份做准备。正如第9.8节所讨论的，恢复过程从REDO点开始，因此pg_backup_start命令必须执行一个检查点，以便在开始进行基本备份时显式地创建REDO点。此外，检查点的检查点位置必须保存在pg_control以外的文件中，因为常规检查点可能在备份期间执行多次。pg_backup_start执行以下4个操作：</p><p>（1）强制数据库进入整页写模式。</p><p>（2）切换到当前的WAL段文件（版本8.4或更高版本）。</p><p>（3）做一个检查点。</p><p>（4）创建一个backup_label文件——该文件创建在基本目录的顶层，包含关于基础备份本身的基本信息，例如该检查点的检查点位置。</p><p>第三和第四项操作是该命令的核心；执行第一和第二个操作是为了更可靠地恢复数据库集群。</p><p>backup_label文件包含以下6项（版本11或更高版本为7项）：</p><ul><li><p>CHECKPOINT LOCATION——这是记录该命令创建的检查点的LSN位置。</p></li><li><p>START WAL LOCATION——这不是用在PITR上，而是用在第11章描述的流复制上。它被命名为“START WAL LOCATION”，因为在复制模式下的备服务器在初始启动时只读取该值一次。</p></li><li><p>BACKUP METHOD——这是用于进行基本备份的方法（’pg_backup_start’或’pg_basebackup’）。</p></li><li><p>BACKUP FROM——显示该备份是从主服务器还是从备服务器获取的。</p></li><li><p>START TIME——这是pg_backup_start命令执行时的时间戳。</p></li><li><p>LABEL——这是在pg_backup_start命令中指定的标签。</p></li><li><p>START TIMELINE——这是备份启动的时间线。这是用于完整性检查，已在版本11中引入。</p></li></ul><p>backup_label</p><p>版本16中使用pg_basebackup获取的backup_label文件的实际示例如下：</p><pre class="line-numbers language-bash"><code class="language-bash">postgres<span class="token operator">></span> <span class="token function">cat</span> /usr/local/pgsql/data/backup_labelSTART WAL LOCATION: 0/1B000028 <span class="token punctuation">(</span>file 00000001000000000000001B<span class="token punctuation">)</span>CHECKPOINT LOCATION: 0/1B000060BACKUP METHOD: streamedBACKUP FROM: primarySTART TIME: 2024-1-1 11:45:19 GMTLABEL: pg_basebackup base backupSTART TIMELINE: 1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>正如你可以想象的那样，当你使用这个基础备份恢复一个数据库时，PostgreSQL从backup_label文件中取出<strong>CHECKPOINT LOCATION</strong> ，从相应的归档日志中读取检查点记录，然后，从它的记录中获取REDO点并开始恢复过程。</p><h4 id="10-1-2-pg-backup-stop"><a href="#10-1-2-pg-backup-stop" class="headerlink" title="10.1.2 pg_backup_stop"></a>10.1.2 pg_backup_stop</h4><p>pg_backup_stop执行以下5个操作来完成备份。</p><ol><li><p>如果已被pg_backup_start命令强制更改，则重置为非整页写模式。</p></li><li><p>写一个XLOG记录的备份。</p></li><li><p>切换WAL段文件。</p></li><li><p>创建历史备份文件。该文件包含backup_label文件的内容和执行pg_backup_stop命令时的时间戳。</p></li><li><p>删除backup_label文件。从基础备份恢复时需要备份backup_label文件，复制完成后，在原数据库集群中就不需要备份了。</p></li></ol><blockquote><p>备份历史文件的命名方法如下所示：</p><p>{WAL段}.{基本备份启动时的偏移值}.backup</p></blockquote><h3 id="10-2-时间点恢复如何工作"><a href="#10-2-时间点恢复如何工作" class="headerlink" title="10.2 时间点恢复如何工作"></a>10.2 时间点恢复如何工作</h3><p>图10.2显示了PITR的基本概念。在PITR模式下的PostgreSQL在基本备份上重放归档日志的WAL数据，从pg_backup_start创建的REDO点到您想要恢复的点。在PostgreSQL中，要恢复的点被称为恢复目标。</p><p><img src="/medias/image/fig-10-02.png" alt="图10.2 PITR的基本概念"></p><p>以下是PITR工作原理的描述。</p><p>假设你在2022年11月18日格林尼治时间12:05犯了一个错误。您应该删除数据库集群，并使用之前的基础备份恢复新的数据库集群。</p><p>首先，您需要设置 <code>restore_command</code> 参数的命令，并将 postgresql.conf（版本11或更早，recovery.conf）文件中<code>recovery_target_time</code> 参数的时间设置为您犯错误的时间（在本例中为12:05 GMT）。</p><pre class="line-numbers language-properties"><code class="language-properties"><span class="token comment" spellcheck="true"># Place archive logs under /mnt/server/archivedir directory.</span><span class="token attr-name">restore_command</span> <span class="token punctuation">=</span> <span class="token attr-value">'cp /mnt/server/archivedir/%f %p'</span><span class="token attr-name">recovery_target_time</span> <span class="token punctuation">=</span> <span class="token attr-value">"2022-11-18 12:05 GMT"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>当PostgreSQL启动时，如果在数据库集群中存在<strong>backup_label</strong>和<strong>recovery. signal</strong>文件（版本11或更早，<strong>recovery.conf</strong>），它将进入PITR模式。</p><blockquote><p>recovery.conf/recovery.signal</p><p>recovery.conf在版本12中已经被废除，所有与恢复相关的参数都应写入postgresql.conf中。详见<a href="https://www.postgresql.org/docs/current/runtime-config-wal.html#RUNTIME-CONFIG-WAL-ARCHIVE-RECOVERY">官方文档</a>。</p><p>在版本12或更高版本中，当您从基本备份恢复服务器时，需要在数据库集群目录中创建一个名为recovery.signal的空文件。</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">touch</span> /usr/local/pgsql/data/recovery.signal<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></blockquote><p>PITR过程与9.8章节中描述的正常恢复过程几乎相同。唯一的区别是：</p><p>1 从哪里读取WAL日志?</p><ul><li><p>正常恢复模式——从基目录下的pg_xlog子目录（在版本10或更高版本中是pg_wal子目录）。</p></li><li><p>PITR模式——从配置参数 <code>archive_command</code> 中设置的归档目录。</p></li></ul><p>2 检查点位置从哪里读取?</p><ul><li><p>正常恢复模式——从pg_control文件。</p></li><li><p>PITR模式——从backup_label文件。</p></li></ul><p>PITR流程概述如下：</p><p>（1）PostgreSQL使用 <em>read_backup_label()</em> 内部函数从backup_label文件中读取<strong>CHECKPOINT LOCATION</strong>的值来找到REDO point。</p><p>（2）PostgreSQL从recovery.conf（版本12或更高，postgreSQL .conf）中读取一些参数值；如<code>restore_command</code> 和<code>recovery_target_time</code>。</p><p>（3）PostgreSQL从REDO点开始重放WAL数据，这可以很容易地从<strong>CHECKPOINT LOCATION</strong>的值中获得。通过执行参数<code>resotere_command</code> 中写入的命令，从归档日志中读取WAL数据，并将归档日志从归档区域复制到临时区域（临时区域内复制的日志文件在使用后会被删除）。</p><p>在这个例子中，PostgreSQL从REDO点读取并重放WAL数据到时间戳<strong>2022-11-18 12:05:00</strong>之前的那个点，因为参数<code>recovery_target_time </code>被设置为这个时间戳。如果恢复目标没有设置为recovery.conf（版本12或更高，postgreSQL .conf），PostgreSQL将会重放直到归档日志结束。</p><p>（4）当恢复过程完成时，一个时间线历史文件，例如<strong>00000002.History</strong>在pg_xlog子目录中创建；如果启用了归档日志功能，则在归档目录下也会创建同名文件。该文件的内容和作用将在以下部分进行描述。</p><p>提交和中止操作的记录包含每个操作完成的时间戳（这两个操作的XLOG数据部分分别在xl_xact_commit和xl_xact_abort中定义）。</p><p> xl_xact_commit</p><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">typedef</span> <span class="token keyword">struct</span> xl_xact_commit<span class="token punctuation">{</span>        TimestampTzxact_time<span class="token punctuation">;</span>          <span class="token comment" spellcheck="true">/* time of commit */</span>        uint32          xinfo<span class="token punctuation">;</span>              <span class="token comment" spellcheck="true">/* info flags */</span>        <span class="token keyword">int</span>            nrels<span class="token punctuation">;</span>              <span class="token comment" spellcheck="true">/* number of RelFileNodes */</span>        <span class="token keyword">int</span>            nsubxacts<span class="token punctuation">;</span>          <span class="token comment" spellcheck="true">/* number of subtransaction XIDs */</span>        <span class="token keyword">int</span>            nmsgs<span class="token punctuation">;</span>              <span class="token comment" spellcheck="true">/* number of shared inval msgs */</span>        Oid            dbId<span class="token punctuation">;</span>               <span class="token comment" spellcheck="true">/* MyDatabaseId */</span>        Oid            tsId<span class="token punctuation">;</span>               <span class="token comment" spellcheck="true">/* MyDatabaseTableSpace */</span>        <span class="token comment" spellcheck="true">/* Array of RelFileNode(s) to drop at commit */</span>        RelFileNode     xnodes<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>          <span class="token comment" spellcheck="true">/* VARIABLE LENGTH ARRAY */</span>        <span class="token comment" spellcheck="true">/* ARRAY OF COMMITTED SUBTRANSACTION XIDs FOLLOWS */</span>        <span class="token comment" spellcheck="true">/* ARRAY OF SHARED INVALIDATION MESSAGES FOLLOWS */</span><span class="token punctuation">}</span> xl_xact_commit<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p> xl_xact_abort</p><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">typedef</span> <span class="token keyword">struct</span> xl_xact_abort<span class="token punctuation">{</span>        TimestampTz     xact_time<span class="token punctuation">;</span>          <span class="token comment" spellcheck="true">/* time of abort */</span>        <span class="token keyword">int</span>            nrels<span class="token punctuation">;</span>              <span class="token comment" spellcheck="true">/* number of RelFileNodes */</span>        <span class="token keyword">int</span>             nsubxacts<span class="token punctuation">;</span>          <span class="token comment" spellcheck="true">/* number of subtransaction XIDs */</span>        <span class="token comment" spellcheck="true">/* Array of RelFileNode(s) to drop at abort */</span>        RelFileNode     xnodes<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>          <span class="token comment" spellcheck="true">/* VARIABLE LENGTH ARRAY */</span>        <span class="token comment" spellcheck="true">/* ARRAY OF ABORTED SUBTRANSACTION XIDs FOLLOWS */</span><span class="token punctuation">}</span> xl_xact_abort<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>因此，如果目标时间设置为<code>recovery_target_time</code> 参数，PostgreSQL可以选择是否继续恢复，无论何时它重播XLOG记录的提交或中止动作。当每个动作的XLOG记录被重播时，PostgreSQL会比较目标时间和记录中写入的每个时间戳，如果时间戳超过目标时间，则PITR进程将结束。</p><p>*read_backup_label()*函数在<a href="https://github.com/postgres/postgres/blob/master/src/backend/access/transam/xlog.c">src/backend/access/transam/xlog.c</a>中定义。</p><p>xl_xact_commit结构体和xl_xact_abort结构体在<a href="https://github.com/postgres/postgres/blob/master/src/include/access/xact.h">src/include/access/xact.h</a>中定义。</p><blockquote><p>为什么我们可以使用常见的归档工具来进行基本备份?</p><p>恢复过程是将数据库集群恢复到一致状态的过程，尽管集群是不一致的。由于PITR基于恢复过程，因此即使基本备份是一堆不一致的文件，它也可以恢复数据库集群。这就是为什么我们可以使用常见的归档工具，而不需要文件系统快照功能或特殊工具。</p></blockquote><h3 id="10-3-时间线和时间线历史文件"><a href="#10-3-时间线和时间线历史文件" class="headerlink" title="10.3 时间线和时间线历史文件"></a>10.3 时间线和时间线历史文件</h3><p>PostgreSQL中的时间线用于区分原始数据库集群和恢复后的数据库集群，是PITR的核心概念。在本节中，将描述与时间线相关的两个内容：时间线和时间线历史文件。</p><h4 id="10-3-1-时间线"><a href="#10-3-1-时间线" class="headerlink" title="10.3.1 时间线"></a>10.3.1 时间线</h4><p>每个时间线都有一个对应的<strong>timelineId</strong>，这是一个从1开始的4字节无符号整数。</p><p>为每个数据库集群分配一个单独的timelineId。使用initdb工具创建的原始数据库集群的timelineId为1。每当数据库集群恢复时，timelineId将增加1。例如，在上一节的示例中，从原集群中恢复的集群的timelineId为2。</p><p>图10.3从timelineId的角度说明了PITR过程。首先，我们移除当前的数据库集群，恢复过去所做的基础备份，以便回到恢复的起点，这种情况如图中红色箭头曲线所示。接下来，我们启动PostgreSQL服务器，该服务器通过沿着初始时间线(timelineId 1)跟踪，从pg_backup_start创建的REDO点重放归档日志中的WAL数据，直到恢复目标，这种情况如图中蓝色箭头线所示。然后，一个新的timelineId 2被分配给恢复的数据库集群，PostgreSQL在新的时间线上运行。</p><p><img src="/medias/image/fig-10-03.png" alt="图10.3 原数据库集群与恢复后的数据库集群之间的timelineId关系"></p><p>如第9章所述，WAL段文件名的前8位数字等于创建该段的数据库集群的timelineId。当timelineId被改变时，WAL段文件名也会被修改。</p><p>以WAL段文件为例，重新描述恢复过程。假设我们使用<strong>000000010000000000000009</strong>和<strong>00000001000000000000000A</strong>两个归档日志恢复数据库集群。新恢复的数据库集群被分配为timelineId 2，PostgreSQL从<strong>00000002000000000000000A</strong>创建WAL段。图10.4显示了这种情况。</p><p><img src="/medias/image/fig-10-04.png" alt="图10.3 原数据库集群与恢复后的数据库集群之间的timelineId关系"></p><h4 id="10-3-2-时间轴历史文件"><a href="#10-3-2-时间轴历史文件" class="headerlink" title="10.3.2 时间轴历史文件"></a>10.3.2 时间轴历史文件</h4><p>当一个PITR进程完成时，一个名为<strong>00000002. history</strong>的时间线历史文件在归档目录和pg_xlog子目录（在版本10或更高版本中是pg_wal子目录）下被创建。这个文件记录它从哪个时间轴开始分支。</p><p>该文件的命名规则如下：</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token string">"8-digit new timelineId"</span>.history<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>时间轴历史文件至少包含一行，每行由以下三部分组成：</p><ul><li><p>timelineId——用于恢复的归档日志的timelineId。</p></li><li><p>LSN——发生WAL段切换的LSN位置。</p></li><li><p>reason——对时间线改变原因的通俗易懂的解释。</p></li></ul><p>具体例子如下：</p><pre class="line-numbers language-bash"><code class="language-bash">postgres<span class="token operator">></span> <span class="token function">cat</span> /home/postgres/archivelogs/00000002.history1  0/A000198before 2022-11-20 12:05:00.861324+00<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>含义如下：</p><blockquote><p>数据库集群（timelineId=2）基于timelineId为1的基本备份，通过重放归档日志在’2022-11-20 12:05:00.861324+00’之前的时间进行恢复，直到0/A000198。</p></blockquote><p>通过这种方式，每个时间线历史文件告诉我们单个恢复的数据库集群的完整历史。此外，它也用于PITR过程本身。细节将在下一节中解释。</p><p>时间线历史文件格式在版本9.3更改。版本9.3或更高版本和更早版本的格式如下所示，不详细说明。</p><p>9.3以后版本：</p><pre class="line-numbers language-bash"><code class="language-bash">timelineIdLSN<span class="token string">"reason"</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>9.2之前版本：</p><pre class="line-numbers language-bash"><code class="language-bash">timelineIdWAL_segment<span class="token string">"reason"</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="10-4-基于时间线历史文件的时间点恢复"><a href="#10-4-基于时间线历史文件的时间点恢复" class="headerlink" title="10.4 基于时间线历史文件的时间点恢复"></a>10.4 基于时间线历史文件的时间点恢复</h3><p>时间线历史文件在第二个和后续的PITR流程中起着重要作用。通过尝试第二次恢复，我们将探索如何使用它。</p><p>同样，假设您在timelineId为2的恢复数据库集群中在12:15:00发生了错误。在这种情况下，要恢复数据库集群，你应该创建一个新的recovery.conf，如下所示：</p><pre class="line-numbers language-bash"><code class="language-bash">restore_command <span class="token operator">=</span> <span class="token string">'cp /mnt/server/archivedir/%f %p'</span>recovery_target_time <span class="token operator">=</span> <span class="token string">"2022-11-20 12:15:00 GMT"</span>recovery_target_timeline <span class="token operator">=</span> 2<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>参数<code>recovery_target_time</code> 设置您犯新错误的时间，并将 <code>recovery_target_timeline</code> 设置为2，以便按照其时间轴进行恢复。</p><p>重新启动PostgreSQL服务器并进入PITR模式，在目标时间点沿timelineId 2恢复数据库，如图10.5。</p><p><img src="/medias/image/fig-10-05.png" alt="图10.5 按照时间线id 2在12:15:00恢复数据库"></p><p>（1）PostgreSQL从backup_label文件中读取<strong>CHECKPOINT LOCATION</strong>的值。</p><p>（2）部分参数值从recovery.conf文件中读取，本例中为restore_command、recovery_target_time和recovery_target_timeline。</p><p>（3）PostgreSQL读取时间线历史文件<strong>00000002.History</strong>，它对应于参数recovery_target_timeline的值。</p><p>（4）PostgreSQL通过以下步骤重放WAL数据：</p><ul><li>从REDO点到写入00000002.History文件的LSN ‘0/A000198’。PostgreSQL读取并回放相应timelineId为1的归档日志的WAL数据。</li><li>从LSN ‘0/A000198’之后到时间戳<strong>2022-11-20 12:15:00</strong>之前，PostgreSQL读取并回放timelineId为2的WAL数据（适当的归档日志）。</li></ul><p>（5）当恢复过程完成时，当前的时间轴id将前进到3，并在pg_xlog子目录（版本10或更高版本则是pg_wal子目录）和归档目录中创建一个名为<strong>00000003.History</strong>的新时间线历史文件。</p><pre class="line-numbers language-bash"><code class="language-bash">postgres<span class="token operator">></span> <span class="token function">cat</span> /home/postgres/archivelogs/00000003.history1         0/A000198     before 2022-11-20 12:05:00.861324+002         0/B000078     before 2022-11-20 12:15:00.927133+00<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>当您多次执行PITR时，您应该显式地设置一个timelineId，以便使用适当的时间线历史文件。</p><p>这样，时间线历史文件既是数据库集群的历史日志，又是PITR进程的恢复指令文档。</p>]]></content>
      
      
      <categories>
          
          <category> postgresql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> postgresql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>11 流复制</title>
      <link href="/2021/11-liu-fu-zhi/"/>
      <url>/2021/11-liu-fu-zhi/</url>
      
        <content type="html"><![CDATA[<p>同步流复制是在9.1版本中实现的。这是一个单主-多从类型的复制，通常主和从这两个术语分别在PostgreSQL中被称为主和备。</p><span id="more"></span><p>在流复制中，有三种类型的进程协同工作:</p><ul><li>主服务器上的walsender进程向备服务器发送WAL (Write-Ahead Log)数据。</li><li>备服务器上的walreceiver进程接收WAL数据。</li><li>备服务器上的startup进程重放WAL数据。</li></ul><p>walsender和walreceiver使用单个TCP连接进行通信。</p><p>[TOC]</p><h3 id="11-1-启动流复制"><a href="#11-1-启动流复制" class="headerlink" title="11.1 启动流复制"></a>11.1 启动流复制</h3><p>图11.1显示了流复制的启动顺序图：</p><p> <img src="/medias/image/fig-11-01.png" alt="图11.1 复制启动顺序"></p><p>(1) 启动主备服务器。</p><p>(2) 备服务器启动startup进程。</p><p>(3) 备服务器启动walreceiver进程。</p><p>(4) walreceiver向主服务器发送连接请求。如果主服务器没有运行，walreceiver会定期发送这些请求。</p><p>(5) 当主服务器收到连接请求时，启动walsender进程，walsender和walreceiver之间建立TCP连接。</p><p>(6) walreceiver发送备用数据库集群的最新LSN（日志序列号）。这在信息技术领域被称为握手。</p><p>(7) 如果备端最新的LSN小于主端最新的LSN， walsender将前一个LSN的WAL数据发送给后一个LSN。这样的WAL数据是由存储在主服务器的pg_xlog子目录（在版本10或更高版本中为pg_wal子目录）中的WAL段提供的。备服务器重新回放收到的WAL数据。在这个阶段中，备用服务器赶上了主服务器，因此称为追赶（catch-up）。</p><p>(8) 流复制开始工作。</p><p>每个walsender进程保持一个适合于连接的walreceiver或应用程序的工作阶段的状态。以下是walsender进程的可能状态:</p><ul><li><p>startup——从开始walsender到握手结束。见图11.1(5)-(6)。</p></li><li><p>catch-up——在追赶阶段。见图11.1(7)。</p></li><li><p>streaming——当流复制正在工作时。见图11.1(8)。</p></li><li><p>backup—为备份工具（如pg_basebackup实用程序）发送整个数据库集群的文件。</p></li></ul><p><code>pg_stat_replication</code> 视图显示所有正在运行的walsender的状态。一个例子如下:</p><pre class="line-numbers language-bash"><code class="language-bash">testdb<span class="token operator">=</span><span class="token comment" spellcheck="true"># SELECT application_name,state FROM pg_stat_replication;</span> application_name <span class="token operator">|</span>   state------------------+----------- standby1         <span class="token operator">|</span> streaming standby2         <span class="token operator">|</span> streaming pg_basebackup    <span class="token operator">|</span> backup<span class="token punctuation">(</span>3 rows<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如上所示，两个walsender正在运行，为连接的备服务器发送WAL数据，另一个walsender正在运行，为pg_basebackup实用程序发送数据库集群的所有文件。</p><blockquote><p><strong>如果备用服务器长时间处于停止状态后重新启动，会发生什么情况?</strong></p><p>在版本9.3或更早的版本中，如果备服务器所需的主服务器的WAL段已经被回收，备服务器就不能赶上主服务器。对于这个问题没有可靠的解决方案，只能为配置参数<code>wal_keep_segments</code>设置一个较大的值，以减少发生这种情况的可能性。这是一个权宜之计。</p><p>在9.4或更高版本中，可以通过使用复制槽来防止这个问题。复制槽是一个扩展了WAL数据发送灵活性的特性，主要用于逻辑复制，这也为这个问题提供了解决方案——通过暂停回收过程，可以将包含pg_xlog（或pg_wal，如果版本10或更高）下未发送数据的WAL段文件保留在复制槽中。详细信息请参考<a href="http://www.postgresql.org/docs/current/static/warm-standby.html#STREAMING-REPLICATION-SLOTS">官方文档</a>。</p></blockquote><h3 id="11-2-如何进行流复制"><a href="#11-2-如何进行流复制" class="headerlink" title="11.2 如何进行流复制"></a>11.2 如何进行流复制</h3><p>流复制有两个方面：日志传送和数据库同步。日志传送是其中主要的一个方面，因为主服务器在写入WAL (Write-Ahead Log)数据时会将其发送到连接的备服务器。同步复制需要数据库同步，其中主服务器与每个备用服务器通信以同步它们的数据库集群。</p><p>为了准确地理解流复制是如何工作的，我们应该了解一个主服务器如何管理多个备用服务器。在本节中，我们将从简单的一主一备系统开始，然后在下一节中讨论一主多备。</p><h4 id="11-2-1-主备间的通信"><a href="#11-2-1-主备间的通信" class="headerlink" title="11.2.1 主备间的通信"></a>11.2.1 主备间的通信</h4><p>假设备服务器处于同步复制模式，但 <code>hot_standby</code> 配置参数被禁用，<code>wal_level</code>为 replica。主服务器的主要参数如下所示:</p><pre class="line-numbers language-properties"><code class="language-properties"><span class="token attr-name">synchronous_standby_names</span> <span class="token punctuation">=</span> <span class="token attr-value">'standby1'</span><span class="token attr-name">hot_standby</span> <span class="token punctuation">=</span> <span class="token attr-value">off</span><span class="token attr-name">wal_level</span> <span class="token punctuation">=</span> <span class="token attr-value">reprica</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>此外，在第9.5节提到的三个写入WAL数据的触发器中，我们主要关注这里提交的事务。</p><p>假设主服务器上的一个后端进程以自动提交模式发出一条简单的INSERT语句。后端启动事务，发出INSERT语句，然后立即提交事务。让我们进一步探讨如何完成这个提交操作。如图11.2中顺序图所示：</p><p><img src="/medias/image/fig-11-02.png" alt="图11.2 流复制的通信顺序图"></p><p>(1) 后端进程通过执行 <em>XLogInsert()</em> 和 <em>XLogFlush()</em> 函数将WAL数据写入和刷新到WAL段文件中。</p><p>(2) walsender进程将写入WAL段的WAL数据发送给walreceiver进程。</p><p>(3) 后端进程发送WAL数据后，继续等待备服务器的ACK响应。更准确地说，后端进程通过执行内部函数 <em>SyncRepWaitForLSN()</em> 获得一个锁存器，并等待它被释放。</p><p>(4) 备服务器上的walreceiver通过系统调用 <em>write()</em>  将收到的WAL数据写入备服务器的WAL段，并返回一个ACK响应给walsender。</p><p>(5) walreceiver使用系统调用（如*fsync()*）将WAL数据刷新到WAL段，并向walsender返回另一个ACK响应，并通知启动进程WAL数据更新。</p><p>(6) startup进程回放已经写入WAL段的WAL数据。</p><p>(7) walsender在收到walreceiver的ACK响应后，释放后端进程的锁存器，然后，后端进程的提交或中止操作将完成。锁存器释放的时间取决于参数 <code>synchronous_commit</code>。默认是on，当接收到步骤(5)的ACK时，锁存器被释放，而当接收到步骤(4)的ACK时，锁存器是remote_write。</p><p>每个ACK响应将备服务器的内部信息通知给主服务器。它包括以下四个项目：</p><ul><li><p>最近一次写入WAL数据的LSN位置。</p></li><li><p>最近一次WAL数据刷写的LSN位置。</p></li><li><p>在strartup进程中重放最新WAL数据的LSN位置。</p></li><li><p>发送响应时的时间戳。</p></li></ul><p>Walreceiver不仅在写入和刷新WAL数据时返回ACK响应，而且还作为备服务器的心跳定期返回。因此，主服务器总是能够准确地了解所有连接的备服务器的状态。</p><p>执行如下所示的查询，可以显示连接的备服务器的LSN相关信息：</p><pre class="line-numbers language-bash"><code class="language-bash">testdb<span class="token operator">=</span><span class="token comment" spellcheck="true"># SELECT application_name AS host,</span>        write_location AS write_LSN, flush_location AS flush_LSN,         replay_location AS replay_LSN FROM pg_stat_replication<span class="token punctuation">;</span>   host   <span class="token operator">|</span> write_lsn <span class="token operator">|</span> flush_lsn <span class="token operator">|</span> replay_lsn ----------+-----------+-----------+------------ standby1 <span class="token operator">|</span> 0/5000280 <span class="token operator">|</span> 0/5000280 <span class="token operator">|</span> 0/5000280 standby2 <span class="token operator">|</span> 0/5000280 <span class="token operator">|</span> 0/5000280 <span class="token operator">|</span> 0/5000280<span class="token punctuation">(</span>2 rows<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>心跳间隔设置为 <code>wal_receiver_status_interval</code> 参数，默认为10秒。</p></blockquote><h4 id="11-2-2-发生故障时的行为"><a href="#11-2-2-发生故障时的行为" class="headerlink" title="11.2.2 发生故障时的行为"></a>11.2.2 发生故障时的行为</h4><p>在本小节中，描述了当同步备服务器发生故障时主服务器的行为，以及如何处理这种情况。</p><p>即使同步备服务器发生故障，不再能够返回ACK响应，主服务器也会一直等待响应。这意味着不能提交正在运行的事务，也不能启动后续的查询处理。换句话说，所有主服务器操作实际上都停止了（流复制不支持通过超时自动恢复到异步模式的功能）。</p><p>有两种方法可以避免这种情况。其中一种方法是使用多个备服务器来提高系统可用性，另一种是手动从同步模式切换到异步模式，步骤如下：</p><ol><li><p>将参数<code>synchronous_standby_names</code>设置为“空字符”。</p><pre class="line-numbers language-properties"><code class="language-properties"><span class="token attr-name">synchronous_standby_names</span> <span class="token punctuation">=</span> <span class="token attr-value">''</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>执行带reload选项的pg_ctl命令。</p><pre class="line-numbers language-bash"><code class="language-bash">postgres<span class="token operator">></span> pg_ctl -D <span class="token variable">$PGDATA</span> reload<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li></ol><p>上述过程不会影响已连接的客户端。主服务器将继续进行事务处理，同时保留客户端和各自后端进程之间的所有会话。</p><h3 id="11-3-管理多个备用服务器"><a href="#11-3-管理多个备用服务器" class="headerlink" title="11.3 管理多个备用服务器"></a>11.3 管理多个备用服务器</h3><p>在本节中，将描述流复制与多个备服务器的工作方式。</p><h4 id="11-3-1-sync-priority-和-sync-state"><a href="#11-3-1-sync-priority-和-sync-state" class="headerlink" title="11.3.1 sync_priority 和 sync_state"></a>11.3.1 <code>sync_priority</code> 和 <code>sync_state</code></h4><p>主服务器将sync_priority和sync_state属性分配给所有受管理的备服务器，并根据其各自的值处理每个备服务器（主服务器分配这些值，即使它只管理一个备服务器，这在前一节中没有提到）。</p><p><code>sync_priority</code> 表示同步模式下备服务器的优先级。该值越小，优先级越高。而特殊值0表示备服务器处于<strong>异步模式</strong>。备服务器的优先级按照主服务器的配置参数 <code>synchronous_standby_names</code> 中列出的顺序分配。例如，以下配置中，standby1和standby2的优先级分别为1和2。</p><pre class="line-numbers language-properties"><code class="language-properties"><span class="token attr-name">synchronous_standby_names</span> <span class="token punctuation">=</span> <span class="token attr-value">'standby1, standby2'</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>(未在此参数中列出的备用服务器为异步模式，优先级为0)</p><p><code>sync_state</code> 是备服务器的状态。以下是可能的状态:</p><ul><li><strong>sync</strong> 备服务器处于同步模式，是当前正在工作的最高优先级的备服务器。</li><li>**potential **备服务器处于同步模式，并且是当前正在工作的低优先级备服务器。如果当前同步备服务器出现故障，则将此备服务器提升为同步状态。</li><li>**async **备服务器为异步模式(它永远不会处于“sync”或“potential”模式)。</li></ul><p>备服务器的优先级和状态可以通过发出以下查询来显示：</p><pre class="line-numbers language-bash"><code class="language-bash">testdb<span class="token operator">=</span><span class="token comment" spellcheck="true"># SELECT application_name AS host, </span>         sync_priority, sync_state FROM pg_stat_replication<span class="token punctuation">;</span>   host   <span class="token operator">|</span> sync_priority <span class="token operator">|</span> sync_state----------+---------------+------------ standby1 <span class="token operator">|</span>             1 <span class="token operator">|</span> <span class="token function">sync</span> standby2 <span class="token operator">|</span>             2 <span class="token operator">|</span> potential<span class="token punctuation">(</span>2 rows<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="11-3-2-主服务器如何管理多个备服务器"><a href="#11-3-2-主服务器如何管理多个备服务器" class="headerlink" title="11.3.2 主服务器如何管理多个备服务器"></a>11.3.2 主服务器如何管理多个备服务器</h4><p>主服务器只等待来自同步备服务器的ACK响应。换句话说，主服务器只确认同步备服务器对WAL数据的写入和刷新。因此，流复制确保只有同步备服务器与主服务器处于一致和同步的状态。</p><p>图11.3显示了潜在备服务器的ACK响应早于主备服务器的ACK响应返回的情况。在这种情况下，主服务器没有完成当前事务的提交操作，而是继续等待备服务器的ACK响应。当主进程接收到响应时，后端进程释放锁存器并完成当前事务处理。</p><p> <img src="/medias/image/fig-11-03.png" alt="图11.3 管理多个备用服务器"></p><p>standby1和standby2的 <code>sync_state</code> 分别为’sync’和’potential’。</p><ol><li>尽管收到了潜在备服务器的ACK响应，主进程的后端进程仍然继续等待同步备服务器的ACK响应。</li><li>主后端进程收到同步备服务器的ACK响应后，释放锁存器，完成当前事务处理。</li></ol><p>相反，同步备服务器的ACK响应比潜在服务器的更早返回，主服务器立即完成当前事务的提交操作，而不用确保潜在的备服务器是否写入和刷新WAL数据。</p><h4 id="11-3-3-发生故障时的行为"><a href="#11-3-3-发生故障时的行为" class="headerlink" title="11.3.3 发生故障时的行为"></a>11.3.3 发生故障时的行为</h4><p>再次看看当备服务器发生故障时主服务器的行为。</p><p>当潜在或异步备服务器发生故障时，主服务器将终止连接到故障备用服务器的walsender进程，并继续所有处理。换句话说，主服务器的事务处理不会受到任何一种备服务器故障的影响。</p><p>当同步备服务器发生故障时，主服务器终止连接到故障备服务器的walsender进程，并用优先级最高的潜在备服务器替换同步备服务器，见图11.4。与上面描述的故障相反，主服务器上的查询处理将从故障点开始暂停，直到同步备服务器被替换。因此，备服务器的故障检测是提高复制系统可用性的一个非常重要的功能，故障检测将在下一节中描述。</p><p> <img src="/medias/image/fig-11-04.png" alt="图11.4 更换同步备用服务器"></p><p>在任何情况下，如果一个或多个备服务器以同步模式运行，则主服务器始终只保留一个同步备服务器，并且该同步备服务器始终与主服务器保持一致和同步状态。</p><h3 id="11-4-检测备服务器故障"><a href="#11-4-检测备服务器故障" class="headerlink" title="11.4 检测备服务器故障"></a>11.4 检测备服务器故障</h3><p>流复制使用两个常见的故障检测过程，完全不需要任何特殊的硬件。</p><p><strong>1 备服务器进程失败检测</strong></p><p>当检测到walsender和walreceiver之间的连接中断时，主服务器立即判断备服务器或walreceiver进程故障。当底层网络函数因写入或读取walreceiver的套接字接口失败而返回错误时，主服务器也立即确定其失败。</p><p><strong>2 硬件和网络故障检测</strong></p><p>如果walreceiver在 <code>wal_sender_timeout</code> 参数设置的时间内（默认为60秒）没有返回任何内容，则主服务器将确定备服务器故障。与上面描述的故障不同，即使备服务器由于某些故障（例如备服务器的硬件故障、网络故障等）不再能够发送任何响应，也需要一定的时间（最长为wal_sender_timeout秒）来确认主服务器上备服务器的死亡。</p><p>根据故障的类型，通常可以在故障发生后立即检测到，而有时在故障发生和检测到故障之间可能有一段时间延迟。特别是，如果在同步备服务器中发生后一种类型的故障，则主服务器上的所有事务处理都将停止，直到检测到备服务器的故障，即使多个潜在的备服务器可能一直在工作。</p><blockquote><p>在9.2或更早的版本中，参数 <code>wal_sender_timeout</code> 被称为 <code>replication_timeout</code>。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> postgresql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> postgresql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>5 并发控制</title>
      <link href="/2021/5.bing-fa-kong-zhi/"/>
      <url>/2021/5.bing-fa-kong-zhi/</url>
      
        <content type="html"><![CDATA[<p>并发控制是一种机制，当多个事务在数据库中并发运行时，它保持原子性和隔离性，这是ACID的两个属性。</p><span id="more"></span><p>[TOC]</p><blockquote><p>共有三种广泛的并发控制技术，即多版本并发控制(MVCC)、严格两阶段锁定(S2PL) 和乐观并发控制(OCC)，每种技术都有许多变体。在 MVCC 中，每个写操作都会创建一个新版本的数据项，同时保留旧版本。当一个事务读取一个数据项时，系统会选择其中一个版本来确保单个事务的隔离。MVCC的主要优点是 ‘<em>读不阻塞写，写不阻塞读</em>‘，相比之下，例如，基于S2PL的系统必须在写入器写入项目时阻止读取器，因为写入器获得了该项目的排它锁。PostgreSQL和一些RDBMS使用称为快照隔离(SI)的MVCC变体。</p><p>为了实现 SI，一些 RDBMS，例如 Oracle，使用回滚段。写入新数据项时，将旧版本项写入回滚段，随后将新项覆盖到数据区。PostgreSQL 使用一种更简单的方法。一个新的数据项被直接插入到相关的表格页面中，在读取项目时，PostgreSQL通过应用可见性检查规则来选择适当版本的项目以响应单个事务。</p><p>SI不允许ANSI SQL-92标准中定义的三种异常，即<em>脏读</em>、<em>不可重复读</em>和<em>幻读</em>。但是，SI 无法实现真正的可序列化，因为它允许序列化异常，例如<em>Write Skew</em>和<em>Read-only Transaction Skew</em>。请注意，基于经典可串行化定义的 ANSI SQL-92 标准并不等同于现代理论中的定义。为了解决这个问题，Serializable Snapshot Isolation(SSI)从9.1版开始添加。SSI可以检测序列化异常并解决此类异常引起的冲突。因此，PostgreSQL9.1及更高版本提供了真正的 SERIALIZABLE隔离级别。（另外，SQL Server也使用SSI，Oracle仍然只使用SI）</p></blockquote><p>本章包括以下四个部分：</p><p><strong>第 1 部分：</strong>第 5.1—5.3 本部分提供理解后续部分所需的基本信息。</p><p>第 5.1 节和第 5.2 节分别描述了事务ID和元组结构，5.3 节展示了如何插入、删除和更新元组。</p><p><strong>第 2 部分：</strong>第 5.4— 5.6 这部分说明了实现并发控制机制所需的关键特性。</p><p>5.4、5.5 和 5.6 节描述了提交日志（clog），它分别保存了所有事务状态、事务快照和可见性检查规则。</p><p><strong>第 3 部分：</strong>第 5.7—5.9 这部分通过具体的例子来描述PostgreSQL中的并发控制。</p><p>5.7 节描述了可见性检查，本节还展示了如何防止ANSI SQL标准中定义的三个异常，第 5.8 节描述了防止丢失更新，第 5.9 节简要描述了SSI。</p><p><strong>第 4 部分：</strong>第 5.10 节。这部分描述了永久运行并发控制机制所需的几个维护过程。维护过程是通过vacuum处理来执行的，这在<a href="http://www.interdb.jp/pg/pgsql06.html">第 6 章</a>中进行了描述。</p><p>本章重点介绍 PostgreSQL 独有的主题，尽管有许多与并发控制相关的主题。注意死锁预防和锁模式的描述被省略（更多信息请参考<a href="https://www.postgresql.org/docs/current/static/explicit-locking.html">官方文档</a>）。</p><p><strong>PostgreSQL 中的事务隔离级别</strong></p><p>PostgreSQL 实现的事务隔离级别如下表所述：</p><table><thead><tr><th align="left">隔离级别</th><th align="left">脏读</th><th align="left">不可重复读</th><th align="left">幻读</th><th align="left">序列化异常</th></tr></thead><tbody><tr><td align="left">读已提交</td><td align="left">不可能</td><td align="left">可能</td><td align="left">可能</td><td align="left">可能</td></tr><tr><td align="left">可重复读</td><td align="left">不可能</td><td align="left">不可能</td><td align="left">在 PG 中不可能(在ANSI SQL中可能)，见<a href="http://www.interdb.jp/pg/pgsql05.html#_5.7.2.">第 5.7.2 节</a></td><td align="left">可能</td></tr><tr><td align="left">可序列化</td><td align="left">不可能</td><td align="left">不可能</td><td align="left">不可能</td><td align="left">不可能</td></tr></tbody></table><blockquote><p>可重复读在9.0及更早版本中，此级别已用作“SERIALIZABLE”，因为它不允许ANSI SQL-92标准中定义的三个异常。但是，随着9.1版中SSI的实现，此级别已更改为“可重复读”并引入了真正的可序列化级别。</p></blockquote><p>PostgreSQL对DML（数据操作语言，例如 SELECT、UPDATE、INSERT、DELETE）使用SSI，对DDL（数据定义语言，例如 CREATE TABLE 等）使用2PL。</p><h2 id="5-1-事务ID"><a href="#5-1-事务ID" class="headerlink" title="5.1 事务ID"></a>5.1 事务ID</h2><p>每当事务开始时，事务管理器都会分配一个唯一标识符，称为事务ID(txid)。PostgreSQL的txid是一个 32位无符号整数，大约为42 亿。如果在事务开始后执行内置的txid_current()函数，该函数将返回当前的txid，如下所示。</p><pre class="line-numbers language-bash"><code class="language-bash">testdb<span class="token operator">=</span><span class="token comment" spellcheck="true"># BEGIN;</span>BEGINtestdb<span class="token operator">=</span><span class="token comment" spellcheck="true"># SELECT txid_current();</span> txid_current --------------          100<span class="token punctuation">(</span>1 row<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>PostgreSQL 保留了以下三个特殊的 txid：</p><ul><li><p><strong>0</strong>表示无效的txid。</p></li><li><p><strong>1</strong>表示Bootstrap txid，仅用于数据库集群的初始化。</p></li><li><p><strong>2</strong>表示Frozen txid，在<a href="http://www.interdb.jp/pg/pgsql05.html#_5.10.1">第 5.10.1 节</a>中描述。</p></li></ul><p>txid可以相互比较。例如，在txid 100的观察下，大于100的txids是’未来的’，在txid 100中是’不可见’的；小于100的txid 是’’过去的’，并且是’可见的’（图 5.1 a）。</p><p><img src="/medias/image/fig-5-01.png" alt="图 5.1 PostgreSQL中的事务ID"></p><p>由于实际系统中txid空间不足，PostgreSQL将txid空间视为一个圆圈。之前的21亿事务是’过去的’，接下来的21亿交易是’’未来的’（图 5.1 b）。在<a href="http://www.interdb.jp/pg/pgsql05.html#_5.10.1.">第 5.10.1 节</a>中描述了所谓的txid环绕问题。</p><p>注意，没有为BEGIN命令分配txid。在PostgreSQL中，当执行完BEGIN命令后执行第一个命令时，事务管理器会分配一个tixd，然后它的事务就开始了。</p><h2 id="5-2-元组结构"><a href="#5-2-元组结构" class="headerlink" title="5.2 元组结构"></a>5.2 元组结构</h2><p>表页中的堆元组分为普通数据元组和TOAST元组，本节仅描述普通的元组。</p><p>一个堆元组由三部分组成，即 HeapTupleHeaderData结构、NULL位图和用户数据（图 5.2）。</p><p><img src="/medias/image/fig-5-02.png" alt="图 5.2 元组结构"></p><p>HeapTupleHeaderData 结构在<a href="https://github.com/postgres/postgres/blob/ee943004466418595363d567f18c053bae407792/src/include/access/htup_details.h">src/include/access/htup_details.h</a>中定义。<a href="void(0)">HeapTupleHeaderData</a>结构包含七个字段，后续部分只说四个字段。</p><ul><li><p><strong>t_xmin</strong>保存插入此元组的事务的txid。</p></li><li><p><strong>t_xmax</strong>保存删除或更新此元组的事务的txid。如果此元组尚未删除或更新，则t_xmax设置为0，这意味着 INVALID。</p></li><li><p><strong>t_cid</strong>保存着command id（cid），意思是从0开始的当前事务内执行此命令之前执行了多少条SQL命令。例如，假设我们在单个事务中执行三个INSERT命令：’BEGIN;INSERT ;INSERT;INSERT;COMMIT;’。如果第一个命令插入这个元组，t_cid 设置为 0，如果第二个命令插入这个，t_cid设置为1，依此类推。</p></li><li><p><strong>t_ctid</strong>保存指向自身或新元组的元组标识符 (tid)。<a href="http://www.interdb.jp/pg/pgsql01.html#_1.3.">第 1.3 节</a>中描述的tid用于标识表中的元组，当这个元组更新时，这个元组的t_ctid指向新的元组，否则t_ctid 指向自身。</p></li></ul><h2 id="5-3-插入、删除和更新元组"><a href="#5-3-插入、删除和更新元组" class="headerlink" title="5.3 插入、删除和更新元组"></a>5.3 插入、删除和更新元组</h2><p>本节介绍如何插入、删除和更新元组。然后简要的描述了用于插入和更新元组的<em>自由空间映射（FSM）</em>。</p><p>为了关注元组，下面没有表示页眉和行指针。图 5.3 显示了如何表示元组的示例。</p><p><img src="/medias/image/fig-5-03.png" alt="图 5.3 元组的表示"></p><h3 id="5-3-1-插入"><a href="#5-3-1-插入" class="headerlink" title="5.3.1 插入"></a>5.3.1 插入</h3><p>通过插入操作，一个新的元组被直接插入到目标表的一页中（图 5.4）。</p><p><img src="/medias/image/fig-5-04.png" alt="图 5.4 插入元组"></p><p>假设一个tuple被一个 txid 为 99 的事务插入到一个页面中。在这种情况下，插入的tuple的header字段设置如下。</p><p>Tuple_1：</p><ul><li><p><strong>t_xmin</strong>设置为 99，因为该元组由txid 99插入。</p></li><li><p><strong>t_xmax</strong>设置为 0，因为此元组尚未删除或更新。</p></li><li><p><strong>t_cid</strong>设置为 0，因为该元组是txid 99插入的第一个元组。</p></li><li><p><strong>t_ctid</strong>设置为 (0,1)，它指向自身，因为这是最新的元组。</p></li></ul><p><strong>页面检查</strong></p><p>PostgreSQL 提供了一个扩展 <em>pageinspect</em>，它是一个贡献模块，用于显示数据库页面的内容。</p><pre class="line-numbers language-bash"><code class="language-bash">testdb<span class="token operator">=</span><span class="token comment" spellcheck="true"># CREATE EXTENSION pageinspect;</span>CREATE EXTENSIONtestdb<span class="token operator">=</span><span class="token comment" spellcheck="true"># CREATE TABLE tbl (data text);</span>CREATE TABLEtestdb<span class="token operator">=</span><span class="token comment" spellcheck="true"># INSERT INTO tbl VALUES('A');</span>INSERT 0 1testdb<span class="token operator">=</span><span class="token comment" spellcheck="true"># SELECT lp as tuple, t_xmin, t_xmax, t_field3 as t_cid, t_ctid </span>                FROM heap_page_items<span class="token punctuation">(</span>get_raw_page<span class="token punctuation">(</span><span class="token string">'tbl'</span>, 0<span class="token punctuation">))</span><span class="token punctuation">;</span> tuple <span class="token operator">|</span> t_xmin <span class="token operator">|</span> t_xmax <span class="token operator">|</span> t_cid <span class="token operator">|</span> t_ctid -------+--------+--------+-------+--------     1 <span class="token operator">|</span>     99 <span class="token operator">|</span>      0 <span class="token operator">|</span>     0 <span class="token operator">|</span> <span class="token punctuation">(</span>0,1<span class="token punctuation">)</span><span class="token punctuation">(</span>1 row<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="5-3-2-删除"><a href="#5-3-2-删除" class="headerlink" title="5.3.2 删除"></a>5.3.2 删除</h3><p>在删除操作中，目标元组被逻辑删除。执行DELETE命令的txid的值设置为元组的t_xmax（图 5.5）。</p><p><img src="/medias/image/fig-5-05.png" alt="图 5.5 元组删除"></p><p>假设Tuple_1被txid 111删除，此时Tuple_1的header字段设置如下。</p><p>Tuple_1：</p><ul><li><strong>t_xmax</strong>设置为 111。</li></ul><p>如果提交了 txid 111，则不再需要 Tuple_1。通常，不需要的元组在 PostgreSQL中被称为<strong>死亡元组</strong>，死亡元组最终应该从页面中删除。清理死元组称为<strong>VACUUM</strong>处理，在<a href="http://www.interdb.jp/pg/pgsql06.html">第 6 章</a>中介绍。</p><h3 id="5-3-3-更新"><a href="#5-3-3-更新" class="headerlink" title="5.3.3 更新"></a>5.3.3 更新</h3><p>在更新操作中，PostgreSQL在逻辑上删除最新的元组并插入一个新元组（图 5.6）。</p><p><img src="/medias/image/fig-5-06.png" alt="图 5.6 元组删除"></p><p>假设由 txid 99插入的行被 txid 100更新了两次。</p><p>当执行第一个UPDATE 命令时，通过将 txid 100 设置为 t_xmax 逻辑删除Tuple_1，然后插入Tuple_2。然后，将Tuple_1的 t_ctid 重写为指向 Tuple_2。Tuple_1 和 Tuple_2 的头域如下。</p><p>Tuple_1：</p><ul><li><strong>t_xmax</strong>设置为 100。</li><li><strong>t_ctid</strong>从 (0, 1) 改写为 (0, 2)。</li></ul><p>Tuple_2：</p><ul><li><strong>t_xmin</strong>设置为 100。</li><li><strong>t_xmax</strong>设置为 0。</li><li><strong>t_cid</strong>设置为 0。</li><li><strong>t_ctid</strong>设置为 (0,2)。</li></ul><p>当执行第二个UPDATE命令时，与第一个UPDATE命令一样，逻辑上删除Tuple_2 并插入Tuple_3。Tuple_2和Tuple_3 的头域如下。</p><p>Tuple_2：</p><ul><li><strong>t_xmax</strong>设置为 100。</li><li><strong>t_ctid</strong>从 (0, 2) 改写为 (0, 3)。</li></ul><p>Tuple_3：</p><ul><li><strong>t_xmin</strong>设置为 100。</li><li><strong>t_xmax</strong>设置为 0。</li><li><strong>t_cid</strong>设置为 1。</li><li><strong>t_ctid</strong>设置为 (0,3)。</li></ul><p>与删除操作一样，如果 txid 100被提交，Tuple_1和 Tuple_2将是死元组，如果 txid 100被中止，Tuple_2 和 Tuple_3 将是死元组。</p><h3 id="5-3-4-Free-Space-Map"><a href="#5-3-4-Free-Space-Map" class="headerlink" title="5.3.4 Free Space Map"></a>5.3.4 Free Space Map</h3><p>在插入堆表或索引元组时，PostgreSQL使用对应表或索引的 <strong>FSM</strong> 来选择可以插入它的页面。</p><p>如<a href="http://www.interdb.jp/pg/pgsql01.html#_1.2.3.">第 1.2.3 节</a>所述，所有表和索引都有各自的FSM，每个FSM将有关每个页面的<strong>可用空间容量的信息</strong>存储在相应的表或索引文件中。所有FSM都以后缀’fsm’存储，如有必要，它们会加载到共享内存中。</p><p><a href="https://www.postgresql.org/docs/current/static/pgfreespacemap.html">pg_freespacemap</a> 扩展提供指定表或者索引的空闲空间。以下查询显示指定表中每个页面的可用空间比例。</p><pre class="line-numbers language-bash"><code class="language-bash">testdb<span class="token operator">=</span><span class="token comment" spellcheck="true"># CREATE EXTENSION pg_freespacemap;</span>CREATE EXTENSIONtestdb<span class="token operator">=</span><span class="token comment" spellcheck="true"># SELECT *, round(100 * avail/8192 ,2) as "freespace ratio"</span>                FROM pg_freespace<span class="token punctuation">(</span><span class="token string">'accounts'</span><span class="token punctuation">)</span><span class="token punctuation">;</span> blkno <span class="token operator">|</span> avail <span class="token operator">|</span> freespace ratio -------+-------+-----------------     0 <span class="token operator">|</span>  7904 <span class="token operator">|</span>           96.00     1 <span class="token operator">|</span>  7520 <span class="token operator">|</span>           91.00     2 <span class="token operator">|</span>  7136 <span class="token operator">|</span>           87.00     3 <span class="token operator">|</span>  7136 <span class="token operator">|</span>           87.00     4 <span class="token operator">|</span>  7136 <span class="token operator">|</span>           87.00     5 <span class="token operator">|</span>  7136 <span class="token operator">|</span>           87.00<span class="token punctuation">..</span><span class="token punctuation">..</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="5-4-提交日志（clog）"><a href="#5-4-提交日志（clog）" class="headerlink" title="5.4. 提交日志（clog）"></a>5.4. 提交日志（clog）</h2><p>PostgreSQL在<strong>Commit Log <strong>（通常称为</strong>clog</strong>）中保存事务的状态，分配给共享内存，并在整个事务处理过程中使用。本节介绍PostgreSQL中事务的状态，clog如何运行，以及clog的维护。</p><h3 id="5-4-1-事务状态"><a href="#5-4-1-事务状态" class="headerlink" title="5.4.1 事务状态"></a>5.4.1 事务状态</h3><p>PostgreSQL定义了四种事务状态，即IN_PROGRESS、COMMITTED、ABORTED和SUB_COMMITTED。前三个状态是显而易见的。例如，当一个事务在进行中时，它的状态是 IN_PROGRES 等。SUB_COMMITTED 用于子事务，本文省略其说明。</p><h3 id="5-4-2-clog的运作"><a href="#5-4-2-clog的运作" class="headerlink" title="5.4.2 clog的运作"></a>5.4.2 clog的运作</h3><p>clog由共享内存中的一个或多个8KB页组成，clog在逻辑上形成一个阵列，数组的索引对应各自的事务id，数组中的每一项都保存着对应的事务id的状态。图 5.7 显示了clog及其运作方式。</p><p><img src="/medias/image/fig-5-07.png" alt="图 5.7 clog如何运作"></p><hr><ul><li><p><strong>T1：</strong> txid 200提交，txid 200的状态从IN_PROGRESS 更改为COMMITTED。</p></li><li><p><strong>T2：</strong> txid 201中止，txid 201的状态从IN_PROGRESS 更改为ABORTED。</p></li></ul><p>当前txid前进并且clog无法再存储它时，会附加一个新页面。</p><p>当需要事务的状态时，调用内部函数，这些函数读取CLOG并返回请求事务的状态。（也可以在<a href="http://www.interdb.jp/pg/pgsql05.html#_5.7.1">第 5.7.1 节</a>中看看 <em>Hint Bits</em>）</p><h3 id="5-4-3-clog的维护"><a href="#5-4-3-clog的维护" class="headerlink" title="5.4.3 clog的维护"></a>5.4.3 clog的维护</h3><p>当PostgreSQL关闭或checkpoint进程运行时，clog的数据被写入存储在<strong>pg_clog</strong>子目录下的文件中。</p><blockquote><p>pg_clog将在版本10中重命名为pg_xact</p></blockquote><p>这些文件被命名为<em>0000</em>、<em>0001</em>等。最大文件大小为 256 KB，当clog使用8页（第一页到第八页，总大小为64 KB）时，将其数据写入0000（64 KB），以37页（296 KB）写入数据分为 0000 和 0001，其大小分别为 256 KB 和 40 KB。</p><p>当PostgreSQL启动时，存储在pg_clog的文件中的数据被加载以初始化clog。clog的大小不断增加，因为每当CLOG被填满时都会附加一个新页面。但是，并非clog中的所有数据都是必需的。<a href="http://www.interdb.jp/pg/pgsql06.html">第 6 章</a>中描述的vacuum处理会定期删除此类旧数据（clog页面和文件），有关删除clog数据的详细信息在<a href="http://www.interdb.jp/pg/pgsql06.html#_6.4">第 6.4 节</a>中描述。</p><h2 id="5-5-事务快照"><a href="#5-5-事务快照" class="headerlink" title="5.5. 事务快照"></a>5.5. 事务快照</h2><p>事务快照是存储有关所有事务是否活跃的信息，在一定的时间点为单个事务的数据集。这里的活动事务意味着它正在进行中或尚未开始。</p><p>PostgreSQL内部将事务快照的文本表示格式定义为’<strong>100:100</strong>‘。例如，’<strong>100:100</strong>‘表示小于99的txid不活跃，等于或大于100的txid是活跃的。在下面的描述中，使用了这种方便的表示形式。如果您不熟悉它，请参阅以下。</p><blockquote><p> 内置函数 txid_current_snapshot 及其文本表示格式</p></blockquote><p>函数<a href="http://www.postgresql.org/docs/current/static/functions-info.html#FUNCTIONS-TXID-SNAPSHOT">txid_current_snapshot</a>显示当前事务的快照。</p><pre class="line-numbers language-bash"><code class="language-bash">testdb<span class="token operator">=</span><span class="token comment" spellcheck="true"># SELECT txid_current_snapshot();</span> txid_current_snapshot ----------------------- 100:104:100,102<span class="token punctuation">(</span>1 row<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>txid_current_snapshot的文本表示为’<strong>xmin:xmax:xip_list</strong>‘，组件描述如下。</p><p>xmin</p><ul><li>仍处于活动状态的最早txid。所有较早的事务要么被提交并可见，要么回滚并死亡。</li></ul><p>xmax</p><ul><li>第一个尚未分配的txid。截至快照时，所有大于或等于此值的 txid 尚未启动，因此不可见。</li></ul><p>xip_list</p><ul><li>快照时的活动txid。该列表仅包括xmin和xmax之间的活动txid。</li></ul><p>例如，在快照’<strong>100:104:100,102</strong>‘中，xmin 为“100”，xmax 为“104”，而 xip_list 为“100:102:”。</p><p>下面给出两个具体的例子：</p><p><img src="/medias/image/fig-5-08.png" alt="图 5.8 事务快照表示的示例"></p><p>第一个例子是’<strong>100:100</strong>‘。该快照的含义如下（图 5.8(a)）：</p><ul><li><p>等于或小于 99 的 txid不活跃，因为 xmin 是 100。</p></li><li><p>等于或大于 100 的 txid是活跃的，因为 xmax 是 100。</p></li></ul><p>第二个例子是’<strong>100:104:100,102</strong>‘。该快照的含义如下（图 5.8(b)）：</p><ul><li><p>等于或小于99的txid不活跃。</p></li><li><p>等于或大于104的txid是活跃的。</p></li><li><p>txid 100和102处于活跃状态，因为它们存在于xip列表中，而 txid 101和103未处于活跃状态。</p></li></ul><p>事务快照由事务管理器提供。在READ COMMITTED隔离级别中，每当执行 SQL 命令时，事务都会获取快照；否则（REPEATABLE READ 或 SERIALIZABLE），事务仅在执行第一个 SQL 命令时获取快照。获取的事务快照用于元组的可见性检查，这在<a href="http://www.interdb.jp/pg/pgsql05.html#_5.7">第 5.7 节</a>中描述。</p><p>当使用获取的快照进行可见性检查时，快照中的<em>活动</em>事务必须被视为<em>进行中，</em> 即使它们实际上已被提交或中止。此规则很重要，因为它会导致READ COMMITTED 和 REPEATABLE READ（或 SERIALIZABLE）之间的行为不同。我们将在以下各节中反复提及此规则。</p><p>在本节的其余部分，事务管理器和事务使用特定场景图 5.9 进行描述。</p><p><img src="/medias/image/fig-5-09.png" alt="图 5.9 事务管理器和事务"></p><p>事务管理器始终保存有关当前正在运行的事务的信息。假设三个事务依次启动，Transaction_A和Transaction_B的隔离级别为READ COMMITTED，Transaction_C的隔离级别为REPEATABLE READ。</p><p><strong>T1：</strong></p><ul><li>Transaction_A启动并执行第一个SELECT命令。在执行第一条命令时，Transaction_A请求了这一刻的txid和快照。在这种情况下，事务管理器分配txid 200，并返回事务快照“200:200:”。</li></ul><p><strong>T2：</strong></p><ul><li>Transaction_B 启动并执行第一个SELECT命令。事务管理器分配 txid 201，并返回事务快照“200:200:”，因为 Transaction_A (txid 200) 正在进行中。因此，从Transaction_B无法看到Transaction_A。</li></ul><p><strong>T3：</strong></p><ul><li>Transaction_C启动并执行第一个SELECT命令。事务管理器分配txid 202，返回事务快照’200:200:’，因此从Transaction_C看不到Transaction_A和Transaction_B。</li></ul><p><strong>T4：</strong></p><ul><li>Transaction_A已提交。事务管理器删除有关此事务的信息。</li></ul><p><strong>T5：</strong></p><ul><li>Transaction_B和Transaction_C执行各自的SELECT命令。</li><li>Transaction_B需要事务快照，因为它处于READ COMMITTED级别。在这种情况下，Transaction_B获得新快照“201:201:”，因为Transaction_A (txid 200) 已提交。因此，Transaction_A不再对Transaction_B不可见。</li><li>Transaction_C不需要事务快照，因为它处于REPEATABLE READ级别并使用获取的快照，即’200:200:’。因此，Transaction_A对Transaction_C仍然不可见。</li></ul><h2 id="5-6-可见性检查规则"><a href="#5-6-可见性检查规则" class="headerlink" title="5.6 可见性检查规则"></a>5.6 可见性检查规则</h2><p>可见性检查规则是一组规则，用于使用元组的t_xmin和t_xmax、clog和获取的事务快照来确定每个元组是可见还是不可见。这些规则太复杂，无法详细解释。因此，本文档显示了后续描述所需的最少规则。在下文中，我们省略了与子事务相关的规则并忽略了关于t_ctid的讨论，即我们不考虑在一个事务中更新超过两次的元组。</p><p>选择的规则数为十个，可以分为三种情况。</p><h3 id="5-6-1-t-xmin的状态为ABORTED"><a href="#5-6-1-t-xmin的状态为ABORTED" class="headerlink" title="5.6.1 t_xmin的状态为ABORTED"></a>5.6.1 t_xmin的状态为ABORTED</h3><p>t_xmin状态为ABORTED的元组始终<em>不可见</em>（规则 1），因为插入此元组的事务已中止。</p><pre class="line-numbers language-c"><code class="language-c"> <span class="token comment" spellcheck="true">/* t_xmin status == ABORTED */</span>Rule <span class="token number">1</span><span class="token punctuation">:</span> IF t_xmin status is <span class="token string">'ABORTED'</span> THEN            RETURN <span class="token string">'Invisible'</span>        END IF<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>该规则明确表示为以下数学表达式。</p><ul><li><strong>规则 1：</strong>如果 Status(t_xmin) = ABORTED ⇒ Invisible</li></ul><h3 id="5-6-2-t-xmin-的状态是IN-PROGRESS"><a href="#5-6-2-t-xmin-的状态是IN-PROGRESS" class="headerlink" title="5.6.2 t_xmin 的状态是IN_PROGRESS"></a>5.6.2 t_xmin 的状态是IN_PROGRESS</h3><p>t_xmin状态为IN_PROGRESS的元组基本上是<em>不可见的</em>（规则 3 和 4），除非在一种情况下。</p><pre class="line-numbers language-c"><code class="language-c"> <span class="token comment" spellcheck="true">/* t_xmin status == IN_PROGRESS */</span>              IF t_xmin status is <span class="token string">'IN_PROGRESS'</span> THEN                   IF t_xmin <span class="token operator">=</span> current_txid THENRule <span class="token number">2</span><span class="token punctuation">:</span>              IF t_xmax <span class="token operator">=</span> INVALID THEN                  RETURN <span class="token string">'Visible'</span>Rule <span class="token number">3</span><span class="token punctuation">:</span>              ELSE  <span class="token comment" spellcheck="true">/* this tuple has been deleted or updated by the current transaction itself. */</span>                  RETURN <span class="token string">'Invisible'</span>                         END IFRule <span class="token number">4</span><span class="token punctuation">:</span>        ELSE   <span class="token comment" spellcheck="true">/* t_xmin ≠ current_txid */</span>                  RETURN <span class="token string">'Invisible'</span>                   END IF             END IF<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如果这个元组被另一个事务插入并且t_xmin的状态是IN_PROGRESS，这个元组显然是<em>不可见的</em>（规则4）。</p><p>如果 t_xmin 等于当前的 txid（即这个元组是由当前事务插入的）并且 t_xmax不是INVALID，那么这个元组是<em>不可见的，</em> 因为它已经被当前事务更新或删除了（规则 3）。</p><p>异常条件是该元组由当前事务插入并且t_xmax 为INVALID 的情况。在这种情况下，这个元组必须从当前事务中<em>可见</em>（规则 2），因为这个元组是当前事务本身插入的元组。</p><ul><li><p><strong>规则 2：</strong>如果 Status(t_xmin) = IN_PROGRESS ∧ t_xmin = current_txid ∧ t_xmax = INVAILD ⇒ 可见</p></li><li><p><strong>规则 3：</strong>如果 Status(t_xmin) = IN_PROGRESS ∧ t_xmin = current_txid ∧ t_xmax ≠ INVAILD ⇒ 不可见</p></li><li><p><strong>规则 4：</strong>如果 Status(t_xmin) = IN_PROGRESS ∧ t_xmin ≠ current_txid ⇒ 不可见</p></li></ul><h3 id="5-6-3-t-xmin的状态是COMMITTED"><a href="#5-6-3-t-xmin的状态是COMMITTED" class="headerlink" title="5.6.3 t_xmin的状态是COMMITTED"></a>5.6.3 t_xmin的状态是COMMITTED</h3><p>t_xmin 状态为COMMITTED 的元组是 <em>可见的</em>（规则 6,8 和 9），但在三种情况下除外。</p><pre class="line-numbers language-c"><code class="language-c"> <span class="token comment" spellcheck="true">/* t_xmin status == COMMITTED */</span>            IF t_xmin status is <span class="token string">'COMMITTED'</span> THENRule <span class="token number">5</span><span class="token punctuation">:</span>      IF t_xmin is active in the obtained transaction snapshot THEN                      RETURN <span class="token string">'Invisible'</span>Rule <span class="token number">6</span><span class="token punctuation">:</span>      ELSE IF t_xmax <span class="token operator">=</span> INVALID OR status of t_xmax is <span class="token string">'ABORTED'</span> THEN                      RETURN <span class="token string">'Visible'</span>                 ELSE IF t_xmax status is <span class="token string">'IN_PROGRESS'</span> THENRule <span class="token number">7</span><span class="token punctuation">:</span>           IF t_xmax <span class="token operator">=</span>  current_txid THEN                            RETURN <span class="token string">'Invisible'</span>Rule <span class="token number">8</span><span class="token punctuation">:</span>           ELSE  <span class="token comment" spellcheck="true">/* t_xmax ≠ current_txid */</span>                            RETURN <span class="token string">'Visible'</span>                      END IF                 ELSE IF t_xmax status is <span class="token string">'COMMITTED'</span> THENRule <span class="token number">9</span><span class="token punctuation">:</span>           IF t_xmax is active in the obtained transaction snapshot THEN                            RETURN <span class="token string">'Visible'</span>Rule <span class="token number">10</span><span class="token punctuation">:</span>         ELSE                            RETURN <span class="token string">'Invisible'</span>                      END IF                 END IF            END IF<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>规则 6 很明显，因为t_xmax是INVALID 或 ABORTED。三个例外条件以及规则8和9描述如下。</p><p>第一个异常条件是t_xmin在获取的事务快照中<em>处于活动状态</em>（规则 5）。在这种情况下，这个元组是<em>不可见的，</em> 因为 t_xmin 应该被视为进行中。</p><p>第二个例外条件是t_xmax是当前的txid（规则 7）。在这种情况下，与规则3一样，此元组是<em>不可见的，</em> 因为它已被此事务本身更新或删除。</p><p>相反，如果t_xmax的状态是IN_PROGRESS并且t_xmax不是当前的txid（规则 8），则元组是<em>可见的，</em> 因为它没有被删除。</p><p>第三个异常条件是t_xmax的状态为COMMITTED且t_xmax在获取的交易快照中不活跃（规则10）。在这种情况下，这个元组是<em>不可见的，</em> 因为它已经被另一个事务更新或删除了。</p><p>相反，如果t_xmax的状态为COMMITTED但 t_xmax 在获得的事务快照中处于活动状态（规则 9），则元组是<em>可见的，</em>因为t_xmax应被视为进行中。</p><ul><li><p><strong>规则 5：</strong>如果 Status(t_xmin) = COMMITTED ∧ Snapshot(t_xmin) = active ⇒ Invisible</p></li><li><p><strong>规则 6：</strong>如果 Status(t_xmin) = COMMITTED ∧ (t_xmax = INVALID ∨ Status(t_xmax) = ABORTED) ⇒ 可见</p></li><li><p><strong>规则 7：</strong>如果 Status(t_xmin) = COMMITTED ∧ Status(t_xmax) = IN_PROGRESS ∧ t_xmax = current_txid ⇒ 不可见</p></li><li><p><strong>规则 8：</strong>如果 Status(t_xmin) = COMMITTED ∧ Status(t_xmax) = IN_PROGRESS ∧ t_xmax ≠ current_txid ⇒ 可见</p></li><li><p><strong>规则 9：</strong>如果 Status(t_xmin) = COMMITTED ∧ Status(t_xmax) = COMMITTED ∧ Snapshot(t_xmax) = active ⇒ Visible</p></li><li><p><strong>规则 10：</strong>如果 Status(t_xmin) = COMMITTED ∧ Status(t_xmax) = COMMITTED ∧ Snapshot(t_xmax) ≠ active ⇒ Invisible</p></li></ul><hr><h2 id="5-7-可见性检查"><a href="#5-7-可见性检查" class="headerlink" title="5.7 可见性检查"></a>5.7 可见性检查</h2><p>本节描述PostgreSQL如何执行可见性检查，即如何选择给定事务中适当版本的堆元组。本节还介绍了 PostgreSQL如何防止ANSI SQL-92 标准中定义的异常：脏读、可重复读和幻读。</p><h3 id="5-7-1-可见性检查"><a href="#5-7-1-可见性检查" class="headerlink" title="5.7.1 可见性检查"></a>5.7.1 可见性检查</h3><p><img src="/medias/image/fig-5-10.png" alt="图 5.10 描述可见性检查的场景"></p><p>在图 5.10 所示的场景中，SQL 命令按以下时间顺序执行。</p><ul><li><p><strong>T1：</strong>开始事务（txid 200）</p></li><li><p><strong>T2：</strong>开始事务（txid 201）</p></li><li><p><strong>T3：</strong>执行txid 200和201的SELECT命令</p></li><li><p><strong>T4：</strong>执行txid 200的UPDATE命令</p></li><li><p><strong>T5：</strong>执行txid 200和201的SELECT命令</p></li><li><p><strong>T6：</strong>提交txid 200</p></li><li><p><strong>T7：</strong>执行txid 201的SELECT命令</p></li></ul><p>为了简化描述，假设只有两个事务，即txid 200和201。txid 200的隔离级别为READ COMMITTED，txid 201的隔离级别为READ COMMITTED或REPEATABLE READ。</p><p>我们探索SELECT命令如何对每个元组执行可见性检查。</p><p><strong>T3的SELECT命令：</strong></p><p>在 T3 时，表<em>tbl中</em>只有一个Tuple_1并且它是由<strong>规则 6</strong><em>可见</em>的；因此，两个事务中的 SELECT 命令都返回“Jekyll”。</p><ul><li>Rule6(Tuple_1) ⇒ 状态(t_xmin:199) = COMMITTED ∧ t_xmax = INVALID ⇒ 可见</li></ul><pre class="line-numbers language-bash"><code class="language-bash">testdb<span class="token operator">=</span><span class="token comment" spellcheck="true"># -- txid 200</span>testdb<span class="token operator">=</span><span class="token comment" spellcheck="true"># SELECT * FROM tbl;</span>  name  -------- Jekyll<span class="token punctuation">(</span>1 row<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-bash"><code class="language-bash">testdb<span class="token operator">=</span><span class="token comment" spellcheck="true"># -- txid 201</span>testdb<span class="token operator">=</span><span class="token comment" spellcheck="true"># SELECT * FROM tbl;</span>  name  -------- Jekyll<span class="token punctuation">(</span>1 row<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>T5的SELECT命令：</strong></p><p>首先，我们探索txid 200执行的SELECT 命令。 Tuple_1 在<strong>规则 7 中</strong>不可见， Tuple_2 在<strong>规则 2 中</strong>可见；因此，这个 SELECT 命令返回 ‘Hyde’。</p><ul><li><p>Rule7(Tuple_1): Status(t_xmin:199) = COMMITTED ∧ Status(t_xmax:200) = IN_PROGRESS ∧ t_xmax:200 = current_txid:200 ⇒ 不可见</p></li><li><p>Rule2(Tuple_2): Status(t_xmin:200) = IN_PROGRESS ∧ t_xmin:200 = current_txid:200 ∧ t_xmax = INVAILD ⇒ 可见</p></li></ul><pre class="line-numbers language-bash"><code class="language-bash">testdb<span class="token operator">=</span><span class="token comment" spellcheck="true"># -- txid 200</span>testdb<span class="token operator">=</span><span class="token comment" spellcheck="true"># SELECT * FROM tbl;</span> name ------ Hyde<span class="token punctuation">(</span>1 row<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>另一方面，在txid 201执行的SELECT命令中，Tuple_1在<strong>Rule 8中</strong>可见，Tuple_2在<strong>Rule 4中</strong>不可见；因此，这个 SELECT命令返回 ‘Jekyll’。</p><ul><li><p>Rule8(Tuple_1): Status(t_xmin:199) = COMMITTED ∧ Status(t_xmax:200) = IN_PROGRESS ∧ t_xmax:200 ≠ current_txid:201 ⇒ 可见</p></li><li><p>Rule4(Tuple_2)：状态(t_xmin:200) = IN_PROGRESS ∧ t_xmin:200 ≠ current_txid:201 ⇒ 不可见</p></li></ul><pre class="line-numbers language-bash"><code class="language-bash">testdb<span class="token operator">=</span><span class="token comment" spellcheck="true"># -- txid 201</span>testdb<span class="token operator">=</span><span class="token comment" spellcheck="true"># SELECT * FROM tbl;</span>  name  -------- Jekyll<span class="token punctuation">(</span>1 row<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如果更新的元组在提交之前从其他事务中可见，则它们被称为<strong>脏读</strong>，也称为<strong>wr-conflicts</strong>。但是，如上所示，在 PostgreSQL 中的任何隔离级别都不会发生脏读。</p><p><strong>T7的SELECT命令：</strong></p><p>下面分别介绍T7的SELECT命令在两个隔离级别下的行为。</p><p>首先，我们探索 txid 201 何时处于 READ COMMITTED 级别。在这种情况下，txid 200 被视为已提交，因为事务快照是’201:201:’<em>。因此，Tuple_1是</em>看不见的由第10和Tuple_2是可见由第6，和SELECT命令返回“Hyde”。</p><ul><li><p>Rule10(Tuple_1): Status(t_xmin:199) = COMMITTED ∧ Status(t_xmax:200) = COMMITTED ∧ Snapshot(t_xmax:200) ≠ active ⇒ Invisible</p></li><li><p>Rule6(Tuple_2): Status(t_xmin:200) = COMMITTED ∧ t_xmax = INVALID ⇒ 可见</p></li></ul><pre class="line-numbers language-bash"><code class="language-bash">testdb<span class="token operator">=</span><span class="token comment" spellcheck="true"># -- txid 201 (READ COMMITTED)</span>testdb<span class="token operator">=</span><span class="token comment" spellcheck="true"># SELECT * FROM tbl;</span> name ------ Hyde<span class="token punctuation">(</span>1 row<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>请注意，在提交 txid 200 之前和之后执行的 SELECT 命令的结果是不同的。这通常称为<strong>不可重复读取</strong>。</p><p>相反，当 txid 201 处于 REPEATABLE READ 级别时，txid 200 必须被视为 IN_PROGRESS，因为事务快照是“200:200:”。因此，Tuple_1是<em>可见</em>由<strong>规则9</strong>和Tuple_2是<em>看不见的</em>由<strong>规则5</strong>，和SELECT命令返回“化身”。请注意，不可重复读取不会发生在可重复读取（和可序列化）级别。</p><ul><li><p>Rule9(Tuple_1): Status(t_xmin:199) = COMMITTED ∧ Status(t_xmax:200) = COMMITTED ∧ Snapshot(t_xmax:200) = active ⇒ Visible</p></li><li><p>Rule5(Tuple_2): Status(t_xmin:200) = COMMITTED ∧ Snapshot(t_xmin:200) = active ⇒ Invisible</p></li></ul><pre class="line-numbers language-bash"><code class="language-bash">testdb<span class="token operator">=</span><span class="token comment" spellcheck="true"># -- txid 201 (REPEATABLE READ)</span>testdb<span class="token operator">=</span><span class="token comment" spellcheck="true"># SELECT * FROM tbl;</span>  name  -------- Jekyll<span class="token punctuation">(</span>1 row<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><em>Hint Bits</em></p><p>为了获取事务的状态，PostgreSQL 内部提供了三个函数，即 TransactionIdIsInProgress、TransactionIdDidCommit 和 TransactionIdDidAbort。实现这些功能是为了减少对阻塞的频繁访问，例如缓存。但是，如果在检查每个元组时执行它们，就会出现瓶颈。</p><p>为了解决这个问题，PostgreSQL使用了<em>提示位</em>，如下所示。</p><pre class="line-numbers language-c"><code class="language-c"><span class="token macro property">#<span class="token directive keyword">define</span> HEAP_XMIN_COMMITTED       0x0100   </span><span class="token comment" spellcheck="true">/* t_xmin committed */</span><span class="token macro property">#<span class="token directive keyword">define</span> HEAP_XMIN_INVALID         0x0200   </span><span class="token comment" spellcheck="true">/* t_xmin invalid/aborted */</span><span class="token macro property">#<span class="token directive keyword">define</span> HEAP_XMAX_COMMITTED       0x0400   </span><span class="token comment" spellcheck="true">/* t_xmax committed */</span><span class="token macro property">#<span class="token directive keyword">define</span> HEAP_XMAX_INVALID         0x0800   </span><span class="token comment" spellcheck="true">/* t_xmax invalid/aborted */</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>在读取或写入元组时，如果可能，PostgreSQL会将提示位设置为元组的t_informask。例如，假设PostgreSQL检查元组的t_xmin状态并获得状态COMMITTED。在这种情况下，PostgreSQL为元组的t_infomask设置一个提示位 HEAP_XMIN_COMMITTED。如果提示位已设置，则不再需要 TransactionIdDidCommit 和 TransactionIdDidAbort。因此，PostgreSQL可以有效地检查每个元组的t_xmin和t_xmax的状态。</p><h3 id="5-7-2-PostgreSQL的REPEATABLE-READ级别中的幻读"><a href="#5-7-2-PostgreSQL的REPEATABLE-READ级别中的幻读" class="headerlink" title="5.7.2 PostgreSQL的REPEATABLE READ级别中的幻读"></a>5.7.2 PostgreSQL的REPEATABLE READ级别中的幻读</h3><p>ANSI SQL-92标准中定义的REPEATABLE READ允许<strong>Phantom Reads</strong>。但是，PostgreSQL的实现不允许它们。原则上，SI不允许幻读。</p><p>假设两个事务，即Tx_A 和Tx_B，正在并发运行。它们的隔离级别是READ COMMITTED和REPEATABLE READ，它们的txids分别是100和101。首先，Tx_A插入一个元组。然后，它被提交。插入元组的t_xmin为100。接下来，Tx_B执行SELECT命令；然而，Tx_A插入的元组在<strong>规则 5 中</strong>是<em>不可见</em>的。因此，不会发生幻读。</p><ul><li>Rule5(new tuple): Status(t_xmin:100) = COMMITTED ∧ Snapshot(t_xmin:100) = active ⇒ Invisible</li></ul><pre class="line-numbers language-bash"><code class="language-bash">testdb<span class="token operator">=</span><span class="token comment" spellcheck="true"># -- Tx_A: txid 100</span>testdb<span class="token operator">=</span><span class="token comment" spellcheck="true"># START TRANSACTION</span>testdb-<span class="token comment" spellcheck="true">#  ISOLATION LEVEL READ COMMITTED;</span>START TRANSACTIONtestdb<span class="token operator">=</span><span class="token comment" spellcheck="true"># INSERT tbl(id, data) </span>                VALUES <span class="token punctuation">(</span>1,<span class="token string">'phantom'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>INSERT 1 testdb<span class="token operator">=</span><span class="token comment" spellcheck="true"># COMMIT;</span>COMMIT<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-bash"><code class="language-bash">testdb<span class="token operator">=</span><span class="token comment" spellcheck="true"># -- Tx_B: txid 101</span>testdb<span class="token operator">=</span><span class="token comment" spellcheck="true"># START TRANSACTION</span>testdb-<span class="token comment" spellcheck="true">#  ISOLATION LEVEL REPEATABLE READ;</span>START TRANSACTIONtestdb<span class="token operator">=</span><span class="token comment" spellcheck="true"># SELECT txid_current();</span> txid_current--------------          101<span class="token punctuation">(</span>1 row<span class="token punctuation">)</span>testdb<span class="token operator">=</span><span class="token comment" spellcheck="true"># SELECT * FROM tbl WHERE id=1;</span> <span class="token function">id</span> <span class="token operator">|</span> data ----+------<span class="token punctuation">(</span>0 rows<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="5-8-防止丢失更新"><a href="#5-8-防止丢失更新" class="headerlink" title="5.8 防止丢失更新"></a>5.8 防止丢失更新</h2><p>一个丢失的更新，也被称为WW冲突，是发生在并发事务更新同一行的异常，它必须在可重复读和可系列化级别都被阻止（请注意，READ COMMITTED级别不需要防止丢失更新）。本节描述PostgreSQL如何防止丢失更新并显示示例。</p><h3 id="5-8-1-并发UPDATE命令的行为"><a href="#5-8-1-并发UPDATE命令的行为" class="headerlink" title="5.8.1 并发UPDATE命令的行为"></a>5.8.1 并发UPDATE命令的行为</h3><p>当执行UPDATE命令时，函数ExecUpdate被内部调用。ExecUpdate的伪代码如下所示：</p><p><em>伪代码：ExecUpdate</em></p><pre class="line-numbers language-c"><code class="language-c"><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>  FOR each row that will be updated by this UPDATE <span class="token function">command</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span>       WHILE true               <span class="token comment" spellcheck="true">/* The First Block */</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span>            IF the target row is being updated <span class="token function">THEN</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span>              WAIT <span class="token keyword">for</span> the termination of the transaction that updated the target <span class="token function">row</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span>              <span class="token function">IF</span> <span class="token punctuation">(</span>the status of the terminated transaction is COMMITTED<span class="token punctuation">)</span>                          <span class="token function">AND</span> <span class="token punctuation">(</span>the isolation level of this transaction is REPEATABLE READ or SERIALIZABLE<span class="token punctuation">)</span> <span class="token function">THEN</span><span class="token punctuation">(</span><span class="token number">6</span><span class="token punctuation">)</span>                       ABORT this transaction  <span class="token comment" spellcheck="true">/* First-Updater-Win */</span>                  <span class="token function">ELSE</span> <span class="token punctuation">(</span><span class="token number">7</span><span class="token punctuation">)</span>                           GOTO <span class="token function">step</span> <span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span>                  END IF               <span class="token comment" spellcheck="true">/* The Second Block */</span><span class="token punctuation">(</span><span class="token number">8</span><span class="token punctuation">)</span>            ELSE IF the target row has been updated by another concurrent transaction <span class="token function">THEN</span><span class="token punctuation">(</span><span class="token number">9</span><span class="token punctuation">)</span>              <span class="token function">IF</span> <span class="token punctuation">(</span>the isolation level of this transaction is READ COMMITTED <span class="token function">THEN</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span>                       UPDATE the target row                  <span class="token function">ELSE</span><span class="token punctuation">(</span><span class="token number">11</span><span class="token punctuation">)</span>                       ABORT this transaction  <span class="token comment" spellcheck="true">/* First-Updater-Win */</span>                  END IF               <span class="token comment" spellcheck="true">/* The Third Block */</span>                ELSE  <span class="token comment" spellcheck="true">/* The target row is not yet modified or has been updated by a terminated transaction. */</span><span class="token punctuation">(</span><span class="token number">12</span><span class="token punctuation">)</span>              UPDATE the target row                END IF           END WHILE       END FOR <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>(1) 获取将被此 UPDATE 命令更新的每一行。</p><p>(2) 重复下面的过程，直到目标行被更新（或者这个事务被中止）。</p><p>(3) 如果目标行<em>正在更新</em>，则进行步骤(3)；否则，继续执行步骤（8）。</p><p>(4) 等待更新目标行的事务终止，因为 PostgreSQL在 SI 中使用<em>first-updater-win</em>方案。</p><p>(5) 如果更新目标行的事务状态为COMMITTED，且该事务的隔离级别为REPEATABLE READ（或SERIALIZABLE），则进行步骤（6）；否则，继续执行步骤（7）。</p><p>(6) 中止此事务以防止丢失更新。</p><p>(7) 继续步骤(2)，尝试在下一轮更新目标行。</p><p>(8) 如果目标行已被另一个并发事务更新，则进行步骤(9)；否则，继续执行步骤（12）。</p><p>(9) 如果该事务的隔离级别为READ COMMITTED，则进行步骤(10)；否则，继续执行步骤（11）。</p><p>(10) UPDATE目标行，进入步骤(1)。</p><p>(11) 中止此事务以防止丢失更新。</p><p>(12) UPDATE目标行，因为目标行还没有被修改或者已经被终止的事务更新，即存在ww-conflict，所以继续步骤(1)。</p><p>此函数为每个目标行执行更新操作。它有一个while循环来更新每一行，while循环内部根据图5.11所示的条件分支为三个块。</p><p><img src="/medias/image/fig-5-11.png" alt="图 5.11 ExecUpdate 中的三个内部块"></p><p>[1]正在更新目标行</p><ul><li><p>“正在更新”意味着该行被另一个并发事务更新，并且其事务尚未终止。在这种情况下，当前事务必须等待更新目标行的事务终止，因为PostgreSQL的SI使用<strong>first-updater-win</strong>方案。例如，假设事务Tx_A和Tx_B同时运行，并且Tx_B尝试更新一行；然而，Tx_A已经更新它并且仍在进行中。在这种情况下，Tx_B等待Tx_A 的终止。</p></li><li><p>更新目标行的事务提交后，继续进行当前事务的更新操作。如果当前事务处于READ COMMITTED级别，则更新目标行；否则（REPEATABLE READ 或 SERIALIZABLE），当前事务将立即中止以防止丢失更新。</p></li></ul><p>[2]目标行已被并发事务更新（图5.11[2]）</p><ul><li>当前事务尝试更新目标元组；但是，另一个并发事务已更新目标行并已提交。在这种情况下，如果当前事务处于READ COMMITTED级别，则会更新目标行；否则，当前事务将立即中止以防止丢失更新。</li></ul><p>[3] 没有冲突（图5.11[3]）</p><ul><li>当没有冲突时，当前事务可以更新目标行。</li></ul><blockquote><p><em>第一个更新者获胜/第一个提交者获胜</em></p><p>PostgreSQL的基于SI的并发控制采用了<em>first-updater-win</em>方案。相比之下，如下一节所述，PostgreSQL的SSI使用第<em>一个提交者获胜的</em>方案。</p></blockquote><h3 id="5-8-2-例子"><a href="#5-8-2-例子" class="headerlink" title="5.8.2 例子"></a>5.8.2 例子</h3><p>下面显示了三个示例。第一和第二示例显示了目标行正在更新时的行为，第三示例显示了更新目标行时的行为。</p><p><strong>示例 1：</strong></p><p>事务Tx_A和Tx_B更新同一个表中的同一行，它们的隔离级别是READ COMMITTED。</p><pre class="line-numbers language-bash"><code class="language-bash">testdb<span class="token operator">=</span><span class="token comment" spellcheck="true"># -- Tx_A</span>testdb<span class="token operator">=</span><span class="token comment" spellcheck="true"># START TRANSACTION</span>testdb-<span class="token comment" spellcheck="true">#    ISOLATION LEVEL READ COMMITTED;</span>START TRANSACTIONtestdb<span class="token operator">=</span><span class="token comment" spellcheck="true"># UPDATE tbl SET name = 'Hyde';</span>UPDATE 1testdb<span class="token operator">=</span><span class="token comment" spellcheck="true"># COMMIT;</span>COMMIT<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-bash"><code class="language-bash">testdb<span class="token operator">=</span><span class="token comment" spellcheck="true"># -- Tx_B</span>testdb<span class="token operator">=</span><span class="token comment" spellcheck="true"># START TRANSACTION</span>testdb-<span class="token comment" spellcheck="true">#    ISOLATION LEVEL READ COMMITTED;</span>START TRANSACTIONtestdb<span class="token operator">=</span><span class="token comment" spellcheck="true"># UPDATE tbl SET name = 'Utterson';</span>    ↓     ↓ this transaction is being blocked    ↓ UPDATE 1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Tx_B 执行如下。</p><p>1）执行UPDATE命令后，Tx_B应该等待Tx_A的终止，因为目标元组正在被Tx_A更新（ExecUpdate中的步骤（4））。</p><p>2）提交Tx_A后，Tx_B尝试更新目标行（ExecUpdate 中的步骤（7））。</p><p>3）在第二轮ExecUpdate中，目标行被Tx_B再次更新（ExecUpdate中的步骤（2），（8），（9），（10））。</p><p><strong>示例 2：</strong></p><p>Tx_A 和 Tx_B 更新同一个表中的同一行，它们的隔离级别分别为 READ COMMITTED和REPEATABLE READ。</p><pre class="line-numbers language-bash"><code class="language-bash">testdb<span class="token operator">=</span><span class="token comment" spellcheck="true"># -- Tx_A</span>testdb<span class="token operator">=</span><span class="token comment" spellcheck="true"># START TRANSACTION</span>testdb-<span class="token comment" spellcheck="true">#    ISOLATION LEVEL READ COMMITTED;</span>START TRANSACTIONtestdb<span class="token operator">=</span><span class="token comment" spellcheck="true"># UPDATE tbl SET name = 'Hyde';</span>UPDATE 1testdb<span class="token operator">=</span><span class="token comment" spellcheck="true"># COMMIT;</span>COMMIT<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-bash"><code class="language-bash">testdb<span class="token operator">=</span><span class="token comment" spellcheck="true"># -- Tx_B</span>testdb<span class="token operator">=</span><span class="token comment" spellcheck="true"># START TRANSACTION</span>testdb-<span class="token comment" spellcheck="true">#    ISOLATION LEVEL REPEATABLE READ;</span>START TRANSACTIONtestdb<span class="token operator">=</span><span class="token comment" spellcheck="true"># UPDATE tbl SET name = 'Utterson';</span>    ↓     ↓ this transaction is being blocked    ↓ERROR:couldn't serialize access due to concurrent update<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Tx_B 的行为描述如下。</p><p>1）执行UPDATE命令后，Tx_B应该等待Tx_A的终止（ExecUpdate中的步骤（4））。</p><p>2）Tx_A提交后，Tx_B被中止解决冲突，因为目标行已经更新，并且这个事务的隔离级别是REPEATABLE READ（ExecUpdate中的步骤（5）和（6））。</p><p><strong>示例 3：</strong></p><p>Tx_B (REPEATABLE READ) 尝试更新已由提交的Tx_A更新的目标行。在这种情况下，Tx_B被中止（ExecUpdate 中的步骤 (2)、(8)、(9) 和 (11)）。</p><pre class="line-numbers language-bash"><code class="language-bash">testdb<span class="token operator">=</span><span class="token comment" spellcheck="true"># -- Tx_A</span>testdb<span class="token operator">=</span><span class="token comment" spellcheck="true"># START TRANSACTION</span>testdb-<span class="token comment" spellcheck="true">#    ISOLATION LEVEL READ COMMITTED;</span>START TRANSACTIONtestdb<span class="token operator">=</span><span class="token comment" spellcheck="true"># UPDATE tbl SET name = 'Hyde';</span>UPDATE 1testdb<span class="token operator">=</span><span class="token comment" spellcheck="true"># COMMIT;</span>COMMIT<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-bash"><code class="language-bash">testdb<span class="token operator">=</span><span class="token comment" spellcheck="true"># -- Tx_B</span>testdb<span class="token operator">=</span><span class="token comment" spellcheck="true"># START TRANSACTION</span>testdb-<span class="token comment" spellcheck="true">#    ISOLATION LEVEL REPEATABLE READ;</span>START TRANSACTIONtestdb<span class="token operator">=</span><span class="token comment" spellcheck="true"># SELECT * FROM tbl;</span>  name  -------- Jekyll<span class="token punctuation">(</span>1 row<span class="token punctuation">)</span>testdb<span class="token operator">=</span><span class="token comment" spellcheck="true"># UPDATE tbl SET name = 'Utterson';</span>ERROR:couldn't serialize access due to concurrent update<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="5-9-可序列化快照隔离"><a href="#5-9-可序列化快照隔离" class="headerlink" title="5.9 可序列化快照隔离"></a>5.9 可序列化快照隔离</h2><p>自 9.1 版以来，可序列化快照隔离 (SSI) 已嵌入到 SI 中，以实现真正的SERIALIZABLE隔离级别。由于SSI的解释并不简单，所以只解释了一个大纲。有关详细信息，请参阅[<a href="http://www.interdb.jp/pg/pgsql05.html#_5.ref.2">2]</a>。</p><p>在下文中，以下所示的技术术语不加定义地使用。如果您不熟悉这些术语，请参阅 [ <a href="http://www.interdb.jp/pg/pgsql05.html#_5.ref.1">1</a> , <a href="http://www.interdb.jp/pg/pgsql05.html#_5.ref.3">3</a> ]。</p><ul><li><p><em>优先级图</em>（也称为<em>依赖图</em>和<em>序列化图）</em></p></li><li><p><em>序列化异常</em>（例如<em>Write-Skew）</em></p></li></ul><h3 id="5-9-1-SSI-实施的基本策略"><a href="#5-9-1-SSI-实施的基本策略" class="headerlink" title="5.9.1 SSI 实施的基本策略"></a>5.9.1 SSI 实施的基本策略</h3><p>如果在优先级图中存在一些冲突产生的循环，就会出现序列化异常。这可以使用最简单的异常来解释，即Write-Skew。</p><p>图 5.12(1) 显示了一个时间表。这里，Transaction_A读取Tuple_B，Transaction_B读取Tuple_A。然后，Transaction_A 写入Tuple_A，Transaction_B写入Tuple_B。在这种情况下，有两个rw-conflicts，它们在这个调度的优先级图中形成一个循环，如图 5.12（2）所示。因此，这个调度有一个序列化异常，即Write-Skew。</p><p><img src="/medias/image/fig-5-12.png" alt="图 5.12 Write-Skew 调度及其优先级图"></p><p>从概念上讲，存在三种类型的冲突：wr-conflicts（脏读）、ww-conflicts（丢失更新）和 rw-conflicts。但是，不需要考虑wr-和ww-conflicts，因为如前几节所示，PostgreSQL可以防止此类冲突。因此，PostgreSQL中的 SSI 实现只需要考虑 rw-conflicts。</p><p>PostgreSQL对SSI的实现采取了以下策略：</p><ol><li><p>将事务访问的所有对象（元组、页面、关系）记录为 SIREAD 锁。</p></li><li><p>每当写入任何堆或索引元组时，使用SIREAD锁检测rw冲突。</p></li><li><p>如果通过检查检测到的rw-conflicts 检测到序列化异常，则中止事务。</p></li></ol><h3 id="5-9-2-在-PostgreSQL-中实现-SSI"><a href="#5-9-2-在-PostgreSQL-中实现-SSI" class="headerlink" title="5.9.2 在 PostgreSQL 中实现 SSI"></a>5.9.2 在 PostgreSQL 中实现 SSI</h3><p>为了实现上述策略，PostgreSQL 实现了很多功能和数据结构。但是，这里我们仅使用两种数据结构：<strong>SIREAD 锁</strong>和<strong>rw-conflicts</strong>来描述 SSI 机制。它们存储在共享内存中。</p><p>为简单起见，本文档中省略了一些重要的数据结构，例如 SERIALIZABLEXACT。因此，CheckTargetForConflictOut、CheckTargetForConflictIn和PreCommit_CheckForSerializationFailure等函数的解释也极其简化。例如，我们指出哪些函数检测冲突；但是，没有详细说明如何检测冲突。如果想了解详细内容，请参考源代码：predicate.c。</p><p><strong>SIREAD 锁：</strong></p><ul><li><p>SIREAD 锁，内部称为谓词锁，是一对对象和（虚拟）txid，用于存储有关谁访问了哪个对象的信息。请注意，省略了虚拟 txid 的描述。使用 txid 而不是虚拟 txid 来简化以下说明。</p></li><li><p>SIREAD 锁由 CheckTargetForConflictsOut 函数创建，每当在 SERIALIZABLE 模式下执行一个 DML 命令时。例如，如果 txid 100 读取给定表的 Tuple_1，则会创建一个 SIREAD 锁 {Tuple_1, {100}}。如果另一个事务，例如 txid 101，读取 Tuple_1，则 SIREAD 锁更新为 {Tuple_1, {100,101}}。请注意，在读取索引页时也会创建 SIREAD 锁，因为当应用<a href="http://www.interdb.jp/pg/pgsql07.html#_7.2.">第 7.2 节</a>中描述的<a href="https://www.postgresql.org/docs/current/static/indexes-index-only-scans.html">仅索引扫描</a>功能时，只读取索引页而不读取表页。</p></li><li><p>SIREAD 锁具有三个级别：元组、页面和关系。如果创建了单个页面内所有元组的 SIREAD 锁，它们将聚合到该页面的单个 SIREAD 锁中，并释放（移除）关联元组的所有 SIREAD 锁，以减少内存空间。对于所有读取的页面也是如此。</p></li><li><p>为索引创建 SIREAD 锁时，会从头创建页级 SIREAD 锁。使用顺序扫描时，无论是否存在索引和/或 WHERE 子句，都会从头创建关系级 SIREAD 锁。请注意，在某些情况下，此实现可能会导致序列化异常的误报检测。详细信息在第 5.9.4 节中描述。</p></li></ul><p><strong>rw-冲突：</strong></p><ul><li><p>rw-conflict 是一个 SIREAD 锁和两个读写 SIREAD 锁的 txid 的三元组。</p></li><li><p>每当在 SERIALIZABLE 模式下执行 INSERT、UPDATE 或 DELETE 命令时，都会调用 CheckTargetForConflictsIn 函数，并在通过检查 SIREAD 锁检测冲突时创建 rw-conflicts。</p></li><li><p>例如，假设 txid 100 读取 Tuple_1，然后 txid 101 更新 Tuple_1。在这种情况下，由 txid 101 中的 UPDATE 命令调用的 CheckTargetForConflictsIn 函数检测到 txid 100 和 101 之间与 Tuple_1 的 rw-冲突，然后创建一个 rw-conflict {r=100, w=101, {Tuple_1}}。</p></li></ul><p>CheckTargetForConflictOut 和 CheckTargetForConflictIn 函数，以及在 SERIALIZABLE 模式下执行 COMMIT 命令时调用的 PreCommit_CheckForSerializationFailure 函数，都使用创建的 rw-conflicts 检查序列化异常。如果他们检测到异常，则仅提交第一个提交的事务，其他事务将中止（通过<strong>先提交者获胜</strong>方案）。</p><h3 id="5-9-3-SSI的表现"><a href="#5-9-3-SSI的表现" class="headerlink" title="5.9.3 SSI的表现"></a>5.9.3 SSI的表现</h3><p>在这里，我们描述了SSI 如何解决 Write-Skew 异常。我们使用一个简单的表<em>tbl，</em>如下所示：</p><pre class="line-numbers language-bash"><code class="language-bash">testdb<span class="token operator">=</span><span class="token comment" spellcheck="true"># CREATE TABLE tbl (id INT primary key, flag bool DEFAULT false);</span>testdb<span class="token operator">=</span><span class="token comment" spellcheck="true"># INSERT INTO tbl (id) SELECT generate_series(1,2000);</span>testdb<span class="token operator">=</span><span class="token comment" spellcheck="true"># ANALYZE tbl;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>事务Tx_A和Tx_B执行以下命令（图 5.13）。</p><p><img src="/medias/image/fig-5-13.png" alt="图 5.13 写偏斜场景"></p><p>假设所有命令都使用索引扫描。因此，当这些命令被执行时，它们会读取堆元组和索引页，每一个都包含指向相应堆元组的索引元组。见图 5.14。</p><p><img src="/medias/image/fig-5-14.png" alt="图 5.14 图5.13所示场景中索引与表的关系"></p><ul><li><p><strong>T1：</strong> Tx_A 执行 SELECT 命令。该命令读取一个堆元组 (Tuple_2000) 和一页主键 (Pkey_2)。</p></li><li><p><strong>T2：</strong> Tx_B 执行 SELECT 命令。该命令读取一个堆元组 (Tuple_1) 和一页主键 (Pkey_1)。</p></li><li><p><strong>T3：</strong> Tx_A 执行 UPDATE 命令来更新 Tuple_1。</p></li><li><p><strong>T4：</strong> Tx_B 执行 UPDATE 命令来更新 Tuple_2000。</p></li><li><p><strong>T5：</strong> Tx_A 提交。</p></li><li><p><strong>T6：</strong> Tx_B 提交；但是，它由于写倾斜异常而中止。</p></li></ul><p>图 5.15 展示了 PostgreSQL 如何检测和解决上述场景中描述的 Write-Skew 异常。</p><p><img src="/medias/image/fig-5-15.png" alt="图 5.15 SIREAD 锁和 rw 冲突，以及图 5.13 所示场景的时间表"></p><p><strong>T1：</strong></p><ul><li><p>在执行 Tx_A 的 SELECT 命令时，CheckTargetForConflictsOut 创建 SIREAD 锁。在这种情况下，该函数创建两个 SIREAD 锁：L1 和 L2。</p></li><li><p>L1 和 L2 分别与 Pkey_2 和 Tuple_2000 相关联。</p></li></ul><p><strong>T2：</strong></p><ul><li><p>在执行 Tx_B 的 SELECT 命令时，CheckTargetForConflictsOut 创建两个 SIREAD 锁：L3 和 L4。</p></li><li><p>L3 和 L4 分别与 Pkey_1 和 Tuple_1 相关联。</p></li></ul><p><strong>T3：</strong></p><ul><li><p>执行Tx_A的UPDATE命令时，在ExecUpdate前后都会调用CheckTargetForConflictsOut和CheckTargetForConflictsIN。</p></li><li><p>在这种情况下，CheckTargetForConflictsOut 什么也不做。</p></li><li><p>CheckTargetForConflictsIn 创建 rw-conflict C1，也就是 Tx_B 和 Tx_A 之间 Pkey_1 和 Tuple_1 的冲突，因为 Pkey_1 和 Tuple_1 都被 Tx_B 读取，被 Tx_A 写入。</p></li></ul><p><strong>T4：</strong></p><ul><li><p>在执行Tx_B的UPDATE命令时，CheckTargetForConflictsIn创建了rw-conflict C2，即Tx_A和Tx_B之间Pkey_2和Tuple_2000的冲突。</p></li><li><p>在这个场景中，C1 和 C2 在优先级图中创建了一个循环；因此，Tx_A 和 Tx_B 处于不可串行化状态。但是，事务 Tx_A 和 Tx_B 尚未提交，因此 CheckTargetForConflictsIn 不会中止 Tx_B。请注意，发生这种情况是因为 PostgreSQL 的 SSI 实现基于<em>先提交者获胜</em>方案。</p></li></ul><p><strong>T5：</strong></p><ul><li>当 Tx_A 尝试提交时，会调用 PreCommit_CheckForSerializationFailure。此函数可以检测序列化异常，并在可能的情况下执行提交操作。在这种情况下，Tx_A 已提交，因为 Tx_B 仍在进行中。</li></ul><p><strong>T6：</strong></p><ul><li>当 Tx_B 尝试提交时，PreCommit_CheckForSerializationFailure 检测到序列化异常并且 Tx_A 已经提交；因此，Tx_B 被中止。</li></ul><p>此外，如果在 Tx_A 提交后（在<strong>T5 处</strong>）由 Tx_B 执行 UPDATE 命令，则 Tx_B 会立即中止，因为 Tx_B 的 UPDATE 命令调用的 CheckTargetForConflictsIn 检测到序列化异常（图 5.16（1））。</p><p>如果在<strong>T6</strong>执行 SELECT 命令而不是 COMMIT ，Tx_B 会立即中止，因为 Tx_B 的 SELECT 命令调用的 CheckTargetForConflictsOut 检测到序列化异常（图 5.16（2））。</p><p><img src="/medias/image/fig-5-16.png" alt="图 5.16 其他 Write-Skew 场景"></p><p>这个<a href="https://wiki.postgresql.org/wiki/SSI"> Wiki</a>解释了几个更复杂的异常。</p><h3 id="5-9-4-误报序列化异常"><a href="#5-9-4-误报序列化异常" class="headerlink" title="5.9.4 误报序列化异常"></a>5.9.4 误报序列化异常</h3><p>在SERIALIZABLE模式下，始终完全保证并发事务的可序列化性，因为永远不会检测到假阴性序列化异常。但是，在某些情况下，可以检测到假阳性异常；因此，用户在使用SERIALIZABLE模式时应牢记这一点。下面介绍PostgreSQL检测误报异常的情况。</p><p>图 5.17 显示了发生假阳性序列化异常的场景。</p><p><img src="/medias/image/fig-5-17.png" alt="图 5.16 其他 Write-Skew 场景"></p><p>使用顺序扫描时，如SIREAD锁的解释中所述，PostgreSQL创建了一个关系级别的SIREAD锁。图 5.18(1) 显示了 PostgreSQL 使用顺序扫描时的 SIREAD 锁和 rw-conflicts。在这种情况下，将创建与 tbl 的 SIREAD 锁相关联的 rw-conflicts C1 和 C2，并且它们在优先级图中创建一个循环。因此，检测到假阳性写入倾斜异常（即使没有冲突，Tx_A 或 Tx_B 也将中止）。</p><p><img src="/medias/image/fig-5-18.png" alt="图 5.18 假阳性异常 (1) – 使用顺序扫描"></p><p>即使在使用索引扫描时，如果事务 Tx_A 和 Tx_B 获得相同的索引 SIREAD 锁，PostgreSQL 也会检测到误报异常。图 5.19 显示了这种情况。假设索引页Pkey_1包含两个索引项，一个指向Tuple_1，另一个指向Tuple_2。当 Tx_A 和 Tx_B 分别执行 SELECT 和 UPDATE 命令时，Pkey_1 被 Tx_A 和 Tx_B 读写。在这种情况下，rw-conflicts C1 和 C2，两者都与 Pkey_1 相关联，在优先级图中创建一个循环；因此，检测到了假阳性 Write-Skew 异常。（如果 Tx_A 和 Tx_B 获得不同索引页的 SIREAD 锁，则不会检测到误报并且可以提交两个事务。）</p><p><img src="/medias/image/fig-5-19.png" alt="图 5.19 假阳性异常 (2) – 使用相同索引页的索引扫描"></p><hr><h2 id="5-10-所需的维护进程"><a href="#5-10-所需的维护进程" class="headerlink" title="5.10 所需的维护进程"></a>5.10 所需的维护进程</h2><p>PostgreSQL的并发控制机制需要以下维护流程：</p><ol><li><p>删除指向相应死元组的索引元组以及死元组</p></li><li><p>去除clog的不必要部分</p></li><li><p>冻结旧的txids</p></li><li><p>更新FSM、VM和统计信息</p></li></ol><p><a href="http://www.interdb.jp/pg/pgsql05.html#_5.3.2.">第5.3.2节</a>和<a href="http://www.interdb.jp/pg/pgsql05.html#_5.4.3.">第5.4.3节</a>分别解释了对第一个和第二个过程的需求。第三个过程与事务id回绕问题有关，在下面的小节中简要描述。</p><p>在PostgreSQL中，<strong>VACUUM</strong>处理负责这些进程。<a href="http://www.interdb.jp/pg/pgsql06.html">第 6 章</a>描述了vacuum进程。</p><h3 id="5-10-1-冻结处理"><a href="#5-10-1-冻结处理" class="headerlink" title="5.10.1 冻结处理"></a>5.10.1 冻结处理</h3><p>在这里，我们描述txid环绕问题。</p><p>假设插入tuple Tuple_1，txid为100，即Tuple_1的t_xmin为100，服务器已经运行了很长时间，Tuple_1没有被修改。当前的txid为21亿+100，并且执行了SELECT 命令。这时候Tuple_1是<em>可见的，</em>因为txid 100是<em>过去的</em>。然后，执行相同的 SELECT 命令；因此，当前的txid是21亿+101。但是，由于txid 100<em>在未来</em>（图 5.20），因此 Tuple_1<em>不再可见</em>。这就是PostgreSQL 中所谓的<em>事务环绕问题</em>。</p><p><img src="/medias/image/fig-5-20.png" alt="图 5.20 环绕问题"></p><p>为了解决这个问题，PostgreSQL引入了一个叫做 <em>freeze txid</em> 的概念，并实现了一个叫做<em>FREEZE</em>的过程。</p><p>在PostgreSQL中，一个冻结的txid，它是一个特殊的保留txid 2，被定义为总是比所有其他txid旧。换句话说，冻结的txid始终处于非活动状态且可见。</p><p>冻结过程由vacuum进程调用。如果t_xmin值早于当前txid减去 <a href="https://www.postgresql.org/docs/current/static/runtime-config-client.html#GUC-VACUUM-FREEZE-MIN-AGE">vacuum_freeze_min_age</a>（默认值为 5000 万），则冻结进程会扫描所有表文件并将元组的t_xmin重写为冻结的 txid 。这在<a href="http://www.interdb.jp/pg/pgsql06.html">第 6 章</a>有更详细的解释。</p><p>例如，如图5.21a)所示，当前txid为5000万，冻结过程由VACUUM命令调用。在这种情况下，Tuple_1和Tuple_2 的t_xmin都被重写为 2。</p><p>在版本9.4或更高版本中，将元组的t_infomask字段设置为XMIN_FROZEN，而不是将元组的t_xmin重写为冻结的 txid（图 5.21 b）。</p><p><img src="/medias/image/fig-5-21.png" alt="图 5.21 冻结过程"></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><p>[1] Abraham Silberschatz、Henry F. Korth 和 S. Sudarshan，“<a href="https://www.amazon.com//dp/0073523321">数据库系统概念</a>”，McGraw-Hill Education，ISBN-13：978-0073523323</p></li><li><p>[2] Dan RK Ports 和 Kevin Grittner ，“ <a href="https://drkp.net/papers/ssi-vldb12.pdf">PostgreSQL 中的可序列化快照隔离</a>”，VDBL 2012</p></li><li><p>[3] Thomas M. Connolly 和 Carolyn E. Begg，“<a href="https://www.amazon.com/dp/0321523067">数据库系统</a>”，Pearson，ISBN-13：978-0321523068</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> postgresql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> postgresql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>3 查询处理</title>
      <link href="/2021/3.cha-xun-chu-li/"/>
      <url>/2021/3.cha-xun-chu-li/</url>
      
        <content type="html"><![CDATA[<p>如官方文档所述，PostgreSQL支持2011年SQL标准所需的大量特性。查询处理是PostgreSQL中最复杂的子系统，它能高效地处理所支持的SQL语句。本章概述了这种查询处理，它特别关注查询优化。</p><span id="more"></span><p>本章由以下三部分组成:</p><ol><li>第3.1节<br>本节概述PostgreSQL中的查询处理。</li><li>第3.2 - 3.4节<br>这一部分解释了获得最优单表查询计划的步骤。在3.2节和3.3节中，我们将分别解释估算成本和创建规划树的过程，3.4节将简要描述执行器进程的操作。</li><li>第3.5 - 3.6节<br>这一部分说明了获取多表查询最优方案的过程。在3.5节中，我们会介绍三种关联方法:嵌套循环、合并和散列关联，3.6节将解释创建多表查询规划树的过程。</li></ol><p>PostgreSQL支持3个技术上有趣且实用的特性，即FDW (Foreign Data wrapper)、并行查询和JIT编译(从版本11开始支持)。前两个将在第4章中介绍。JIT编译超出了本文的范围;具体请参见官方文档。</p><p>[TOC]</p><h2 id="3-1-概述"><a href="#3-1-概述" class="headerlink" title="3.1 概述"></a>3.1 概述</h2><p>在PostgreSQL中，虽然在9.6版本中实现的并行查询使用了多个后台worker进程，但基本上是一个后端进程处理连接的客户端发出的所有查询。该后端由5个子系统组成，如下所示:</p><ol><li>解析器Parser<br>解析器从纯文本的SQL语句生成解析树。</li><li>分析器Analyser<br>分析器对解析树进行语义分析并生成查询树。</li><li>重写Rewriter<br>如果存在这样的规则，重写器将使用存储在规则系统中的规则转换查询树。</li><li>规划器Planner<br>规划器生成能够从查询树中最有效地执行的规划树。</li><li>执行器Executor<br>执行器按照计划树创建的顺序访问表和索引来执行查询。</li></ol><p><img src="/medias/image/fig-3-01.png" alt="图 3.1 查询处理"></p><p>本节将概述这些子系统。由于规划器和执行器非常复杂，下面将详细解释这些函数。</p><p>PostgreSQL的查询处理在官方文档中有详细描述。</p><h3 id="3-1-1-解析器"><a href="#3-1-1-解析器" class="headerlink" title="3.1.1 解析器"></a>3.1.1 解析器</h3><p>解析器生成一个解析树，后续子系统可以从纯文本的SQL语句中读取该解析树。下面给出了一个具体的例子，但没有详细描述。</p><p>让我们考虑下面的查询。</p><pre class="line-numbers language-bash"><code class="language-bash">testdb<span class="token operator">=</span><span class="token comment" spellcheck="true"># SELECT id, data FROM tbl_a WHERE id &lt; 300 ORDER BY data;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>解析树是一棵树，其根节点是在parsenodes.h中定义的SelectStmt结构，图3.2(b)说明了图3.2(a)所示查询的解析树。</p><p><img src="/medias/image/fig-3-02.png" alt="图 3.2 解析树的示例"></p><p>选择查询的元素和解析树的对应元素编号相同。例如，(1)是第一个目标列表中的一个元素，它是表的’id’列，(4)是WHERE子句，以此类推。</p><p>由于解析器在生成解析树时只检查输入的语法，所以它只在查询中有语法错误时返回错误。解析器不检查输入查询的语义。例如，即使查询包含一个不存在的表名，解析器也不会返回错误。语义检查由分析器完成。</p><h3 id="3-1-2-分析器"><a href="#3-1-2-分析器" class="headerlink" title="3.1.2 分析器"></a>3.1.2 分析器</h3><p>analyzer对解析器生成的解析树进行语义分析，并生成查询树。</p><p>查询树的根是定义在parsenodes.h中的查询结构。该结构包含相应查询的元数据，例如该命令的类型(SELECT、INSERT或其他)和几个叶子，每个叶结点构成一个链表或树，保存着各个子句的数据。</p><p>图3-3展示了前一小节中图3.2(a)所示查询的查询树。</p><p><img src="/medias/image/fig-3-03.png" alt="图 3.3 查询树的示例"></p><p>上面的查询树简要描述如下。</p><p>targetlist是此查询结果的列的列表。在这个例子中，这个列表由两列组成:<code>id</code>和<code>data</code>。如果输入的查询树使用<code>∗</code>(星号)，分析器将显式地将其替换为所有列。范围表是此查询中使用的关系列表。在这个例子中，这个表保存了表<code>tbl_a</code>的信息，例如这个表的oid和这个表的名称。join树存储FROM子句和WHERE子句。sort子句是SortGroupClause的一个列表。查询树的详细信息在官方文档中描述。</p><h3 id="3-1-3-重写器"><a href="#3-1-3-重写器" class="headerlink" title="3.1.3 重写器"></a>3.1.3 重写器</h3><p>重写器是实现规则系统的系统，必要时根据pg_rules系统目录中存储的规则对查询树进行转换。规则系统本身是一个有趣的系统，但为避免本章太长，这里省略了对规则系统和重写器的描述。</p><p><strong>视图</strong><br>PostgreSQL中的视图是使用规则系统实现的。当通过CREATE view命令定义视图时，相应的规则将自动生成并存储在目录中。</p><p>假定已经定义了以下视图，对应的规则存储在pg_rules系统目录中。</p><pre class="line-numbers language-bash"><code class="language-bash">sampledb<span class="token operator">=</span><span class="token comment" spellcheck="true"># CREATE VIEW employees_list </span>sampledb-<span class="token comment" spellcheck="true">#      AS SELECT e.id, e.name, d.name AS department </span>sampledb-<span class="token comment" spellcheck="true">#            FROM employees AS e, departments AS d WHERE e.department_id = d.id;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>当发出包含如下所示视图的查询时，解析器会创建如图3.4(a)所示的解析树。</p><pre class="line-numbers language-bash"><code class="language-bash">sampledb<span class="token operator">=</span><span class="token comment" spellcheck="true"># SELECT * FROM employees_list;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>在此阶段，重写器将范围表节点处理为子查询的解析树，这是存储在pg_rules中的相应视图。</p><p><img src="/medias/image/fig-3-04.png" alt="图 3.4重写阶段的一个例子"></p><blockquote><p>由于PostgreSQL使用这种机制实现视图，因此直到9.2版本也不能更新视图。从9.3版本支持更新，尽管如此，更新视图有许多限制。这些细节在官方文档中有描述。</p></blockquote><h3 id="3-1-4-计划器和执行器"><a href="#3-1-4-计划器和执行器" class="headerlink" title="3.1.4 计划器和执行器"></a>3.1.4 计划器和执行器</h3><p>规划器从重写器接收一个查询树，并生成一个执行器可以最有效地处理的(查询)规划树。</p><p>PostgreSQL中的规划器是基于纯代价优化的，它不支持基于规则的优化和提示。规划器是RDBMS中最复杂的子系统，因此本章后续章节将对规划器进行概述。</p><blockquote><p><strong>pg_hint_plan</strong><br>PostgreSQL不支持SQL中的规划器提示，而且永远也不会支持。如果您想在查询中使用提示，则值得考虑pg_hint_plan的扩展。详情请参阅官方网站。</p></blockquote><p>与其他RDBMS一样，PostgreSQL中的EXPLAIN命令显示规划树本身。一个具体的例子如下所示。</p><pre class="line-numbers language-bash"><code class="language-bash">testdb<span class="token operator">=</span><span class="token comment" spellcheck="true"># EXPLAIN SELECT * FROM tbl_a WHERE id &lt; 300 ORDER BY data;</span>                          QUERY PLAN                           --------------------------------------------------------------- Sort  <span class="token punctuation">(</span>cost<span class="token operator">=</span>182.34<span class="token punctuation">..</span>183.09 rows<span class="token operator">=</span>300 width<span class="token operator">=</span>8<span class="token punctuation">)</span>   Sort Key: data   -<span class="token operator">></span>  Seq Scan on tbl_a  <span class="token punctuation">(</span>cost<span class="token operator">=</span>0.00<span class="token punctuation">..</span>170.00 rows<span class="token operator">=</span>300 width<span class="token operator">=</span>8<span class="token punctuation">)</span>         Filter: <span class="token punctuation">(</span>id <span class="token operator">&lt;</span> 300<span class="token punctuation">)</span><span class="token punctuation">(</span>4 rows<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在图3.5所示的平面图树显示了这个结果。</p><p><img src="/medias/image/fig-3-05.png" alt="图 3.5 一个简单的规划树以及规划树和EXPLAIN命令结果之间的关系"></p><p>规划树由称为规划节点的元素组成，它连接到PlannedStmt结构的plantree链表。这些元素定义在plannodes.h中。详情将在3.3.3节(和3.5.4.2节)中解释。</p><p>每个计划节点都有执行器需要处理的信息，并且在单表查询的情况下，执行者从计划树的末尾一直处理到根。</p><p>例如，图3.5所示的规划树是一个排序节点和顺序扫描节点的列表，因此执行器会顺序扫描表 tbl_a，然后对得到的结果排序。</p><p>执行器通过<a href="https://www.interdb.jp/pg/pgsql08.html">第 8 章</a>描述的缓冲管理器来读写数据库集群中的表和索引。在处理查询时，执行器会使用一些预先分配的内存区，如temp_buffers和work_mem，并在必要时创建临时文件。</p><p>此外，在访问元组时，PostgreSQL使用并发控制机制来维护运行事务的一致性和隔离性。并发控制机制将在<a href="https://www.interdb.jp/pg/pgsql05.html">第 5 章</a>中描述。</p><p><img src="/medias/image/fig-3-06.png" alt="图 3.6执行器、缓冲区管理器和临时文件之间的关系"></p><h2 id="3-2-单表查询的代价估算"><a href="#3-2-单表查询的代价估算" class="headerlink" title="3.2 单表查询的代价估算"></a>3.2 单表查询的代价估算</h2><p>PostgreSQL的查询优化是基于成本的。成本是无量纲的值，这些不是绝对的性能指标，而是比较操作的相对性能的指标。成本由<a href="https://github.com/postgres/postgres/blob/master/src/backend/optimizer/path/costsize.c">costsize.c</a>中定义的函数估计。执行器执行的所有操作都有相应的代价函数。例如，顺序扫描和索引扫描的开销分别由cost_seqscan()和cost_index()估计。</p><p>在PostgreSQL中，有三种成本：启动成本、运行成本和总成本。总成本是启动和运行成本的总和。因此只有启动和运行成本是独立估计的。</p><ol><li>启动成本是在获取第一个元组之前花费的成本。例如，索引扫描节点的启动开销就是读取索引页以访问目标表中的第一个元组的开销。</li><li>运行开销是获取所有元组的开销。</li><li>总成本是启动成本和运行成本的总和。</li></ol><p>EXPLAIN命令显示每个操作的启动成本和总成本。最简单的例子如下所示:</p><pre class="line-numbers language-bash"><code class="language-bash">testdb<span class="token operator">=</span><span class="token comment" spellcheck="true"># EXPLAIN SELECT * FROM tbl;</span>                       QUERY PLAN                        --------------------------------------------------------- Seq Scan on tbl  <span class="token punctuation">(</span>cost<span class="token operator">=</span>0.00<span class="token punctuation">..</span>145.00 rows<span class="token operator">=</span>10000 width<span class="token operator">=</span>8<span class="token punctuation">)</span><span class="token punctuation">(</span>1 row<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在第4行，该命令显示顺序扫描的信息。在成本部分，有两个值，0.00和145.00。在本例中，启动和总成本分别为0.00和145.00。在本节中，我们将详细探讨如何估计顺序扫描、索引扫描和排序操作。</p><p>在下面的解释中，我们使用一个特定的表和一个索引，如下所示：</p><pre class="line-numbers language-bash"><code class="language-bash">testdb<span class="token operator">=</span><span class="token comment" spellcheck="true"># CREATE TABLE tbl (id int PRIMARY KEY, data int);</span>testdb<span class="token operator">=</span><span class="token comment" spellcheck="true"># CREATE INDEX tbl_data_idx ON tbl (data);</span>testdb<span class="token operator">=</span><span class="token comment" spellcheck="true"># INSERT INTO tbl SELECT generate_series(1,10000),generate_series(1,10000);</span>testdb<span class="token operator">=</span><span class="token comment" spellcheck="true"># ANALYZE;</span>testdb<span class="token operator">=</span><span class="token comment" spellcheck="true"># \d tbl</span>      Table <span class="token string">"public.tbl"</span> Column <span class="token operator">|</span>  Type   <span class="token operator">|</span> Modifiers --------+---------+----------- <span class="token function">id</span>     <span class="token operator">|</span> integer <span class="token operator">|</span> not null data   <span class="token operator">|</span> integer <span class="token operator">|</span> Indexes:    <span class="token string">"tbl_pkey"</span> PRIMARY KEY, btree <span class="token punctuation">(</span>id<span class="token punctuation">)</span>    <span class="token string">"tbl_data_idx"</span> btree <span class="token punctuation">(</span>data<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="3-2-1-顺序扫描"><a href="#3-2-1-顺序扫描" class="headerlink" title="3.2.1 顺序扫描"></a>3.2.1 顺序扫描</h3><p>顺序扫描的开销由cost_seqscan()函数估算。在本节中，我们将探讨如何估计以下查询的顺序扫描开销。</p><pre class="line-numbers language-bash"><code class="language-bash">testdb<span class="token operator">=</span><span class="token comment" spellcheck="true"># SELECT * FROM tbl WHERE id &lt; 8000;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>在顺序扫描中，启动成本等于0，运行成本由以下等式定义：</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token string">'run cost'</span><span class="token operator">=</span><span class="token string">'cpu run cost'</span>+<span class="token string">'disk run cost'</span>            <span class="token operator">=</span><span class="token punctuation">(</span>cpu_tuple_cost+cpu_operator_cost<span class="token punctuation">)</span>×Ntuple+seq_page_cost×Npage<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>其中seq_page_cost、cpu_tuple_cost和cpu_operator_cost在postgresql.conf文件中设置，默认值分别为1.0、0.01和0.0025，<br> Ntuple and Npage 分别是这个表中所有元组的数目和所有页的数目，可以使用以下查询来显示这些编号：</p><pre class="line-numbers language-bash"><code class="language-bash">testdb<span class="token operator">=</span><span class="token comment" spellcheck="true"># SELECT relpages, reltuples FROM pg_class WHERE relname = 'tbl';</span> relpages <span class="token operator">|</span> reltuples ----------+-----------       45 <span class="token operator">|</span>     10000<span class="token punctuation">(</span>1 row<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-bash"><code class="language-bash">Ntuple<span class="token operator">=</span>10000,Npage<span class="token operator">=</span>10000,<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>因此</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token string">'run cost'</span><span class="token operator">=</span><span class="token punctuation">(</span>0.01+0.0025<span class="token punctuation">)</span>×10000+1.0×45<span class="token operator">=</span>170.0<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>最终</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token string">'total cost'</span><span class="token operator">=</span>0.0+170.0<span class="token operator">=</span>170.0<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>为了确认，上面查询的EXPLAIN命令的结果如下所示：</p><pre class="line-numbers language-bash"><code class="language-bash">testdb<span class="token operator">=</span><span class="token comment" spellcheck="true"># EXPLAIN SELECT * FROM tbl WHERE id &lt; 8000;</span>                       QUERY PLAN                       -------------------------------------------------------- Seq Scan on tbl  <span class="token punctuation">(</span>cost<span class="token operator">=</span>0.00<span class="token punctuation">..</span>170.00 rows<span class="token operator">=</span>8000 width<span class="token operator">=</span>8<span class="token punctuation">)</span>   Filter: <span class="token punctuation">(</span>id <span class="token operator">&lt;</span> 8000<span class="token punctuation">)</span><span class="token punctuation">(</span>2 rows<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在第4行中，我们可以发现启动成本和总成本分别为0.00和170.00，估计通过扫描所有行将选择8000行(元组)。</p><p>在第5行中，显示了顺序扫描的过滤器<code>filter:(id &lt; 8000)</code>。更准确地说，它被称为表级过滤器谓词(table level filter predicate)。注意，这种类型的过滤器在读取表中的所有元组时使用，它不会缩小扫描表页的范围。</p><p>从运行成本估算中可以理解，PostgreSQL假设所有页面都将从存储中读取，也就是说，PostgreSQL不考虑扫描的页面是否在共享缓冲区中。</p><h2 id="3-3-创建单表查询的规划树"><a href="#3-3-创建单表查询的规划树" class="headerlink" title="3.3 创建单表查询的规划树"></a>3.3 创建单表查询的规划树</h2><p>由于规划器的处理非常复杂，本节将描述最简单的过程，即如何创建单表查询的规划树。3.6节将介绍更复杂的处理，即如何创建多表查询的规划树。</p><p>PostgreSQL中的规划器执行如下三个步骤：</p><ol><li><p>进行预处理。</p></li><li><p>通过估计所有可能的访问路径的开销来获得最廉价的访问路径。</p></li><li><p>从最廉价的路径创建规划树。</p></li></ol><p>访问路径是用于估算成本的处理单元，例如，顺序扫描、索引扫描、排序和各种连接操作都有对应的路径。访问路径仅在规划器中用于创建规划树。访问路径最基本的数据结构是在relationship.h中定义的路径结构，它对应于顺序扫描。所有其他访问路径都基于它。细节将在以下解释中描述。</p><p>为了处理上述步骤，规划器在内部创建一个PlannerInfo结构，并保存查询树、查询中包含的关系信息、访问路径等。在本节中，我们将通过具体的例子描述如何从查询树创建规划树。</p><h3 id="3-3-1-预处理"><a href="#3-3-1-预处理" class="headerlink" title="3.3.1 预处理"></a>3.3.1 预处理</h3><p>在创建规划树之前，规划器会对存储在PlannerInfo结构中的查询树进行一些预处理。</p><p>虽然预处理涉及很多步骤，但本节只讨论单表查询的主要预处理。其他预处理操作将在3.6节介绍。</p><ol><li><p>简化目标列表、限制子句等。<br>例如，子句c中定义的eval_const_expressions()函数将<code>2 + 2</code>重写为<code>4</code>。</p></li><li><p>布尔表达式。<br>例如，<code>NOT (NOT a)</code>被重写为<code>a</code>。</p></li><li><p>扁平化AND/OR表达。<br>AND和OR在SQL标准中是二元运算符，然而，在PostgreSQL内部，它们是n元运算符，规划器总是假设所有嵌套的AND和OR表达式都是扁平化的。给一个具体的例子，考虑一个布尔表达式<code>(id = 1) OR (id = 2) OR (id = 3)</code>。图3 - 9(a)展示了使用二元运算符时查询树的一部分。运算符使用三进制运算符将树扁平化。参见图3.9(b)。</p></li></ol><p><img src="/medias/image/fig-3-09.png" alt="图 3.9 一个扁平化和/或表达式的例子"></p><h3 id="3-3-2-获取最廉价的访问路径"><a href="#3-3-2-获取最廉价的访问路径" class="headerlink" title="3.3.2 获取最廉价的访问路径"></a>3.3.2 获取最廉价的访问路径</h3><p>为了得到最廉价的访问路径，规划器估计所有可能的访问路径的开销，并选择最廉价的路径。更具体地说，规划器执行以下操作:</p><ol><li><p>创建一个RelOptInfo结构来存储访问路径和相应的开销。<br>RelOptInfo结构由make_one_rel()函数创建，保存在PlannerInfo结构的simple_rel_array中。参见图3.10。在初始状态下，RelOptInfo保存了baserestrictinfo和indexlist(如果存在相关的索引);baserestrictinfo存储了查询的WHERE子句，indexlist存储了目标表的相关索引。</p></li><li><p>估计所有可能的访问路径的开销，并将访问路径添加到RelOptInfo结构中。处理的细节如下:</p><p>创建路径，估计顺序扫描的开销，并将估计的开销写入路径。然后，该路径被添加到RelOptInfo结构的路径列表中。</p><p>如果存在与目标表相关的索引，则创建索引访问路径，估计所有索引扫描成本，并将估计的成本写入路径。然后，将索引路径添加到路径列表中。</p><p>如果位图扫描可以完成，则创建位图扫描路径，估计所有位图扫描开销，并将估计的开销写入路径中。然后，位图扫描路径被添加到路径列表中。</p></li><li><p>获取RelOptInfo结构的路径列表中最便宜的访问路径。</p></li><li><p>如有必要，预估限制、订购和登记fdd成本。</p></li></ol><h4 id="3-3-2-1-示例1"><a href="#3-3-2-1-示例1" class="headerlink" title="3.3.2.1 示例1"></a>3.3.2.1 示例1</h4><p>首先，我们探索一个简单的无索引单表查询，这个查询包含WHERE和ORDER BY子句。</p><pre class="line-numbers language-bash"><code class="language-bash">testdb<span class="token operator">=</span><span class="token comment" spellcheck="true"># \d tbl_1</span>     Table <span class="token string">"public.tbl_1"</span> Column <span class="token operator">|</span>  Type   <span class="token operator">|</span> Modifiers --------+---------+----------- <span class="token function">id</span>     <span class="token operator">|</span> integer <span class="token operator">|</span>  data   <span class="token operator">|</span> integer <span class="token operator">|</span> testdb<span class="token operator">=</span><span class="token comment" spellcheck="true"># SELECT * FROM tbl_1 WHERE id &lt; 300 ORDER BY data;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>图 3-10和图 3-11描述了规划器在这个例子中的执行情况。</p><p><img src="/medias/image/fig-3-10.png" alt="图 3.10如何获取示例1中的最便宜路径"></p><p>(1) 创建一个RelOptInfo结构，并将其存储在PlannerInfo的simple_rel_array中。</p><p>(2) 在RelOptInfo的baserestrictinfo中添加WHERE子句。<br>在initsplan.c中定义的distribute_restrictinfo_to_rels()函数将WHERE子句’ id &lt; 300 ‘添加到baserestrictinfo。此外，RelOptInfo的indexlist是NULL，因为目标表没有相关的索引。</p><p>(3) 通过planner.c中定义的standard_qp_callback()函数，将用于排序的pathkey添加到PlannerInfo的sort_pathkeys中。<br>Pathkey是一个表示路径排序顺序的数据结构。在这个例子中，“data”列作为pathkey被添加到sort_pathkeys中，因为这个查询包含一个ORDER BY子句，它的列是’ data ‘。</p><p>(4) 创建一个路径结构，使用cost_seqscan函数估计顺序扫描的开销，并将估计的开销写入路径。然后，通过pathnode.c中定义的add_path()函数将路径添加到RelOptInfo中。如前所述，Path结构包含启动成本和总成本，由cost_seqscan函数估算，依此类推。</p><p>在这个例子中，规划器只估计顺序扫描的开销，因为目标表没有索引;因此，自动确定最便宜的访问路径。</p><p><img src="/medias/image/fig-3-11.png" alt="图 3.11如何得到示例1中的最便宜路径(从图3-10继续)"></p><p>(5) 创建一个新的RelOptInfo结构来按过程处理订单。注意，新的RelOptInfo没有baserestrictinfo，即WHERE子句的信息。</p><p>(6) 创建一个排序路径并将其添加到新的RelOptInfo，然后，将顺序扫描路径链接到排序路径的子路径。SortPath结构由两个路径结构组成:路径和子路径;路径存储了排序操作本身的信息，子路径存储了价格最低的路径。请注意，顺序扫描路径的<code>parent</code>项保存了到旧的RelOptInfo的链接，旧的RelOptInfo将WHERE子句存储在其baserestrictinfo中。因此，在下一阶段，即创建一个规划树，规划器可以创建一个包含WHERE子句的顺序扫描节点作为“过滤器”，即使新的RelOptInfo没有baserestrictinfo。</p><p>根据得到的最便宜访问路径，生成规划树。详情见3.3.3节。</p><h4 id="3-3-2-2-示例2"><a href="#3-3-2-2-示例2" class="headerlink" title="3.3.2.2 示例2"></a>3.3.2.2 示例2</h4><p>接下来，我们探索另一个具有两个索引的单表查询;这个查询包含一个WHERE子句。</p><pre class="line-numbers language-bash"><code class="language-bash">testdb<span class="token operator">=</span><span class="token comment" spellcheck="true"># \d tbl_2</span>     Table <span class="token string">"public.tbl_2"</span> Column <span class="token operator">|</span>  Type   <span class="token operator">|</span> Modifiers --------+---------+----------- <span class="token function">id</span>     <span class="token operator">|</span> integer <span class="token operator">|</span> not null data   <span class="token operator">|</span> integer <span class="token operator">|</span> Indexes:    <span class="token string">"tbl_2_pkey"</span> PRIMARY KEY, btree <span class="token punctuation">(</span>id<span class="token punctuation">)</span>    <span class="token string">"tbl_2_data_idx"</span> btree <span class="token punctuation">(</span>data<span class="token punctuation">)</span>testdb<span class="token operator">=</span><span class="token comment" spellcheck="true"># SELECT * FROM tbl_2 WHERE id &lt; 240;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>图3.12到图3.14描述了规划器在这个例子中的执行情况。</p><p>(1) 创建一个RelOptInfo结构。<br>(2) 在baserestrictinfo中添加WHERE子句，并将目标表的索引添加到indexlist中。<br>在这个例子中，在baserestrictinfo中添加了WHERE子句’ id &lt; 240 ‘，在RelOptInfo的索引列表中添加了两个索引tbl_2_pkey和tbl_2_data_idx。</p><p>(3) 创建一个路径，估计顺序扫描的开销，并将该路径添加到RelOptInfo的路径列表中。</p><p><img src="/medias/image/fig-3-12.png" alt="图 3.12 如何获取示例2中的最廉价的路径。"></p><p><img src="/medias/image/fig-3-13.png" alt="图 3.13如何得到示例2中的最便宜路径(从图3-12继续)。"></p><p>(4) 创建一个IndexPath，估计索引扫描的开销，并使用add_path()函数将IndexPath添加到RelOptInfo的路径列表中。在这个例子中，因为有两个索引，tbl_2_pkey和tbl_2_data_idx，所以这些索引是按顺序处理的。首先处理Tbl_2_pkey。为tbl_2_pkey创建一个IndexPath，并估计启动成本和总成本。在这个例子中，tbl_2_pkey是与列’ id ‘相关的索引，WHERE子句包含列’ id ‘;因此，WHERE子句存储在IndexPath的indexclause中。请注意，当添加访问路径到路径列表时，add_path()函数按总代价的排序顺序添加路径。在这个例子中，索引扫描的总开销小于顺序扫描的总开销;因此，该索引路径插入到顺序扫描路径之前。</p><p>(5) 创建另一个IndexPath，估计其他索引扫描的开销，并将索引路径添加到RelOptInfo的路径列表中。接下来，为tbl_2_data_idx创建一个IndexPath，估算成本并将其添加到路径列表中。在这个例子中，没有与tbl_2_data_idx索引相关的WHERE子句;因此，索引子句为NULL。</p><blockquote><p>注意，add_path()函数并不总是添加路径。由于该操作的复杂性，这里省略了细节。具体请参见add_path()函数的注释。</p></blockquote><p>(6) 创建一个新的RelOptInfo结构。<br>(7) 将最便宜的路径添加到新的RelOptInfo的路径列表中。<br>在这个例子中，最便宜的路径是使用索引tbl_2_pkey的索引路径;因此，它的路径被添加到新的RelOptInfo的路径列表中。</p><p><img src="/medias/image/fig-3-14.png" alt="图 3.14 如何得到示例2中的最便宜路径(从图3-13继续)。"></p>]]></content>
      
      
      <categories>
          
          <category> postgresql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> postgresql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>7 仅堆元组和仅索引扫描</title>
      <link href="/2021/7.jin-dui-yuan-zu-he-jin-suo-yin-sao-miao/"/>
      <url>/2021/7.jin-dui-yuan-zu-he-jin-suo-yin-sao-miao/</url>
      
        <content type="html"><![CDATA[<p>本章描述了与索引扫描相关的两个特性，它们是仅堆元组和仅索引扫描。</p><span id="more"></span><p>[TOC]</p><h2 id="7-1-仅堆元组（热）"><a href="#7-1-仅堆元组（热）" class="headerlink" title="7.1 仅堆元组（热）"></a>7.1 仅堆元组（热）</h2><p>HOT 在 8.3 版中实现，当更新的行存储在与存储旧行的同一表页中时，以有效地使用索引和表的页。HOT 还减少了 VACUUM 处理的必要性。</p><p>本章简单介绍HOT，HOT的细节在源代码目录下的<a href="https://github.com/postgres/postgres/blob/master/src/backend/access/heap/README.HOT">README.HOT</a>中有描述。首先，第 7.1.1 节描述了如何在没有 HOT 的情况下更新行，以阐明解决的问题。接下来，第 7.1.2 节描述了 HOT 的执行方式。</p><h3 id="7-1-1-更新没有-HOT-的行"><a href="#7-1-1-更新没有-HOT-的行" class="headerlink" title="7.1.1 更新没有 HOT 的行"></a>7.1.1 更新没有 HOT 的行</h3><p>假设表tbl有两列：id和data；id是tbl的主键。</p><pre class="line-numbers language-sql-monosp"><code class="language-sql-monosp">testdb=# \d tbl                Table "public.tbl" Column |  Type   | Collation | Nullable | Default --------+---------+-----------+----------+--------- id     | integer |           | not null |  data   | text    |           |          | Indexes:    "tbl_pkey" PRIMARY KEY, btree (id)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>表tbl有 1000 个元组；id 为1000的最后一个元组存储在表的第 5 页。索引元组指向对应的最后一个元组，其键是1000，tid是’(5,1)’。参见图 7.1(a)。</p><p><img src="/medias/image/fig-7-01.png" alt="图 7.1 更新没有 HOT 的行"></p><p>我们考虑如何在没有 HOT 的情况下更新最后一个元组。</p><pre class="line-numbers language-sql-monosp"><code class="language-sql-monosp">testdb=# UPDATE tbl SET data = 'B' WHERE id = 1000;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>在这种情况下，PostgreSQL 不仅会在索引页中插入新的表元组，还会插入新的索引元组。参见图 7.1(b)。</p><p>索引元组的插入会消耗索引页空间，索引元组的插入和清空成本都很高。HOT 减少了这些问题的影响。</p><h3 id="7-1-2-HOT-表现如何"><a href="#7-1-2-HOT-表现如何" class="headerlink" title="7.1.2 HOT 表现如何"></a>7.1.2 HOT 表现如何</h3><p>当一行被 HOT 更新时，如果更新后的行存储在与旧行的同一个表页中，PostgreSQL 不会插入相应的索引元组并将 HEAP_HOT_UPDATED 位和 HEAP_ONLY_TUPLE 位设置为旧的 t_informask2 字段元组和新元组，分别参见图7.2 和 7.3。</p><p><img src="/medias/image/fig-7-02.png" alt="图 7.2 用 HOT 更新一行"></p><p>例如，在这种情况下，“Tuple_1”和“Tuple_2”分别设置为 HEAP_HOT_UPDATED 位和 HEAP_ONLY_TUPLE 位。</p><p>此外，HEAP_HOT_UPDATED 和 HEAP_ONLY_TUPLE 位的使用与<em>修剪</em>和<em>碎片整理</em>过程无关，下文将介绍这些过程。</p><p><img src="/medias/image/fig-7-03.png" alt="图 7.3 HEAP_HOT_UPDATED 和 HEAP_ONLY_TUPLE 位"></p><p>下面介绍PostgreSQL在HOT更新元组后，如何使用索引扫描访问更新后的元组。参见图 7.4(a)。</p><p><img src="/medias/image/fig-7-04.png" alt="图 7.4 修剪线指针"></p><p>(1) 找到指向目标元组的索引元组。</p><p>(2) 访问从获取索引元组指向的行指针’[1]’。</p><p>(3) 读取“Tuple_1”。</p><p>(4) 通过’Tuple_1’的t_ctid读取’Tuple_2’。</p><p>在这种情况下，PostgreSQL 读取两个元组，’Tuple_1’ 和 ‘Tuple_2’，并使用<a href="http://www.interdb.jp/pg/pgsql05.html">第 5 章</a>中描述的并发控制机制决定哪个是可见的。</p><p>但是，如果删除表页中的死元组，则会出现问题。例如，在图 7.4(a) 中，如果 ‘Tuple_1’ 因为它是一个死元组而被删除，则无法从索引中访问 ‘Tuple_2’。</p><p>为了解决这个问题，PostgreSQL 在适当的时候将指向旧元组的行指针重定向到指向新元组的行指针。在 PostgreSQL 中，这种处理称为<strong>pruning</strong>。图 7.4(b) 描述了 PostgreSQL 如何在修剪后访问更新的元组。</p><p>(1) 找到索引元组。</p><p>(2) 访问从获取索引元组指向的行指针’[1]’。</p><p>(3) 通过重定向的行指针访问指向’Tuple_2’的行指针’[2]’。</p><p>(4) 读取从行指针’[2]’指向的’Tuple_2’。</p><p>如果可能，将在执行 SELECT、UPDATE、INSERT 和 DELETE 等 SQL 命令时执行修剪处理。具体的执行时序在本章中不做描述，因为它非常复杂。<a href="https://github.com/postgres/postgres/blob/master/src/backend/access/heap/README.HOT">README.HOT</a> 文件中描述了详细信息。</p><p>如果可能，PostgreSQL 会在适当的时间删除死元组，就像在修剪过程中一样。在 PostgreSQL 的文档中，这种处理称为<strong>碎片整理</strong>。图 7.5 描述了 HOT 的碎片整理。</p><p><img src="/medias/image/fig-7-05.png" alt="图 7.5 死元组的碎片整理"></p><p>请注意，碎片整理的成本低于正常 VACUUM 处理的成本，因为碎片整理不涉及删除索引元组。</p><p>因此，使用 HOT 减少了索引页和表的消耗；这也减少了 VACUUM 处理必须处理的元组数量。因此，HOT 对性能有很好的影响，因为它最终通过更新和 VACUUM 处理的必要性减少了索引元组的插入次数。</p><p><em>HOT 不可用的情况</em></p><p>为了清楚地了解 HOT 的性能，这里描述了 HOT 不可用的情况。</p><ol><li><p>当更新的元组存储在另一个页面中时，该页面没有存储旧的元组，指向该元组的索引元组也被插入到索引页面中。参见图 7.6(a)。</p></li><li><p>当索引元组的键值更新时，新的索引元组被插入到索引页中。参见图 7.6(b)。</p></li></ol><p><img src="/medias/image/fig-7-06.png" alt="图 7.6 HOT 不可用的情况"></p><p> <em>HOT相关统计</em></p><p><a href="https://www.postgresql.org/docs/current/static/monitoring-stats.html#PG-STAT-ALL-TABLES-VIEW">pg_stat_all_tables</a>所述视图提供为每个表的统计值。另请参阅此<a href="https://github.com/s-hironobu/pg_stats">扩展名</a>。</p><h2 id="7-2-仅索引扫描"><a href="#7-2-仅索引扫描" class="headerlink" title="7.2 仅索引扫描"></a>7.2 仅索引扫描</h2><p>为了降低 I/O（输入/输出）成本，当 SELECT 语句的所有目标条目都包含在索引键。几乎所有商业 RDBMS 都提供这种技术，例如 DB2 和 Oracle。PostgreSQL 从 9.2 版本开始引入了这个选项。</p><p>下面通过一个具体的例子，说明PostgreSQL中的 <code>index-only</code> 扫描是如何进行的。</p><p>该示例的假设解释如下：</p><ul><li>表定义</li></ul><p>我们有一个表tbl，其定义如下所示：</p><pre class="line-numbers language-sql-monosp"><code class="language-sql-monosp">testdb=# \d tbl      Table "public.tbl" Column |  Type   | Modifiers --------+---------+----------- id     | integer |  name   | text    |  data   | text    | Indexes:    "tbl_idx" btree (id, name)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>索引</li></ul><p>表 tbl 有一个索引 tbl_idx，它由两列组成：id 和 name。</p><ul><li>元组</li></ul><p>tbl 已经插入了元组。</p><p>Tuple_18，其id为18，名称为Queen，存储在第0页。</p><p>Tuple_19，其id为19，名称为BOSTON，存储在第1页。</p><ul><li>可见性</li></ul><p>第 0 页中的所有元组始终可见；第1页中的元组并不总是可见的。注意，每个页面的可见性存储在对应的可见性图中，可见性图在<a href="http://www.interdb.jp/pg/pgsql06.html#_6.2.">第6.2 节</a>中描述。</p><p>让我们探讨一下 PostgreSQL 在执行以下 SELECT 命令时如何读取元组。</p><pre class="line-numbers language-sql-monosp"><code class="language-sql-monosp">testdb=# SELECT id, name FROM tbl WHERE id BETWEEN 18 and 19; id |  name   ----+-------- 18 | Queen 19 | Boston(2 rows)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>此查询从表的两列获取数据：id 和name，索引tbl_idx 由这些列组成。因此，当使用索引扫描时，乍一看似乎不需要访问表页，因为索引元组包含必要的数据。实际上，PostgreSQL 原则上必须检查元组的可见性，索引元组没有任何有关事务的信息，例如堆元组的 <code>t_xmin</code> 和 <code>t_xmax</code>，这在<a href="http://www.interdb.jp/pg/pgsql05.html#_5.2.">第5.2节 </a>中进行描述了。因此，PostgreSQL 必须访问表数据来检查索引元组中数据的可见性，这有点本末倒置。</p><p>为了避免这种困境，PostgreSQL 使用了目标表的可见性映射。如果存储在一个页面中的所有元组都可见，则PostgreSQL使用索引元组的键，不访问索引元组指向的表页来检查其可见性；否则，PostgreSQL 从索引元组中读取指向的表元组，并检查元组的可见性，这是普通的过程。</p><p>本例中不需要访问Tuple_18，因为存储Tuple_18的第0页是可见的，即第0页中包含Tuple_18的所有元组都是可见的。相比之下，需要访问Tuple_19来处理并发控制，因为第一页的可见性是不可见的。参见图 7.7。</p><p><img src="/medias/image/fig-7-07.png" alt="图 7.7 仅索引扫描如何执行"></p>]]></content>
      
      
      <categories>
          
          <category> postgresql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> postgresql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>6 vacuum进程</title>
      <link href="/2021/6.vacuum-jin-cheng/"/>
      <url>/2021/6.vacuum-jin-cheng/</url>
      
        <content type="html"><![CDATA[<p>vacuum进程是一种便于PostgreSQL持久运行的维护过程。它的两个主要任务是删除死元组和冻结事务id。</p><span id="more"></span><p>为了去除死元组，清理过程有两种模式，即并发vacuum和vacuum full。并发VACUUM删除表文件每个页面的死元组，并且在此进程运行时，其他事务可以读取表。相反，vacuum full在整个文件中删除死元组并对活元组进行碎片整理，在vacuum full运行时，其他事务不能访问表。</p><blockquote><p>尽管vacuum进程对于PostgreSQL来说是必不可少的，但与其他功能相比，它的功能改进一直很缓慢。例如，在8.0版本之前，这个进程必须手动执行（使用psql实用程序或使用cron守护进程），它是在2005年实现autovacuum守护进程时实现的。</p><p>由于vacuum工作涉及扫描整个表，这是一个昂贵的过程。在8.4(2009)版本中，引入了可见性地图(VM)来提高删除死元组的效率。在9.6(2016)版本中，通过增强VM改进了冻结过程。</p></blockquote><p>第6.1节概述了VACUUM过程，后面的部分将描述以下内容。</p><ul><li>可见性地图(VM)</li><li>冻结处理</li><li>删除不必要的阻塞文件</li><li>autovacuum守护进程</li><li>vacuum full</li></ul><p>[TOC]</p><h2 id="6-1-vacuum概述"><a href="#6-1-vacuum概述" class="headerlink" title="6.1 vacuum概述"></a>6.1 vacuum概述</h2><p>vacuum进程对数据库中的指定表或所有表执行以下任务。</p><ol><li><p>删除死亡元组</p><p>为每个页面删除死元组并对活元组进行碎片整理。</p><p>删除指向死元组的索引元组。</p></li><li><p>冻结旧的txids</p><p>必要时冻结元组的旧txids。</p><p>更新冻结的txid相关的系统目录（pg_database和pg_class）。</p><p>如果可能的话，移除不必要的clog。</p></li><li><p>其他</p><p>更新已处理表的FSM和VM。</p><p>更新一些统计信息（pg_stat_all_tables等）。</p></li></ol><p>本文假定读者熟悉以下术语：死亡元组、冻结txid、FSM和clog。 如果你不熟悉，请参阅 第 5 章，VM将在6.2节中介绍。</p><p>下面的伪代码描述了vacuum进程。</p><p>伪代码：并行vacuum</p><pre class="line-numbers language-c"><code class="language-c"><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>  FOR each <span class="token function">table</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span>       Acquire ShareUpdateExclusiveLock lock <span class="token keyword">for</span> the target table          <span class="token comment" spellcheck="true">/* The first block */</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span>       Scan all pages to get all dead tuples<span class="token punctuation">,</span> and freeze old tuples <span class="token keyword">if</span> <span class="token function">necessary</span> <span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span>       Remove the index tuples that point to the respective dead tuples <span class="token keyword">if</span> exists          <span class="token comment" spellcheck="true">/* The second block */</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span>       FOR each page of the <span class="token function">table</span><span class="token punctuation">(</span><span class="token number">6</span><span class="token punctuation">)</span>            Remove the dead tuples<span class="token punctuation">,</span> and Reallocate the live tuples in the <span class="token function">page</span><span class="token punctuation">(</span><span class="token number">7</span><span class="token punctuation">)</span>            Update FSM and VM           END FOR          <span class="token comment" spellcheck="true">/* The third block */</span><span class="token punctuation">(</span><span class="token number">8</span><span class="token punctuation">)</span>       Clean up <span class="token function">indexes</span><span class="token punctuation">(</span><span class="token number">9</span><span class="token punctuation">)</span>       Truncate the last page <span class="token keyword">if</span> <span class="token function">possible</span><span class="token punctuation">(</span><span class="token number">10</span>       Update both the statistics and system catalogs of the target table           Release ShareUpdateExclusiveLock lock       END FOR        <span class="token comment" spellcheck="true">/* Post-processing */</span><span class="token punctuation">(</span><span class="token number">11</span><span class="token punctuation">)</span>  Update statistics and system <span class="token function">catalogs</span><span class="token punctuation">(</span><span class="token number">12</span><span class="token punctuation">)</span>  Remove both unnecessary files and pages of the clog <span class="token keyword">if</span> possible<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol><li><p>从指定的表中获取每个表。</p></li><li><p>获取表的 <code>ShareUpdateExclusiveLock</code> 锁，该锁允许从其他事务中读取数据。</p></li><li><p>扫描所有页面，获取所有死元组，必要时冻结旧元组。</p></li><li><p>如果存在，删除指向相应死亡元组的索引元组。</p></li><li><p>对表格的每一页执行步骤(6)和(7)。</p></li><li><p>删除死元组，重新分配页面中的活元组。</p></li><li><p>分别更新目标表的FSM和VM。</p></li><li><p>使用 <code>index_vacuum_cleanup()@indexam.c</code> 函数清理索引。</p></li><li><p>如果最后一页没有任何元组，则截断最后一页。</p></li><li><p>更新目标表中与vacuum处理相关的统计数据和系统目录。</p></li><li><p>更新与vacuum处理有关的统计数据和系统目录。</p></li><li><p>如果可能，删除不必要的文件和clog页。</p></li></ol><p>这个伪代码有两个部分：每个表的循环和后处理。内环可以分为三个块，每个块都有独立的任务。</p><p>下面概述了这三个块和后处理。</p><blockquote><p><strong>并行的选项</strong></p><p>VACUUM命令从版本13开始就支持 <code>PARALLEL</code> 选项，如果设置了该选项并且创建了多个索引，则它将并行处理清空索引和清理索引阶段。注意，该特性仅在VACUUM命令中有效，autovacuum不支持它。</p></blockquote><h3 id="6-1-1-第一块"><a href="#6-1-1-第一块" class="headerlink" title="6.1.1 第一块"></a>6.1.1 第一块</h3><p>该块执行冻结处理并删除指向死元组的索引元组。</p><p>首先，PostgreSQL扫描一个目标表，建立一个死元组列表，如果可能的话冻结旧元组。列表存储在本地内存的<a href="https://www.postgresql.org/docs/current/static/runtime-config-resource.html#GUC-MAINTENANCE-WORK-MEM">maintenance_work_mem</a> 中。冻结处理将在6.3节中介绍。</p><p>扫描完成后，PostgreSQL通过引用死元组列表删除索引元组。这个过程在内部被称为“清理阶段”。不用说，这个过程是昂贵的。在版本10或更早的版本中，总是执行清理阶段。在版本11或更高版本中，如果目标索引是B-tree，则是否执行清理阶段由配置参数 <a href="https://www.postgresql.org/docs/devel/static/runtime-config-resource.html#RUNTIME-CONFIG-INDEX-VACUUM">vacuum_cleanup_index_scale_factor</a> 决定，请参见该参数的详细说明。</p><p>当 <code>maintenance_work_mem</code> 已满且扫描未完成时，PostgreSQL将继续执行下一个任务，即步骤4到7，然后返回步骤3，进行剩余扫描。</p><h3 id="6-1-2-第二块"><a href="#6-1-2-第二块" class="headerlink" title="6.1.2 第二块"></a>6.1.2 第二块</h3><p>这个块会删除死元组，并逐页更新FSM和VM。图6.1给出了一个例子：</p><p><img src="/medias/image/fig-6-01-167673093401620.png" alt="图6.1 删除死元组"></p><p>假设表包含三个页面，我们关注第0页(即第一页)。这个页面有三个元组，Tuple_2是一个死元组(图6.1(1))。在这种情况下，PostgreSQL删除Tuple_2并重新排序剩余的元组以修复碎片，然后更新该页的FSM和VM(图6.1(2))。PostgreSQL继续这个过程直到最后一页。</p><p>注意，不必要的行指针不会被删除，它们将在将来被重用。因为，如果删除行指针，则必须更新关联索引的所有索引元组。</p><h3 id="6-1-3-第三块"><a href="#6-1-3-第三块" class="headerlink" title="6.1.3 第三块"></a>6.1.3 第三块</h3><p>第三个块在删除索引之后执行清理，并且还更新与每个目标表的vacuum进程相关的统计信息和系统目录。此外，如果最后一页没有元组，则从表文件中截断它。</p><h3 id="6-1-4-后处理"><a href="#6-1-4-后处理" class="headerlink" title="6.1.4 后处理"></a>6.1.4 后处理</h3><p>当vacuum进程完成时，PostgreSQL会更新一些与vacuum进程相关的统计数据和系统目录，并尽可能删除不必要的clog(6.4章节)。vacuum进程使用环形缓冲器，如第 8.5 节所述，因此处理过的页面不会缓存在共享缓冲区中。</p><h2 id="6-2-可见性地图"><a href="#6-2-可见性地图" class="headerlink" title="6.2 可见性地图"></a>6.2 可见性地图</h2><blockquote><p>vacuum进程是昂贵的，因此，在8.4版中引入了VM以降低这一成本。</p></blockquote><p>VM的基本概念很简单，每个表都有一个单独的可见性映射，用于保存表文件中每个页面的可见性。页面的可见性决定了每个页面是否有死元组，vacuum进程可以跳过没有死元组的页面。</p><p>图 6.2 显示了VM的使用情况。假设表由三页组成，第0页和第2页包含死元组，而第1页不包含。该表的VM保存了关于哪些页面包含死元组的信息。在这种情况下，vacuum进程通过引用VM的信息跳过第一页。</p><p><img src="/medias/image/fig-6-02.png" alt="图 6.2 VM的使用方式 "></p><p>每个VM由一个或多个8KB的页面组成，该文件以 <code>VM</code> 后缀存储。以relfilenode为18751的表文件为例，其中 <code>FSM</code> (18751_fsm)和 <code>VM</code> (18751_vm)文件如下所示。</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">cd</span> <span class="token variable">$PGDATA</span>$ <span class="token function">ls</span> -la base/16384/18751*-rw------- 1 postgres postgres  8192 Apr 21 10:21 base/16384/18751-rw------- 1 postgres postgres 24576 Apr 21 10:18 base/16384/18751_fsm-rw------- 1 postgres postgres  8192 Apr 21 10:18 base/16384/18751_vm<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="6-2-1-VM增强"><a href="#6-2-1-VM增强" class="headerlink" title="6.2.1 VM增强"></a>6.2.1 VM增强</h3><p>9.6版本对VM进行了增强，提高了冻结处理的效率。新的VM显示页面可见性，以及关于元组在每个页面中是否冻结的信息(6.3.3章节)。</p><h2 id="6-3-冻结处理"><a href="#6-3-冻结处理" class="headerlink" title="6.3 冻结处理"></a>6.3 冻结处理</h2><p>冻结处理有两种模式，根据特定条件以任何一种模式执行。为方便起见，这些模式被称为<strong>惰性模式</strong>和<strong>急切模式</strong>。</p><p>冻结处理通常以惰性模式运行，但是，当满足特定条件时，就会运行急切模式。在惰性模式下，冻结处理仅使用目标表的相应 VM 扫描包含死元组的页面。相比之下，急切模式会扫描所有页面，无论每个页面是否包含死元组，它还会更新与冻结处理相关的系统目录，并尽可能删除不必要的clog页面和文件。</p><h3 id="6-3-1-惰性模式"><a href="#6-3-1-惰性模式" class="headerlink" title="6.3.1 惰性模式"></a>6.3.1 惰性模式</h3><p>当开始冻结处理时，PostgreSQL 计算 freezeLimit_txid 并冻结 t_xmin 小于 freezeLimit txid 的元组。</p><p>freezeLimit_txid 定义如下：</p><pre class="line-numbers language-bash"><code class="language-bash">freezeLimit_txid<span class="token operator">=</span><span class="token punctuation">(</span>OldestXmin−vacuum_freeze_min_age<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>在那里最旧的XminOldestXmin是当前正在运行的事务中最旧的 txid。例如，如果在执行 VACUUM 命令时三个事务（txids 100、101 和 102）正在运行， 最旧的XminOldestXmin 是 100。如果不存在其他事务， 最旧的XminOldestXmin是执行这个 VACUUM 命令的 txid。在这里，<a href="https://www.postgresql.org/docs/current/static/runtime-config-client.html#GUC-VACUUM-FREEZE-MIN-AGE">vacuum_freeze_min_age</a>是一个配置参数（默认为 50,000,000）。</p><p>一个具体示例。在这里，Table_1 由三个页面组成，每个页面有三个元组。执行 VACUUM 命令时，当前 txid 为 50,002,500，没有其他事物。在这种情况下，最旧的XminOldestXmin是 50,002,500；因此，freezeLimit_txid 为 2500。冻结处理如下执行。</p><p><strong>在惰性模式下冻结元组</strong></p><p><img src="/medias/image/fig-6-03-167673167640625.png" alt="图 7 在惰性模式下冻结元组"></p><ul><li><p>第0页：</p><p>三个元组被冻结，因为所有 t_xmin 值都小于 freezeLimit txid。此外，由于死元组，在此vacuum过程中删除了 Tuple_1。</p></li><li><p>第1页：</p><p>参考VM跳过此页。</p></li><li><p>第2页：</p><p>Tuple_7 和 Tuple_8 被冻结；Tuple_7 被删除。</p></li></ul><p>在完成vacuum过程之前，更新与vacuum相关的统计信息，例如 <a href="https://www.postgresql.org/docs/current/static/monitoring-stats.html#PG-STAT-ALL-TABLES-VIEW">pg_stat_all_tables</a>的n_live_tup、n_dead_tup、last_vacuum、vacuum_count等。</p><p>如上例所示，惰性模式可能无法完全冻结元组，因为它可以跳过页面。</p><h3 id="6-3-2-急切模式"><a href="#6-3-2-急切模式" class="headerlink" title="6.3.2 急切模式"></a>6.3.2 急切模式</h3><p>急切模式弥补了惰性模式的缺陷。它扫描所有页面以检查表中的所有元组，更新相关的系统目录，并尽可能删除不必要的clog页面和文件。</p><p>当满足以下条件时执行急切模式。</p><pre class="line-numbers language-bash"><code class="language-bash">pg_database.datfrozenxid<span class="token operator">&lt;</span><span class="token punctuation">(</span>OldestXmin−vacuum_freeze_table_age<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>在上述条件中， pg_database.datfrozenxid代表<a href="https://www.postgresql.org/docs/current/static/catalog-pg-database.html">pg_database</a>系统目录的列，并保存每个数据库最旧的冻结 txid，细节在后面描述。因此，我们假设所有 pg_database.datfrozenxid 的值为 1821（这是 9.5 版新数据库集群安装后的初始值）。 <a href="https://www.postgresql.org/docs/current/static/runtime-config-client.html#GUC-VACUUM-FREEZE-TABLE-AGE">vacuum_freeze_table_age</a>是一个配置参数（默认为 150,000,000）。</p><p>下图显示了一个具体示例。在 Table_1 中，Tuple_1 和 Tuple_7 都被删除了。Tuple_10 和 Tuple_11 已插入到第二页。执行 VACUUM 命令时，当前 txid 为 150,002,000，没有其他事物。因此，OldestXmin 为 150,002,000，freezeLimit txid 为 100,002,000。在这种情况下，满足上述条件，因为1821&lt;(150002000−150000000)，因此，冻结处理在急切模式下执行如下。</p><p>（注意这是 9.5 或更早版本的行为）</p><p><strong>急切模式下冻结旧的元组（9.5 或更早版本）</strong></p><p><img src="/medias/image/fig-6-04-167673167640626.png" alt="图 8 在 Eager 模式下冻结旧的元组（9.5 或更早版本）"></p><ul><li><p>第0页：</p><p>Tuple_2 和 Tuple_3 已被检查，即使所有元组都已被冻结。</p></li><li><p>第1页：</p><p>此页面中的三个元组已被冻结，因为所有 t_xmin 值都小于 freezeLimit txid。请注意，在惰性模式下会跳过此页面。</p></li><li><p>第2页：</p><p>Tuple_10 已被冻结，Tuple_11 没有。</p></li></ul><p>冻结每个表后，更新目标表的pg_class.relfrozenxid。pg_class是一个系统目录，每个 pg_class.relfrozenxid 列都保存着对应表的最新冻结 xid。本例中，Table_1 的 pg_class.relfrozenxid 更新为当前的 freezeLimit txid（即 100,002,000），这意味着 Table_1 中所有t_xmin 小于 100,002,000 的元组都被冻结。</p><p>在完成vacuum过程之前，pg_database.datfrozenxid 会根据需要进行更新。每个 pg_database.datfrozenxid 列保存对应数据库中的最小 pg_class.relfrozenxid。例如，如果只有 Table_1 在急切模式下被冻结，则该数据库的 pg_database.datfrozenxid 不会更新，因为其他关系（从当前数据库中可以看到的其他表和系统目录）的 pg_class.relfrozenxid 没有更改。如果当前数据库中的所有关系都在急切模式下被冻结，则更新数据库的 pg_database.datfrozenxid，因为该数据库的所有关系的 pg_class.relfrozenxid 都更新为当前的 freezeLimit txid。</p><p><strong>pg_database.datfrozenxid 和 pg_class.relfrozenxid(s) 之间的关系</strong></p><p><img src="/medias/image/fig-6-05-167673167640627.png" alt="图 9 pg_database.datfrozenxid 和 pg_class.relfrozenxid(s) 之间的关系"></p><p><em>如何显示 pg_class.relfrozenxid 和 pg_database.datfrozenxid</em></p><p>在下文中，第一个查询显示了“testdb”数据库中所有可见关系的 relfrozenxid，第二个查询显示了“testdb”数据库的 pg_database.datfrozenxld。</p><pre class="line-numbers language-sql-monosp"><code class="language-sql-monosp">testdb=# VACUUM table_1;VACUUMtestdb=# SELECT n.nspname as "Schema", c.relname as "Name", c.relfrozenxid             FROM pg_catalog.pg_class c             LEFT JOIN pg_catalog.pg_namespace n ON n.oid = c.relnamespace             WHERE c.relkind IN ('r','')                   AND n.nspname <> 'information_schema' AND n.nspname !~ '^pg_toast'                   AND pg_catalog.pg_table_is_visible(c.oid)                   ORDER BY c.relfrozenxid::text::bigint DESC;   Schema   |            Name         | relfrozenxid ------------+-------------------------+-------------- public     | table_1                 |    100002000 public     | table_2                 |         1846 pg_catalog | pg_database             |         1827 pg_catalog | pg_user_mapping         |         1821 pg_catalog | pg_largeobject          |         1821... pg_catalog | pg_transform            |         1821(57 rows)testdb=# SELECT datname, datfrozenxid FROM pg_database WHERE datname = 'testdb'; datname | datfrozenxid ------------------------+-------------- testdb                  |         1821(1 row)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><em>冻结选项</em></p><p>带有 <code>FREEZE</code> 选项的 VACUUM 命令强制冻结指定表中的所有 txid，这是在急切模式下执行的。但是，freezeLimit 设置为 OldestXmin（不是“OldestXmin - Vacuum_freeze_min_age”）。例如，当 txid 5000 执行 VACUUM FULL 命令且没有其他正在运行的事务时，OldesXmin 设置为 5000，小于 5000 的 txid 将被冻结。</p><h3 id="6-3-3-在急切模式下改进冻结处理"><a href="#6-3-3-在急切模式下改进冻结处理" class="headerlink" title="6.3.3 在急切模式下改进冻结处理"></a><strong>6.3.3 在急切模式下改进冻结处理</strong></h3><p>9.5 或更早版本中的急切模式效率不高，因为总是扫描所有页面。例如，在上节示例中，即使第 0 页中的所有元组都被冻结，也会扫描第 0 页。</p><p>为了解决这个问题，9.6 版本对 VM 和冻结过程进行了改进，新 VM 具有关于是否所有元组在每个页面中都被冻结的信息。当以急切模式执行冻结处理时，可以跳过仅包含冻结元组的页面。</p><p>冻结此表时，参考VM信息跳过第0页。冻结第 1 页后，更新关联的 VM 信息，因为该页的所有元组都已冻结。</p><p><strong>在急切模式下冻结旧的元组（9.6 或更高版本）</strong></p><p><img src="/medias/image/fig-6-06-167673167640628.png" alt="图 10 在 Eager 模式下冻结旧的元组（9.6 或更高版本）"></p><h2 id="6-4-删除不必要的阻塞文件"><a href="#6-4-删除不必要的阻塞文件" class="headerlink" title="6.4 删除不必要的阻塞文件"></a>6.4 删除不必要的阻塞文件</h2><p>当 pg_database.datfrozenxid 更新时，PostgreSQL 会尝试删除不必要的clog文件。请注意，相应的clog页面也会被删除。</p><p>下图显示了一个示例。如果最小 pg_database.datfrozenxid 包含在 clog 文件“0002”中，则可以删除旧文件（“0000”和“0001”），因为存储在这些文件中的所有事务都可以被视为整个数据库集群中的冻结 txid。</p><p><strong>删除不必要的阻塞文件和页面</strong></p><p><img src="/medias/image/fig-6-07-167673167640629.png" alt="图 11 删除不必要的阻塞文件和页面"></p><p><em>pg_database.datfrozenxid 和 clog 文件</em></p><p>下面显示了 pg_database.datfrozenxid 和 clog 文件的实际输出：</p><pre class="line-numbers language-sql-monosp"><code class="language-sql-monosp">$ psql testdb -c "SELECT datname, datfrozenxid FROM pg_database"  datname  | datfrozenxid -----------+-------------- template1 |      7308883 template0 |      7556347 postgres  |      7339732 testdb    |      7506298(4 rows)$ ls -la -h data/pg_xact/    # In version 9.6 or earlier, "ls -la -h data/pg_clog/"total 316Kdrwx------  2 postgres postgres   28 Dec 29 17:15 .drwx------ 20 postgres postgres 4.0K Dec 29 17:13 ..-rw-------  1 postgres postgres 256K Dec 29 17:15 0006-rw-------  1 postgres postgres  56K Dec 29 17:15 0007<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="6-5-autovacuum守护进程"><a href="#6-5-autovacuum守护进程" class="headerlink" title="6.5 autovacuum守护进程"></a>6.5 autovacuum守护进程</h2><p>vacuum处理已通过 autovacuum 守护进程自动化，因此 PostgreSQL 的操作变得异常简单。</p><p>autovacuum 守护进程定期调用几个 autovacuum_worker 进程。默认情况下，它每 1 分钟唤醒一次（由<a href="https://www.postgresql.org/docs/current/static/runtime-config-autovacuum.html#GUC-AUTOVACUUM-NAPTIME">autovacuum_naptime</a>定义），并调用三个 worker（由<a href="https://www.postgresql.org/docs/current/static/runtime-config-autovacuum.html#GUC-AUTOVACUUM-MAX-WORKERS">autovacuum_max_works</a>定义）。</p><p>由 autovacuum 调用的 autovacuum worker 并行的对各个表同时执行真空处理，对数据库活动的影响最小。</p><h2 id="6-6-VACUUM-FULL"><a href="#6-6-VACUUM-FULL" class="headerlink" title="6.6 VACUUM FULL"></a>6.6 VACUUM FULL</h2><p>尽管并行 VACUUM 对于操作是必不可少的，但这还不够。例如，即使删除了许多死元组，它也无法减小表大小。</p><p>如图显示了一个极端的例子。假设一个表由三页组成，每页包含六个元组，执行以下 DELETE 命令删除元组，执行 VACUUM 命令删除死元组：</p><p><strong>并行 VACUUM 缺点的示例</strong><img src="/medias/image/fig-6-08-167673167640730.png" alt="图 12 显示（并发）VACUUM 缺点的示例"></p><pre class="line-numbers language-sql-monosp"><code class="language-sql-monosp">testdb=# DELETE FROM tbl WHERE id % 6 != 0;testdb=# VACUUM tbl;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>删除死元组，但是，表大小并没有减少。这既浪费了磁盘空间，又对数据库性能产生了负面影响。例如，在上面的示例中，当读取表中的三个元组时，必须从磁盘加载三个页面。</p><p>为了应对这种情况，PostgreSQL 提供了 VACUUM FULL 模式。下图显示了该模式的概要。</p><p><strong>VACUUM FULL 模式的概要</strong></p><p><img src="/medias/image/fig-6-09-167673167640731.png" alt="图 13 Full VACUUM 模式的概要"></p><ol><li><p>新建表文件：图 (1)</p><p>当对一个表执行 VACUUM FULL 命令时，PostgreSQL 首先获取该表的 AccessExclusiveLock 锁，并创建一个大小为 8 KB 的新表文件。AccessExclusiveLock 锁不允许访问。</p></li><li><p>将活动元组复制到新表中：图 (2)</p><p>PostgreSQL 仅将旧表文件中的活动元组复制到新表中。</p></li><li><p>删除旧文件，重建索引，更新统计、FSM、VM：图(3)</p><p>复制所有活动元组后，PostgreSQL 删除旧文件，重建所有关联的表索引，更新该表的 FSM 和 VM，并更新关联的统计信息和系统目录。</p></li></ol><p>VACUUM FULL 的伪代码如下所示：</p><p><em>伪代码：VACUUM FULL</em></p><pre class="line-numbers language-sql"><code class="language-sql"><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>  <span class="token keyword">FOR</span> each <span class="token keyword">table</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span>       Acquire AccessExclusiveLock <span class="token keyword">lock</span> <span class="token keyword">for</span> the <span class="token keyword">table</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span>       <span class="token keyword">Create</span> <span class="token number">a</span> new <span class="token keyword">table</span> <span class="token keyword">file</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span>       <span class="token keyword">FOR</span> each live tuple <span class="token operator">in</span> the old <span class="token keyword">table</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span>            Copy the live tuple <span class="token keyword">to</span> the new <span class="token keyword">table</span> <span class="token keyword">file</span><span class="token punctuation">(</span><span class="token number">6</span><span class="token punctuation">)</span>            Freeze the tuple <span class="token keyword">IF</span> necessary            <span class="token keyword">END</span> <span class="token keyword">FOR</span><span class="token punctuation">(</span><span class="token number">7</span><span class="token punctuation">)</span>        Remove the old <span class="token keyword">table</span> <span class="token keyword">file</span><span class="token punctuation">(</span><span class="token number">8</span><span class="token punctuation">)</span>        Rebuild <span class="token keyword">all</span> indexes<span class="token punctuation">(</span><span class="token number">9</span><span class="token punctuation">)</span>        <span class="token keyword">Update</span> FSM <span class="token operator">and</span> VM<span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span>      <span class="token keyword">Update</span> <span class="token keyword">statistics</span>           <span class="token keyword">Release</span> AccessExclusiveLock <span class="token keyword">lock</span>      <span class="token keyword">END</span> <span class="token keyword">FOR</span><span class="token punctuation">(</span><span class="token number">11</span><span class="token punctuation">)</span>  Remove unnecessary clog files <span class="token operator">and</span> pages <span class="token keyword">if</span> possib  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>使用 VACUUM FULL 命令时应考虑两点。</p><ol><li>当 VACUUM FULL 正在处理时，没有用户可以访问（读/写）表。</li><li>最多临时使用表磁盘空间的两倍，因此，在处理一个巨大的表时，需要检查剩余的磁盘容量。</li></ol><p><em>我应该什么时候做 VACUUM FULL？</em></p><p>不幸的是，当您应该执行“VACUUM FULL”时，没有最佳实践。然而，扩展<a href="https://www.postgresql.org/docs/current/static/pgfreespacemap.html">pg_freespacemap</a>可能会给你很好的建议。</p><p>以下查询显示了您想知道的表的平均可用空间比率。</p><pre class="line-numbers language-sql-monosp"><code class="language-sql-monosp">testdb=# CREATE EXTENSION pg_freespacemap;CREATE EXTENSIONtestdb=# SELECT count(*) as "number of pages",       pg_size_pretty(cast(avg(avail) as bigint)) as "Av. freespace size",       round(100 * avg(avail)/8192 ,2) as "Av. freespace ratio"       FROM pg_freespace('accounts'); number of pages | Av. freespace size | Av. freespace ratio -----------------+--------------------+---------------------            1640 | 99 bytes           |                1.21(1 row)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如上结果，您可以发现可用空间很少。</p><p>如果你删除几乎元组并执行 VACUUM 命令，你会发现几乎页是空格的。</p><pre class="line-numbers language-sql-monosp"><code class="language-sql-monosp">testdb=# DELETE FROM accounts WHERE aid %10 != 0 OR aid < 100;DELETE 90009testdb=# VACUUM accounts;VACUUMtestdb=# SELECT count(*) as "number of pages",      pg_size_pretty(cast(avg(avail) as bigint)) as "Av. freespace size",      round(100 * avg(avail)/8192 ,2) as "Av. freespace ratio"      FROM pg_freespace('accounts');number of pages | Av. freespace size | Av. freespace ratio -----------------+--------------------+---------------------           1640 | 7124 bytes         |               86.97(1 row)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>以下查询检查指定表的每一页的可用空间比率。</p><pre class="line-numbers language-sql-monosp"><code class="language-sql-monosp">testdb=# SELECT *, round(100 * avail/8192 ,2) as "freespace ratio"                FROM pg_freespace('accounts'); blkno | avail | freespace ratio -------+-------+-----------------     0 |  7904 |           96.00     1 |  7520 |           91.00     2 |  7136 |           87.00     3 |  7136 |           87.00     4 |  7136 |           87.00     5 |  7136 |           87.00....<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>执行 VACUUM FULL 后，可以发现表文件已经被压实。</p><pre class="line-numbers language-sql-monosp"><code class="language-sql-monosp">testdb=# VACUUM FULL accounts;VACUUMtestdb=# SELECT count(*) as "number of blocks",       pg_size_pretty(cast(avg(avail) as bigint)) as "Av. freespace size",       round(100 * avg(avail)/8192 ,2) as "Av. freespace ratio"       FROM pg_freespace('accounts'); number of pages | Av. freespace size | Av. freespace ratio -----------------+--------------------+---------------------             164 | 0 bytes            |                0.00(1 row)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> postgresql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> postgresql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>8 缓冲区管理器</title>
      <link href="/2021/8.huan-chong-qu-guan-li-qi/"/>
      <url>/2021/8.huan-chong-qu-guan-li-qi/</url>
      
        <content type="html"><![CDATA[<p>缓冲区管理器管理着共享内存和持久存储之间的数据传输，它会对 DBMS 的性能有着重要的影响。PostgreSQL 的缓冲区管理器十分高效。</p><span id="more"></span><p>[TOC]</p><p>本章介绍了 PostgreSQL 的缓冲区管理器。图8.1展示了缓冲区管理器存储和后端进程之间的关系，后续部分描述以下内容：</p><ul><li>缓冲区管理器的结构</li><li>缓冲区管理器的锁</li><li>缓冲区管理器的工作原理</li><li>环形缓冲区</li><li>脏页刷盘</li></ul><p><img src="/medias/image/fig-8-01.png" alt="图8.1 缓冲区管理器存储和后端进程之间的关系"></p><h2 id="8-1-概览"><a href="#8-1-概览" class="headerlink" title="8.1 概览"></a>8.1 概览</h2><p>本节介绍了为理解后续章节所需的关键概念。</p><h3 id="8-1-1-缓冲区管理器的结构"><a href="#8-1-1-缓冲区管理器的结构" class="headerlink" title="8.1.1 缓冲区管理器的结构"></a>8.1.1 缓冲区管理器的结构</h3><p>PostgreSQL缓冲区管理器由缓冲表、缓冲区描述符和缓冲池组成，这些将在下一节中介绍。缓冲池层存储数据着数据文件页面，如表</p><p>页和索引页，以及相应的<a href="https://jinlid.github.io/2021/8.huan-chong-qu-guan-li-qi/#_5.3.4">自由空间映射</a>和<a href="https://jinlid.github.io/2021/6.vacuum-jin-cheng/#_6.2">可见性映射</a>的页面。缓冲池是一个数组，数据的每个槽中存储数据文件的一页。缓冲池数组的序</p><p>号索引称为<strong>buffer_id</strong>。第<a href="https://jinlid.github.io/2021/8.huan-chong-qu-guan-li-qi/#8.2">8.2</a>、<a href="https://jinlid.github.io/2021/8.huan-chong-qu-guan-li-qi/#8.3">8.3节</a>描述了缓冲区管理器的内部细节。</p><h3 id="8-1-2-缓冲区标签（Buffer-Tag）"><a href="#8-1-2-缓冲区标签（Buffer-Tag）" class="headerlink" title="8.1.2 缓冲区标签（Buffer Tag）"></a>8.1.2 缓冲区标签（Buffer Tag）</h3><p>PostgreSQL中的每个数据文件页面都可以分配唯一的标签，即<strong>缓冲区标签</strong>。当缓冲区管理器收到请求时，PostgreSQL会用到</p><p>目标页面的缓冲区标签。</p><p>缓冲区标签有五个值：</p><ul><li>specOid：包含目标页的关系所属表空间的OID。</li><li>dbOid：包含目标页面的关系所属数据库的OID。</li><li>relNumber：包含目标页面的关系文件的编号。</li><li>blockNum：关系中目标页的块号。</li><li>forkNum：页面所属关系的分支。表、自由空间映射和可见性映射的分支分别定义为 0、1 和 2。</li></ul><p>例如，缓冲区标签 ‘{16821, 16384, 37721, 0, 7}’ 标识位于表的第7号页面，其中OID和分叉号分别为37721和0。该表包含在OID为 16384</p><p>的数据库中，位于OID为16821的表空间下。</p><p>类似地，缓冲区标签 ‘{16821, 16384, 37721, 1, 3}’ 标识位于自由空间映射的第3号页面，其OID和分支分别为37721和1。</p><h3 id="8-1-3-后端进程如何读取数据页"><a href="#8-1-3-后端进程如何读取数据页" class="headerlink" title="8.1.3 后端进程如何读取数据页"></a>8.1.3 后端进程如何读取数据页</h3><p>本小节描述了后端进程如何从缓冲区管理器中读取数据页（图 8.2）。</p><p><img src="/medias/image/fig-8-02.png" alt="图8.2 后端如何从缓冲区管理器读取页面"></p><ol><li>当读取表或索引页时，后端进程向缓冲区管理器发送请求，请求中带有目标页面的 <code>buffer_tag</code> 。</li><li>缓冲区管理器会根据 <code>buffer_tag</code> 返回一个 <code>buffer_id</code>，即目标页面存储在数组中的槽位的序号。如果请求的页面没有存储在缓冲池中，那么缓冲管理器会将页面从持久存储位置加载到其中一个缓冲池槽位中，然后再返回该槽位的 <code>buffer_ID</code>。</li><li>后端进程访问 <code>buffer_ID</code> 的槽位（以读取需要的页面）。</li></ol><p>当后端进程修改缓冲池中的页面时（例如向页面插入元组），这种尚未刷新到持久存储，但已被修改的页面被称为<strong>脏页</strong>。</p><p>第<a href="https://jinlid.github.io/2021/8.huan-chong-qu-guan-li-qi/#_8.4.">8.4 节</a>描述了缓冲区管理器的工作原理。</p><h3 id="8-1-4-页面置换算法"><a href="#8-1-4-页面置换算法" class="headerlink" title="8.1.4 页面置换算法"></a>8.1.4 页面置换算法</h3><p>当所有缓冲池槽位都被占用，并且未包含所请求的页面时，缓冲管理器必须在缓冲池中选择一个页面逐出，用于放置被请求的页面。在计</p><p>算机科学领域，选择页面的算法被称为<strong>页面置换算法</strong>，并且所选择的页面被称为<strong>受害者页面</strong>。</p><p>自计算机科学出现以来，针对页面置换算法的研究一直在进行。许多置换算法被提出，PostgreSQL从8.1版本开始使用<strong>时钟扫描</strong>算法。比</p><p>起以前版本中使用的 LRU 算法更简单高效。</p><p><a href="https://jinlid.github.io/2021/8.huan-chong-qu-guan-li-qi/#_8.4.4">8.4.4 节</a>将描述时钟扫描的细节。</p><h3 id="8-1-5-脏页刷盘"><a href="#8-1-5-脏页刷盘" class="headerlink" title="8.1.5 脏页刷盘"></a>8.1.5 脏页刷盘</h3><p>脏页最终应该被刷新到存储中，然而缓冲区管理器需要额外帮助才能执行此任务。在PostgreSQL中，<strong>checkpointer</strong>和</p><p><strong>background writer</strong>这两个后台进程负责此任务。</p><p>第<a href="https://jinlid.github.io/2021/8.huan-chong-qu-guan-li-qi/#_8.6">8.6 节</a>描述了checkpointer和background writer。</p><blockquote><p>PostgreSQL版本15及更早版本不支持直接I/O，尽管已经对此进行了讨论。请参阅<a href="http://www.postgresql.org/message-id/529E267F.4050700@agliodbs.com">这篇</a>关于pgsql-ML的文章和<a href="http://lwn.net/Articles/580542/">这篇文章</a>。</p><p>在版本 16 中，添加了<a href="https://www.postgresql.org/docs/16/runtime-config-developer.html#GUC-DEBUG-IO-DIRECT">debug-io-direct选项</a>。该选项供开发人员改进PostgreSQL中直接I/O的使用。如果开发顺利的话，Direct I/O将在不久的将来正式支持。</p></blockquote><h2 id="8-2-缓冲区管理器的结构"><a href="#8-2-缓冲区管理器的结构" class="headerlink" title="8.2 缓冲区管理器的结构"></a>8.2 缓冲区管理器的结构</h2><p>PostgreSQL缓冲管理器由三层组成，即<strong>缓冲表层</strong>、<strong>缓冲区描述符层</strong>和<strong>缓冲池层</strong>（图 8.3）。</p><ul><li><p><strong>缓冲表层</strong>：是一个散列表，它存储着页面的 <code>buffer_tags</code> 与描述符的 <code>buffer_id</code> 之间的映射关系。</p></li><li><p><strong>缓冲区描述符层</strong>：是一个由缓冲区描述符组成的数组。每个描述符与缓冲池槽一一对应，并保存着相应槽的元数据。请注意，为了方便起见，采用术语“缓冲区描述符层”，并且仅在本文档中使用。</p></li><li><p><strong>缓冲池层</strong>：是一个数组，每个槽都存储一个数据文件页。数组槽的索引称为<strong>buffer_id</strong>。</p></li></ul><p><img src="/medias/image/fig-8-03.png" alt="图8.3 缓冲区管理器的三层结构"></p><p>这些层将在以下小节中详细描述。</p><h3 id="8-2-1-缓冲表"><a href="#8-2-1-缓冲表" class="headerlink" title="8.2.1 缓冲表"></a>8.2.1 缓冲表</h3><p>缓冲区表在逻辑上可以分为三个部分：散列函数、散列桶槽和数据项（图 8.4）。</p><p>内置的散列函数将 <code>buffer_tag</code> 映射到散列桶槽。即使散列桶槽数大于缓冲池槽数，也可能发生冲突。因此，缓冲表使用<strong>链表的分离链</strong></p><p><strong>接</strong>方法来解决冲突。当数据项映射到同一个桶槽时，该方法将这些数据项存储在同一个链表中，如图8.4所示。</p><p><img src="/medias/image/fig-8-04.png" alt="图8.4 缓冲表"></p><p>数据项包含两个值：页面的 <code>buffer_tag</code> 和包含页面元数据的描述符的 <code>buffer_id</code>。例如，数据项 Tag_A, id=1 表示 buffer_id=1对应的</p><p>缓冲区描述符中，存储着页面 Tag_A 的元数据。</p><blockquote><p> 散列函数</p><p>散列函数是由<a href="https://doxygen.postgresql.org/dynahash_8c.html#ae802f2654df749ae0e0aadf4b5c5bcbd">calc_bucket()</a>和 <a href="https://doxygen.postgresql.org/rege__dfa_8c.html#a6aa3a27e7a0fc6793f3329670ac3b0cb">hash()</a>组合而成。 以下是用伪函数的表示的形式。</p><pre class="line-numbers language-c"><code class="language-c">uint32 bucket_slot <span class="token operator">=</span> <span class="token function">calc_bucket</span><span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token function">hash</span><span class="token punctuation">(</span>BufferTag buffer_tag<span class="token punctuation">)</span><span class="token punctuation">,</span> uint32 bucket_size<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></blockquote><p>暂时还没有对数据项的查找、插入和删除进行解释。这些常见的操作将在以下部分进行详细说明。</p><h3 id="8-2-2-缓冲区描述符"><a href="#8-2-2-缓冲区描述符" class="headerlink" title="8.2.2 缓冲区描述符"></a>8.2.2 缓冲区描述符</h3><p>本节介绍缓冲区描述符的结构，下一节介绍缓冲区描述符层。</p><p>缓冲区描述符存储着页面的元数据，这些与缓冲区描述符相应的页面保存在缓冲池槽中。缓冲区描述符的结构由BufferDesc结构定义。主</p><p>要字段如下所示：</p><ul><li><p><strong>tag</strong> 保存着目标页面的buffer_tag，该页面存储在相应的缓冲池槽中，缓冲区标签在第 8.1节中给出 。</p></li><li><p><strong>buffer_id</strong> 标识了缓冲区描述符，相当于对应缓冲池槽的buffer_id。</p></li><li><p>**refcount **保存当前访问相关页面的 PostgreSQL 进程数。它也称为钉数。当 PostgreSQL 进程访问相应页面时，其引用计数必须加1（refcount++）。访问页面结束后，其引用计数必须减1（refcount–）。当引用计数为零时，即页面当前并未被访问时，则该页将取钉；否则它会被钉住。</p></li><li><p>**usage_count **保存着相应页面加载至相应缓冲池槽后的访问次数。usage_count 会在页面置换算法中被用到，见第8.4.4节。</p></li><li><p><strong>context_lock</strong>和<strong>io_in_progress_lock</strong> 是轻量级锁，用于控制对相关页面的访问。这些字段将在第 8.3.2 节中描述。</p></li><li><p>flags 用于保存相关页面的状态，主要状态如下：</p><ul><li><strong>脏位</strong> 指明相应页面是否为脏页。</li><li><strong>有效位</strong> 指明相应页面是否可以被读写（有效）。例如，如果该位被设置为 <code>valid</code>， 那就意味着对应的缓冲池槽中存储着一个页面，而该描述符中保存着该页面的元数据，因而可以对该页面进行读写。反之如果有效位被设置为 <code>invalid</code>，那就意味着该描述符中并没有保存任何元数据，即对应的页面无法读写，缓冲区管理器可能正在将该页面换出。</li><li>**io进行标记位 **指明缓冲区管理器是否正在从存储读/写相应页面。换句话说，该位指示是否有一个进程持有该描述符上的 io_in_progress_lock。</li></ul></li><li><p><strong>freeNext</strong> 是一个指针，指向下一个描述符，并以此构成一个空闲列表（freelist），这将在下一小节中描述。</p></li></ul><p>结构<code>BufferDesc</code>在<a href="https://github.com/postgres/postgres/blob/master/src/include/storage/buf_internals.h">src/include/storage/buf_internals.h </a>中定义。</p><p>为了简化后续章节的描述，这里定义了三个描述符状态：</p><ul><li><strong>空</strong>：当相应的缓冲池槽不存储页面，即 <code>refcount</code>和 <code>usage_count</code>都是0，该描述符的状态为空。</li><li><strong>钉住</strong>：当相应的缓冲池槽中存储着页面，且有PostgreSQL进程正在访问的相应页面（即 <code>refcount</code>和 <code>usage_count</code>都大于或等于1），该缓冲区描述符的钉住。</li><li><strong>未钉住</strong>：当对应的缓冲池槽存储页面，但没有PostgreSQL进程访问相应页面时（即 <code>usage_count</code>大于等于1，但 <code>refcount</code>为0），这个缓冲区描述符的状态为未钉住。</li></ul><p>每个描述符都处于上述状态之一。描述符的状态会根据特定条件而变化，这将在下一小节中描述。</p><p>缓冲区描述符的状态由彩色框表示。</p><ul><li>（白色）<em>空</em></li><li>（蓝色）<em>钉住</em></li><li>（水蓝色）未钉住</li></ul><p>此外，脏页用 <strong>X</strong>表示。例如，未钉住的脏描述符由 X 表示。</p><h3 id="8-2-3-缓冲区描述符层"><a href="#8-2-3-缓冲区描述符层" class="headerlink" title="8.2.3 缓冲区描述符层"></a>8.2.3 缓冲区描述符层</h3><p>缓冲区描述符的集合构成一个数组。在本文档中，该数组被称为<strong>缓冲区描述符层</strong>。</p><p>当 PostgreSQL 服务器启动时，所有缓冲区描述符的状态都为空。在 PostgreSQL 中，这些描述符构成了一个名为<strong>freelist</strong>的链表，缓冲</p><p>区管理器的初始化状态如图 8.5所示。</p><p><img src="/medias/image/fig-8-05.png" alt="图8.5 缓冲区管理器初始化状态"></p><blockquote><p>注意，在PostgreSQL中的 freelist 是从完全不同于Oracle中的 freelist 的概念。PostgreSQL 的 freelist 只是空缓冲区描述符的链</p><p>表。在<a href="http://www.interdb.jp/pg/pgsql05.html#_5.3.4.">5.3.4 节</a>中已描述，PostgreSQL中与Oracle中的freelist相对应的对象是空闲空间映射（FSM）。</p></blockquote><p>图 8.6 展示了第一个页面是如何加载的。</p><ol><li>从 <code>freelist</code> 的头部取一个空描述符，并将其钉住，即将refcount和usage_count增加1。</li><li>在缓冲表中插入新项，该缓冲表项保存了页面 buffer_tag 与所获描述符 buffer_id 之间的关系。</li><li>将新页面从存储器加载至相应的缓冲池槽中。</li><li>将新页面的元数据保存至所获取的描述符中。</li></ol><p>第二页和后续页面的加载方式类似。第 8.4.2 节提供了其他详细信息。</p><p><img src="/medias/image/fig-8-06.png" alt="图8.6 加载第一页"></p><p>从 freelist 中摘出的描述符始终保存着页面的元数据。换句话说，仍然在使用的非空描述符不会返还到 freelist 中。但当发生以下任一情</p><p>况时，描述符状态变为“空”，并被重新添加至 freelist  中：</p><ol><li>相关表或索引已被删除。</li><li>相关数据库已被删除。</li><li>相关表或索引已经被 VACUUM FULL 命令清理。</li></ol><blockquote><p> 为什么使用 freelist 来维护空描述符？</p><p>保留 freelist 的原因是为了立即获取第一个描述符。这是内存动态分配的常见做法。请参阅<a href="https://en.wikipedia.org/wiki/Free_list">此说明</a>。</p></blockquote><p>缓冲区描述符层包含一个32 位无符号的整数变量，即<strong>nextVictimBuffer</strong>。该变量用于第 8.4.4 节中描述的页面置换算法。</p><h3 id="8-2-4-缓冲池"><a href="#8-2-4-缓冲池" class="headerlink" title="8.2.4 缓冲池"></a>8.2.4 缓冲池</h3><p>缓冲池只是一个用于存储关系数据文件（例如表和索引）页面的简单数组。缓冲池数组的序号索引也就是 <code>buffer_id</code>。</p><p>缓冲池槽的大小为8KB，等于一个页面的大小。因此，每个槽都能存储整个页面。</p><h2 id="8-3-缓冲区管理器锁"><a href="#8-3-缓冲区管理器锁" class="headerlink" title="8.3 缓冲区管理器锁"></a>8.3 缓冲区管理器锁</h2><p>缓冲区管理器会出于不同的目的使用各式各样的锁，本节将介绍后续章节中所必备的一些锁。</p><blockquote><p>注意，本节中描述的锁是缓冲区管理器同步机制的一部分。它们与SQL语句和SQL操作中的锁没有任何关系。</p></blockquote><h3 id="8-3-1-缓冲表锁"><a href="#8-3-1-缓冲表锁" class="headerlink" title="8.3.1 缓冲表锁"></a>8.3.1 缓冲表锁</h3><p><strong>BufMappingLock</strong>保护整个缓冲表的数据完整性。它是一种轻量级的锁，有共享模式和独占模式。在缓冲区表中搜索条目时，后端进</p><p>程会持有共享的 BufMappingLock。插入或删除条目时，后端进程持有独占的 BufMappingLock。</p><p>BufMappingLock 会被分成多个分区，以减少缓冲表中的争用（默认为 128 个分区）。每个 BufMappingLock 分区都保护着一部分相应</p><p>的散列桶槽。</p><p>图 8.7 是一个典型的 BufMappingLock 分区示例。两个后端进程可以同时持有各自分区的 BufMappingLock 独占锁，以便插入新的数据</p><p>项。如果 BufMappingLock 是系统级的锁，那么其中一个进程就需要等待另一个进程完成处理。</p><p><img src="/medias/image/fig-8-07.png" alt="图8.7 两个进程同时获取相应分区的 BufMappingLock独占锁，以插入新数据项"></p><p>缓冲表也需要许多其他锁。例如，在缓冲表内部使用自旋锁（spin lock）来删除数据项。然而，本章不需要这些锁的其他相关知识，因此</p><p>这里省略了对其他锁的介绍。</p><blockquote><p>在 9.4 版本之前，BufMappingLock 默认被拆分为 16 个独立的锁。</p></blockquote><h3 id="8-3-2-缓冲区描述符相关的锁"><a href="#8-3-2-缓冲区描述符相关的锁" class="headerlink" title="8.3.2 缓冲区描述符相关的锁"></a>8.3.2 缓冲区描述符相关的锁</h3><p>每个缓冲区描述符都会用到内容锁（<strong>content_lock</strong>）与IO进行锁（<strong>io_in_progress_lock</strong>）这两个轻量级锁，以控制对相应缓冲池槽页</p><p>面的访问。当检查或更改描述符本身字段的值时，就会用到自旋锁。</p><h4 id="8-3-2-1-内容锁"><a href="#8-3-2-1-内容锁" class="headerlink" title="8.3.2.1 内容锁"></a>8.3.2.1 内容锁</h4><p>内容锁（content_lock）是一个典型的强制限制访问的锁。它有共享和独占两种模式。当读取页面时，后端进程以共享模式获取页面相应</p><p>缓冲区描述符中的 content lock。执行下列操作之一时，则会获取独占模式的 content lock。</p><p>但是，在执行以下操作之一时会获得一个独占的 content_lock：</p><ul><li><p>将行（即元组）插入页面，或更改页面中元组的  t_xmin/t_xmax 字段（t_xmin 和 t_xmax 在第 5.2 节中介绍，简单地说，这些字段</p><p>会在相关元组被删除或更新行时发生更改） 。</p></li><li><p>物理移除元组，或压紧页面上的空闲空间（由清理过程和HOT执行，分别在第6章和第7章中有介绍过）。</p></li><li><p>冻结页面中的元组（冻结过程在第 5.10.1节和第 6.3节中有过介绍）。</p></li></ul><p>官方<a href="https://github.com/postgres/postgres/blob/master/src/backend/storage/buffer/README">README</a> 文件包含了更多的细节。</p><h4 id="8-3-2-2-IO进行锁"><a href="#8-3-2-2-IO进行锁" class="headerlink" title="8.3.2.2 IO进行锁"></a>8.3.2.2 IO进行锁</h4><p>IO进行锁（io_in_progress_lock） 用于等待缓冲区上的 I/O 完成。当 PostgreSQL 进程加载/写入页面数据时，该进程在访问页面期间持</p><p>有相应描述符上独占的 io_in_progress_lock。</p><h4 id="8-3-2-3-自旋锁"><a href="#8-3-2-3-自旋锁" class="headerlink" title="8.3.2.3 自旋锁"></a>8.3.2.3 自旋锁</h4><p>当检查或更改标记字段或其他字段时，例如 refcount 和 usage_count，会使用自旋锁。下面是两个使用自旋锁的具体例子：</p><ol><li><p>钉住缓冲区描述符.</p><p>获取缓冲区描述符上的自旋锁。</p><p>将其 refcount 和 usage_count 的值加1。</p><p>释放自旋锁。</p><pre class="line-numbers language-c-monosp"><code class="language-c-monosp">LockBufHdr(bufferdesc);    /* Acquire a spinlock */bufferdesc->refcont++;bufferdesc->usage_count++;UnlockBufHdr(bufferdesc); /* Release the spinlock */<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>将脏位设置为”1“。</p><p>获取缓冲区描述符上的自旋锁。</p><p>使用位操作将脏位置设置为“1”。</p><p>释放自旋锁。</p><pre class="line-numbers language-c"><code class="language-c"><span class="token macro property">#<span class="token directive keyword">define</span> BM_DIRTY             (1 &lt;&lt; 0)    </span><span class="token comment" spellcheck="true">/* 数据需要回写 */</span><span class="token macro property">#<span class="token directive keyword">define</span> BM_VALID             (1 &lt;&lt; 1)    </span><span class="token comment" spellcheck="true">/* 数据有效 */</span><span class="token macro property">#<span class="token directive keyword">define</span> BM_TAG_VALID         (1 &lt;&lt; 2)    </span><span class="token comment" spellcheck="true">/* 已经分配了TAG */</span><span class="token macro property">#<span class="token directive keyword">define</span> BM_IO_IN_PROGRESS    (1 &lt;&lt; 3)    </span><span class="token comment" spellcheck="true">/* 正在进行读写 */</span><span class="token macro property">#<span class="token directive keyword">define</span> BM_JUST_DIRTIED      (1 &lt;&lt; 5)    </span><span class="token comment" spellcheck="true">/* 开始写之后数据刚被修改 */</span><span class="token function">LockBufHdr</span><span class="token punctuation">(</span>bufferdesc<span class="token punctuation">)</span><span class="token punctuation">;</span>bufferdesc<span class="token operator">-></span>flags <span class="token operator">|</span><span class="token operator">=</span> BM_DIRTY<span class="token punctuation">;</span><span class="token function">UnlockBufHdr</span><span class="token punctuation">(</span>bufferdesc<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>其他标记位也是通过相同的方式来设置的。</p></li></ol><blockquote><p>用原子操作替换缓冲区管理器的自旋锁</p><p>在 9.6 版本中，缓冲区管理器的自旋锁将被替换为原子操作。可以参考<a href="https://commitfest.postgresql.org/9/408/">commitfest </a>中提交日志的内容。如果想了解详细信息，请参</p><p>阅<a href="http://www.postgresql.org/message-id/flat/2400449.GjM57CE0Yg@dinodell#2400449.GjM57CE0Yg@dinodell">此讨论</a>。</p></blockquote><h2 id="8-4-缓冲区管理器的工作原理"><a href="#8-4-缓冲区管理器的工作原理" class="headerlink" title="8.4 缓冲区管理器的工作原理"></a>8.4 缓冲区管理器的工作原理</h2><p>本节介绍缓冲区管理器的工作原理。当后端进程想要访问所需页面时，它会调用 <em>ReadBufferExtended</em> 函数。</p><p>函数 <em>ReadBufferExtended</em> 的行为因场景而异，在逻辑上具体可以分为三种情况。每种情况都将用一小节介绍。第8.4.4节将介绍</p><p>PostgreSOL中基于时钟扫描的页面置换算法。</p><h3 id="8-4-1-访问存储在缓冲池中的页面"><a href="#8-4-1-访问存储在缓冲池中的页面" class="headerlink" title="8.4.1 访问存储在缓冲池中的页面"></a>8.4.1 访问存储在缓冲池中的页面</h3><p>当从缓冲池槽中的页面里读取行时，PostgreSQL 进程获取相应缓冲区描述符的共享 content_lock，因而缓冲池槽可以同时被多个进程读</p><p>取。</p><p>当向页面插入（及更新、删除）行时，该 postgres 后端进程获取相应缓冲区描述符的独占 content_lock （注意，这里必须将相应页面的脏位置设为”1”）。</p><p>访问完页面后，相应缓冲区描述符的引用计数值减1。</p><p>图8.8是访问存储在缓冲池中的页面示意图。</p><p><img src="/medias/image/fig-8-08.png" alt="图8.8 访问存储在缓冲池中的页面"></p><p>我们来介绍最简单的情况，即所需页面已经存储在缓冲池中。在这种情况下，缓冲区管理器会执行以下步骤：</p><ol><li>创建所需页面的 buffer_tag（在本例中 buffer_tag 是’Tag_C’），并使用散列函数计算与描述符相对应的散列桶槽。</li><li>获取相应散列桶槽分区上的 <em>BufMappingLock</em> 共享锁。</li><li>查找标签为’Tag_C’的条目，并从条目中获取buffer_id。本例中buffer_id为2。</li><li>将buffer_id=2的缓冲区描述符钉住，即将描述符的 refcount 和usage_count增加1。</li><li>释放 BufMappingLock。</li><li>访问 bufferid=2 的缓冲池槽。</li></ol><h3 id="8-4-2-将页面从存储加载到空槽"><a href="#8-4-2-将页面从存储加载到空槽" class="headerlink" title="8.4.2 将页面从存储加载到空槽"></a>8.4.2 将页面从存储加载到空槽</h3><p>图 8.9 是将页面从存储加载到空槽的示意图。</p><p><img src="/medias/image/fig-8-09.png" alt="图8.9 将页面从存储加载到空槽"></p><p>在第二种情况下，假设所需页面不在缓冲池中，且 freelist 中有空闲元素（空描述符）。</p><p>这时，缓冲区管理器将执行以下步骤：</p><ol><li><p>查找缓冲区表（本节假设页面不存在，找不到对应页面）。</p><p>第一，创建所需页面的buffer_tag（本例中buffer_tag 为’Tag_E’）并计算其散列桶槽。</p><p>第二，以共享模式获取相应分区上的 BufMappingLock。</p><p>第三，查找缓冲区表（根据假设，这里没找到）。</p><p>第四，释放 BufMappingLock。</p></li><li><p>从 freelist 中获取空缓冲区描述符，并将其钉住。在本例中所获的描述符 buffer_id=4。</p></li><li><p>以独占模式获取相应分区的 BufMappingLock （此锁将在步骤(6)中被释放）。</p></li><li><p>创建一条新的缓冲表数据项：buffer_tag=’Tag_E，buffer id=4，并将其插入缓冲区表中。</p></li><li><p>将页面数据从存储加载至 buffer_id=4 的缓冲池槽中，如下所示:</p><p>第一，以排他模式获取相应描述符的 io_in_progress_lock。</p><p>第二，将相应描述符的 IO_IN_PROGRESS 标记位设置为1，以防其他进程访问。</p><p>第三，将所需的页面数据从存储加载到缓冲池插槽中。</p><p>第四，更改相应描述符的状态，将 IO_IN_PROGRESS 标记位设置为”0”，且VALID标记位设置为”1”。</p><p>第五，释放 io_in_progress_lock。</p></li><li><p>释放相应分区的 BufMappingLock。</p></li><li><p>访问 bufferid=4 的缓冲池槽。</p></li></ol><h3 id="8-4-3-将页面从存储加载到受害者缓冲池槽"><a href="#8-4-3-将页面从存储加载到受害者缓冲池槽" class="headerlink" title="8.4.3 将页面从存储加载到受害者缓冲池槽"></a>8.4.3 将页面从存储加载到受害者缓冲池槽</h3><p>在这种情况下，假设所有缓冲池槽位都被页面占用，且未存储所需的页面。图 8.10、图8.11是将页面从存储加载到受害者缓冲池槽的示意</p><p>图。</p><p><img src="/medias/image/fig-8-10.png" alt="图8.10 将页面从存储加载到受害者缓冲池槽"></p><p><img src="/medias/image/fig-8-11.png" alt="图8.11 将页面从存储加载到受害者缓冲池槽（接图8.10）"></p><p>缓冲区管理器将执行以下步骤：</p><ol><li><p>创建所需页面的 buffer_tag 并查找缓冲表。在本例中假设 buffer_tag 是’Tag_M’（且相应的页面在缓冲区中找不到）。</p></li><li><p>使用时钟扫描算法选择一个受害者缓冲池槽位，从缓冲表中获取包含着受害者槽位 buffer_id 的旧表项，并在缓冲区描述符层将受害</p><p>者槽位的缓冲区描述符钉住。本例中受害者槽的 buffer_id=5，旧表项为 ‘Tag_F’，id = 5。时钟扫描将在下一节介绍。</p></li><li><p>如果受害者页面是脏页，则将其刷盘（write &amp; fsnc），否则进入步骤4。</p><p>在使用新数据覆盖脏页之前，必须将脏页写入存储中。脏页的刷盘步骤如下:</p><p>第一，获取 buffer_id=5 描述符上的共享 content_lock 和独占 io_in_progress_lock 。</p><p>第二，更改相应描述符的状态：相应 IO_IN_PROCESS 位设置为”1”，JUST_DIRTIED 位设置为”0”。</p><p>第三,根据具体情况，调用 <em>XLogFlush()</em> 函数将WAL缓冲区上的 WAL数据写入当前 WAL段文件（WAL和XLogFlush函数将在第9章中介绍）。</p><p>第四，将受害者页面的数据刷盘至存储中。</p><p>第五，更改相应描述符的状态：将 IO_IN_PROCESS 位设置为”0,将VALID位设置为”1”。</p><p>第六，释放 io_in_progress_lock 和 content_lock。</p></li><li><p>以排他模式获取缓冲区表中旧表项所在分区上的 BufMappingLock。</p></li><li><p>获取新表项所在分区上的 BufMappingLock，并将新表项插入缓冲表：</p><p>第一，创建新表项：由 buffer_tag=’Tag M’与受害者的 buffer_id 组成的新表项。</p><p>第二，以独占模式获取新表项所在分区上的 BufMappingLock。</p><p>第三，将新表项插入缓冲区表中。</p></li><li><p>从缓冲表中删除旧表项，并释放旧表项所在分区的 BufMappingLock。</p></li><li><p>将目标页面数据从存储加载至受害者槽位，然后用 buffer_id=5 更新描述符的标识字段，将脏位设置为0，并按流程初始化其他标记</p><p>位。</p></li><li><p>释放新表项所在分区上的 BufMappingLock。</p></li><li><p>访问 buffer_id=5 对应的缓冲区槽位。</p></li></ol><h3 id="8-4-4-页替换算法：时钟扫描"><a href="#8-4-4-页替换算法：时钟扫描" class="headerlink" title="8.4.4 页替换算法：时钟扫描"></a>8.4.4 页替换算法：时钟扫描</h3><p>本节的其余部分介绍了 <strong>时钟扫描</strong>算法。该算法是NFU（Not Frequently Used）算法的变体，开销较低，能高效地选出较少使用的页面。</p><p>我们将缓冲区描述符想象为一个循环列表，如图8.12所示。缓冲区描述符为黑色或灰色的方框，框中的数字显示每个描述符的 </p><p>usage_count。而 nextVictimBuffer 是一个32位的无符号整型变量，它总是指向某个缓冲区描述符并按顺时针顺序旋转。</p><p><img src="/medias/image/fig-8-12.png" alt="图8.12 时钟扫描 "></p><p>伪代码：时钟扫描<br>WHILE true</p><ol><li><p>获取 nextVictimBuffer 指向的候选缓冲区描述符。</p></li><li><p>如果候选描述符未被钉住，则进入步骤3，否则进入步骤4。</p></li><li><p>如果候选描述符的 usage_count 为0，则选择该描述符对应的槽作为受害者，并进入步骤5，否则将此描述符的 usage_count 减1，</p><p>并继续执行步骤4。</p></li><li><p>将 nextVictimBuffer 迭代至下一个描述符（如果到末尾则回绕至头部）并返回步骤1，重复直到找到受害者。</p></li><li><p>返回受害者的 buffer_id。</p></li></ol><p>该算法的伪代码与算法描述如下：</p><ol><li><p>nextVictimBuffer 指向第一个描述符(buffer_id=1)，但因为该描述符被钉住了，所以跳过。</p></li><li><p>nextVictimBuffer 指向第二个描述符(buffer_id=2)，该描述符未被钉住，但其 usage_count 为2，因此该描述符的 usage_count 将减</p><p>1,而nextVictimBuffer 选代至第三个候选描述符。</p></li><li><p>nextVictimBuffer 指向第三个描述符(buffer_id=3)，该描述符未被钉住，但其 usage_count=0，因而成为本轮的受害者。</p></li><li><p>当 nextVictimBuffer 扫过未钉住的描述符时，其 usage_count 会减1。因此只要缓冲池中存在未钉住的描述符，该算法总能在旋转若于次 nextVictimBuffer 后，找到一个 usage_count 为0的受害者。</p></li></ol><h2 id="8-5-环形缓冲器"><a href="#8-5-环形缓冲器" class="headerlink" title="8.5 环形缓冲器"></a>8.5 环形缓冲器</h2><p>在读取或写入大表时，PostgreSQL会使用<strong>环形缓冲区</strong>而不是缓冲池。环形缓冲器是一个很小的临时缓冲区域。当满足下列任一条件时，</p><p>PostgreSQL 将在共享内存中分配一个环形缓冲区。</p><ol><li><p>批量读取，当扫描关系读取数据的大小超过缓冲池的四分之一时，环形缓冲区的大小为256 KB。</p></li><li><p>批量写入，当执行下列的 SQL 命令时。环形缓冲区大小为16 MB。</p><p>COPY FROM</p><p>CREATE TABLE AS</p><p>CREATE MATERIALIZED VIEW 或 REFRESH MATERIALIZED VIEW 命令</p><p>ALTER TABLE</p></li><li><p>清理过程，当自动清理守护进程执行清理过程时，环形缓冲区的大小为256 KB。</p></li></ol><p>分配的环形缓冲区将在使用后立即释放。环形缓冲区的好处显而易见，如果后端进程在不使用环形缓冲区的情况下读取大表，则所有存储</p><p>在缓冲池中的页面都会被移除，这会导致缓存命中率降低。环形缓冲区可以避免此问题。</p><blockquote><p>为什么批量读取和清理过程的默认环形缓冲区大小为256KB</p><p>源代码中缓冲区管理器目录下的 <a href="https://github.com/postgres/postgres/blob/master/src/backend/storage/buffer/README">README</a>中解释了这个问题。</p><p>顺序扫描使用 256KB的环形缓冲区，它足够小，因而能放入L2缓存中，从而使得操作系统缓存到共享缓冲区的页面传输变得高效。</p><p>通常更小一点也可以，但环形缓冲区需要足够大到能同时容纳扫描中被钉住的所有页面。</p></blockquote><h2 id="8-6-脏页刷盘"><a href="#8-6-脏页刷盘" class="headerlink" title="8.6 脏页刷盘"></a>8.6 脏页刷盘</h2><p>除了置换受害者页面之外，检查点进程和后台写入器进程也会将脏页刷盘至存储中。尽管两个进程都具有相同的功能（脏页刷盘），但是</p><p>它们有着不同的角色和行为。</p><p>检查点进程将检查点记录写入WAL段文件，并在检查点开始时进行脏页刷盘。第9.7节介绍了检查点和检查点开始的时机。</p><p>后台写入器的目的是通过少量多次的脏页刷盘，减少检查点带来的密集写入的影响。后台写入器会一点点地将脏页落盘，尽可能减少对数</p><p>据库活动造成的影响。在默认情况下，后台写入器每 200ms被唤醒一次（由参数 <code>bgwriter_delay</code> 定义），且最多刷写 </p><p><code>bgwriter_lrumaxpages</code> 个页面（默认为100个页面）。</p><blockquote><p>为什么检查点进程与后台写入器相分离</p><p>在 9.1及更低版本中，后台写入器会规律性地执行检查点进程。在 9.2 版本中，检查点进程从后台写入被单独剥离出来。原因在一篇</p><p>题为“将检查点进程与后台写入器相分离”的提案中有介绍。下面是一些摘录：</p><p>当前（在 2011 年）后台写入器进程既执行后台写入，又负责检查点，还处理一些其他的职责。这意味着我们没法在不停止后台写入</p><p>的情况下执行检查点最终的 fsync。因此，在同一个进程中做两件事会有负面的性能影响。</p><p>此外，在9.2版本中，我们的一个目标是通过将轮询循环替换为锁存器，从而降低功耗。bgwriter 中的循环复杂度太高了，以至于无</p><p>法找到一种简单的使用锁存器的方法。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> postgresql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> postgresql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>9 预写日志—WAL</title>
      <link href="/2021/9.yu-xie-ri-zhi-wal/"/>
      <url>/2021/9.yu-xie-ri-zhi-wal/</url>
      
        <content type="html"><![CDATA[<p><strong>事务日志</strong>是数据库的重要组成部分，因为所有的数据库管理系统都要求即使发生系统故障也不丢失任何数据。它是数据库系统中所有更改操作的历史日志，以确保没有由于故障（例如电源故障）或其他导致服务器崩溃的服务器故障而丢失数据。由于日志包含有关已执行的每个事务的足够信息，因此数据库服务器应该能够通过在服务器崩溃的情况下，重新回放事务日志中的更改操作来恢复数据库集群。</p><span id="more"></span><p>[TOC]</p><p>在计算机科学领域，<strong>WAL</strong>是 <strong>Write Ahead Logging</strong> 的首字母缩写，它是一种将更改操作都写入事务日志的协议或规则，而在PostgreSQL中，WAL是 <strong>Write Ahead Log</strong> 的首字母缩写。</p><p>WAL机制在7.1版本中首次实现，以减轻服务器崩溃的影响。这也成为可能的执行点即时恢复（PITR）和流复制（SR），这两者将分别在<a href="https://jinlid.github.io/2021/10-ji-chu-bei-fen-he-shi-jian-dian-hui-fu/">第10</a>和<a href="https://jinlid.github.io/2021/11-liu-fu-zhi/">第11章</a>中介绍。</p><p>尽管了解WAL机制对于使用PostgreSQL的系统集成和管理至关重要，但由于该机制的复杂性，无法对其描述进行简要总结。所以对PostgreSQL中WAL的完整解释如下：第一部分已经提供了WAL的整体图，介绍了一些重要的概念和关键词。在随后的部分中，将描述以下主题：</p><ul><li><p>WAL（事务日志）的逻辑结构和物理结构</p></li><li><p>WAL数据内部布局</p></li><li><p>WAL数据的写入</p></li><li><p>WAL写进程</p></li><li><p>检查点处理</p></li><li><p>数据库恢复处理</p></li><li><p>管理WAL段文件</p></li><li><p>连续归档</p></li></ul><h2 id="9-1-概述"><a href="#9-1-概述" class="headerlink" title="9.1 概述"></a>9.1 概述</h2><p>我们先来看看WAL机制的概况。为了澄清WAL一直在处理的问题，第一小节显示了如果PostgreSQL没有实现WAL发生崩溃时会发生什么，第二小节介绍了一些关键概念，并展示了本章主要主题的概述、WAL数据的编写和数据库恢复处理。最后一小节完成了WAL的概述，添加了另一个关键概念。</p><p>在本节中，为了简化描述，使用了仅包含一页的表TABLE_A。</p><h3 id="9-1-1-没有-WAL-的插入操作"><a href="#9-1-1-没有-WAL-的插入操作" class="headerlink" title="9.1.1 没有 WAL 的插入操作"></a>9.1.1 没有 WAL 的插入操作</h3><p>如<a href="https://jinlid.github.io/2021/8.huan-chong-qu-guan-li-qi/">第 8 章</a>所述，为了提供对关系页面的高效访问，每个DBMS都实现了共享缓冲池。</p><p>假设我们在没有实现WAL特性的PostgreSQL上的TABLE_A中插入了一些数据元组；这种情况如图 9.1 所示。</p><p><img src="/medias/image/fig-9-01.png" alt="图 9.1 没有 WAL 的插入操作"></p><p>(1) 发出第一条INSERT语句，PostgreSQL将TABLE_A的页面从数据库集群加载到内存共享缓冲池中，并在页面中插入一个元组。该页面不会立即写入数据库集群。（修改后的页面通常称为<strong>脏页</strong>）</p><p>(2) 发出第二条INSERT语句，PostgreSQL在缓冲池上的页中插入一个新元组。此页尚未写入存储。</p><p>(3) 如果操作系统或PostgreSQL服务器因停电等任何原因出现故障，所有插入的数据都会丢失。</p><p>因此，没有WAL的数据库容易受到系统故障的影响。</p><blockquote><p>在引入 WAL 之前，PostgreSQL通过在每次更改内存中的页面时发出同步系统调用来同步写入磁盘，以确保持久性。因此，INSERT和UPDATE等修改命令的性能非常差。</p></blockquote><h3 id="9-1-2-插入操作和数据库恢复"><a href="#9-1-2-插入操作和数据库恢复" class="headerlink" title="9.1.2 插入操作和数据库恢复"></a>9.1.2 插入操作和数据库恢复</h3><p>为了在不影响性能的情况下处理上述系统故障，PostgreSQL支持WAL。</p><p>PostgreSQL将所有的修改作为历史数据写入持久存储，为失败做准备。在PostgreSQL中，历史数据被称为<strong>XLOG记录</strong>或<strong>WAL数据</strong>。</p><p>XLOG记录通过插入、删除或提交等更改操作写入内存中的<strong>WAL缓冲区</strong>。当事务提交/中止时，它们会立即写入存储上的<strong>WAL段文件</strong>（准确的说，XLOG记录的写入可能在其他情况下发生，具体将在<a href="https://jinlid.github.io/2021/9.yu-xie-ri-zhi-wal#_9.5">9.5 节</a>中描述）。XLOG 记录的<strong>LSN</strong>（日志序列号，LSN用作记录XLOG中的唯一ID）表示其记录在事务日志上的写入位置。</p><p>当我们考虑数据库系统如何恢复时，可能会有一个问题；PostgreSQL从什么时候开始恢复？答案是<strong>REDO点</strong>；也就是最近一次<strong>checkpoint</strong>启动时写入XLOG记录的位置（PostgreSQL中的checkpoint在<a href="https://jinlid.github.io/2021/9.yu-xie-ri-zhi-wal#_9.7">9.7节</a>有介绍）。事实上，数据库恢复处理与检查点处理密切相关，这两者是密不可分的。</p><blockquote><p>WAL和checkpoint进程在7.1版本中同时实现。</p></blockquote><p>主要关键字和概念的介绍刚刚结束，下面就是用WAL插入元组的说明，参见图9.2和以下说明。（另请参阅<a href="http://www.slideshare.net/suzuki_hironobu/fig-902">此幻灯片</a>）</p><p><img src="/medias/image/fig-9-02.png" alt="图 9.2 使用 WAL 进行插入操作"></p><p>符号 <code>TABLE_A's LSN</code> 显示了 TABLE_A 的页头中 <code>pd_lsn</code> 的值，<code>page's LSN</code> 一样。</p><p>(1) checkpointer，一个后台进程，周期性地执行checkpoint。每当检查点启动时，它都会将一个名为检查点的XLOG记录写入当前WAL段，该记录包含最新REDO点的位置。</p><p>(2) 发出第一条INSERT语句，PostgreSQL将 TABLE_A 的页面加载到共享缓冲池中，在页面中插入一个元组，在位置 <code>LSN_1</code> 处创建并写入这条语句的XLOG记录到WAL缓冲区，并更新 TABLE_A 的 LSN从 <code>LSN_0</code> 到 <code>LSN_1</code>。</p><p>在这个例子中，这个XLOG记录的是<strong>一对header-data和完整元组</strong>。</p><p>(3) 当这个事务提交时，PostgreSQL会创建这个提交操作的XLOG记录并将其写入WAL缓冲区，然后，将WAL缓冲区上的所有XLOG记录写入 <code>LSN_1</code> 并刷新到WAL段文件。</p><p>(4) 发出第二条INSERT语句，PostgreSQL在页面中插入一个新的元组，创建这个元组的XLOG记录并将其写入 <code>LSN_2</code> 处的WAL缓冲区，并将 TABLE_A 的 LSN 从 <code>LSN_1</code> 更新为 <code>LSN_2</code>。</p><p>(5) 当这条语句的事务提交时，PostgreSQL以与步骤(3) 中相同的方式进行操作。</p><p>(6) 想象一下，什么时候可能发生系统故障。即使共享缓冲池上的所有数据都丢失了，页面的所有修改也已作为历史数据写入WAL段文件。</p><p>以下说明显示了如何将我们的数据库集群恢复到崩溃前的状态。不需要做任何特别的事情，因为PostgreSQL会通过重新启动自动进入恢复模式。参见图 9.3（和这张<a href="http://www.slideshare.net/suzuki_hironobu/fig-903">幻灯片</a>）。PostgreSQL将从REDO点依次读取和重放相应 WAL段文件中的XLOG记录。</p><p><img src="/medias/image/fig-9-03.png" alt="图 9.3 使用 WAL 进行数据库恢复"></p><p>(1) PostgreSQL从相应的WAL段文件中读取第一个INSERT语句的XLOG记录，将 TABLE_A 的页面从数据库集群加载到共享缓冲池中。</p><p>(2) 在尝试重放XLOG记录之前，PostgreSQL会比较XLOG记录的LSN与对应页面的LSN，原因将在<a href="https://jinlid.github.io/2021/9.yu-xie-ri-zhi-wal#_9.8">9.8 节</a>中说明。重放XLOG记录的规则如下所示：</p><p>如果XLOG记录的LSN大于页面的LSN，则将XLOG记录的数据部分插入到页面中，并将页面的LSN更新为 XLOG记录的LSN。如果XLOG记录的LSN较小，则读取下一个WAL数据。</p><p>在此示例中，由于XLOG记录的LSN ( <code>LSN_1</code> ) 大于 TABLE_A 的LSN ( <code>LSN_0</code> )，因此重放 XLOG记录；然后，TABLE_A 页面更改到<code>LSN_1</code>。</p><p>(3) PostgreSQL以同样的方式重放剩余的XLOG记录。</p><p>PostgreSQL通过按照这种时间顺序的方式重放WAL段文件的XLOG记录来恢复自身，显然，PostgreSQL的XLOG记录的是<strong>REDO log</strong>。</p><blockquote><p>PostgreSQL不支持UNDO日志。</p><p>虽然写XLOG记录肯定要花费一定的成本，但与写整个修改过的页面相比，这不算什么。</p></blockquote><h3 id="9-1-3-整页写入"><a href="#9-1-3-整页写入" class="headerlink" title="9.1.3 整页写入"></a>9.1.3 整页写入</h3><p>如果操作系统发生故障，假设存储上 TABLE_A 的页面数据已损坏，而后台写入进程一直在写入脏页面，由于无法在损坏的页面上重放XLOG记录，我们需要一个额外的功能。</p><p>PostgreSQL支持称为<strong>整页写入</strong>的功能来处理此类故障。如果启用，PostgreSQL在每个检查点后每个页面的第一次更改期间，写入一对<strong>header-data和整个页面</strong>作为XLOG记录，默认启用。在PostgreSQL中，这样一个包含整个页面的XLOG记录被称为<strong>备份块</strong>。</p><p>启用了整页写入，让我们再次描述元组的插入。参见图 9.4 和以下说明。</p><p><img src="/medias/image/fig-9-04.png" alt="图 9.4 整页写"></p><p>(1) checkpointer启动一个checkpoint进程。</p><p>(2) 在第一条INSERT语句的插入中，虽然PostgreSQL的操作方式和上一小节几乎一样，但是这个XLOG记录是这个页面的备份块（即它包含了整个页面），因为这是在最新的检查点之后第一次写入此页面。</p><p>(3) 当这个事务提交时，PostgreSQL以与上一小节相同的方式运行。</p><p>(4) 在第二条INSERT语句的插入中，由于这条XLOG记录不是备份块，PostgreSQL的操作方式与上一小节相同。</p><p>(5) 当这条语句的事务提交时，PostgreSQL以与上一小节相同的方式运行。</p><p>(6) 为了证明整页写入的有效性，这时我们考虑在后台写入器一直将脏页面写入硬盘时，由于操作系统发生故障，存储上的 TABLE_A 页面已损坏的情况。</p><p>重启PostgreSQL服务器以修复损坏的集群，参见图 9.5 和以下说明。</p><p><img src="/medias/image/fig-9-05.png" alt="图 9.5 使用备份块进行数据库恢复"></p><p>(1) PostgreSQL读取第一个INSERT语句的XLOG记录，并将损坏的 TABLE_A 页面从数据库集群加载到共享缓冲池中。在这个例子中，XLOG记录是一个备份块，因为按照整页写的写规则，每页的第一个XLOG记录总是它的备份块。</p><p>(2) 当一个XLOG记录是它的备份块时，应用另一个重放规则：不管两个LSN的值如何，记录的数据部分（即页面本身）都将被覆盖到页面上，并且页面的LSN更新到XLOG记录的LSN。</p><p>在此示例中，PostgreSQL将记录的数据部分覆盖到损坏的页面，并将 TABLE_A 的LSN更新为 <code>LSN_1</code> 。通过这种方式，损坏的页面由其备份块恢复。</p><p>(3) 由于第二条XLOG记录是一个非备份块，PostgreSQL的操作方式与上一小节中的指令相同。</p><p>即使发生了一些数据写入失败，PostgreSQL也可以恢复（当然，如果发生文件系统或媒体故障，则这不适用）。</p><h2 id="9-2-事务日志和WAL段文件"><a href="#9-2-事务日志和WAL段文件" class="headerlink" title="9.2 事务日志和WAL段文件"></a>9.2 事务日志和WAL段文件</h2><p>从逻辑上讲，PostgreSQL将XLOG记录写入事务日志中，事务日志是一个8字节长（16 ExaByte）的虚拟文件。</p><p>由于事务日志的容量实际上是无限的，因此可以说8字节的地址空间足够大，我们不可能处理8字节长度的容量的文件。因此，PostgreSQL中的事务日志默认分为16 MB的文件，每个文件称为<strong>WAL段</strong>，参见图 9.6。</p><p><strong>WAL段文件大小</strong></p><blockquote><p>在版本11或更高版本中，当通过initdb命令创建PostgreSQL集群时，可以使用<a href="https://www.postgresql.org/docs/11/static/app-initdb.html">–wal-segsize</a>选项配置 WAL 段文件的大小。</p></blockquote><p><img src="/medias/image/fig-9-06.png" alt="图 9.6 事务日志和 WAL 段文件"></p><p>WAL段文件名是16进制的 24 位数字，命名规则如下：</p><p>WAL segment file name=timelineId+(uint32)LSN−116M∗256+(uint32)(LSN−116M)%256</p><p><strong>时间线ID</strong></p><p>PostgreSQL的WAL包含<strong>时间线ID</strong>（4 字节无符号整数）的概念，用于<a href="https://jinlid.github.io/2021/10-ji-chu-bei-fen-he-shi-jian-dian-hui-fu/">第 10 章</a> 中描述的时间点恢复（PITR）。</p><p>第一个WAL段文件是 00000001 00000000 00000001。如果第一个已被写入XLOG记录，则将提供第二个 00000001 00000000 00000002。后继文件按升序依次使用，00000001 00000000 000000FF填满后，将提供下一个00000001 00000001 00000000。这样，每当最后2位结转时，中间的8位数字就加一，依此类推。</p><p><em>pg_xlogfile_name / pg_walfile_name</em></p><p>使用内置函数<em>pg_xlogfile_name</em>（版本 9.6 或更早版本）或<em>pg_walfile_name</em>（版本 10 或更高版本），我们可以找到包含指定LSN的WAL段文件名，一个例子如下所示：</p><pre class="line-numbers language-bash"><code class="language-bash">testdb<span class="token operator">=</span><span class="token comment" spellcheck="true"># SELECT pg_xlogfile_name('1/00002D3E');  # In version 10 or later, "SELECT pg_walfile_name('1/00002D3E');"</span>     pg_xlogfile_name     -------------------------- 000000010000000100000000<span class="token punctuation">(</span>1 row<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="9-3-WAL段内部布局"><a href="#9-3-WAL段内部布局" class="headerlink" title="9.3 WAL段内部布局"></a>9.3 WAL段内部布局</h2><p>默认情况下，WAL段是一个16MB的文件，它在内部被分成8192字节 (8KB) 的页面。第一个页面具有由结构 <em>XLogLongPageHeaderData</em>定义的标题数据，而所有其他页面的标题由结构 <em>XLogPageHeaderData</em> 定义的页面信息。在页头之后，XLOG记录从头开始按降序写入每一页。参见图9.7。</p><p><img src="/medias/image/fig-9-07.png" alt="图 9.7 WAL 段文件的内部布局"></p><p>结构体 XLogLongPageHeaderData 和XLogPageHeaderData在<a href="https://github.com/postgres/postgres/blob/master/src/include/access/xlog_internal.h">src/include/access/xlog_internal.h</a>中定义。因为以下介绍中不需要这两种结构，所以省略了对这两种结构的解释。</p><h2 id="9-4-XLOG-Record的内部布局"><a href="#9-4-XLOG-Record的内部布局" class="headerlink" title="9.4 XLOG Record的内部布局"></a>9.4 XLOG Record的内部布局</h2><p>XLOG Record包括通用标题部分和每个相关联的数据部分。第一部分描述头结构，剩下的两个小节分别解释了9.4或更早版本和9.5版本中数据部分的结构（数据格式在9.5版本中发生了变化）。</p><h3 id="9-4-1-XLOG-Record的头部分"><a href="#9-4-1-XLOG-Record的头部分" class="headerlink" title="9.4.1 XLOG Record的头部分"></a>9.4.1 XLOG Record的头部分</h3><p>所有XLOG记录都有一个由结构体 <code>XLogRecord</code> 定义的通用头部分。在9.4及更早版本的结构体如下所示，在9.5版本中有所更改。</p><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">typedef</span> <span class="token keyword">struct</span> XLogRecord<span class="token punctuation">{</span>   uint32          xl_tot_len<span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">/* total len of entire record */</span>   TransactionId   xl_xid<span class="token punctuation">;</span>       <span class="token comment" spellcheck="true">/* xact id */</span>   uint32          xl_len<span class="token punctuation">;</span>       <span class="token comment" spellcheck="true">/* total len of rmgr data */</span>   uint8           xl_info<span class="token punctuation">;</span>      <span class="token comment" spellcheck="true">/* flag bits, see below */</span>   RmgrId          xl_rmid<span class="token punctuation">;</span>      <span class="token comment" spellcheck="true">/* resource manager for this record */</span>   <span class="token comment" spellcheck="true">/* 2 bytes of padding here, initialize to zero */</span>   XLogRecPtr      xl_prev<span class="token punctuation">;</span>      <span class="token comment" spellcheck="true">/* ptr to previous record in log */</span>   pg_crc32        xl_crc<span class="token punctuation">;</span>       <span class="token comment" spellcheck="true">/* CRC for this record */</span><span class="token punctuation">}</span> XLogRecord<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>除了两个变量，大部分变量都是显而易见的，不需要描述。</p><p><strong>xl_rmid</strong>和<strong>xl_info</strong>是相关变量的资源管理器，这是与WAL相关的操作集合的写入及XLOG记录重放功能等。资源管理器的数量随着每个PostgreSQL版本的增加而增加，版本10包含以下内容：</p><table><thead><tr><th align="left">Operation</th><th align="left">Resource manager</th></tr></thead><tbody><tr><td align="left">Heap tuple operations</td><td align="left">RM_HEAP, RM_HEAP2</td></tr><tr><td align="left">Index operations</td><td align="left">RM_BTREE, RM_HASH, RM_GIN, RM_GIST, RM_SPGIST, RM_BRIN</td></tr><tr><td align="left">Sequence operations</td><td align="left">RM_SEQ</td></tr><tr><td align="left">Transaction operations</td><td align="left">RM_XACT, RM_MULTIXACT, RM_CLOG, RM_XLOG, RM_COMMIT_TS</td></tr><tr><td align="left">Tablespace operations</td><td align="left">RM_SMGR, RM_DBASE, RM_TBLSPC, RM_RELMAP</td></tr><tr><td align="left">replication and hot standby operations</td><td align="left">RM_STANDBY, RM_REPLORIGIN, RM_GENERIC_ID, RM_LOGICALMSG_ID</td></tr></tbody></table><p>以下是资源管理器在以下工作方式的一些代表性示例：</p><ul><li><p>如果发出INSERT语句，则其XLOG记录的头变量 <code>xl_rmid</code> 和 <code>xl_info</code> 分别设置为<code>RM_HEAP</code> 和<code>XLOG_HEAP_INSERT</code>。恢复数据库集群时，根据 <code>xl_info</code> 选择的 <code>RM_HEAP</code> 的函数 <em>heap_xlog_insert()</em> 重放这条XLOG记录。</p></li><li><p>UPDATE语句类似，但XLOG记录的头变量 <code>xl_info</code> 设置为 <code>XLOG_HEAP_UPDATE</code>，并且 <code>RM_HEAP</code> 的函数 <em>heap_xlog_update()</em> 在数据库恢复时重放其记录。</p></li><li><p>当事务提交时，其XLOG记录的头变量 <code>xl_rmid</code> 和 <code>xl_info</code> 分别设置为 <code>RM_XACT</code> 和<code>XLOG_XACT_COMMIT</code>。在恢复数据库集群时，函数 <em>xact_redo_commit()</em> 会重放这条记录。</p></li></ul><p>在 9.5 或更高版本中， XLogRecord结构体删除了一个变量 (xl_len) 以优化XLOG记录格式，从而将大小减少了几个字节。</p><p>XLogRecord结构体在9.4或更早版本<a href="https://github.com/postgres/postgres/blob/REL9_4_STABLE/src/include/access/xlog.h">src/include/access/xlog.h</a>中定义，9.5或更高版本在<a href="https://github.com/postgres/postgres/blob/master/src/include/access/xlogrecord.h">src/include/access/xlogrecord.h</a>中定义。</p><p><em>heap_xlog_insert</em> 和 <em>heap_xlog_update</em> 在<a href="https://github.com/postgres/postgres/blob/master/src/backend/access/heap/heapam.c">src/backend/access/heap/heapam.c </a>中定义；而函数 <em>xact_redo_commit</em> 在<a href="https://github.com/postgres/postgres/blob/master/src/backend/access/transam/xact.c">src/backend/access/transam/xact.c</a>中定义。</p><h3 id="9-4-2-XLOG-Record的数据部分（9-4-或更早版本）"><a href="#9-4-2-XLOG-Record的数据部分（9-4-或更早版本）" class="headerlink" title="9.4.2 XLOG Record的数据部分（9.4 或更早版本）"></a>9.4.2 XLOG Record的数据部分（9.4 或更早版本）</h3><p>XLOG Record的数据部分分为备份块（整页）和非备份块（按不同数据操作）。</p><p><img src="/medias/image/fig-9-08.png" alt="图 9.8 XLOG 记录示例（9.4 或更早版本）"></p><p>XLOG Record的内部布局在下面使用一些具体示例进行描述。</p><h4 id="9-4-2-1-备份块"><a href="#9-4-2-1-备份块" class="headerlink" title="9.4.2.1 备份块"></a>9.4.2.1 备份块</h4><p>备份块如图 9.8(a) 所示。它由两个数据结构和一个数据对象组成，如下所示：</p><ol><li><p>XLogRecord结构体（头部分）</p></li><li><p>BkpBlock结构体</p></li><li><p>除了FSM之外的整个页面</p></li></ol><p>该BkpBlock包含数据库集群中找出这个页面的变量（即包含此页面的关系的<code>relfilenode</code>和叉号，和这个页面的块号），开始位置，这个页面上的可用空间的长度。</p><h4 id="9-4-2-2-非备份块"><a href="#9-4-2-2-非备份块" class="headerlink" title="9.4.2.2 非备份块"></a>9.4.2.2 非备份块</h4><p>在非备份块中，数据部分的布局因每个操作而异。这里，以INSERT语句的XLOG记录为例进行说明。见图9.8(b)。在这种情况下，INSERT语句的XLOG记录由两个数据结构和一个数据对象组成，如下所示：</p><ol><li><p>XLogRecord结构体（头部分）</p></li><li><p>xl_heap_insert结构体</p></li><li><p>插入的元组–准确地说，从元组中删除了几个字节</p></li></ol><p>结构体 <code>xl_heap_insert</code> 包含用于标识数据库集群中插入的元组的变量（即包含该元组的表的<em>relfilenode</em>以及该元组的<em>tid</em>），以及该元组的<strong>可见性标志</strong>。</p><p>从插入的元组中删除几个字节的原因在<code>xl_heap_header</code>结构体的源代码注释中有描述：</p><blockquote><p>我们不会在WAL中存储插入或更新的元组的整个固定部分（HeapTupleHeaderData）；我们可以通过重构WAL记录中其他地方可用的字段来节省一些字节，或者可能只是不需要重构。</p></blockquote><p>Checkpoint记录的XLOG记录很简单，见图 9.8(c)。它由两种数据结构组成，如下所示：</p><ol><li><p>XLogRecord结构体（头部分）</p></li><li><p>包含检查点信息的检查点结构（请参阅<a href="https://jinlid.github.io/2021/9.yu-xie-ri-zhi-wal/#_9.7">第 9.7 节</a>中的更多详细信息）</p></li></ol><p><code>xl_heap_header</code>结构体在<a href="https://github.com/postgres/postgres/blob/master/src/include/access/htup.h">src/include/access/htup.h</a>中定义，而CheckPoint结构体在<a href="https://github.com/postgres/postgres/blob/master/src/include/catalog/pg_control.h">src/include/catalog/pg_control.h</a>中定义。</p><h3 id="9-4-3-XLOG-Record的数据部分（9-5-或更高版本）"><a href="#9-4-3-XLOG-Record的数据部分（9-5-或更高版本）" class="headerlink" title="9.4.3 XLOG Record的数据部分（9.5 或更高版本）"></a>9.4.3 XLOG Record的数据部分（9.5 或更高版本）</h3><p>在 9.4 或更早的版本中，XLOG 记录没有通用的格式，因此每个资源管理器都必须定义自己的格式。在这种情况下，维护源代码和实现与 WAL 相关的新功能变得越来越困难。为了解决这个问题，9.5 版本中引入了一种不依赖于资源管理器的通用结构化格式。</p><p>XLOG 记录的数据部分可以分为两部分：头部和数据。见图 9.9。</p><p><img src="/medias/image/fig-9-09.png" alt="图 9.9 常见的 XLOG 记录格式"></p><p>Header 部分包含零个或多个 <code>XLogRecordBlockHeaders</code> 和零个或一个<code>XLogRecordDataHeaderShort</code>（或 XLogRecordDataHeaderLong）；它必须至少包含其中之一。当其记录存储整页图像（即备份块）时， <code>XLogRecordBlockHeader</code> 包括<code>XLogRecordBlockImageHeader</code>，如果其块被压缩，则还包括 <code>XLogRecordBlockCompressHeader</code>。</p><p>数据部分由零个或多个块数据和零个或一个主数据组成，分别对应于 <code>XLogRecordBlockHeader(s)</code> 和 <code>XLogRecordDataHeader</code>。</p><p><strong>WAL 压缩</strong></p><p>在 9.5 或更高版本中，可以通过设置参数（ <code>wal_compression=enable</code> ）使用 LZ 压缩方法压缩 XLOG 记录中的整页图像。在这种情况下，将添加结构 <code>XLogRecordBlockCompressHeader</code>。</p><p>此功能有两个优点和一个缺点。优点是减少写入记录的 I/O 成本并抑制 WAL 段文件的消耗。缺点是需要消耗大量 CPU 资源进行压缩。</p><p><img src="/medias/image/fig-9-10.png" alt="图 9.10 XLOG 记录示例（9.5 版或更高版本）"></p><p>下面显示了一些具体示例，如上一小节所示。</p><h4 id="9-4-3-1-备份块"><a href="#9-4-3-1-备份块" class="headerlink" title="9.4.3.1 备份块"></a>9.4.3.1 备份块</h4><p>INSERT 语句创建的备份块如图 9.10(a)所示。它由四种数据结构和一个数据对象组成，如下所示：</p><ol><li><p>XLogRecord结构体（头部分）</p></li><li><p>XLogRecordBlockHeader结构体包括一个 XLogRecordBlockImageHeader</p></li><li><p>XLogRecordDataHeaderShort结构体</p></li><li><p>一个备份块（块数据）</p></li><li><p>xl_heap_insert结构体（主数据）</p></li></ol><p>XLogRecordBlockHeader 包含用于标识数据库集群中的块的变量（relfilenode<em>、</em>分叉号<em>和</em>块号）；XLogRecordImageHeader 包含这个块的长度和偏移量（这两个头结构一起可以存储9.4版本之前使用的BkpBlock的相同数据）。</p><p>XLogRecordDataHeaderShort 存储 xl_heap_insert结构体的长度，它是记录的主要数据。</p><p>包含整页图像的 XLOG 记录的主要数据，除了在某些特殊情况下（例如在逻辑解码和推测插入中）外不使用。重放这条记录时忽略它，这是冗余数据，将来可能会改进。</p><p>此外，备份块记录的主要数据取决于创建它们的语句。例如，UPDATE 语句附加 <code>xl_heap_lock</code>或 <code>xl_heap_updated</code>。</p><h4 id="9-4-3-2-非备份块"><a href="#9-4-3-2-非备份块" class="headerlink" title="9.4.3.2 非备份块"></a>9.4.3.2 非备份块</h4><p>接下来，将描述由 INSERT 语句创建的非备份块记录（另请参见图 9.10（b））。它由四种数据结构和一个数据对象组成，如下所示：</p><ol><li><p>XLogRecord结构体（头部分）</p></li><li><p>XLogRecordBlockHeader结构体</p></li><li><p>XLogRecordDataHeaderShort结构体</p></li><li><p>插入的元组（准确地说，是一个xl_heap_header结构体和一个插入的数据整体）</p></li><li><p>xl_heap_insert结构体（主数据）</p></li></ol><p>XLogRecordBlockHeader 包含三个值（relfilenode<em>、</em>fork number和block number）来指定插入元组的块，以及插入元组的数据部分的长度。XLogRecordDataHeaderShort 包含新的xl_heap_insert结构体的长度，是这条记录的主要数据。</p><p>新的xl_heap_insert只包含两个值：<strong>块内此元组的偏移量</strong>和<strong>可见性标志</strong>；它变得非常简单，因为 XLogRecordBlockHeader 存储了旧数据中包含的大部分数据。</p><p>作为最后一个例子，检查点记录如图 9.10(c) 所示。它由三个数据结构组成，如下所示：</p><ol><li><p>XLogRecord结构体（头部分）</p></li><li><p>XLogRecordDataHeaderShort结构体包含主数据长度</p></li><li><p>CheckPoint结构体（主数据）</p></li></ol><p>xl_heap_header结构体定义在<a href="https://github.com/postgres/postgres/blob/master/src/include/access/htup.h">src/include/access/htup.h</a>中，CheckPoint结构体定义在<a href="https://github.com/postgres/postgres/blob/master/src/include/catalog/pg_control.h">src/include/catalog/pg_control.h</a>中。</p><p>虽然新的格式对我们来说有点复杂，但它是为资源管理器的解析器设计的，而且许多类型的 XLOG 记录的大小通常比以前的要小。主要结构尺寸见图9.8 和 9.10，因此您可以计算这些记录的大小并相互比较（新检查点的大小比前一个大，但包含更多变量）。</p><h2 id="9-5-XLOG-记录的编写"><a href="#9-5-XLOG-记录的编写" class="headerlink" title="9.5 XLOG 记录的编写"></a>9.5 XLOG 记录的编写</h2><p>完成了热身练习，现在我们可以开始理解XLOG记录的编写了。因此，我将在本节中尽可能准确地解释它。</p><p>首先，发出以下语句来探索PostgreSQL内部：</p><pre class="line-numbers language-bash"><code class="language-bash">testdb<span class="token operator">=</span><span class="token comment" spellcheck="true"># INSERT INTO tbl VALUES ('A');</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>通过发出上述语句，调用内部函数 <em>exec_simple_query()<em>；</em>exec_simple_query()</em> 的伪代码如下所示：</p><pre class="line-numbers language-c"><code class="language-c"><span class="token function">exec_simple_query</span><span class="token punctuation">(</span><span class="token punctuation">)</span> @postgres<span class="token punctuation">.</span><span class="token function">c</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token function">ExtendCLOG</span><span class="token punctuation">(</span><span class="token punctuation">)</span> @clog<span class="token punctuation">.</span>c                  <span class="token comment" spellcheck="true">/* Write the state of this transaction                                           * "IN_PROGRESS" to the CLOG.                                           */</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span> <span class="token function">heap_insert</span><span class="token punctuation">(</span><span class="token punctuation">)</span>@heapam<span class="token punctuation">.</span>c                <span class="token comment" spellcheck="true">/* Insert a tuple, creates a XLOG record,                                           * and invoke the function XLogInsert.                                           */</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span> <span class="token function">XLogInsert</span><span class="token punctuation">(</span><span class="token punctuation">)</span> @xlog<span class="token punctuation">.</span><span class="token function">c</span> <span class="token punctuation">(</span><span class="token number">9.5</span> or later<span class="token punctuation">,</span> xloginsert<span class="token punctuation">.</span>c<span class="token punctuation">)</span>                                          <span class="token comment" spellcheck="true">/* Write the XLOG record of the inserted tuple                                           *  to the WAL buffer, and update page's pd_lsn.                                           */</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span> <span class="token function">finish_xact_command</span><span class="token punctuation">(</span><span class="token punctuation">)</span> @postgres<span class="token punctuation">.</span>c     <span class="token comment" spellcheck="true">/* Invoke commit action.*/</span>         <span class="token function">XLogInsert</span><span class="token punctuation">(</span><span class="token punctuation">)</span> @xlog<span class="token punctuation">.</span><span class="token function">c</span>  <span class="token punctuation">(</span><span class="token number">9.5</span> or later<span class="token punctuation">,</span> xloginsert<span class="token punctuation">.</span>c<span class="token punctuation">)</span>                                          <span class="token comment" spellcheck="true">/* Write a XLOG record of this commit action                                            * to the WAL buffer.                                           */</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span> <span class="token function">XLogWrite</span><span class="token punctuation">(</span><span class="token punctuation">)</span> @xlog<span class="token punctuation">.</span>c                   <span class="token comment" spellcheck="true">/* Write and flush all XLOG records on                                            * the WAL buffer to WAL segment.                                           */</span><span class="token punctuation">(</span><span class="token number">6</span><span class="token punctuation">)</span> <span class="token function">TransactionIdCommitTree</span><span class="token punctuation">(</span><span class="token punctuation">)</span> @transam<span class="token punctuation">.</span>c  <span class="token comment" spellcheck="true">/* Change the state of this transaction                                            * from "IN_PROGRESS" to "COMMITTED" on the CLOG.                                           */</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在下面的段落中，将解释每一行伪代码以理解XLOG记录的写入，另请参见图9.11和9.12。</p><p>(1) <em>ExtendCLOG()</em> 函数将这个事务<code>IN_PROGRESS</code>的状态写入CLOG（内存中）。</p><p>(2) <em>heap_insert()</em> 函数在共享缓冲池上的目标页中插入一个堆元组，创建该页的XLOG记录，并调用 <em>XLogInsert()</em> 函数。</p><p>(3) XLogInsert() 函数在 <code>LSN_1</code>写出由 <em>heap_insert()</em> 创建的XLOG记录到WAL缓冲区，然后更新页面的pd_lsn从<code>LSN_0</code>更改为<code>LSN_1</code>。</p><p>(4) 调用 <em>finish_xact_command()</em> 函数提交此事务，创建该提交动作的XLOG记录，然后在<code>LSN_2</code> 将 <em>XLogInsert()</em> 函数的记录写入到在WAL缓冲区。</p><p><img src="/medias/image/fig-9-11.png" alt="图 9.11 XLOG 记录的写入序列"></p><p>这些 XLOG记录的格式为9.4版。</p><p>(5) <em>XLogWrite()</em> 函数将WAL缓冲区上的所有XLOG记录写入并刷新到WAL段文件中。</p><p>如果参数 <code>wal_sync_method</code>设置为<code>open_sync</code> 或 <code>open_datasync</code>，则记录被同步写入，因为该函数使用 <em>open()</em> 系统调用指定标志<code>O_SYNC</code>或<code>O_DSYNC</code>写入所有记录。如果参数设置为<code>fsync</code>、<code>fsync_writethrough</code>或<code>fdatasync</code>，则相应的系统调用 – *fsync()<em>、</em>fcntl()<em>和 <code>F_FULLFSYNC</code> 选项或</em>fdatasync()*——将被处理。在任何情况下，都确保所有XLOG记录都写入存储。</p><p>(6) *TransactionIdCommitTree()*函数将CLOG上的此事务的状态从<code>N_PROGRESS</code>更改为<code>COMMITTED</code>。</p><p><img src="/medias/image/fig-9-12.png" alt="图 9.12 XLOG 记录的写入顺序（接图 9.11）"></p><p>在上面的例子中，commit动作导致了XLOG记录写入WAL段，但是当发生以下任何一种情况时，也会导致这种写入：</p><ol><li><p>一个正在运行的事务已提交或已中止。</p></li><li><p>WAL缓冲区已经填满了许多已写入的元组（WAL缓冲区大小设置为参数<a href="https://www.postgresql.org/docs/current/static/runtime-config-wal.html#GUC-WAL-BUFFERS">wal_buffers</a>）。</p></li><li><p>WAL writer进程定期写入。</p></li></ol><p>如果发生上述之一，则WAL缓冲区上的所有WAL记录都将写入WAL段文件，无论它们的事务是否已提交。</p><p>DML（数据操作语言）操作写入XLOG记录是理所当然的，但非DML操作也是如此。如上所述，提交操作写入包含已提交事务id的XLOG记录。另一个示例可能是检查点操作，用于写入包含此检查点的基本信息的XLOG记录。此外，SELECT语句在特殊情况下会创建XLOG记录，尽管通常不会创建。例如，如果HOT(Heap Only Tuple)在SELECT语句处理过程中删除了不必要的元组并对页面中的必要元组进行碎片整理，则将修改页面的XLOG记录写入WAL缓冲区。</p><h2 id="9-6-WAL写入进程"><a href="#9-6-WAL写入进程" class="headerlink" title="9.6 WAL写入进程"></a>9.6 WAL写入进程</h2><p>WAL writer是一个后台进程，它会定期检查WAL缓冲区并将所有未写入的XLOG记录写入WAL段。这个过程的目的是为了避免XLOG记录的突发写入。如果没有开启这个进程，当一次提交大量数据时，XLOG记录的写入可能会遇到瓶颈。</p><p>WAL writer默认工作，不能被禁用。检查间隔设置为配置参数 <code>wal_writer_delay</code>，默认值为200毫秒。</p><h2 id="9-7-PostgreSQL中的检查点处理"><a href="#9-7-PostgreSQL中的检查点处理" class="headerlink" title="9.7 PostgreSQL中的检查点处理"></a>9.7 PostgreSQL中的检查点处理</h2><p>在PostgreSQL中，checkpointer（后台）进程执行checkpoint；当以下情况之一发生时，其进程开始：</p><ol><li><p>参数<code>checkpoint_timeout</code> 设置的间隔时间自上一个检查点已经过去（默认间隔为5 分钟）。</p></li><li><p>在9.4或更早版本中，参数 <code>checkpoint_segments</code> 设置的WAL段文件的数量（默认数量为 3）自上一个检查点以来已被消耗。</p></li><li><p>在9.5或更高版本中，pg_xlog中的WAL段文件的总大小已超过参数 <code>max_wal_size</code> 的值（默认值为 1GB）。</p></li><li><p>PostgreSQL服务器在smart或fast模式下停止。</p></li><li><p>当超级用户手动发出CHECKPOINT命令时，也会做。</p></li></ol><blockquote><p>在9.1或更早版本中（<a href="https://jinlid.github.io/2021/8.huan-chong-qu-guan-li-qi/#_8.6">第 8.6 节</a>中所述），后台写入进程同时执行checkpinting and dirty-page writing。</p></blockquote><p>在以下小节中，将描述检查点的概要和保存当前检查点元数据的pg_control文件。</p><h3 id="9-7-1-检查点处理概要"><a href="#9-7-1-检查点处理概要" class="headerlink" title="9.7.1 检查点处理概要"></a>9.7.1 检查点处理概要</h3><p>Checkpoint进程用在两个方面：数据库恢复的准备，以及共享缓冲池上脏页的清理。本节重点介绍其内部处理。参见图9.13和以下说明。</p><p><img src="/medias/image/fig-9-13.png" alt="图 9.13 PostgreSQL 检查点的内部处理"></p><p>(1) 一个checkpoint进程开始后，REDO点被存入内存；REDO点是最近一次checkpoint启动时写入XLOG记录的位置，是数据库恢复的起点。</p><p>(2) checkpoint记录写入WAL缓冲区。记录的数据部分由结构<a href="void(0)">CheckPoint</a>定义，它包含几个变量，例如在步骤 (1) 中存储的REDO点。此外，写入检查点记录的位置字面上称为<strong>检查点</strong>。</p><p>(3) 共享内存中的所有数据（例如<a href="https://jinlid.github.io/2021/5.bing-fa-kong-zhi/5.4.3">clog</a>的内容等）都被刷新到存储中。</p><p>(4) 共享缓冲池上的所有脏页被逐渐写入并刷新到存储中。</p><p>(5) <strong>pg_control</strong>文件更新。该文件包含检查点的基本信息，例如检查点记录写入的位置。</p><p>从数据库恢复的角度总结上面的描述，检查点创建包含REDO点的检查点记录，并将检查点位置等存储到pg_control文件中。因此，PostgreSQL能够通过从pg_control文件提供的REDO点重放WAL数据来恢复自身。</p><h3 id="9-7-2-pg-control-文件"><a href="#9-7-2-pg-control-文件" class="headerlink" title="9.7.2 pg_control 文件"></a>9.7.2 pg_control 文件</h3><p>由于pg_control文件包含检查点的基本信息，因此它对于数据库恢复当然是必不可少的。如果损坏或无法读取，将无法获得起点，从而无法启动恢复过程。</p><p>pg_control文件存储了40多个条目，下一节中需要的3个项目如下所示：</p><ul><li><strong>状态</strong>： 最近一次检查点开始时数据库服务器的状态。共有七种状态：<strong>启动</strong>是系统正在启动的状态；<strong>shut down</strong>是系统被shutdown命令正常关闭的状态；<strong>生产中</strong>是系统正在运行的状态，等等。</li><li><strong>最新检查点位置</strong>：最新检查点记录的LSN位置。</li><li><strong>先前检查点位置</strong>：先前检查点记录的LSN位置。</li></ul><p>详细信息如下：</p><p>一个pg_control文件存放在data-directory下的global子目录中；可以使用<strong>pg_controldata</strong>实用程序查看其内容。</p><pre class="line-numbers language-bash"><code class="language-bash">postgres<span class="token operator">></span> pg_controldata  /usr/local/pgsql/datapg_control version number:            937Catalog version number:               201405111Database system identifier:           6035535450242021944Database cluster state:               <span class="token keyword">in</span> productionpg_control last modified:             Mon Nov 22 15:16:38 2021Latest checkpoint location:           0/C000F48Prior checkpoint location:            0/C000E70<span class="token punctuation">..</span>. snip <span class="token punctuation">..</span>.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>PostgreSQL 11 中的删除先前检查点，PostgreSQL11或更高版本将只存储包含最新检查点或更新的WAL段；将不会存储包含先前检查点的旧段文件，以减少用于在 pg_xlog(pg_wal) 子目录下保存WAL段文件的磁盘空间。具体信息查看<a href="http://www.postgresql-archive.org/Remove-secondary-checkpoint-tt5989050.html">此文 </a>。</p></blockquote><h2 id="9-8-PostgreSQL中的数据库恢复"><a href="#9-8-PostgreSQL中的数据库恢复" class="headerlink" title="9.8 PostgreSQL中的数据库恢复"></a>9.8 PostgreSQL中的数据库恢复</h2><p>PostgreSQL实现了基于重做日志的恢复功能。如果数据库服务器崩溃，PostgreSQL会通过从REDO点顺序重放 WAL段文件中的XLOG记录来恢复数据库集群。</p><p>到本节为止，我们已经多次讨论过数据库恢复，我将描述有关恢复的两件事，还没有解释。</p><p>首先是PostgreSQL如何开始恢复过程。当PostgreSQL启动时，它首先读取pg_control文件。以下是从该点开始恢复处理的详细信息。参见图 9.14和以下说明。</p><p><img src="/medias/image/fig-9-14.png" alt="图 9.14 恢复过程的详细信息"></p><p>(1) PostgreSQL在启动时读取pg_control文件的所有项。如果<strong>状态</strong>项在<strong>in production</strong>，PostgreSQL将进入恢复模式，因为这意味着数据库没有正常停止；如果为 <strong>shut down</strong>，它将进入正常启动模式。</p><p>(2) PostgreSQL从相应的WAL段文件中读取最新的checkpoint记录，该记录的位置写在pg_control文件中，并从该记录中获取REDO点。如果最新的检查点记录无效，PostgreSQL会读取它之前的记录。如果两个记录都不可读，它会放弃自行恢复。</p><p>(3) 数据库从REDO点开始依次读取和重放XLOG记录，直到它们到达最新WAL段的最后一点。当一个XLOG记录被重放时，如果它是一个备份块，它会在相应表的页面上被覆盖，而不管它的LSN是什么。否则，仅当该记录的LSN大于相应页面的 <code>pd_lsn</code> 时，才会重放（非备份块的）XLOG记录。</p><p>第二点是关于LSN的比较：为什么要比较非备份块的LSN和对应page的<code>pd_lsn</code>。与前面的示例不同，再次使用特定示例进行解释，需要强调在两个LSN之间进行比较。见图9.15 和 9.16（为了简化描述，省略了WAL缓冲区）。</p><p><img src="/medias/image/fig-9-15.png" alt="图 9.15 后台编写器工作期间的插入操作"></p><p>(1) PostgreSQL在 TABLE_A 中插入一个元组，并将 <code>LSN_1</code> 写入XLOG记录。</p><p>(2) 后台写入进程将 TABLE_A 的页面写入存储。此时，该页面的 <code>pd_lsn</code> 改为 <code>LSN_1</code>。</p><p>(3) PostgreSQL在 TABLE_A 中插入一个新元组，并在 <code>LSN_2</code> 处写入一条XLOG记录。修改后的页面还没有写入存储。</p><p>与概述中的示例不同，在这种情况下，TABLE_A 的页面已被写入存储。</p><p>使用 <code>immediate-mode</code> 关闭，然后启动。</p><p><img src="/medias/image/fig-9-16.png" alt="图 9.16 数据库恢复"></p><p>(1) PostgreSQL加载第一个XLOG记录和 TABLE_A 的页面，但不重放它，因为该记录的LSN不大于 TABLE_A 的LSN（两个值都是<code>LSN_1</code>）。其实一看就明白了，不需要重播。</p><p>(2) 接下来，PostgreSQL重放第二条XLOG记录，因为该记录的LSN ( <code>LSN_2</code> ) 大于当前 TABLE_A 的LSN ( <code>LSN_1</code> )。</p><p>从这个例子可以看出，如果非备份块的重放顺序不正确或非备份块重放多次，数据库集群将不再一致。总之，非备份块的重放操作不是幂等的。因此，为了保持正确的重放顺序，当且仅当其LSN大于相应页面的 <code>pd_lsn</code> 时，非备份块记录才应重放。</p><p>另一方面，由于备份块的重做操作是幂等的，无论其LSN是多少，备份块都可以重放任意次数。</p><h2 id="9-9-WAL段文件管理"><a href="#9-9-WAL段文件管理" class="headerlink" title="9.9 WAL段文件管理"></a>9.9 WAL段文件管理</h2><p>PostgreSQL将XLOG记录写入存储在pg_xlog子目录（在版本10或更高版本中为pg_wal子目录）中的WAL段文件之一，如果旧的已填满，则切换到新的。WAL文件的数量取决于几个配置参数以及服务器活动。此外，他们的管理策略在9.5版本中得到了改进。</p><p>在以下小节中，将描述WAL段文件的切换和管理。</p><h3 id="9-9-1-WAL段开关"><a href="#9-9-1-WAL段开关" class="headerlink" title="9.9.1 WAL段开关"></a>9.9.1 WAL段开关</h3><p>WAL段切换发生在以下情况之一时：</p><ol><li><p>WAL段已填满。</p></li><li><p>函数<em>pg_switch_xlog</em>被执行。</p></li><li><p><code>archive_mode</code>已启用，并且已超过设置为<code>archive_timeout</code>的时间。</p></li></ol><p>切换后的文件通常会被回收（重命名和重用）以备将来使用，但如果没有必要，它可能会在以后删除。</p><h3 id="9-9-2-9-5或更高版本中的WAL段管理"><a href="#9-9-2-9-5或更高版本中的WAL段管理" class="headerlink" title="9.9.2 9.5或更高版本中的WAL段管理"></a>9.9.2 9.5或更高版本中的WAL段管理</h3><p>每当检查点开始时，PostgreSQL都会估计并准备下一个检查点周期所需的WAL段文件的数量。此类估计是根据先前检查点周期中消耗的文件数进行的。它们是从包含先前REDO点的段开始计算的，其值介于 <code>min_wal_size</code>（默认为 80 MB，即5个文件）和 <code>max_wal_size</code>（1 GB，即64个文件）之间。如果检查点启动，必要的文件将被保留或回收，而不必要的文件将被删除。</p><p>具体示例如图9.17所示。假设checkpoint开始前有6个文件，WAL_3包含了之前的REDO点（10及之前版本；11及之后版本，REDO点），PostgreSQL估计需要5个文件。在这种情况下，WAL_1将重命名为WAL_7以进行回收，而WAL_2将被删除。</p><p>可以删除比包含先前重做点的文件更旧的文件，因为从<a href="https://jinlid.github.io/2021/9.yu-xie-ri-zhi-wal/#_9.8">第 9.8 节</a>中描述的恢复机制中可以清楚地看出，它们永远不会被使用。</p><p><img src="/medias/image/fig-9-17.png" alt="图 9.17 在检查点回收和删除 WAL 段文件"></p><p>如果由于WAL活动激增而需要更多文件，则将创建新文件，而WAL文件的总大小小于 <code>max_wal_size</code>。例如，在图9.18中，如果WAL_7已被填满，则新创建WAL_8。</p><p><img src="/medias/image/fig-9-18.png" alt="图 9.18 创建 WAL 段文件"></p><p>WAL文件的数量根据服务器活动自适应地变化。如果WAL数据写入量不断增加，WAL段文件的估计数量以及WAL文件的总大小也会逐渐增加。在相反的情况下（即 WAL 数据写入量减少），这些减少。</p><p>如果WAL文件的总大小超过<code>max_wal_size</code>，将启动检查点。图9.19说明了这种情况。通过检查点，将创建一个新的重做点，最后一个重做点将是前一个；然后不必要的旧文件将被回收。这样，PostgreSQL将始终只保存数据库恢复所需的WAL段文件。</p><p><img src="/medias/image/fig-9-19.png" alt="图 9.19 检查点和回收 WAL 段文件"></p><p>配置参数 <code>wal_keep_segments</code>和<strong>复制槽</strong>功能也会影响WAL段文件的数量。</p><h3 id="9-9-3-9-4或更早版本中的WAL段管理"><a href="#9-9-3-9-4或更早版本中的WAL段管理" class="headerlink" title="9.9.3 9.4或更早版本中的WAL段管理"></a>9.9.3 9.4或更早版本中的WAL段管理</h3><p>WAL段文件的数量主要由以下三个参数控制：<code>checkpoint_segments</code>、<code>checkpoint_completion_target</code> 和 <code>wal_keep_segments</code>。它的数量通常超过((2+checkpoint_completion_target)×checkpoint_segments+1)或者 (checkpoint_segments+wal_keep_segments+1)(checkpoint_segments+wal_keep_segments+1) 文件。这个数字可能会暂时达到(3×checkpoint_segments+1)，(3×checkpoint_segments+1) 文件取决于服务器活动。 复制插槽也影响他们的数目。</p><p>如<a href="https://jinlid.github.io/2021/9.yu-xie-ri-zhi-wal/#_9.7">第 9.7 节</a>所述，当<code>checkpoint_segments</code>文件的数量已被消耗时，就会发生检查点过程。因此可以保证WAL文件中总是包含两个或更多的REDO点，因为文件的数量总是大于2个checkpoint_segments。 如果超时发生也是如此。因此，PostgreSQL将始终拥有恢复所需的足够的WAL段文件（有时超过必要的）。</p><p>在 9.4 或更早版本中，参数 <code>checkpoint_segments</code> 令人头疼。如果设置的小，checkpoint会频繁出现，导致性能下降，而设置的大，WAL文件总是需要巨大的磁盘空间，其中一些并不总是必要的。</p><p>在 9.5 版本中，WAL文件的管理策略有所改进，并且<code>checkpoint_segments</code>已过时。因此，上述权衡问题也得到了解决。</p><h2 id="9-10-连续归档和归档日志"><a href="#9-10-连续归档和归档日志" class="headerlink" title="9.10 连续归档和归档日志"></a>9.10 连续归档和归档日志</h2><p>连续归档是在WAL段切换时将WAL段文件复制到归档区的功能，由<strong>归档进程</strong>执行。复制的文件称为存档日志。此功能通常用于<a href="https://jinlid.github.io/2021/10-ji-chu-bei-fen-he-shi-jian-dian-hui-fu/">第 10 章</a>所述的物理热备份和PITR（Point-in-Time Recovery）。</p><p>归档区的路径设置为配置参数 <code>archive_command</code>。例如，使用以下参数，每次每个段切换时，WAL段文件都会复制到目录 <code>/home/postgres/archives/</code>：</p><pre class="line-numbers language-properties"><code class="language-properties"><span class="token attr-name">archive_command</span> <span class="token punctuation">=</span> <span class="token attr-value">'cp %p /home/postgres/archives/%f'</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>其中，占位符<code>%p</code>是复制的WAL段，而<code>%f</code>是存档日志。</p><p><img src="/medias/image/fig-9-20.png" alt="图 9.20 持续归档"></p><hr><p>当 WAL 段文件WAL_7被切换时，该文件被复制到归档区作为Archive log 7。</p><p>参数<code>archive_command</code>可以设置任何Unix命令和工具，因此您可以通过设置scp命令或任何文件备份工具代替普通的copy命令将归档日志传输到其他主机。</p><p>PostgreSQL不会清理创建的归档日志，因此您在使用此功能时应该正确管理日志。如果您什么都不做，归档日志的数量将继续增加。</p><p><a href="http://www.postgresql.org/docs/current/static/pgarchivecleanup.html">pg_archivecleanup</a> 工具是针对归档日志管理的有效工具之一。</p><p>此外，unix 命令<code>find</code>可用于删除存档日志，以下命令删除三天前创建的归档日志。</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">find</span> /home/postgres/archives -mtime +3d -exec <span class="token function">rm</span>  -f <span class="token punctuation">{</span><span class="token punctuation">}</span> \<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> postgresql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> postgresql </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
