<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>docker模块的使用</title>
      <link href="/2025/docker-mo-kuai-de-shi-yong/"/>
      <url>/2025/docker-mo-kuai-de-shi-yong/</url>
      
        <content type="html"><![CDATA[<p>本教程将详细介绍如何使用 Docker SDK for Python 来管理 Docker 容器、镜像和网络。</p><h2 id="1-安装与初始化"><a href="#1-安装与初始化" class="headerlink" title="1. 安装与初始化"></a>1. 安装与初始化</h2><h3 id="安装-Docker-SDK"><a href="#安装-Docker-SDK" class="headerlink" title="安装 Docker SDK"></a>安装 Docker SDK</h3><pre class="line-numbers language-bash"><code class="language-bash">pip <span class="token function">install</span> docker<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="创建-Docker-客户端"><a href="#创建-Docker-客户端" class="headerlink" title="创建 Docker 客户端"></a>创建 Docker 客户端</h3><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">import</span> docker<span class="token comment" spellcheck="true"># 最简单的方式 - 使用环境变量</span>client <span class="token operator">=</span> docker<span class="token punctuation">.</span>from_env<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 或者指定 Docker 守护进程地址</span><span class="token comment" spellcheck="true"># client = docker.DockerClient(base_url="tcp://192.168.137.129:2375")</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="2-镜像管理"><a href="#2-镜像管理" class="headerlink" title="2. 镜像管理"></a>2. 镜像管理</h2><h3 id="列出所有镜像"><a href="#列出所有镜像" class="headerlink" title="列出所有镜像"></a>列出所有镜像</h3><pre class="line-numbers language-python"><code class="language-python">images <span class="token operator">=</span> client<span class="token punctuation">.</span>images<span class="token punctuation">.</span>list<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">for</span> image <span class="token keyword">in</span> images<span class="token punctuation">:</span>    <span class="token keyword">print</span><span class="token punctuation">(</span>f<span class="token string">"ID: {image.short_id}, Tags: {image.tags}"</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="查看镜像详细信息"><a href="#查看镜像详细信息" class="headerlink" title="查看镜像详细信息"></a>查看镜像详细信息</h3><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">import</span> jsonimages <span class="token operator">=</span> client<span class="token punctuation">.</span>images<span class="token punctuation">.</span>list<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">for</span> image <span class="token keyword">in</span> images<span class="token punctuation">:</span>    <span class="token keyword">print</span><span class="token punctuation">(</span>json<span class="token punctuation">.</span>dumps<span class="token punctuation">(</span>image<span class="token punctuation">.</span>attrs<span class="token punctuation">,</span> indent<span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="删除镜像"><a href="#删除镜像" class="headerlink" title="删除镜像"></a>删除镜像</h3><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">remove_image</span><span class="token punctuation">(</span>image_name_or_id<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">try</span><span class="token punctuation">:</span>        client<span class="token punctuation">.</span>images<span class="token punctuation">.</span>remove<span class="token punctuation">(</span>image_name_or_id<span class="token punctuation">)</span>        <span class="token keyword">print</span><span class="token punctuation">(</span>f<span class="token string">"成功删除镜像: {image_name_or_id}"</span><span class="token punctuation">)</span>    <span class="token keyword">except</span> docker<span class="token punctuation">.</span>errors<span class="token punctuation">.</span>ImageNotFound<span class="token punctuation">:</span>        <span class="token keyword">print</span><span class="token punctuation">(</span>f<span class="token string">"镜像不存在: {image_name_or_id}"</span><span class="token punctuation">)</span>    <span class="token keyword">except</span> docker<span class="token punctuation">.</span>errors<span class="token punctuation">.</span>APIError <span class="token keyword">as</span> e<span class="token punctuation">:</span>        <span class="token keyword">print</span><span class="token punctuation">(</span>f<span class="token string">"删除镜像时出错: {e}"</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 使用示例</span>remove_image<span class="token punctuation">(</span><span class="token string">"alpine:latest"</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="清理未使用的镜像"><a href="#清理未使用的镜像" class="headerlink" title="清理未使用的镜像"></a>清理未使用的镜像</h3><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">prune_unused_images</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">try</span><span class="token punctuation">:</span>        result <span class="token operator">=</span> client<span class="token punctuation">.</span>images<span class="token punctuation">.</span>prune<span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token keyword">print</span><span class="token punctuation">(</span>f<span class="token string">"已清理未使用的镜像, 释放空间: {result['SpaceReclaimed']}字节"</span><span class="token punctuation">)</span>    <span class="token keyword">except</span> docker<span class="token punctuation">.</span>errors<span class="token punctuation">.</span>APIError <span class="token keyword">as</span> e<span class="token punctuation">:</span>        <span class="token keyword">print</span><span class="token punctuation">(</span>f<span class="token string">"清理镜像时出错: {e}"</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="构建镜像"><a href="#构建镜像" class="headerlink" title="构建镜像"></a>构建镜像</h3><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">build_image</span><span class="token punctuation">(</span>dockerfile_path<span class="token punctuation">,</span> tag<span class="token punctuation">,</span> build_args<span class="token operator">=</span>None<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">try</span><span class="token punctuation">:</span>        build_output <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>        image<span class="token punctuation">,</span> logs <span class="token operator">=</span> client<span class="token punctuation">.</span>images<span class="token punctuation">.</span>build<span class="token punctuation">(</span>            path<span class="token operator">=</span>dockerfile_path<span class="token punctuation">,</span>            tag<span class="token operator">=</span>tag<span class="token punctuation">,</span>            buildargs<span class="token operator">=</span>build_args <span class="token operator">or</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span>            rm<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">,</span>            forcerm<span class="token operator">=</span><span class="token boolean">True</span>        <span class="token punctuation">)</span>                <span class="token comment" spellcheck="true"># 处理构建日志</span>        <span class="token keyword">for</span> line <span class="token keyword">in</span> logs<span class="token punctuation">:</span>            <span class="token keyword">if</span> <span class="token string">'stream'</span> <span class="token keyword">in</span> line<span class="token punctuation">:</span>                stream <span class="token operator">=</span> line<span class="token punctuation">[</span><span class="token string">'stream'</span><span class="token punctuation">]</span><span class="token punctuation">.</span>strip<span class="token punctuation">(</span><span class="token punctuation">)</span>                <span class="token keyword">if</span> stream<span class="token punctuation">:</span>                    build_output<span class="token punctuation">.</span>append<span class="token punctuation">(</span>stream<span class="token punctuation">)</span>                    <span class="token keyword">print</span><span class="token punctuation">(</span>stream<span class="token punctuation">)</span>            <span class="token keyword">elif</span> <span class="token string">'error'</span> <span class="token keyword">in</span> line<span class="token punctuation">:</span>                error_msg <span class="token operator">=</span> line<span class="token punctuation">[</span><span class="token string">'error'</span><span class="token punctuation">]</span>                <span class="token keyword">raise</span> Exception<span class="token punctuation">(</span>f<span class="token string">"构建错误: {error_msg}"</span><span class="token punctuation">)</span>                <span class="token keyword">print</span><span class="token punctuation">(</span>f<span class="token string">"成功构建镜像: {tag}"</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> image    <span class="token keyword">except</span> Exception <span class="token keyword">as</span> e<span class="token punctuation">:</span>        <span class="token keyword">print</span><span class="token punctuation">(</span>f<span class="token string">"构建镜像时出错: {e}"</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> None<span class="token comment" spellcheck="true"># 使用示例</span>build_args <span class="token operator">=</span> <span class="token punctuation">{</span>    <span class="token string">'URL'</span><span class="token punctuation">:</span> <span class="token string">'https://mirrors.aliyun.com/postgresql/source'</span><span class="token punctuation">,</span>    <span class="token string">'PGVERSION'</span><span class="token punctuation">:</span> <span class="token string">'15.10'</span><span class="token punctuation">}</span>build_image<span class="token punctuation">(</span>    dockerfile_path<span class="token operator">=</span><span class="token string">'./dockerfiles'</span><span class="token punctuation">,</span>    tag<span class="token operator">=</span><span class="token string">'postgresql:15.10'</span><span class="token punctuation">,</span>    build_args<span class="token operator">=</span>build_args<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="3-容器管理"><a href="#3-容器管理" class="headerlink" title="3. 容器管理"></a>3. 容器管理</h2><h3 id="创建并运行容器"><a href="#创建并运行容器" class="headerlink" title="创建并运行容器"></a>创建并运行容器</h3><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">run_container</span><span class="token punctuation">(</span>image_name<span class="token punctuation">,</span> command<span class="token operator">=</span>None<span class="token punctuation">,</span> detach<span class="token operator">=</span><span class="token boolean">False</span><span class="token punctuation">,</span>                   name<span class="token operator">=</span>None<span class="token punctuation">,</span> ports<span class="token operator">=</span>None<span class="token punctuation">,</span> volumes<span class="token operator">=</span>None<span class="token punctuation">,</span>                   environment<span class="token operator">=</span>None<span class="token punctuation">,</span> network<span class="token operator">=</span>None<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">try</span><span class="token punctuation">:</span>        container <span class="token operator">=</span> client<span class="token punctuation">.</span>containers<span class="token punctuation">.</span>run<span class="token punctuation">(</span>            image<span class="token operator">=</span>image_name<span class="token punctuation">,</span>            command<span class="token operator">=</span>command<span class="token punctuation">,</span>            detach<span class="token operator">=</span>detach<span class="token punctuation">,</span>            name<span class="token operator">=</span>name<span class="token punctuation">,</span>            ports<span class="token operator">=</span>ports <span class="token operator">or</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span>            volumes<span class="token operator">=</span>volumes <span class="token operator">or</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span>            environment<span class="token operator">=</span>environment <span class="token operator">or</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span>            network<span class="token operator">=</span>network        <span class="token punctuation">)</span>        <span class="token keyword">print</span><span class="token punctuation">(</span>f<span class="token string">"成功创建容器: {container.id}"</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> container    <span class="token keyword">except</span> docker<span class="token punctuation">.</span>errors<span class="token punctuation">.</span>APIError <span class="token keyword">as</span> e<span class="token punctuation">:</span>        <span class="token keyword">print</span><span class="token punctuation">(</span>f<span class="token string">"创建容器时出错: {e}"</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> None<span class="token comment" spellcheck="true"># 使用示例</span>container <span class="token operator">=</span> run_container<span class="token punctuation">(</span>    image_name<span class="token operator">=</span><span class="token string">"alpine"</span><span class="token punctuation">,</span>    command<span class="token operator">=</span><span class="token string">"echo hello world"</span><span class="token punctuation">,</span>    name<span class="token operator">=</span><span class="token string">"test_container"</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="列出容器"><a href="#列出容器" class="headerlink" title="列出容器"></a>列出容器</h3><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">list_containers</span><span class="token punctuation">(</span>all_containers<span class="token operator">=</span><span class="token boolean">False</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">try</span><span class="token punctuation">:</span>        containers <span class="token operator">=</span> client<span class="token punctuation">.</span>containers<span class="token punctuation">.</span>list<span class="token punctuation">(</span>all<span class="token operator">=</span>all_containers<span class="token punctuation">)</span>        <span class="token keyword">print</span><span class="token punctuation">(</span>f<span class="token string">"找到 {len(containers)} 个容器:"</span><span class="token punctuation">)</span>        <span class="token keyword">for</span> container <span class="token keyword">in</span> containers<span class="token punctuation">:</span>            <span class="token keyword">print</span><span class="token punctuation">(</span>f<span class="token string">"ID: {container.short_id}, Name: {container.name}, Status: {container.status}"</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> containers    <span class="token keyword">except</span> docker<span class="token punctuation">.</span>errors<span class="token punctuation">.</span>APIError <span class="token keyword">as</span> e<span class="token punctuation">:</span>        <span class="token keyword">print</span><span class="token punctuation">(</span>f<span class="token string">"获取容器列表时出错: {e}"</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token comment" spellcheck="true"># 使用示例</span>list_containers<span class="token punctuation">(</span>all_containers<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="获取容器详细信息"><a href="#获取容器详细信息" class="headerlink" title="获取容器详细信息"></a>获取容器详细信息</h3><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">get_container_info</span><span class="token punctuation">(</span>container_id_or_name<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">try</span><span class="token punctuation">:</span>        container <span class="token operator">=</span> client<span class="token punctuation">.</span>containers<span class="token punctuation">.</span>get<span class="token punctuation">(</span>container_id_or_name<span class="token punctuation">)</span>        <span class="token keyword">print</span><span class="token punctuation">(</span>json<span class="token punctuation">.</span>dumps<span class="token punctuation">(</span>container<span class="token punctuation">.</span>attrs<span class="token punctuation">,</span> indent<span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> container<span class="token punctuation">.</span>attrs    <span class="token keyword">except</span> docker<span class="token punctuation">.</span>errors<span class="token punctuation">.</span>NotFound<span class="token punctuation">:</span>        <span class="token keyword">print</span><span class="token punctuation">(</span>f<span class="token string">"容器不存在: {container_id_or_name}"</span><span class="token punctuation">)</span>    <span class="token keyword">except</span> docker<span class="token punctuation">.</span>errors<span class="token punctuation">.</span>APIError <span class="token keyword">as</span> e<span class="token punctuation">:</span>        <span class="token keyword">print</span><span class="token punctuation">(</span>f<span class="token string">"获取容器信息时出错: {e}"</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 使用示例</span>get_container_info<span class="token punctuation">(</span><span class="token string">"postgresql_16.6"</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="停止和删除容器"><a href="#停止和删除容器" class="headerlink" title="停止和删除容器"></a>停止和删除容器</h3><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">stop_and_remove_container</span><span class="token punctuation">(</span>container_id_or_name<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">try</span><span class="token punctuation">:</span>        container <span class="token operator">=</span> client<span class="token punctuation">.</span>containers<span class="token punctuation">.</span>get<span class="token punctuation">(</span>container_id_or_name<span class="token punctuation">)</span>                <span class="token comment" spellcheck="true"># 停止容器</span>        <span class="token keyword">if</span> container<span class="token punctuation">.</span>status <span class="token operator">==</span> <span class="token string">'running'</span><span class="token punctuation">:</span>            container<span class="token punctuation">.</span>stop<span class="token punctuation">(</span><span class="token punctuation">)</span>            <span class="token keyword">print</span><span class="token punctuation">(</span>f<span class="token string">"已停止容器: {container_id_or_name}"</span><span class="token punctuation">)</span>                <span class="token comment" spellcheck="true"># 删除容器</span>        container<span class="token punctuation">.</span>remove<span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token keyword">print</span><span class="token punctuation">(</span>f<span class="token string">"已删除容器: {container_id_or_name}"</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> <span class="token boolean">True</span>    <span class="token keyword">except</span> docker<span class="token punctuation">.</span>errors<span class="token punctuation">.</span>NotFound<span class="token punctuation">:</span>        <span class="token keyword">print</span><span class="token punctuation">(</span>f<span class="token string">"容器不存在: {container_id_or_name}"</span><span class="token punctuation">)</span>    <span class="token keyword">except</span> docker<span class="token punctuation">.</span>errors<span class="token punctuation">.</span>APIError <span class="token keyword">as</span> e<span class="token punctuation">:</span>        <span class="token keyword">print</span><span class="token punctuation">(</span>f<span class="token string">"操作容器时出错: {e}"</span><span class="token punctuation">)</span>    <span class="token keyword">return</span> <span class="token boolean">False</span><span class="token comment" spellcheck="true"># 使用示例</span>stop_and_remove_container<span class="token punctuation">(</span><span class="token string">"test_container"</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="4-网络管理"><a href="#4-网络管理" class="headerlink" title="4. 网络管理"></a>4. 网络管理</h2><h3 id="列出网络"><a href="#列出网络" class="headerlink" title="列出网络"></a>列出网络</h3><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">list_networks</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">try</span><span class="token punctuation">:</span>        networks <span class="token operator">=</span> client<span class="token punctuation">.</span>networks<span class="token punctuation">.</span>list<span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token keyword">print</span><span class="token punctuation">(</span>f<span class="token string">"找到 {len(networks)} 个网络:"</span><span class="token punctuation">)</span>        <span class="token keyword">for</span> network <span class="token keyword">in</span> networks<span class="token punctuation">:</span>            <span class="token keyword">print</span><span class="token punctuation">(</span>f<span class="token string">"Name: {network.name}, Driver: {network.attrs['Driver']}, Scope: {network.attrs['Scope']}"</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> networks    <span class="token keyword">except</span> docker<span class="token punctuation">.</span>errors<span class="token punctuation">.</span>APIError <span class="token keyword">as</span> e<span class="token punctuation">:</span>        <span class="token keyword">print</span><span class="token punctuation">(</span>f<span class="token string">"获取网络列表时出错: {e}"</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token comment" spellcheck="true"># 使用示例</span>list_networks<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="创建自定义网络"><a href="#创建自定义网络" class="headerlink" title="创建自定义网络"></a>创建自定义网络</h3><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">create_custom_network</span><span class="token punctuation">(</span>network_name<span class="token punctuation">,</span> driver<span class="token operator">=</span><span class="token string">'bridge'</span><span class="token punctuation">,</span> subnet<span class="token operator">=</span>None<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">try</span><span class="token punctuation">:</span>        <span class="token comment" spellcheck="true"># 检查网络是否已存在</span>        existing_networks <span class="token operator">=</span> <span class="token punctuation">[</span>n<span class="token punctuation">.</span>name <span class="token keyword">for</span> n <span class="token keyword">in</span> client<span class="token punctuation">.</span>networks<span class="token punctuation">.</span>list<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">]</span>        <span class="token keyword">if</span> network_name <span class="token keyword">in</span> existing_networks<span class="token punctuation">:</span>            <span class="token keyword">print</span><span class="token punctuation">(</span>f<span class="token string">"网络已存在: {network_name}"</span><span class="token punctuation">)</span>            <span class="token keyword">return</span> client<span class="token punctuation">.</span>networks<span class="token punctuation">.</span>get<span class="token punctuation">(</span>network_name<span class="token punctuation">)</span>                <span class="token comment" spellcheck="true"># 配置IPAM（如果指定了子网）</span>        ipam_config <span class="token operator">=</span> None        <span class="token keyword">if</span> subnet<span class="token punctuation">:</span>            ipam_config <span class="token operator">=</span> docker<span class="token punctuation">.</span>types<span class="token punctuation">.</span>IPAMConfig<span class="token punctuation">(</span>                pool_configs<span class="token operator">=</span><span class="token punctuation">[</span>docker<span class="token punctuation">.</span>types<span class="token punctuation">.</span>IPAMPool<span class="token punctuation">(</span>subnet<span class="token operator">=</span>subnet<span class="token punctuation">)</span><span class="token punctuation">]</span>            <span class="token punctuation">)</span>                <span class="token comment" spellcheck="true"># 创建网络</span>        network <span class="token operator">=</span> client<span class="token punctuation">.</span>networks<span class="token punctuation">.</span>create<span class="token punctuation">(</span>            network_name<span class="token punctuation">,</span>            driver<span class="token operator">=</span>driver<span class="token punctuation">,</span>            ipam<span class="token operator">=</span>ipam_config        <span class="token punctuation">)</span>        <span class="token keyword">print</span><span class="token punctuation">(</span>f<span class="token string">"成功创建网络: {network_name}"</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> network    <span class="token keyword">except</span> docker<span class="token punctuation">.</span>errors<span class="token punctuation">.</span>APIError <span class="token keyword">as</span> e<span class="token punctuation">:</span>        <span class="token keyword">print</span><span class="token punctuation">(</span>f<span class="token string">"创建网络时出错: {e}"</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> None<span class="token comment" spellcheck="true"># 使用示例</span>create_custom_network<span class="token punctuation">(</span>    network_name<span class="token operator">=</span><span class="token string">"postgrenetwork"</span><span class="token punctuation">,</span>    subnet<span class="token operator">=</span><span class="token string">"172.19.1.0/24"</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="获取容器IP地址"><a href="#获取容器IP地址" class="headerlink" title="获取容器IP地址"></a>获取容器IP地址</h3><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">get_container_ips</span><span class="token punctuation">(</span>container_id_or_name<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">try</span><span class="token punctuation">:</span>        container <span class="token operator">=</span> client<span class="token punctuation">.</span>containers<span class="token punctuation">.</span>get<span class="token punctuation">(</span>container_id_or_name<span class="token punctuation">)</span>        networks <span class="token operator">=</span> container<span class="token punctuation">.</span>attrs<span class="token punctuation">[</span><span class="token string">'NetworkSettings'</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token string">'Networks'</span><span class="token punctuation">]</span>                <span class="token keyword">print</span><span class="token punctuation">(</span>f<span class="token string">"容器 {container_id_or_name} 的IP地址:"</span><span class="token punctuation">)</span>        <span class="token keyword">for</span> network_name<span class="token punctuation">,</span> network_info <span class="token keyword">in</span> networks<span class="token punctuation">.</span>items<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">print</span><span class="token punctuation">(</span>f<span class="token string">"{network_name}: {network_info['IPAddress']}"</span><span class="token punctuation">)</span>                <span class="token keyword">return</span> networks    <span class="token keyword">except</span> docker<span class="token punctuation">.</span>errors<span class="token punctuation">.</span>NotFound<span class="token punctuation">:</span>        <span class="token keyword">print</span><span class="token punctuation">(</span>f<span class="token string">"容器不存在: {container_id_or_name}"</span><span class="token punctuation">)</span>    <span class="token keyword">except</span> docker<span class="token punctuation">.</span>errors<span class="token punctuation">.</span>APIError <span class="token keyword">as</span> e<span class="token punctuation">:</span>        <span class="token keyword">print</span><span class="token punctuation">(</span>f<span class="token string">"获取容器IP时出错: {e}"</span><span class="token punctuation">)</span>    <span class="token keyword">return</span> None<span class="token comment" spellcheck="true"># 使用示例</span>get_container_ips<span class="token punctuation">(</span><span class="token string">"postgresql_16.6"</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="5-容器日志与命令执行"><a href="#5-容器日志与命令执行" class="headerlink" title="5. 容器日志与命令执行"></a>5. 容器日志与命令执行</h2><h3 id="查看容器日志"><a href="#查看容器日志" class="headerlink" title="查看容器日志"></a>查看容器日志</h3><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">get_container_logs</span><span class="token punctuation">(</span>container_id_or_name<span class="token punctuation">,</span> tail<span class="token operator">=</span><span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">try</span><span class="token punctuation">:</span>        container <span class="token operator">=</span> client<span class="token punctuation">.</span>containers<span class="token punctuation">.</span>get<span class="token punctuation">(</span>container_id_or_name<span class="token punctuation">)</span>        logs <span class="token operator">=</span> container<span class="token punctuation">.</span>logs<span class="token punctuation">(</span>tail<span class="token operator">=</span>tail<span class="token punctuation">)</span><span class="token punctuation">.</span>decode<span class="token punctuation">(</span><span class="token string">'utf-8'</span><span class="token punctuation">)</span>        <span class="token keyword">print</span><span class="token punctuation">(</span>f<span class="token string">"容器 {container_id_or_name} 的日志:"</span><span class="token punctuation">)</span>        <span class="token keyword">print</span><span class="token punctuation">(</span>logs<span class="token punctuation">)</span>        <span class="token keyword">return</span> logs    <span class="token keyword">except</span> docker<span class="token punctuation">.</span>errors<span class="token punctuation">.</span>NotFound<span class="token punctuation">:</span>        <span class="token keyword">print</span><span class="token punctuation">(</span>f<span class="token string">"容器不存在: {container_id_or_name}"</span><span class="token punctuation">)</span>    <span class="token keyword">except</span> docker<span class="token punctuation">.</span>errors<span class="token punctuation">.</span>APIError <span class="token keyword">as</span> e<span class="token punctuation">:</span>        <span class="token keyword">print</span><span class="token punctuation">(</span>f<span class="token string">"获取日志时出错: {e}"</span><span class="token punctuation">)</span>    <span class="token keyword">return</span> None<span class="token comment" spellcheck="true"># 使用示例</span>get_container_logs<span class="token punctuation">(</span><span class="token string">"postgresql_16.6"</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="在容器中执行命令"><a href="#在容器中执行命令" class="headerlink" title="在容器中执行命令"></a>在容器中执行命令</h3><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">exec_command_in_container</span><span class="token punctuation">(</span>container_id_or_name<span class="token punctuation">,</span> command<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">try</span><span class="token punctuation">:</span>        container <span class="token operator">=</span> client<span class="token punctuation">.</span>containers<span class="token punctuation">.</span>get<span class="token punctuation">(</span>container_id_or_name<span class="token punctuation">)</span>                <span class="token comment" spellcheck="true"># 执行命令</span>        exec_result <span class="token operator">=</span> container<span class="token punctuation">.</span>exec_run<span class="token punctuation">(</span>            cmd<span class="token operator">=</span>command<span class="token punctuation">,</span>            stdout<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">,</span>            stderr<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">,</span>            stdin<span class="token operator">=</span><span class="token boolean">False</span><span class="token punctuation">,</span>            tty<span class="token operator">=</span><span class="token boolean">False</span>        <span class="token punctuation">)</span>                <span class="token comment" spellcheck="true"># 解码输出</span>        output <span class="token operator">=</span> exec_result<span class="token punctuation">.</span>output<span class="token punctuation">.</span>decode<span class="token punctuation">(</span><span class="token string">'utf-8'</span><span class="token punctuation">)</span>        exit_code <span class="token operator">=</span> exec_result<span class="token punctuation">.</span>exit_code                <span class="token keyword">print</span><span class="token punctuation">(</span>f<span class="token string">"在容器 {container_id_or_name} 中执行命令: {command}"</span><span class="token punctuation">)</span>        <span class="token keyword">print</span><span class="token punctuation">(</span>f<span class="token string">"退出码: {exit_code}"</span><span class="token punctuation">)</span>        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"输出:"</span><span class="token punctuation">)</span>        <span class="token keyword">print</span><span class="token punctuation">(</span>output<span class="token punctuation">)</span>                <span class="token keyword">return</span> output<span class="token punctuation">,</span> exit_code    <span class="token keyword">except</span> docker<span class="token punctuation">.</span>errors<span class="token punctuation">.</span>NotFound<span class="token punctuation">:</span>        <span class="token keyword">print</span><span class="token punctuation">(</span>f<span class="token string">"容器不存在: {container_id_or_name}"</span><span class="token punctuation">)</span>    <span class="token keyword">except</span> docker<span class="token punctuation">.</span>errors<span class="token punctuation">.</span>APIError <span class="token keyword">as</span> e<span class="token punctuation">:</span>        <span class="token keyword">print</span><span class="token punctuation">(</span>f<span class="token string">"执行命令时出错: {e}"</span><span class="token punctuation">)</span>    <span class="token keyword">return</span> None<span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token comment" spellcheck="true"># 使用示例</span>exec_command_in_container<span class="token punctuation">(</span><span class="token string">"postgresql_16.6"</span><span class="token punctuation">,</span> <span class="token string">"ps aux"</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="6-综合示例"><a href="#6-综合示例" class="headerlink" title="6. 综合示例"></a>6. 综合示例</h2><h3 id="部署一个简单的Web应用"><a href="#部署一个简单的Web应用" class="headerlink" title="部署一个简单的Web应用"></a>部署一个简单的Web应用</h3><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">deploy_web_app</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">try</span><span class="token punctuation">:</span>        <span class="token comment" spellcheck="true"># 1. 拉取镜像</span>        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"正在拉取nginx镜像..."</span><span class="token punctuation">)</span>        client<span class="token punctuation">.</span>images<span class="token punctuation">.</span>pull<span class="token punctuation">(</span><span class="token string">"nginx:latest"</span><span class="token punctuation">)</span>                <span class="token comment" spellcheck="true"># 2. 创建网络</span>        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"正在创建网络..."</span><span class="token punctuation">)</span>        network <span class="token operator">=</span> create_custom_network<span class="token punctuation">(</span><span class="token string">"web_network"</span><span class="token punctuation">)</span>                <span class="token comment" spellcheck="true"># 3. 运行容器</span>        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"正在启动容器..."</span><span class="token punctuation">)</span>        container <span class="token operator">=</span> run_container<span class="token punctuation">(</span>            image_name<span class="token operator">=</span><span class="token string">"nginx:latest"</span><span class="token punctuation">,</span>            name<span class="token operator">=</span><span class="token string">"web_server"</span><span class="token punctuation">,</span>            ports<span class="token operator">=</span><span class="token punctuation">{</span><span class="token string">'80/tcp'</span><span class="token punctuation">:</span> <span class="token number">8080</span><span class="token punctuation">}</span><span class="token punctuation">,</span>            network<span class="token operator">=</span><span class="token string">"web_network"</span><span class="token punctuation">,</span>            detach<span class="token operator">=</span><span class="token boolean">True</span>        <span class="token punctuation">)</span>                <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"部署成功!"</span><span class="token punctuation">)</span>        <span class="token keyword">print</span><span class="token punctuation">(</span>f<span class="token string">"访问地址: http://localhost:8080"</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> container    <span class="token keyword">except</span> Exception <span class="token keyword">as</span> e<span class="token punctuation">:</span>        <span class="token keyword">print</span><span class="token punctuation">(</span>f<span class="token string">"部署失败: {e}"</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> None<span class="token comment" spellcheck="true"># 使用示例</span>deploy_web_app<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本教程涵盖了 Docker SDK for Python 的主要功能：</p><ol><li><strong>镜像管理</strong> - 列出、构建、删除镜像</li><li><strong>容器管理</strong> - 创建、启动、停止、删除容器</li><li><strong>网络管理</strong> - 创建自定义网络，查看容器IP</li><li><strong>日志与命令</strong> - 查看容器日志，在容器内执行命令</li><li><strong>综合应用</strong> - 完整的应用部署流程</li></ol><p>通过这些功能，您可以轻松地在 Python 程序中集成 Docker 管理功能，实现自动化部署和管理容器化应用。</p>]]></content>
      
      
      <categories>
          
          <category> postgresql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> postgresql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Kubernetes教程--ConfigMap与Secret的使用</title>
      <link href="/2024/kubernetes-jiao-cheng-configmap-yu-secret-de-shi-yong/"/>
      <url>/2024/kubernetes-jiao-cheng-configmap-yu-secret-de-shi-yong/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h2 id="1-configMap-基础"><a href="#1-configMap-基础" class="headerlink" title="1. configMap 基础"></a><strong>1. configMap 基础</strong></h2><p>ConfigMap 用于存储非敏感的配置数据，如环境变量、配置文件等。</p><p><strong>1. 从字面量创建 ConfigMap</strong></p><pre class="line-numbers language-bash"><code class="language-bash">kubectl create cm info --from-literal<span class="token operator">=</span>k<span class="token operator">=</span>v --dry-run<span class="token operator">=</span>client -o yaml<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>2. 从 YAML 文件创建 ConfigMap</strong></p><pre class="line-numbers language-yaml"><code class="language-yaml"><span class="token comment" spellcheck="true"># cm.yml</span><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> v1<span class="token key atrule">kind</span><span class="token punctuation">:</span> ConfigMap<span class="token key atrule">metadata</span><span class="token punctuation">:</span>  <span class="token key atrule">name</span><span class="token punctuation">:</span> info<span class="token key atrule">data</span><span class="token punctuation">:</span>  <span class="token key atrule">count</span><span class="token punctuation">:</span> <span class="token number">10</span>  <span class="token key atrule">debug</span><span class="token punctuation">:</span> <span class="token string">'on'</span>  <span class="token key atrule">path</span><span class="token punctuation">:</span> <span class="token string">'/etc/systemd'</span>  <span class="token key atrule">greeting</span><span class="token punctuation">:</span> <span class="token punctuation">|</span><span class="token scalar string">    say hello to kubernetes.</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>3. 应用与查看</strong></p><pre class="line-numbers language-bash"><code class="language-bash">kubectl apply -f cm.ymlkubectl get cm  <span class="token comment" spellcheck="true"># 查看ConfigMap列表</span>kubectl describe cm info  <span class="token comment" spellcheck="true"># 查看详情</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h2 id="2-Secret-基础"><a href="#2-Secret-基础" class="headerlink" title="2. Secret 基础"></a><strong>2. Secret 基础</strong></h2><p>Secret 用于存储敏感数据，如密码、密钥等，数据会被 Base64 编码。</p><p><strong>1. 从字面量创建 Secret</strong></p><pre class="line-numbers language-bash"><code class="language-bash">kubectl create secret generic user --from-literal<span class="token operator">=</span>name<span class="token operator">=</span>root --dry-run<span class="token operator">=</span>client -o yaml<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>2. 手动编码创建 Secret</strong></p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 生成Base64编码</span><span class="token keyword">echo</span> -n <span class="token string">'123456'</span> <span class="token operator">|</span> base64  <span class="token comment" spellcheck="true"># MTIzNDU2</span><span class="token keyword">echo</span> -n <span class="token string">'postgres'</span> <span class="token operator">|</span> base64  <span class="token comment" spellcheck="true"># cG9zdGdyZXM=</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-yaml"><code class="language-yaml"><span class="token comment" spellcheck="true"># secret.yml</span><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> v1<span class="token key atrule">kind</span><span class="token punctuation">:</span> Secret<span class="token key atrule">metadata</span><span class="token punctuation">:</span>  <span class="token key atrule">name</span><span class="token punctuation">:</span> user<span class="token key atrule">type</span><span class="token punctuation">:</span> Opaque<span class="token key atrule">data</span><span class="token punctuation">:</span>  <span class="token key atrule">name</span><span class="token punctuation">:</span> cm9vdA==  <span class="token comment" spellcheck="true"># root</span>  <span class="token key atrule">pwd</span><span class="token punctuation">:</span> MTIzNDU2   <span class="token comment" spellcheck="true"># 123456</span>  <span class="token key atrule">db</span><span class="token punctuation">:</span> cG9zdGdyZXM=  <span class="token comment" spellcheck="true"># postgres</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>3. 应用与查看</strong></p><pre class="line-numbers language-bash"><code class="language-bash">kubectl apply -f secret.ymlkubectl get secrets  <span class="token comment" spellcheck="true"># 查看Secret列表</span>kubectl describe secret user  <span class="token comment" spellcheck="true"># 查看详情（值不会明文显示）</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h2 id="3-在-Pod-中使用-ConfigMap-x2F-Secret-作为环境变量"><a href="#3-在-Pod-中使用-ConfigMap-x2F-Secret-作为环境变量" class="headerlink" title="3. 在 Pod 中使用 ConfigMap/Secret 作为环境变量"></a><strong>3. 在 Pod 中使用 ConfigMap/Secret 作为环境变量</strong></h2><p><strong>1. 配置 Pod 环境变量</strong></p><pre class="line-numbers language-yaml"><code class="language-yaml"><span class="token comment" spellcheck="true"># env-pod.yml</span><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> v1<span class="token key atrule">kind</span><span class="token punctuation">:</span> Pod<span class="token key atrule">metadata</span><span class="token punctuation">:</span>  <span class="token key atrule">name</span><span class="token punctuation">:</span> env<span class="token punctuation">-</span>pod<span class="token key atrule">spec</span><span class="token punctuation">:</span>  <span class="token key atrule">containers</span><span class="token punctuation">:</span>  <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> busy    <span class="token key atrule">image</span><span class="token punctuation">:</span> busybox    <span class="token key atrule">command</span><span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token string">"/bin/sleep"</span><span class="token punctuation">,</span> <span class="token string">"300"</span><span class="token punctuation">]</span>    <span class="token key atrule">env</span><span class="token punctuation">:</span>      <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> COUNT        <span class="token key atrule">valueFrom</span><span class="token punctuation">:</span>          <span class="token key atrule">configMapKeyRef</span><span class="token punctuation">:</span>            <span class="token key atrule">name</span><span class="token punctuation">:</span> info            <span class="token key atrule">key</span><span class="token punctuation">:</span> count      <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> GREETING        <span class="token key atrule">valueFrom</span><span class="token punctuation">:</span>          <span class="token key atrule">configMapKeyRef</span><span class="token punctuation">:</span>            <span class="token key atrule">name</span><span class="token punctuation">:</span> info            <span class="token key atrule">key</span><span class="token punctuation">:</span> greeting      <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> USERNAME        <span class="token key atrule">valueFrom</span><span class="token punctuation">:</span>          <span class="token key atrule">secretKeyRef</span><span class="token punctuation">:</span>            <span class="token key atrule">name</span><span class="token punctuation">:</span> user            <span class="token key atrule">key</span><span class="token punctuation">:</span> name      <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> PASSWORD        <span class="token key atrule">valueFrom</span><span class="token punctuation">:</span>          <span class="token key atrule">secretKeyRef</span><span class="token punctuation">:</span>            <span class="token key atrule">name</span><span class="token punctuation">:</span> user            <span class="token key atrule">key</span><span class="token punctuation">:</span> pwd<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>2. 验证环境变量</strong></p><pre class="line-numbers language-bash"><code class="language-bash">kubectl apply -f env-pod.ymlkubectl <span class="token function">exec</span> env-pod -- <span class="token function">env</span> <span class="token operator">|</span> <span class="token function">grep</span> -E <span class="token string">'COUNT|GREETING|USERNAME|PASSWORD'</span><span class="token comment" spellcheck="true"># 输出:</span><span class="token comment" spellcheck="true"># COUNT=10</span><span class="token comment" spellcheck="true"># GREETING=say hello to kubernetes.</span><span class="token comment" spellcheck="true"># USERNAME=root</span><span class="token comment" spellcheck="true"># PASSWORD=123456</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="4-在-Pod-中使用-ConfigMap-x2F-Secret-作为文件挂载"><a href="#4-在-Pod-中使用-ConfigMap-x2F-Secret-作为文件挂载" class="headerlink" title="4. 在 Pod 中使用 ConfigMap/Secret 作为文件挂载"></a><strong>4. 在 Pod 中使用 ConfigMap/Secret 作为文件挂载</strong></h2><p><strong>1. 配置 Volume 挂载</strong></p><pre class="line-numbers language-yaml"><code class="language-yaml"><span class="token comment" spellcheck="true"># vol-pod.yml</span><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> v1<span class="token key atrule">kind</span><span class="token punctuation">:</span> Pod<span class="token key atrule">metadata</span><span class="token punctuation">:</span>  <span class="token key atrule">name</span><span class="token punctuation">:</span> vol<span class="token punctuation">-</span>pod<span class="token key atrule">spec</span><span class="token punctuation">:</span>  <span class="token key atrule">containers</span><span class="token punctuation">:</span>  <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> busy    <span class="token key atrule">image</span><span class="token punctuation">:</span> busybox    <span class="token key atrule">command</span><span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token string">"/bin/sleep"</span><span class="token punctuation">,</span> <span class="token string">"300"</span><span class="token punctuation">]</span>    <span class="token key atrule">volumeMounts</span><span class="token punctuation">:</span>    <span class="token punctuation">-</span> <span class="token key atrule">mountPath</span><span class="token punctuation">:</span> /tmp/cm<span class="token punctuation">-</span>items  <span class="token comment" spellcheck="true"># ConfigMap挂载路径</span>      <span class="token key atrule">name</span><span class="token punctuation">:</span> cm<span class="token punctuation">-</span>vol    <span class="token punctuation">-</span> <span class="token key atrule">mountPath</span><span class="token punctuation">:</span> /tmp/sec<span class="token punctuation">-</span>items  <span class="token comment" spellcheck="true"># Secret挂载路径</span>      <span class="token key atrule">name</span><span class="token punctuation">:</span> sec<span class="token punctuation">-</span>vol  <span class="token key atrule">volumes</span><span class="token punctuation">:</span>  <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> cm<span class="token punctuation">-</span>vol    <span class="token key atrule">configMap</span><span class="token punctuation">:</span>      <span class="token key atrule">name</span><span class="token punctuation">:</span> info  <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> sec<span class="token punctuation">-</span>vol    <span class="token key atrule">secret</span><span class="token punctuation">:</span>      <span class="token key atrule">secretName</span><span class="token punctuation">:</span> user<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>2. 验证文件挂载</strong></p><pre class="line-numbers language-bash"><code class="language-bash">kubectl apply -f vol-pod.ymlkubectl <span class="token function">exec</span> -it vol-pod -- sh<span class="token comment" spellcheck="true"># 在容器内执行:</span><span class="token function">ls</span> /tmp/cm-items/  <span class="token comment" spellcheck="true"># 查看ConfigMap文件</span><span class="token function">cat</span> /tmp/cm-items/count  <span class="token comment" spellcheck="true"># 查看ConfigMap值</span><span class="token function">ls</span> /tmp/sec-items/  <span class="token comment" spellcheck="true"># 查看Secret文件</span><span class="token function">cat</span> /tmp/sec-items/pwd  <span class="token comment" spellcheck="true"># 查看Secret值</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="5-最佳实践与注意事项"><a href="#5-最佳实践与注意事项" class="headerlink" title="5. 最佳实践与注意事项"></a><strong>5. 最佳实践与注意事项</strong></h2><ol><li><p><strong>敏感数据处理</strong></p><ul><li>Secret 仅提供基础编码（Base64），非加密</li><li>避免在 YAML 文件中硬编码敏感信息，建议使用工具如<a href="https://github.com/bitnami-labs/sealed-secrets">kubeseal</a>或外部密钥管理系统</li></ul></li><li><p><strong>数据更新机制</strong></p><ul><li>环境变量方式：更新 ConfigMap/Secret 后，Pod 需重启才能获取新值</li><li>挂载文件方式：部分应用支持动态加载配置文件（如 Nginx）</li></ul></li><li><p><strong>挂载权限控制</strong></p><pre class="line-numbers language-yaml"><code class="language-yaml"><span class="token key atrule">volumes</span><span class="token punctuation">:</span><span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> sec<span class="token punctuation">-</span>vol  <span class="token key atrule">secret</span><span class="token punctuation">:</span>    <span class="token key atrule">secretName</span><span class="token punctuation">:</span> user    <span class="token key atrule">defaultMode</span><span class="token punctuation">:</span> <span class="token number">0400  </span><span class="token comment" spellcheck="true"># 限制文件权限为只读（默认0644）</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p><strong>常见类型 Secret</strong></p><ul><li><code>Opaque</code>：通用密钥</li><li><code>kubernetes.io/dockerconfigjson</code>：Docker 镜像仓库认证</li><li><code>kubernetes.io/tls</code>：TLS 证书</li></ul></li></ol><h2 id="6-管理命令速查表"><a href="#6-管理命令速查表" class="headerlink" title="6. 管理命令速查表"></a><strong>6. 管理命令速查表</strong></h2><table><thead><tr><th>操作</th><th>ConfigMap 命令</th><th>Secret 命令</th></tr></thead><tbody><tr><td>创建</td><td><code>kubectl create cm info --from-literal=k=v</code></td><td><code>kubectl create secret generic user --from-literal=name=root</code></td></tr><tr><td>从文件创建</td><td><code>kubectl create cm info --from-file=app.conf</code></td><td><code>kubectl create secret generic user --from-file=./password</code></td></tr><tr><td>查看列表</td><td><code>kubectl get cm</code></td><td><code>kubectl get secrets</code></td></tr><tr><td>查看详情</td><td><code>kubectl describe cm info</code></td><td><code>kubectl describe secret user</code></td></tr><tr><td>编辑</td><td><code>kubectl edit cm info</code></td><td><code>kubectl edit secret user</code></td></tr><tr><td>删除</td><td><code>kubectl delete cm info</code></td><td><code>kubectl delete secret user</code></td></tr></tbody></table><p>通过以上步骤，你可以掌握 ConfigMap 和 Secret 的基本用法，实现应用配置与敏感信息的安全管理。</p>]]></content>
      
      
      <categories>
          
          <category> Kubernetes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 容器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Kubernetes教程--Job与CronJob的使用</title>
      <link href="/2024/kubernetes-jiao-cheng-job-yu-cronjob-de-shi-yong/"/>
      <url>/2024/kubernetes-jiao-cheng-job-yu-cronjob-de-shi-yong/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h2 id="1、Job-基础概念"><a href="#1、Job-基础概念" class="headerlink" title="1、Job 基础概念"></a><strong>1、Job 基础概念</strong></h2><p>Job 是 Kubernetes 中用于运行一次性任务的资源对象，它会创建一个或多个 Pod，并确保指定数量的 Pod 成功完成。核心参数：</p><ul><li><code>completions</code>：需要成功完成的 Pod 总数</li><li><code>parallelism</code>：同时运行的 Pod 数量</li><li><code>backoffLimit</code>：任务失败后的重试次数</li><li><code>activeDeadlineSeconds</code>：Job 允许运行的最长时间</li></ul><h2 id="2、创建简单-Job"><a href="#2、创建简单-Job" class="headerlink" title="2、创建简单 Job"></a><strong>2、创建简单 Job</strong></h2><p><strong>1. 生成 Job 模板</strong></p><pre class="line-numbers language-bash"><code class="language-bash">kubectl create job busy-job --image<span class="token operator">=</span>busybox --dry-run<span class="token operator">=</span>client -o yaml <span class="token operator">></span> busy-job.yml<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>2. 编辑 Job 配置</strong></p><pre class="line-numbers language-yaml"><code class="language-yaml"><span class="token comment" spellcheck="true"># busy-job.yml</span><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> batch/v1<span class="token key atrule">kind</span><span class="token punctuation">:</span> Job<span class="token key atrule">metadata</span><span class="token punctuation">:</span>  <span class="token key atrule">name</span><span class="token punctuation">:</span> busy<span class="token punctuation">-</span>job<span class="token key atrule">spec</span><span class="token punctuation">:</span>  <span class="token key atrule">template</span><span class="token punctuation">:</span>    <span class="token key atrule">spec</span><span class="token punctuation">:</span>      <span class="token key atrule">restartPolicy</span><span class="token punctuation">:</span> OnFailure  <span class="token comment" spellcheck="true"># 失败时重启容器</span>      <span class="token key atrule">containers</span><span class="token punctuation">:</span>      <span class="token punctuation">-</span> <span class="token key atrule">image</span><span class="token punctuation">:</span> busybox        <span class="token key atrule">name</span><span class="token punctuation">:</span> busybox        <span class="token key atrule">command</span><span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token string">"/bin/echo"</span><span class="token punctuation">]</span>        <span class="token key atrule">args</span><span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token string">"hello"</span><span class="token punctuation">,</span> <span class="token string">"world"</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>3. 应用并验证</strong></p><pre class="line-numbers language-bash"><code class="language-bash">kubectl apply -f busy-job.ymlkubectl get job  <span class="token comment" spellcheck="true"># 查看Job状态</span>kubectl get pods  <span class="token comment" spellcheck="true"># 查看Pod状态</span>kubectl logs <span class="token operator">&lt;</span>pod-name<span class="token operator">></span>  <span class="token comment" spellcheck="true"># 查看输出日志</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h2 id="3、并行-Job-配置"><a href="#3、并行-Job-配置" class="headerlink" title="3、并行 Job 配置"></a><strong>3、并行 Job 配置</strong></h2><p><strong>1. 创建并行 Job</strong></p><pre class="line-numbers language-yaml"><code class="language-yaml"><span class="token comment" spellcheck="true"># busybox-mutil-job.yml</span><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> batch/v1<span class="token key atrule">kind</span><span class="token punctuation">:</span> Job<span class="token key atrule">metadata</span><span class="token punctuation">:</span>  <span class="token key atrule">name</span><span class="token punctuation">:</span> busybox<span class="token key atrule">spec</span><span class="token punctuation">:</span>  <span class="token key atrule">activeDeadlineSeconds</span><span class="token punctuation">:</span> <span class="token number">15  </span><span class="token comment" spellcheck="true"># 最长运行时间15秒</span>  <span class="token key atrule">backoffLimit</span><span class="token punctuation">:</span> <span class="token number">2            </span><span class="token comment" spellcheck="true"># 最多重试2次</span>  <span class="token key atrule">completions</span><span class="token punctuation">:</span> <span class="token number">4             </span><span class="token comment" spellcheck="true"># 需要完成4个任务</span>  <span class="token key atrule">parallelism</span><span class="token punctuation">:</span> <span class="token number">2             </span><span class="token comment" spellcheck="true"># 同时运行2个Pod</span>  <span class="token key atrule">template</span><span class="token punctuation">:</span>    <span class="token key atrule">spec</span><span class="token punctuation">:</span>      <span class="token key atrule">restartPolicy</span><span class="token punctuation">:</span> OnFailure      <span class="token key atrule">containers</span><span class="token punctuation">:</span>      <span class="token punctuation">-</span> <span class="token key atrule">image</span><span class="token punctuation">:</span> busybox        <span class="token key atrule">command</span><span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token string">"/bin/sh"</span><span class="token punctuation">,</span> <span class="token string">"-c"</span><span class="token punctuation">]</span>        <span class="token key atrule">args</span><span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token string">"sleep 300"</span><span class="token punctuation">]</span>  <span class="token comment" spellcheck="true"># 模拟长时间任务</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>2. 验证超时机制</strong></p><pre class="line-numbers language-bash"><code class="language-bash">kubectl apply -f busybox-mutil-job.ymlkubectl get job  <span class="token comment" spellcheck="true"># 查看状态（等待15秒后会超时）</span>kubectl describe job busybox  <span class="token comment" spellcheck="true"># 查看详细信息</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><strong>3. 关键点说明</strong></p><ul><li><code>activeDeadlineSeconds</code> 超时后，Job 状态变为 <code>Failed</code>，所有 Pod 会被终止</li><li><code>completions</code> 和 <code>parallelism</code> 控制任务的总数量和并行度</li></ul><h2 id="4、CronJob（定时任务）"><a href="#4、CronJob（定时任务）" class="headerlink" title="4、CronJob（定时任务）"></a><strong>4、CronJob（定时任务）</strong></h2><p>CronJob 是 Job 的上层资源，用于按时间调度重复执行的任务。</p><p><strong>1. 生成 CronJob 模板</strong></p><pre class="line-numbers language-bash"><code class="language-bash">kubectl create cj busy-job --image<span class="token operator">=</span>busybox --schedule<span class="token operator">=</span><span class="token string">""</span> --dry-run<span class="token operator">=</span>client -o yaml <span class="token operator">></span> cronjob.yml<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>2. 配置定时任务</strong></p><pre class="line-numbers language-yaml"><code class="language-yaml"><span class="token comment" spellcheck="true"># cronjob.yml</span><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> batch/v1beta1<span class="token key atrule">kind</span><span class="token punctuation">:</span> CronJob<span class="token key atrule">metadata</span><span class="token punctuation">:</span>  <span class="token key atrule">name</span><span class="token punctuation">:</span> echo<span class="token punctuation">-</span>hello<span class="token key atrule">spec</span><span class="token punctuation">:</span>  <span class="token key atrule">schedule</span><span class="token punctuation">:</span> <span class="token string">'*/1 * * * *'</span>  <span class="token comment" spellcheck="true"># 每分钟执行一次</span>  <span class="token key atrule">jobTemplate</span><span class="token punctuation">:</span>    <span class="token key atrule">spec</span><span class="token punctuation">:</span>      <span class="token key atrule">template</span><span class="token punctuation">:</span>        <span class="token key atrule">spec</span><span class="token punctuation">:</span>          <span class="token key atrule">restartPolicy</span><span class="token punctuation">:</span> OnFailure          <span class="token key atrule">containers</span><span class="token punctuation">:</span>          <span class="token punctuation">-</span> <span class="token key atrule">image</span><span class="token punctuation">:</span> busybox            <span class="token key atrule">command</span><span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token string">"/bin/echo"</span><span class="token punctuation">]</span>            <span class="token key atrule">args</span><span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token string">"hello"</span><span class="token punctuation">,</span> <span class="token string">"world"</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>3. 应用并验证</strong></p><pre class="line-numbers language-bash"><code class="language-bash">kubectl apply -f cronjob.ymlkubectl get cj  <span class="token comment" spellcheck="true"># 查看CronJob列表</span>kubectl get <span class="token function">jobs</span>  <span class="token comment" spellcheck="true"># 查看创建的Job</span>kubectl get pods  <span class="token comment" spellcheck="true"># 查看执行任务的Pod</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h2 id="5、实战案例：PostgreSQL-备份任务"><a href="#5、实战案例：PostgreSQL-备份任务" class="headerlink" title="5、实战案例：PostgreSQL 备份任务"></a><strong>5、实战案例：PostgreSQL 备份任务</strong></h2><p><strong>1. 配置 CronJob</strong></p><pre class="line-numbers language-yaml"><code class="language-yaml"><span class="token comment" spellcheck="true"># postgres-backup.yml</span><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> batch/v1<span class="token key atrule">kind</span><span class="token punctuation">:</span> CronJob<span class="token key atrule">metadata</span><span class="token punctuation">:</span>  <span class="token key atrule">name</span><span class="token punctuation">:</span> postgres<span class="token punctuation">-</span>backup<span class="token key atrule">spec</span><span class="token punctuation">:</span>  <span class="token key atrule">schedule</span><span class="token punctuation">:</span> <span class="token string">"0 2 * * *"</span>  <span class="token comment" spellcheck="true"># 每天凌晨2点执行</span>  <span class="token key atrule">jobTemplate</span><span class="token punctuation">:</span>    <span class="token key atrule">spec</span><span class="token punctuation">:</span>      <span class="token key atrule">template</span><span class="token punctuation">:</span>        <span class="token key atrule">spec</span><span class="token punctuation">:</span>          <span class="token key atrule">containers</span><span class="token punctuation">:</span>          <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> backup            <span class="token key atrule">image</span><span class="token punctuation">:</span> bitnami/kubectl            <span class="token key atrule">command</span><span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token string">"/bin/sh"</span><span class="token punctuation">,</span> <span class="token string">"-c"</span><span class="token punctuation">]</span>            <span class="token key atrule">args</span><span class="token punctuation">:</span>              <span class="token punctuation">-</span> kubectl exec postgresql<span class="token punctuation">-</span>0 <span class="token punctuation">-</span><span class="token punctuation">-</span> pg_dump <span class="token punctuation">-</span>U postgres <span class="token punctuation">-</span>d mydb <span class="token punctuation">></span> /backup/mydb_$(date +%Y%m%d).sql            <span class="token key atrule">volumeMounts</span><span class="token punctuation">:</span>            <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> backup<span class="token punctuation">-</span>storage              <span class="token key atrule">mountPath</span><span class="token punctuation">:</span> /backup          <span class="token key atrule">volumes</span><span class="token punctuation">:</span>          <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> backup<span class="token punctuation">-</span>storage            <span class="token key atrule">persistentVolumeClaim</span><span class="token punctuation">:</span>              <span class="token key atrule">claimName</span><span class="token punctuation">:</span> postgres<span class="token punctuation">-</span>backup<span class="token punctuation">-</span>pvc  <span class="token comment" spellcheck="true"># 挂载PVC存储备份</span>          <span class="token key atrule">restartPolicy</span><span class="token punctuation">:</span> OnFailure<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>2. 关键点说明</strong></p><ul><li>使用 <code>kubectl exec</code> 命令执行数据库备份</li><li>通过 PVC 持久化存储备份文件</li><li>时间表达式 <code>0 2 * * *</code> 表示每天凌晨 2 点执行</li></ul><h2 id="6、Job-x2F-CronJob-管理命令"><a href="#6、Job-x2F-CronJob-管理命令" class="headerlink" title="6、Job/CronJob 管理命令"></a><strong>6、Job/CronJob 管理命令</strong></h2><table><thead><tr><th>操作</th><th>命令示例</th><th>说明</th></tr></thead><tbody><tr><td>创建资源</td><td><code>kubectl apply -f job.yml</code></td><td>从 YAML 文件创建 Job/CronJob</td></tr><tr><td>查看 Job 列表</td><td><code>kubectl get jobs</code></td><td>显示所有 Job 及其状态</td></tr><tr><td>查看 CronJob 列表</td><td><code>kubectl get cronjobs</code></td><td>显示所有 CronJob 及其状态</td></tr><tr><td>查看 Job 详情</td><td><code>kubectl describe job &lt;name&gt;</code></td><td>获取 Job 详细信息</td></tr><tr><td>查看 Pod 日志</td><td><code>kubectl logs &lt;pod-name&gt;</code></td><td>获取任务输出日志</td></tr><tr><td>删除资源</td><td><code>kubectl delete -f job.yml</code></td><td>删除 Job/CronJob 及其 Pod</td></tr><tr><td>暂停 CronJob</td><td><code>kubectl patch cj &lt;name&gt; -p '{"spec":{"suspend":true}}'</code></td><td>暂停调度</td></tr></tbody></table><h2 id="7、常见问题排查"><a href="#7、常见问题排查" class="headerlink" title="7、常见问题排查"></a><strong>7、常见问题排查</strong></h2><ol><li><strong>Job 未完成且不超时</strong><ul><li>检查 <code>activeDeadlineSeconds</code> 是否设置过小</li><li>使用 <code>kubectl describe job</code> 查看事件日志</li></ul></li><li><strong>CronJob 未按计划执行</strong><ul><li>验证 <code>schedule</code> 表达式格式（可使用工具如 <a href="https://crontab.guru/">crontab.guru</a> 检查）</li><li>检查 CronJob 状态：<code>kubectl get cj &lt;name&gt; -o yaml</code></li></ul></li><li><strong>Pod 一直重启</strong><ul><li>检查 <code>restartPolicy</code> 设置（Job 中推荐使用 <code>OnFailure</code> 或 <code>Never</code>）</li><li>查看 Pod 日志定位错误原因</li></ul></li></ol><p>通过以上步骤，你可以掌握 Kubernetes 中 Job 和 CronJob 的基本使用方法，实现一次性任务和定时任务的自动化执行。</p>]]></content>
      
      
      <categories>
          
          <category> Kubernetes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 容器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Kubernetes教程--使用NFS持久化存储</title>
      <link href="/2024/kubernetes-jiao-cheng-shi-yong-nfs-chi-jiu-hua-cun-chu/"/>
      <url>/2024/kubernetes-jiao-cheng-shi-yong-nfs-chi-jiu-hua-cun-chu/</url>
      
        <content type="html"><![CDATA[<p>本教程将详细介绍如何在 Kubernetes 中使用 NFS 作为持久化存储，包括 PV (PersistentVolume)、PVC (PersistentVolumeClaim) 的创建和使用，以及 Deployment 挂载 PVC 的完整流程。</p><p>[TOC]</p><h2 id="1-NFS-服务器配置"><a href="#1-NFS-服务器配置" class="headerlink" title="1. NFS 服务器配置"></a><strong>1. NFS 服务器配置</strong></h2><p>NFS（Network File System）是一种分布式文件系统协议，允许客户端通过网络访问服务器上的文件。</p><p><strong>步骤：</strong></p><ol><li><p><strong>安装 NFS 服务</strong></p><pre class="line-numbers language-bash"><code class="language-bash">yum <span class="token function">install</span> nfs-utils -ysystemctl <span class="token function">enable</span> nfs-server<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li><p><strong>创建共享目录并配置权限</strong></p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">mkdir</span> /home/jinli/nfs/data -p<span class="token function">chown</span> -R jinli: /home/jinli/nfs<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li><p><strong>配置 NFS 导出规则</strong></p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">cat</span> <span class="token operator">></span> /etc/exports <span class="token operator">&lt;&lt;</span><span class="token string">EOF/home/jinli/nfs/data 192.168.137.226/24(rw,no_root_squash)EOF</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><ul><li><code>rw</code>：允许读写访问</li><li><code>no_root_squash</code>：不将 root 用户映射为匿名用户</li></ul></li><li><p><strong>启动 NFS 服务</strong></p><pre class="line-numbers language-bash"><code class="language-bash">systemctl start nfs-server<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p><strong>验证共享目录</strong></p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">su</span> - jinli<span class="token function">touch</span> /home/jinli/nfs/data/a  <span class="token comment" spellcheck="true"># 创建测试文件</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li></ol><h2 id="2-NFS-客户端挂载测试"><a href="#2-NFS-客户端挂载测试" class="headerlink" title="2. NFS 客户端挂载测试"></a><strong>2. NFS 客户端挂载测试</strong></h2><p>在 Kubernetes 节点上验证 NFS 挂载：</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 在节点上执行</span>showmount -e 192.168.137.226  <span class="token comment" spellcheck="true"># 查看NFS服务器共享列表</span><span class="token function">mkdir</span> /home/jinli/nfs/data -p<span class="token function">chown</span> -R jinli:jinli /home/jinli/nfs<span class="token function">mount</span> -t nfs 192.168.137.226:/home/jinli/nfs/data /home/jinli/nfs/data<span class="token function">df</span> -h  <span class="token comment" spellcheck="true"># 查看挂载结果</span>ll /home/jinli/nfs/data  <span class="token comment" spellcheck="true"># 应看到测试文件a</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="3-创建-Kubernetes-PersistentVolume-PV"><a href="#3-创建-Kubernetes-PersistentVolume-PV" class="headerlink" title="3. 创建 Kubernetes PersistentVolume (PV)"></a><strong>3. 创建 Kubernetes PersistentVolume (PV)</strong></h2><p>PV 是集群中的存储资源，由管理员预先配置。</p><pre class="line-numbers language-yaml"><code class="language-yaml"><span class="token comment" spellcheck="true"># pv-nfs.yml</span><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> v1<span class="token key atrule">kind</span><span class="token punctuation">:</span> PersistentVolume<span class="token key atrule">metadata</span><span class="token punctuation">:</span>  <span class="token key atrule">name</span><span class="token punctuation">:</span> pv001  <span class="token key atrule">labels</span><span class="token punctuation">:</span>    <span class="token key atrule">pvname</span><span class="token punctuation">:</span> pv001<span class="token key atrule">spec</span><span class="token punctuation">:</span>  <span class="token key atrule">capacity</span><span class="token punctuation">:</span>    <span class="token key atrule">storage</span><span class="token punctuation">:</span> 2Gi  <span class="token key atrule">accessModes</span><span class="token punctuation">:</span>    <span class="token punctuation">-</span> ReadWriteOnce  <span class="token comment" spellcheck="true"># 单节点读写</span>  <span class="token key atrule">persistentVolumeReclaimPolicy</span><span class="token punctuation">:</span> Recycle  <span class="token comment" spellcheck="true"># 删除PVC后自动清理数据</span>  <span class="token key atrule">nfs</span><span class="token punctuation">:</span>    <span class="token key atrule">path</span><span class="token punctuation">:</span> /home/jinli/nfs/data    <span class="token key atrule">server</span><span class="token punctuation">:</span> 192.168.137.226<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>应用并验证：</strong></p><pre class="line-numbers language-bash"><code class="language-bash">kubectl apply -f pv-nfs.ymlkubectl get <span class="token function">pv</span>  <span class="token comment" spellcheck="true"># 状态应为Available</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="4-创建-PersistentVolumeClaim-PVC"><a href="#4-创建-PersistentVolumeClaim-PVC" class="headerlink" title="4. 创建 PersistentVolumeClaim (PVC)"></a><strong>4. 创建 PersistentVolumeClaim (PVC)</strong></h2><p>PVC 是用户对存储的请求，用于绑定 PV。</p><pre class="line-numbers language-yaml"><code class="language-yaml"><span class="token comment" spellcheck="true"># pvc-nfs.yml</span><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> v1<span class="token key atrule">kind</span><span class="token punctuation">:</span> PersistentVolumeClaim<span class="token key atrule">metadata</span><span class="token punctuation">:</span>  <span class="token key atrule">name</span><span class="token punctuation">:</span> myclaim01<span class="token key atrule">spec</span><span class="token punctuation">:</span>  <span class="token key atrule">accessModes</span><span class="token punctuation">:</span>    <span class="token punctuation">-</span> ReadWriteOnce  <span class="token key atrule">resources</span><span class="token punctuation">:</span>    <span class="token key atrule">requests</span><span class="token punctuation">:</span>      <span class="token key atrule">storage</span><span class="token punctuation">:</span> 2Gi  <span class="token key atrule">selector</span><span class="token punctuation">:</span>    <span class="token key atrule">matchExpressions</span><span class="token punctuation">:</span>      <span class="token punctuation">-</span> <span class="token key atrule">key</span><span class="token punctuation">:</span> pvname        <span class="token key atrule">operator</span><span class="token punctuation">:</span> In        <span class="token key atrule">values</span><span class="token punctuation">:</span>          <span class="token punctuation">-</span> pv001  <span class="token comment" spellcheck="true"># 匹配PV的标签</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>应用并验证：</strong></p><pre class="line-numbers language-bash"><code class="language-bash">kubectl apply -f pvc-nfs.ymlkubectl get pvc  <span class="token comment" spellcheck="true"># 状态应为Bound</span>kubectl get <span class="token function">pv</span>  <span class="token comment" spellcheck="true"># PV状态应为Bound</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h2 id="5-在-Pod-中使用-PVC"><a href="#5-在-Pod-中使用-PVC" class="headerlink" title="5. 在 Pod 中使用 PVC"></a><strong>5. 在 Pod 中使用 PVC</strong></h2><p>通过 Deployment 创建 Pod，并挂载 PVC。</p><pre class="line-numbers language-yaml"><code class="language-yaml"><span class="token comment" spellcheck="true"># pv-deployment.yml</span><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> apps/v1<span class="token key atrule">kind</span><span class="token punctuation">:</span> Deployment<span class="token key atrule">metadata</span><span class="token punctuation">:</span>  <span class="token key atrule">name</span><span class="token punctuation">:</span> pv<span class="token punctuation">-</span>deploy<span class="token key atrule">spec</span><span class="token punctuation">:</span>  <span class="token key atrule">replicas</span><span class="token punctuation">:</span> <span class="token number">2</span>  <span class="token key atrule">selector</span><span class="token punctuation">:</span>    <span class="token key atrule">matchLabels</span><span class="token punctuation">:</span>      <span class="token key atrule">app</span><span class="token punctuation">:</span> nfs<span class="token punctuation">-</span>pod  <span class="token key atrule">template</span><span class="token punctuation">:</span>    <span class="token key atrule">metadata</span><span class="token punctuation">:</span>      <span class="token key atrule">labels</span><span class="token punctuation">:</span>        <span class="token key atrule">app</span><span class="token punctuation">:</span> nfs<span class="token punctuation">-</span>pod    <span class="token key atrule">spec</span><span class="token punctuation">:</span>      <span class="token key atrule">containers</span><span class="token punctuation">:</span>      <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> myfrontend        <span class="token key atrule">image</span><span class="token punctuation">:</span> nginx<span class="token punctuation">:</span>latest        <span class="token key atrule">volumeMounts</span><span class="token punctuation">:</span>        <span class="token punctuation">-</span> <span class="token key atrule">mountPath</span><span class="token punctuation">:</span> <span class="token string">"/var/www/html"</span>  <span class="token comment" spellcheck="true"># 容器内挂载路径</span>          <span class="token key atrule">name</span><span class="token punctuation">:</span> mypd      <span class="token key atrule">volumes</span><span class="token punctuation">:</span>      <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> mypd        <span class="token key atrule">persistentVolumeClaim</span><span class="token punctuation">:</span>          <span class="token key atrule">claimName</span><span class="token punctuation">:</span> myclaim01  <span class="token comment" spellcheck="true"># 引用PVC</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>应用并验证：</strong></p><pre class="line-numbers language-bash"><code class="language-bash">kubectl apply -f pv-deployment.ymlkubectl get pods  <span class="token comment" spellcheck="true"># 确保Pod状态为Running</span><span class="token comment" spellcheck="true"># 验证数据共享</span><span class="token function">cp</span> /etc/profile /home/jinli/nfs/data/  <span class="token comment" spellcheck="true"># 在NFS服务器添加文件</span>kubectl <span class="token function">exec</span> <span class="token operator">&lt;</span>pod-name<span class="token operator">></span> -- <span class="token function">ls</span> /var/www/html  <span class="token comment" spellcheck="true"># 应看到a和profile文件</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="6-数据持久化验证"><a href="#6-数据持久化验证" class="headerlink" title="6. 数据持久化验证"></a><strong>6. 数据持久化验证</strong></h2><p>删除 Pod 后重建，数据仍然存在：</p><pre class="line-numbers language-bash"><code class="language-bash">kubectl delete pod <span class="token operator">&lt;</span>pod-name<span class="token operator">></span>  <span class="token comment" spellcheck="true"># 删除Pod</span>kubectl get pods  <span class="token comment" spellcheck="true"># 等待新Pod启动</span>kubectl <span class="token function">exec</span> <span class="token operator">&lt;</span>new-pod-name<span class="token operator">></span> -- <span class="token function">ls</span> /var/www/html  <span class="token comment" spellcheck="true"># 数据仍然存在</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h2 id="7-清理资源"><a href="#7-清理资源" class="headerlink" title="7. 清理资源"></a><strong>7. 清理资源</strong></h2><p>按顺序删除资源：</p><pre class="line-numbers language-bash"><code class="language-bash">kubectl delete -f pv-deployment.yml  <span class="token comment" spellcheck="true"># 删除Deployment</span>kubectl delete -f pvc-nfs.yml  <span class="token comment" spellcheck="true"># 删除PVC</span><span class="token comment" spellcheck="true"># 检查PV状态变为Released后，自动清理数据（Recycle策略）</span>kubectl get <span class="token function">pv</span>  <span class="token comment" spellcheck="true"># 最终状态变为Available</span><span class="token function">ls</span> /home/jinli/nfs/data  <span class="token comment" spellcheck="true"># NFS目录应被清空</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>关键点说明</strong></p><ol><li><strong>PV 与 PVC 绑定</strong>：通过标签选择器（<code>selector</code>）匹配 PV 和 PVC。</li><li>访问模式：<ul><li><code>ReadWriteOnce</code>：单节点读写</li><li><code>ReadOnlyMany</code>：多节点只读</li><li><code>ReadWriteMany</code>：多节点读写</li></ul></li><li>回收策略：<ul><li><code>Recycle</code>：删除 PVC 后自动清理数据（NFS 支持）</li><li><code>Retain</code>：保留数据，需手动清理</li><li><code>Delete</code>：删除 PV 时自动删除存储（云存储常用）</li></ul></li><li><strong>NFS 优势</strong>：支持多节点挂载，适合需要共享存储的场景。</li></ol><h2 id="8-常见问题排查"><a href="#8-常见问题排查" class="headerlink" title="8. 常见问题排查"></a><strong>8. 常见问题排查</strong></h2><ol><li><strong>PVC 状态为 Pending</strong>：<ul><li>PV 容量不足</li><li>标签选择器不匹配</li><li>NFS 服务器不可达</li></ul></li><li><strong>Pod 无法启动</strong>：<ul><li>检查 NFS 服务器 IP 和路径是否正确</li><li>确认 NFS 服务正常运行</li><li>检查防火墙是否开放 NFS 端口（默认 2049）</li></ul></li></ol><p>通过以上步骤，你已成功实现 NFS 与 Kubernetes 的集成，为 Pod 提供了持久化存储。</p>]]></content>
      
      
      <categories>
          
          <category> Kubernetes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 容器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Harbor私有镜像仓库使用教程</title>
      <link href="/2024/harbor-si-you-jing-xiang-cang-ku-shi-yong-jiao-cheng/"/>
      <url>/2024/harbor-si-you-jing-xiang-cang-ku-shi-yong-jiao-cheng/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h2 id="1-环境准备"><a href="#1-环境准备" class="headerlink" title="1. 环境准备"></a>1. 环境准备</h2><h3 id="1-1-安装-Docker-Compose"><a href="#1-1-安装-Docker-Compose" class="headerlink" title="1.1 安装 Docker Compose"></a>1.1 安装 Docker Compose</h3><pre class="line-numbers language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 下载 Docker Compose</span><span class="token function">wget</span> https://github.com/docker/compose/releases/download/v2.37.1/docker-compose-linux-x86_64 -o /usr/local/bin/docker-compose<span class="token comment" spellcheck="true"># 添加执行权限</span><span class="token function">chmod</span> +x /usr/local/bin/docker-compose<span class="token comment" spellcheck="true"># 验证安装</span>docker-compose version<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="2-安装-Harbor"><a href="#2-安装-Harbor" class="headerlink" title="2. 安装 Harbor"></a>2. 安装 Harbor</h2><h3 id="2-1-下载并解压-Harbor"><a href="#2-1-下载并解压-Harbor" class="headerlink" title="2.1 下载并解压 Harbor"></a>2.1 下载并解压 Harbor</h3><pre class="line-numbers language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 下载 Harbor 离线安装包</span><span class="token function">wget</span> https://github.com/goharbor/harbor/releases/download/v2.6.1/harbor-offline-installer-v2.6.1.tgz<span class="token comment" spellcheck="true"># 解压安装包</span><span class="token function">tar</span> xf harbor-offline-installer-v2.6.1.tgz<span class="token comment" spellcheck="true"># 进入 Harbor 目录</span><span class="token function">cd</span> harbor<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="2-2-配置-Harbor"><a href="#2-2-配置-Harbor" class="headerlink" title="2.2 配置 Harbor"></a>2.2 配置 Harbor</h3><pre class="line-numbers language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 复制配置文件模板</span><span class="token function">cp</span> harbor.yml.tmpl harbor.yml<span class="token comment" spellcheck="true"># 编辑配置文件</span><span class="token function">vi</span> harbor.yml<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>配置示例：</p><pre class="line-numbers language-yaml"><code class="language-yaml"><span class="token key atrule">hostname</span><span class="token punctuation">:</span> 192.168.137.226<span class="token comment" spellcheck="true"># http 相关配置</span><span class="token key atrule">http</span><span class="token punctuation">:</span>  <span class="token comment" spellcheck="true"># HTTP 端口，默认为 80。如果启用了 HTTPS，此端口将重定向到 HTTPS 端口</span>  <span class="token key atrule">port</span><span class="token punctuation">:</span> <span class="token number">5000</span><span class="token comment" spellcheck="true"># https 相关配置（可选）</span><span class="token comment" spellcheck="true">#https:</span><span class="token comment" spellcheck="true">#  # harbor 的 https 端口，默认为 443</span><span class="token comment" spellcheck="true">#  port: 443</span><span class="token comment" spellcheck="true">#  # nginx 的证书和密钥文件路径</span><span class="token comment" spellcheck="true">#  certificate: /your/certificate/path</span><span class="token comment" spellcheck="true">#  private_key: /your/private/key/path</span><span class="token comment" spellcheck="true"># 数据卷路径</span><span class="token key atrule">data_volume</span><span class="token punctuation">:</span> /home/jinli/harbor/data<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="2-3-安装-Harbor"><a href="#2-3-安装-Harbor" class="headerlink" title="2.3 安装 Harbor"></a>2.3 安装 Harbor</h3><pre class="line-numbers language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 运行安装脚本</span>./install.sh<span class="token comment" spellcheck="true"># 安装成功后，您将看到以下消息：</span>✔ ----Harbor has been installed and started successfully.----<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="3-访问-Harbor-Web-界面"><a href="#3-访问-Harbor-Web-界面" class="headerlink" title="3. 访问 Harbor Web 界面"></a>3. 访问 Harbor Web 界面</h2><p>在浏览器中打开：</p><pre class="line-numbers language-bash"><code class="language-bash">http://192.168.137.226:5000/<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>默认管理员用户名和密码：</p><ul><li>用户名：admin</li><li>密码：Harbor12345</li></ul><h2 id="4-管理-Harbor-服务"><a href="#4-管理-Harbor-服务" class="headerlink" title="4. 管理 Harbor 服务"></a>4. 管理 Harbor 服务</h2><pre class="line-numbers language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 停止 Harbor 服务</span>docker-compose down -v<span class="token comment" spellcheck="true"># 启动 Harbor 服务</span>docker-compose up -d<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="5-配置-Docker-客户端"><a href="#5-配置-Docker-客户端" class="headerlink" title="5. 配置 Docker 客户端"></a>5. 配置 Docker 客户端</h2><h3 id="5-1-配置-Docker-信任私有仓库"><a href="#5-1-配置-Docker-信任私有仓库" class="headerlink" title="5.1 配置 Docker 信任私有仓库"></a>5.1 配置 Docker 信任私有仓库</h3><pre class="line-numbers language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 编辑 Docker 配置文件</span><span class="token function">vi</span> /etc/docker/daemon.json<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>添加以下内容：</p><pre class="line-numbers language-json"><code class="language-json"><span class="token punctuation">{</span>  <span class="token property">"insecure-registries"</span><span class="token operator">:</span> <span class="token punctuation">[</span><span class="token string">"192.168.137.226:5000"</span><span class="token punctuation">]</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>重启 Docker 服务：</p><pre class="line-numbers language-bash"><code class="language-bash">systemctl restart docker<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="5-2-重启-Harbor-服务"><a href="#5-2-重启-Harbor-服务" class="headerlink" title="5.2 重启 Harbor 服务"></a>5.2 重启 Harbor 服务</h3><pre class="line-numbers language-bash"><code class="language-bash">docker-compose down -vdocker-compose up -d<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="6-使用-Harbor-仓库"><a href="#6-使用-Harbor-仓库" class="headerlink" title="6. 使用 Harbor 仓库"></a>6. 使用 Harbor 仓库</h2><h3 id="6-1-登录-Harbor"><a href="#6-1-登录-Harbor" class="headerlink" title="6.1 登录 Harbor"></a>6.1 登录 Harbor</h3><pre class="line-numbers language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 登录 Harbor</span>docker login 192.168.137.226:5000<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="6-2-登出-Harbor"><a href="#6-2-登出-Harbor" class="headerlink" title="6.2 登出 Harbor"></a>6.2 登出 Harbor</h3><pre class="line-numbers language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 登出 Harbor</span>docker <span class="token function">logout</span> 192.168.137.226:5000<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="6-3-推送镜像到-Harbor"><a href="#6-3-推送镜像到-Harbor" class="headerlink" title="6.3 推送镜像到 Harbor"></a>6.3 推送镜像到 Harbor</h3><pre class="line-numbers language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 1. 登录 Harbor</span>docker login 192.168.137.226:5000<span class="token comment" spellcheck="true"># 2. 为镜像打标签</span>docker tag postgres 192.168.137.226:5000/library/postgres<span class="token comment" spellcheck="true"># 3. 推送镜像到 Harbor</span>docker push 192.168.137.226:5000/library/postgres<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="7-总结"><a href="#7-总结" class="headerlink" title="7. 总结"></a>7. 总结</h2><p>本教程介绍了如何安装和配置 Harbor 私有 Docker 镜像仓库，包括：</p><ol><li>安装 Docker Compose</li><li>下载和安装 Harbor</li><li>配置 Harbor</li><li>访问 Web 界面</li><li>管理 Harbor 服务</li><li>配置 Docker 客户端</li><li>使用 Harbor 进行镜像推送和拉取</li></ol><p>通过 Harbor，您可以方便地管理私有 Docker 镜像，提高开发和部署效率。</p>]]></content>
      
      
      <categories>
          
          <category> Kubernetes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Harbor </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Kubernetes教程--Deployment的创建和管理</title>
      <link href="/2024/kubernetes-jiao-cheng-deployment-de-chuang-jian-he-guan-li/"/>
      <url>/2024/kubernetes-jiao-cheng-deployment-de-chuang-jian-he-guan-li/</url>
      
        <content type="html"><![CDATA[<p>本教程以部署Nginx为例，将带你逐步学习如何使用 Kubernetes Deployment 来管理 Pod，包括创建、查看、扩缩容和删除 Deployment 的全过程。</p><p>[TOC]</p><h2 id="1-准备-Deployment-配置文件"><a href="#1-准备-Deployment-配置文件" class="headerlink" title="1. 准备 Deployment 配置文件"></a>1. 准备 Deployment 配置文件</h2><p>首先创建一个 YAML 文件来定义我们的 Deployment：</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">touch</span> nginx-deployment.yaml<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>将以下内容写入 <code>nginx-deployment.yaml</code> 文件：</p><pre class="line-numbers language-yaml"><code class="language-yaml"><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> apps/v1<span class="token key atrule">kind</span><span class="token punctuation">:</span> Deployment<span class="token key atrule">metadata</span><span class="token punctuation">:</span>  <span class="token key atrule">name</span><span class="token punctuation">:</span> mynginx<span class="token punctuation">-</span>deployment<span class="token punctuation">-</span>new<span class="token key atrule">spec</span><span class="token punctuation">:</span>  <span class="token key atrule">replicas</span><span class="token punctuation">:</span> <span class="token number">3</span>  <span class="token key atrule">selector</span><span class="token punctuation">:</span>    <span class="token key atrule">matchLabels</span><span class="token punctuation">:</span>      <span class="token key atrule">app</span><span class="token punctuation">:</span> nginx      <span class="token key atrule">track</span><span class="token punctuation">:</span> stable  <span class="token key atrule">template</span><span class="token punctuation">:</span>    <span class="token key atrule">metadata</span><span class="token punctuation">:</span>      <span class="token key atrule">labels</span><span class="token punctuation">:</span>        <span class="token key atrule">app</span><span class="token punctuation">:</span> nginx        <span class="token key atrule">track</span><span class="token punctuation">:</span> stable    <span class="token key atrule">spec</span><span class="token punctuation">:</span>      <span class="token key atrule">containers</span><span class="token punctuation">:</span>        <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> nginx<span class="token punctuation">-</span>container          <span class="token key atrule">image</span><span class="token punctuation">:</span> nginx          <span class="token key atrule">ports</span><span class="token punctuation">:</span>            <span class="token punctuation">-</span> <span class="token key atrule">containerPort</span><span class="token punctuation">:</span> <span class="token number">80</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>配置文件解析：</strong></p><ul><li><code>apiVersion: apps/v1</code>: 指定使用的 Kubernetes API 版本</li><li><code>kind: Deployment</code>: 声明这是一个 Deployment 资源</li><li><code>replicas: 3</code>: 指定需要运行 3 个 Pod 副本</li><li><code>selector</code>: 定义 Deployment 如何找到要管理的 Pod</li><li><code>template</code>: 定义 Pod 的模板，包括元数据和容器规格</li></ul><h2 id="2-创建-Deployment"><a href="#2-创建-Deployment" class="headerlink" title="2. 创建 Deployment"></a>2. 创建 Deployment</h2><p>应用配置文件创建 Deployment:</p><pre class="line-numbers language-bash"><code class="language-bash">kubectl apply -f nginx-deployment.yaml<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>预期输出：</p><pre class="line-numbers language-bash"><code class="language-bash">deployment.apps/mynginx-deployment-new created<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="3-查看-Deployment-状态"><a href="#3-查看-Deployment-状态" class="headerlink" title="3. 查看 Deployment 状态"></a>3. 查看 Deployment 状态</h2><p>检查 Deployment 是否创建成功：</p><pre class="line-numbers language-bash"><code class="language-bash">kubectl get deployment<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>预期输出类似：</p><pre class="line-numbers language-bash"><code class="language-bash">NAME                      READY   UP-TO-DATE   AVAILABLE   AGEmynginx-deployment-new    3/3     3            3           30s<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>查看 Deployment 的详细信息：</p><pre class="line-numbers language-bash"><code class="language-bash">kubectl describe deployment mynginx-deployment-new<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这将显示 Deployment 的详细配置和状态信息。</p><h2 id="4-查看相关资源"><a href="#4-查看相关资源" class="headerlink" title="4. 查看相关资源"></a>4. 查看相关资源</h2><p>检查由 Deployment 创建的 ReplicaSet：</p><pre class="line-numbers language-bash"><code class="language-bash">kubectl get replicaset<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>预期输出类似：</p><pre class="line-numbers language-bash"><code class="language-bash">NAME                                DESIRED   CURRENT   READY   AGEmynginx-deployment-new-7cfb8ff87f   3         3         3       2m<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>查看由 ReplicaSet 创建的 Pod：</p><pre class="line-numbers language-bash"><code class="language-bash">kubectl get pods -o wide --show-labels<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre><code>NAME                                      READY   STATUS    LABELSmynginx-deployment-new-7cfb8ff87f-llhx6   1/1     Running   app=nginx,track=stablemynginx-deployment-new-7cfb8ff87f-n2p5k   1/1     Running   app=nginx,track=stablemynginx-deployment-new-7cfb8ff87f-x9z7q   1/1     Running   app=nginx,track=stable</code></pre><h2 id="5-扩缩容-Deployment"><a href="#5-扩缩容-Deployment" class="headerlink" title="5. 扩缩容 Deployment"></a>5. 扩缩容 Deployment</h2><p>将 Pod 副本数从 3 缩减到 2：</p><pre class="line-numbers language-bash"><code class="language-bash">kubectl scale deployment mynginx-deployment-new --replicas<span class="token operator">=</span>2<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>验证 Pod 数量：</p><pre class="line-numbers language-bash"><code class="language-bash">kubectl get pods<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>现在应该只看到 2 个 Pod 在运行。</p><h2 id="6-测试-Deployment-的自愈能力"><a href="#6-测试-Deployment-的自愈能力" class="headerlink" title="6. 测试 Deployment 的自愈能力"></a>6. 测试 Deployment 的自愈能力</h2><p>手动删除一个 Pod，观察 Deployment 的行为：</p><pre class="line-numbers language-bash"><code class="language-bash">kubectl delete pod mynginx-deployment-new-7cfb8ff87f-llhx6<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>立即检查 Pod 状态：</p><pre class="line-numbers language-bash"><code class="language-bash">kubectl get pods -w<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>你会看到 Kubernetes 自动创建了一个新的 Pod 来替换被删除的 Pod，以维持指定的副本数。</p><h2 id="7-删除-Deployment"><a href="#7-删除-Deployment" class="headerlink" title="7. 删除 Deployment"></a>7. 删除 Deployment</h2><p>当不再需要 Deployment 时，可以删除它：</p><pre class="line-numbers language-bash"><code class="language-bash">kubectl delete deployment mynginx-deployment-new<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这将删除 Deployment 及其管理的所有 Pod。</p><h2 id="8-验证删除结果"><a href="#8-验证删除结果" class="headerlink" title="8. 验证删除结果"></a>8. 验证删除结果</h2><p>检查所有资源是否已删除：</p><pre class="line-numbers language-bash"><code class="language-bash">kubectl get deploymentkubectl get pods<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>应该看不到任何相关资源。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>通过本教程，你学会了：</p><ol><li>如何定义 Kubernetes Deployment</li><li>如何创建和管理 Deployment</li><li>如何查看 Deployment 及其相关资源</li><li>如何进行扩缩容操作</li><li>如何测试 Deployment 的自愈能力</li><li>如何清理 Deployment 资源</li></ol><p>Deployment 是 Kubernetes 中最常用的工作负载资源之一，它提供了声明式更新、滚动升级和回滚等功能，是管理无状态应用的理想选择。</p>]]></content>
      
      
      <categories>
          
          <category> Kubernetes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 容器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Kubernetes教程--Deployment节点选择</title>
      <link href="/2024/kubernetes-jiao-cheng-deployment-jie-dian-xuan-ze/"/>
      <url>/2024/kubernetes-jiao-cheng-deployment-jie-dian-xuan-ze/</url>
      
        <content type="html"><![CDATA[<p>本教程以部署Nginx为例，将带你逐步学习如何使用 Kubernetes Deployment 来管理 Pod，包括创建、查看、扩缩容、节点选择以及删除 Deployment 的全过程。</p><p>[TOC]</p><h2 id="1-准备-Deployment-配置文件"><a href="#1-准备-Deployment-配置文件" class="headerlink" title="1. 准备 Deployment 配置文件"></a>1. 准备 Deployment 配置文件</h2><p>首先创建一个 YAML 文件来定义我们的 Deployment：</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">touch</span> nginx-deployment.yaml<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>将以下内容写入 <code>nginx-deployment.yaml</code> 文件：</p><pre class="line-numbers language-yaml"><code class="language-yaml"><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> apps/v1<span class="token key atrule">kind</span><span class="token punctuation">:</span> Deployment<span class="token key atrule">metadata</span><span class="token punctuation">:</span>  <span class="token key atrule">name</span><span class="token punctuation">:</span> mynginx<span class="token punctuation">-</span>deployment<span class="token punctuation">-</span>new<span class="token key atrule">spec</span><span class="token punctuation">:</span>  <span class="token key atrule">replicas</span><span class="token punctuation">:</span> <span class="token number">3</span>  <span class="token key atrule">selector</span><span class="token punctuation">:</span>    <span class="token key atrule">matchLabels</span><span class="token punctuation">:</span>      <span class="token key atrule">app</span><span class="token punctuation">:</span> nginx      <span class="token key atrule">track</span><span class="token punctuation">:</span> stable  <span class="token key atrule">template</span><span class="token punctuation">:</span>    <span class="token key atrule">metadata</span><span class="token punctuation">:</span>      <span class="token key atrule">labels</span><span class="token punctuation">:</span>        <span class="token key atrule">app</span><span class="token punctuation">:</span> nginx        <span class="token key atrule">track</span><span class="token punctuation">:</span> stable    <span class="token key atrule">spec</span><span class="token punctuation">:</span>      <span class="token key atrule">containers</span><span class="token punctuation">:</span>        <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> nginx<span class="token punctuation">-</span>container          <span class="token key atrule">image</span><span class="token punctuation">:</span> nginx          <span class="token key atrule">ports</span><span class="token punctuation">:</span>            <span class="token punctuation">-</span> <span class="token key atrule">containerPort</span><span class="token punctuation">:</span> <span class="token number">80</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>基础配置文件解析：</strong></p><ul><li><code>apiVersion: apps/v1</code>: 指定使用的 Kubernetes API 版本</li><li><code>kind: Deployment</code>: 声明这是一个 Deployment 资源</li><li><code>replicas: 3</code>: 指定需要运行 3 个 Pod 副本</li><li><code>selector</code>: 定义 Deployment 如何找到要管理的 Pod</li><li><code>template</code>: 定义 Pod 的模板，包括元数据和容器规格</li></ul><h2 id="2-添加节点选择器-nodeSelector"><a href="#2-添加节点选择器-nodeSelector" class="headerlink" title="2. 添加节点选择器 (nodeSelector)"></a>2. 添加节点选择器 (nodeSelector)</h2><p>要指定 Pod 运行在特定节点上，我们需要：</p><ol><li>首先给目标节点打标签</li><li>然后在 Deployment 中添加 nodeSelector</li></ol><h3 id="2-1-给节点打标签"><a href="#2-1-给节点打标签" class="headerlink" title="2.1 给节点打标签"></a>2.1 给节点打标签</h3><p>假设我们要将 Pod 调度到 node02 上：</p><pre class="line-numbers language-bash"><code class="language-bash">kubectl label nodes node02 node-type<span class="token operator">=</span>worker<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>验证标签是否添加成功：</p><pre class="line-numbers language-bash"><code class="language-bash">kubectl get nodes --show-labels<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="2-2-更新-Deployment-配置"><a href="#2-2-更新-Deployment-配置" class="headerlink" title="2.2 更新 Deployment 配置"></a>2.2 更新 Deployment 配置</h3><p>修改 <code>nginx-deployment.yaml</code>，添加 nodeSelector：</p><pre class="line-numbers language-yaml"><code class="language-yaml"><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> apps/v1<span class="token key atrule">kind</span><span class="token punctuation">:</span> Deployment<span class="token key atrule">metadata</span><span class="token punctuation">:</span>  <span class="token key atrule">name</span><span class="token punctuation">:</span> mynginx<span class="token punctuation">-</span>deployment<span class="token punctuation">-</span>new<span class="token key atrule">spec</span><span class="token punctuation">:</span>  <span class="token key atrule">replicas</span><span class="token punctuation">:</span> <span class="token number">3</span>  <span class="token key atrule">selector</span><span class="token punctuation">:</span>    <span class="token key atrule">matchLabels</span><span class="token punctuation">:</span>      <span class="token key atrule">app</span><span class="token punctuation">:</span> nginx      <span class="token key atrule">track</span><span class="token punctuation">:</span> stable  <span class="token key atrule">template</span><span class="token punctuation">:</span>    <span class="token key atrule">metadata</span><span class="token punctuation">:</span>      <span class="token key atrule">labels</span><span class="token punctuation">:</span>        <span class="token key atrule">app</span><span class="token punctuation">:</span> nginx        <span class="token key atrule">track</span><span class="token punctuation">:</span> stable    <span class="token key atrule">spec</span><span class="token punctuation">:</span>      <span class="token key atrule">containers</span><span class="token punctuation">:</span>        <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> nginx<span class="token punctuation">-</span>container          <span class="token key atrule">image</span><span class="token punctuation">:</span> nginx          <span class="token key atrule">ports</span><span class="token punctuation">:</span>            <span class="token punctuation">-</span> <span class="token key atrule">containerPort</span><span class="token punctuation">:</span> <span class="token number">80</span>      <span class="token key atrule">nodeSelector</span><span class="token punctuation">:</span>        <span class="token key atrule">node-type</span><span class="token punctuation">:</span> worker  <span class="token comment" spellcheck="true"># 与前面添加的标签匹配</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="3-创建-Deployment"><a href="#3-创建-Deployment" class="headerlink" title="3. 创建 Deployment"></a>3. 创建 Deployment</h2><p>应用配置文件创建 Deployment:</p><pre class="line-numbers language-bash"><code class="language-bash">kubectl apply -f nginx-deployment.yaml<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>预期输出：</p><pre class="line-numbers language-bash"><code class="language-bash">deployment.apps/mynginx-deployment-new created<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="4-查看-Deployment-状态"><a href="#4-查看-Deployment-状态" class="headerlink" title="4. 查看 Deployment 状态"></a>4. 查看 Deployment 状态</h2><p>检查 Deployment 是否创建成功：</p><pre class="line-numbers language-bash"><code class="language-bash">kubectl get deployment -o wide<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>查看 Pod 调度到的节点：</p><pre class="line-numbers language-bash"><code class="language-bash">kubectl get pods -o wide<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>你应该能看到所有 Pod 都被调度到了 node02 上。</p><h2 id="5-验证节点选择器"><a href="#5-验证节点选择器" class="headerlink" title="5. 验证节点选择器"></a>5. 验证节点选择器</h2><p>为了验证节点选择器是否生效，可以尝试：</p><p>删除节点标签：</p><pre class="line-numbers language-bash"><code class="language-bash">kubectl label nodes node02 node-type-<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>观察 Pod 状态：</p><pre class="line-numbers language-bash"><code class="language-bash">kubectl get pods -o wide -w<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>你会发现 Pod 会变成 Pending 状态，因为不再有节点满足选择条件。</p><p>恢复节点标签：</p><pre class="line-numbers language-bash"><code class="language-bash">kubectl label nodes node02 node-type<span class="token operator">=</span>worker<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>Pod 应该会恢复正常运行状态。</p><h2 id="6-扩缩容-Deployment"><a href="#6-扩缩容-Deployment" class="headerlink" title="6. 扩缩容 Deployment"></a>6. 扩缩容 Deployment</h2><p>将 Pod 副本数从 3 缩减到 2：</p><pre class="line-numbers language-bash"><code class="language-bash">kubectl scale deployment mynginx-deployment-new --replicas<span class="token operator">=</span>2<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>验证 Pod 数量和所在节点：</p><pre class="line-numbers language-bash"><code class="language-bash">kubectl get pods -o wide<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="7-更新-Deployment-配置"><a href="#7-更新-Deployment-配置" class="headerlink" title="7. 更新 Deployment 配置"></a>7. 更新 Deployment 配置</h2><p>你可以修改 YAML 文件后重新应用：</p><pre class="line-numbers language-bash"><code class="language-bash">kubectl apply -f nginx-deployment.yaml<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>或者直接使用命令修改：</p><pre class="line-numbers language-ba"><code class="language-ba">kubectl edit deployment mynginx-deployment-new<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="8-清理资源"><a href="#8-清理资源" class="headerlink" title="8. 清理资源"></a>8. 清理资源</h2><p>删除 Deployment 和节点标签：</p><pre class="line-numbers language-ba"><code class="language-ba">kubectl delete deployment mynginx-deployment-newkubectl label nodes node02 node-type-<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="9-节点选择高级用法"><a href="#9-节点选择高级用法" class="headerlink" title="9.节点选择高级用法"></a>9.节点选择高级用法</h2><p>除了简单的节点选择，你还可以使用：</p><ol><li><strong>节点亲和性 (nodeAffinity)</strong> - 更灵活的节点选择规则</li><li><strong>Pod 亲和性/反亲和性</strong> - 控制 Pod 之间的调度关系</li><li><strong>污点和容忍度 (Taints and Tolerations)</strong> - 限制 Pod 调度到特定节点</li></ol><p>示例：使用节点亲和性</p><pre class="line-numbers language-yaml"><code class="language-yaml"><span class="token key atrule">affinity</span><span class="token punctuation">:</span>  <span class="token key atrule">nodeAffinity</span><span class="token punctuation">:</span>    <span class="token key atrule">requiredDuringSchedulingIgnoredDuringExecution</span><span class="token punctuation">:</span>      <span class="token key atrule">nodeSelectorTerms</span><span class="token punctuation">:</span>      <span class="token punctuation">-</span> <span class="token key atrule">matchExpressions</span><span class="token punctuation">:</span>        <span class="token punctuation">-</span> <span class="token key atrule">key</span><span class="token punctuation">:</span> node<span class="token punctuation">-</span>type          <span class="token key atrule">operator</span><span class="token punctuation">:</span> In          <span class="token key atrule">values</span><span class="token punctuation">:</span>          <span class="token punctuation">-</span> worker<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>通过本教程，你学会了：</p><ol><li>如何定义 Kubernetes Deployment</li><li>如何使用 nodeSelector 控制 Pod 调度</li><li>如何给节点添加和管理标签</li><li>如何进行 Deployment 的基本操作</li><li>如何验证节点选择器的效果</li><li>了解更高级的调度策略</li></ol><p>节点选择是 Kubernetes 调度系统的重要组成部分，合理使用可以优化资源利用率和应用性能。</p>]]></content>
      
      
      <categories>
          
          <category> Kubernetes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 容器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Kubernetes教程--Pod的创建和管理</title>
      <link href="/2024/kubernetes-jiao-cheng-pod-de-chuang-jian-he-guan-li/"/>
      <url>/2024/kubernetes-jiao-cheng-pod-de-chuang-jian-he-guan-li/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h2 id="1-创建Pod的几种方式"><a href="#1-创建Pod的几种方式" class="headerlink" title="1. 创建Pod的几种方式"></a>1. 创建Pod的几种方式</h2><h3 id="1-1-使用kubectl-run命令"><a href="#1-1-使用kubectl-run命令" class="headerlink" title="1.1 使用kubectl run命令"></a>1.1 使用kubectl run命令</h3><pre class="line-numbers language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 创建简单Pod</span>kubectl run mynginx --image<span class="token operator">=</span>nginx<span class="token comment" spellcheck="true"># 查看Pod状态</span>kubectl get pods<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="1-2-使用YAML文件创建Pod"><a href="#1-2-使用YAML文件创建Pod" class="headerlink" title="1.2 使用YAML文件创建Pod"></a>1.2 使用YAML文件创建Pod</h3><p>创建nginx.yaml文件：</p><pre class="line-numbers language-yaml"><code class="language-yaml"><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> v1<span class="token key atrule">kind</span><span class="token punctuation">:</span> Pod<span class="token key atrule">metadata</span><span class="token punctuation">:</span>  <span class="token key atrule">name</span><span class="token punctuation">:</span> mynginx<span class="token key atrule">spec</span><span class="token punctuation">:</span>  <span class="token key atrule">containers</span><span class="token punctuation">:</span>    <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> nginx<span class="token punctuation">-</span>container      <span class="token key atrule">image</span><span class="token punctuation">:</span> nginx<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>应用YAML文件：</p><pre class="line-numbers language-bash"><code class="language-bash">kubectl apply -f nginx.yaml<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="2-Pod管理操作"><a href="#2-Pod管理操作" class="headerlink" title="2. Pod管理操作"></a>2. Pod管理操作</h2><h3 id="2-1-查看Pod"><a href="#2-1-查看Pod" class="headerlink" title="2.1 查看Pod"></a>2.1 查看Pod</h3><pre class="line-numbers language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 查看所有Pod</span>kubectl get pods<span class="token comment" spellcheck="true"># 查看Pod详细信息</span>kubectl get pods -o wide<span class="token comment" spellcheck="true"># 查看特定Pod详情</span>kubectl describe pod mynginx<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="2-2-查看Pod日志"><a href="#2-2-查看Pod日志" class="headerlink" title="2.2 查看Pod日志"></a>2.2 查看Pod日志</h3><pre class="line-numbers language-bash"><code class="language-bash">kubectl logs mynginx<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="2-3-进入Pod容器"><a href="#2-3-进入Pod容器" class="headerlink" title="2.3 进入Pod容器"></a>2.3 进入Pod容器</h3><pre class="line-numbers language-bash"><code class="language-bash">kubectl <span class="token function">exec</span> -it mynginx -- /bin/bash<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="2-4-端口转发"><a href="#2-4-端口转发" class="headerlink" title="2.4 端口转发"></a>2.4 端口转发</h3><pre class="line-numbers language-bash"><code class="language-bash">kubectl port-forward pod/mynginx 8080:80<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="2-5-删除Pod"><a href="#2-5-删除Pod" class="headerlink" title="2.5 删除Pod"></a>2.5 删除Pod</h3><pre class="line-numbers language-bash"><code class="language-bash">kubectl delete pod mynginx<span class="token comment" spellcheck="true"># 通过YAML文件删除</span>kubectl delete -f nginx.yml<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h2 id="3-常见问题排查"><a href="#3-常见问题排查" class="headerlink" title="3. 常见问题排查"></a>3. 常见问题排查</h2><h3 id="3-1-Pod状态异常"><a href="#3-1-Pod状态异常" class="headerlink" title="3.1 Pod状态异常"></a>3.1 Pod状态异常</h3><pre class="line-numbers language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 查看Pod详情</span>kubectl describe pod <span class="token operator">&lt;</span>pod-name<span class="token operator">></span><span class="token comment" spellcheck="true"># 查看Pod日志</span>kubectl logs <span class="token operator">&lt;</span>pod-name<span class="token operator">></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本教程涵盖了Pod创建管理的完整流程，包括：</p><ol><li>多种Pod创建方式</li><li>日常Pod管理操作</li></ol><p>对于生产环境，建议使用Deployment而不是直接创建Pod，以获得更好的弹性和管理能力。</p>]]></content>
      
      
      <categories>
          
          <category> Kubernetes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 容器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Kubernetes教程--Service的创建和管理</title>
      <link href="/2024/kubernetes-jiao-cheng-service-de-chuang-jian-he-guan-li/"/>
      <url>/2024/kubernetes-jiao-cheng-service-de-chuang-jian-he-guan-li/</url>
      
        <content type="html"><![CDATA[<p>本教程将指导您如何创建和管理 Kubernetes Service，包括 ClusterIP 和 NodePort 类型的服务。</p><p>[TOC]</p><h2 id="1-创建-Service-定义文件"><a href="#1-创建-Service-定义文件" class="headerlink" title="1. 创建 Service 定义文件"></a>1. 创建 Service 定义文件</h2><p>首先创建一个 YAML 文件来定义 Service：</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">touch</span> service.yaml<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>将以下内容写入 <code>service.yaml</code>：</p><pre class="line-numbers language-yaml"><code class="language-yaml"><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> v1<span class="token key atrule">kind</span><span class="token punctuation">:</span> Service<span class="token key atrule">metadata</span><span class="token punctuation">:</span>  <span class="token key atrule">name</span><span class="token punctuation">:</span> web<span class="token punctuation">-</span>service<span class="token key atrule">spec</span><span class="token punctuation">:</span>  <span class="token key atrule">selector</span><span class="token punctuation">:</span>    <span class="token key atrule">app</span><span class="token punctuation">:</span> nginx  <span class="token key atrule">ports</span><span class="token punctuation">:</span>    <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> http      <span class="token key atrule">protocol</span><span class="token punctuation">:</span> TCP      <span class="token key atrule">port</span><span class="token punctuation">:</span> <span class="token number">80</span>      <span class="token key atrule">targetPort</span><span class="token punctuation">:</span> <span class="token number">80</span>    <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> https      <span class="token key atrule">protocol</span><span class="token punctuation">:</span> TCP      <span class="token key atrule">port</span><span class="token punctuation">:</span> <span class="token number">443</span>      <span class="token key atrule">targetPort</span><span class="token punctuation">:</span> <span class="token number">443</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这个 Service 定义:</p><ul><li>名为 <code>web-service</code></li><li>选择标签为 <code>app: nginx</code> 的 Pod</li><li>暴露两个端口: 80 (HTTP) 和 443 (HTTPS)</li><li>默认类型为 ClusterIP (只能在集群内部访问)</li></ul><h2 id="2-应用-Service-配置"><a href="#2-应用-Service-配置" class="headerlink" title="2. 应用 Service 配置"></a>2. 应用 Service 配置</h2><p>使用以下命令创建 Service:</p><pre class="line-numbers language-bash"><code class="language-bash">kubectl apply -f service.yaml<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="3-查看-Service-信息"><a href="#3-查看-Service-信息" class="headerlink" title="3. 查看 Service 信息"></a>3. 查看 Service 信息</h2><p>查看所有 Service:</p><pre class="line-numbers language-bash"><code class="language-bash">kubectl get svc<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>输出示例:</p><pre class="line-numbers language-bash"><code class="language-bash">NAME          TYPE        CLUSTER-IP       EXTERNAL-IP   PORT<span class="token punctuation">(</span>S<span class="token punctuation">)</span>          AGEkubernetes    ClusterIP   10.96.0.1        <span class="token operator">&lt;</span>none<span class="token operator">></span>        443/TCP          44hweb-service   ClusterIP   10.107.154.190   <span class="token operator">&lt;</span>none<span class="token operator">></span>        80/TCP,443/TCP   25s<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>查看更详细的信息:</p><pre class="line-numbers language-bash"><code class="language-bash">kubectl get svc -o wide<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>输出示例:</p><pre class="line-numbers language-bash"><code class="language-bash">NAME          TYPE        CLUSTER-IP       EXTERNAL-IP   PORT<span class="token punctuation">(</span>S<span class="token punctuation">)</span>          AGE   SELECTORkubernetes    ClusterIP   10.96.0.1        <span class="token operator">&lt;</span>none<span class="token operator">></span>        443/TCP          44h   <span class="token operator">&lt;</span>none<span class="token operator">></span>web-service   ClusterIP   10.107.154.190   <span class="token operator">&lt;</span>none<span class="token operator">></span>        80/TCP,443/TCP   31s   app<span class="token operator">=</span>nginx<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>查看 Service 的 endpoints (后端 Pod):</p><pre class="line-numbers language-bash"><code class="language-bash">kubectl get endpoints web-service<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>输出示例:</p><pre class="line-numbers language-bash"><code class="language-bash">NAME          ENDPOINTS                                                           AGEweb-service   192.168.2.145:443,192.168.2.146:443,192.168.2.147:443 + 5 more<span class="token punctuation">..</span>.   48s<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>查看 Service 的详细描述:</p><pre class="line-numbers language-bash"><code class="language-bash">kubectl describe <span class="token function">service</span> web-service<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="4-删除-Service"><a href="#4-删除-Service" class="headerlink" title="4. 删除 Service"></a>4. 删除 Service</h2><p>删除 Service 有两种方法:</p><p>方法1: 通过 YAML 文件删除</p><pre class="line-numbers language-bash"><code class="language-bash">kubectl delete -f service.yaml<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>方法2: 直接通过服务名删除</p><pre class="line-numbers language-bash"><code class="language-bash">kubectl delete <span class="token function">service</span> web-service<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="5-创建-NodePort-类型的-Service"><a href="#5-创建-NodePort-类型的-Service" class="headerlink" title="5. 创建 NodePort 类型的 Service"></a>5. 创建 NodePort 类型的 Service</h2><p>NodePort 类型的 Service 允许从集群外部访问服务。</p><p>创建 NodePort 定义文件:</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">touch</span> nodeport.yaml<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>将以下内容写入 <code>nodeport.yaml</code>:</p><pre class="line-numbers language-yaml"><code class="language-yaml"><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> v1<span class="token key atrule">kind</span><span class="token punctuation">:</span> Service<span class="token key atrule">metadata</span><span class="token punctuation">:</span>  <span class="token key atrule">name</span><span class="token punctuation">:</span> web<span class="token punctuation">-</span>service<span class="token punctuation">-</span>nodeport<span class="token key atrule">spec</span><span class="token punctuation">:</span>  <span class="token key atrule">selector</span><span class="token punctuation">:</span>    <span class="token key atrule">app</span><span class="token punctuation">:</span> nginx  <span class="token key atrule">ports</span><span class="token punctuation">:</span>    <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> http      <span class="token key atrule">port</span><span class="token punctuation">:</span> <span class="token number">8000</span>      <span class="token key atrule">protocol</span><span class="token punctuation">:</span> TCP      <span class="token key atrule">targetPort</span><span class="token punctuation">:</span> <span class="token number">80</span>  <span class="token key atrule">type</span><span class="token punctuation">:</span> NodePort<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这个 Service 定义:</p><ul><li>名为 <code>web-service-nodeport</code></li><li>选择标签为 <code>app: nginx</code> 的 Pod</li><li>将容器的 80 端口映射到 Service 的 8000 端口</li><li>类型为 NodePort (会自动分配一个外部可访问的端口)</li></ul><p>应用配置:</p><pre class="line-numbers language-bash"><code class="language-bash">kubectl apply -f nodeport.yaml<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>查看 NodePort Service:</p><pre class="line-numbers language-bash"><code class="language-bash">kubectl get svc -o wide<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>输出示例:</p><pre class="line-numbers language-bash"><code class="language-bash">NAME                   TYPE        CLUSTER-IP       EXTERNAL-IP   PORT<span class="token punctuation">(</span>S<span class="token punctuation">)</span>          AGE   SELECTORweb-service-nodeport   NodePort    10.110.194.163   <span class="token operator">&lt;</span>none<span class="token operator">></span>        8000:31869/TCP   36s   app<span class="token operator">=</span>nginx<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>这里 <code>8000:31869</code> 表示:</p><ul><li>集群内部通过 8000 端口访问</li><li>集群外部通过任意节点的 31869 端口访问</li></ul><h2 id="6-测试-NodePort-Service"><a href="#6-测试-NodePort-Service" class="headerlink" title="6. 测试 NodePort Service"></a>6. 测试 NodePort Service</h2><p>从集群外部访问服务:</p><pre class="line-numbers language-bash"><code class="language-bash">curl http://<span class="token operator">&lt;</span>节点IP<span class="token operator">></span>:<span class="token operator">&lt;</span>NodePort<span class="token operator">></span>/<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>例如:</p><pre class="line-numbers language-bash"><code class="language-bash">curl http://192.168.137.226:31869/<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol><li>Service 允许您将一组 Pod 作为网络服务公开</li><li>ClusterIP 是默认类型，只能在集群内部访问</li><li>NodePort 类型允许从集群外部通过节点IP和端口访问服务</li><li>使用 <code>kubectl apply -f</code> 创建/更新服务</li><li>使用 <code>kubectl get svc</code> 和 <code>kubectl describe svc</code> 查看服务信息</li><li>使用 <code>kubectl delete</code> 删除服务</li></ol><p>通过本教程，您应该已经掌握了 Kubernetes Service 的基本创建和管理操作。</p>]]></content>
      
      
      <categories>
          
          <category> Kubernetes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 容器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Kubernetes教程--部署Flask应用</title>
      <link href="/2024/kubernetes-jiao-cheng-bu-shu-flask-ying-yong/"/>
      <url>/2024/kubernetes-jiao-cheng-bu-shu-flask-ying-yong/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h2 id="1-环境准备"><a href="#1-环境准备" class="headerlink" title="1. 环境准备"></a><strong>1. 环境准备</strong></h2><p>确保已安装以下工具：</p><ul><li><code>kubectl</code>（Kubernetes 命令行工具）</li><li>Docker（本地构建镜像）</li><li>可用的 Kubernetes 集群（如 Minikube、Kind 或云服务商提供的集群）</li></ul><h2 id="2-创建命名空间"><a href="#2-创建命名空间" class="headerlink" title="2. 创建命名空间"></a><strong>2. 创建命名空间</strong></h2><p>创建 <code>postgres-ns</code> 命名空间用于部署 PostgreSQL 数据库：</p><pre class="line-numbers language-yaml"><code class="language-yaml"><span class="token comment" spellcheck="true"># postgres-ns.yaml</span><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> v1<span class="token key atrule">kind</span><span class="token punctuation">:</span> Namespace<span class="token key atrule">metadata</span><span class="token punctuation">:</span>  <span class="token key atrule">name</span><span class="token punctuation">:</span> postgres<span class="token punctuation">-</span>ns  <span class="token key atrule">labels</span><span class="token punctuation">:</span>    <span class="token key atrule">name</span><span class="token punctuation">:</span> postgres<span class="token punctuation">-</span>ns<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>执行命令</strong>：</p><pre class="line-numbers language-bash"><code class="language-bash">kubectl apply -f postgres-ns.yaml<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-bash"><code class="language-bash">kubectl get namespaces <span class="token operator">|</span> <span class="token function">grep</span> postgres<span class="token comment" spellcheck="true"># 输出应包含：postgres-ns       Active</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="3-创建数据库凭证"><a href="#3-创建数据库凭证" class="headerlink" title="3. 创建数据库凭证"></a><strong>3. 创建数据库凭证</strong></h2><p>创建 Secret 存储 PostgreSQL 密码、用户名和数据库名：</p><pre class="line-numbers language-bash"><code class="language-bash">kubectl create secret generic postgres-secret -n postgres-ns \  --from-literal<span class="token operator">=</span>POSTGRES_PASSWORD<span class="token operator">=</span>123456 \  --from-literal<span class="token operator">=</span>POSTGRES_USER<span class="token operator">=</span>postgres \  --from-literal<span class="token operator">=</span>POSTGRES_DB<span class="token operator">=</span>mydb<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><strong>验证</strong>：</p><pre class="line-numbers language-bash"><code class="language-bash">kubectl get secret -n postgres-ns<span class="token comment" spellcheck="true"># 应看到 postgres-secret 已创建</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="4-部署-PostgreSQL-数据库"><a href="#4-部署-PostgreSQL-数据库" class="headerlink" title="4. 部署 PostgreSQL 数据库"></a><strong>4. 部署 PostgreSQL 数据库</strong></h2><p>创建 StatefulSet 部署 PostgreSQL：</p><pre class="line-numbers language-yaml"><code class="language-yaml"><span class="token comment" spellcheck="true"># postgres-statefulset.yaml</span><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> apps/v1<span class="token key atrule">kind</span><span class="token punctuation">:</span> StatefulSet<span class="token key atrule">metadata</span><span class="token punctuation">:</span>  <span class="token key atrule">name</span><span class="token punctuation">:</span> postgres  <span class="token key atrule">namespace</span><span class="token punctuation">:</span> postgres<span class="token punctuation">-</span>ns<span class="token key atrule">spec</span><span class="token punctuation">:</span>  <span class="token key atrule">serviceName</span><span class="token punctuation">:</span> postgres  <span class="token key atrule">replicas</span><span class="token punctuation">:</span> <span class="token number">2</span>  <span class="token key atrule">selector</span><span class="token punctuation">:</span>    <span class="token key atrule">matchLabels</span><span class="token punctuation">:</span>      <span class="token key atrule">app</span><span class="token punctuation">:</span> postgres  <span class="token key atrule">template</span><span class="token punctuation">:</span>    <span class="token key atrule">metadata</span><span class="token punctuation">:</span>      <span class="token key atrule">labels</span><span class="token punctuation">:</span>        <span class="token key atrule">app</span><span class="token punctuation">:</span> postgres    <span class="token key atrule">spec</span><span class="token punctuation">:</span>      <span class="token key atrule">containers</span><span class="token punctuation">:</span>      <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> postgres        <span class="token key atrule">image</span><span class="token punctuation">:</span> postgres<span class="token punctuation">:</span><span class="token number">13</span>        <span class="token key atrule">env</span><span class="token punctuation">:</span>        <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> POSTGRES_PASSWORD          <span class="token key atrule">valueFrom</span><span class="token punctuation">:</span>            <span class="token key atrule">secretKeyRef</span><span class="token punctuation">:</span>              <span class="token key atrule">name</span><span class="token punctuation">:</span> postgres<span class="token punctuation">-</span>secret              <span class="token key atrule">key</span><span class="token punctuation">:</span> POSTGRES_PASSWORD        <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> POSTGRES_USER          <span class="token key atrule">valueFrom</span><span class="token punctuation">:</span>            <span class="token key atrule">secretKeyRef</span><span class="token punctuation">:</span>              <span class="token key atrule">name</span><span class="token punctuation">:</span> postgres<span class="token punctuation">-</span>secret              <span class="token key atrule">key</span><span class="token punctuation">:</span> POSTGRES_USER        <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> POSTGRES_DB          <span class="token key atrule">valueFrom</span><span class="token punctuation">:</span>            <span class="token key atrule">secretKeyRef</span><span class="token punctuation">:</span>              <span class="token key atrule">name</span><span class="token punctuation">:</span> postgres<span class="token punctuation">-</span>secret              <span class="token key atrule">key</span><span class="token punctuation">:</span> POSTGRES_DB        <span class="token key atrule">ports</span><span class="token punctuation">:</span>        <span class="token punctuation">-</span> <span class="token key atrule">containerPort</span><span class="token punctuation">:</span> <span class="token number">5432</span>          <span class="token key atrule">name</span><span class="token punctuation">:</span> postgres<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>执行命令</strong>：</p><pre class="line-numbers language-bash"><code class="language-bash">kubectl apply -f postgres-statefulset.yaml -n postgres-ns<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="5-暴露-PostgreSQL-服务"><a href="#5-暴露-PostgreSQL-服务" class="headerlink" title="5. 暴露 PostgreSQL 服务"></a><strong>5. 暴露 PostgreSQL 服务</strong></h2><p>创建 NodePort 类型的 Service 对外暴露数据库：</p><pre class="line-numbers language-yaml"><code class="language-yaml"><span class="token comment" spellcheck="true"># postgres-service.yaml</span><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> v1<span class="token key atrule">kind</span><span class="token punctuation">:</span> Service<span class="token key atrule">metadata</span><span class="token punctuation">:</span>  <span class="token key atrule">name</span><span class="token punctuation">:</span> postgres  <span class="token key atrule">namespace</span><span class="token punctuation">:</span> postgres<span class="token punctuation">-</span>ns  <span class="token key atrule">labels</span><span class="token punctuation">:</span>    <span class="token key atrule">app</span><span class="token punctuation">:</span> postgres<span class="token key atrule">spec</span><span class="token punctuation">:</span>  <span class="token key atrule">selector</span><span class="token punctuation">:</span>    <span class="token key atrule">app</span><span class="token punctuation">:</span> postgres  <span class="token key atrule">ports</span><span class="token punctuation">:</span>  <span class="token punctuation">-</span> <span class="token key atrule">port</span><span class="token punctuation">:</span> <span class="token number">5432</span>    <span class="token key atrule">name</span><span class="token punctuation">:</span> postgres    <span class="token key atrule">targetPort</span><span class="token punctuation">:</span> <span class="token number">5432</span>  <span class="token key atrule">type</span><span class="token punctuation">:</span> NodePort<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>执行命令</strong>：</p><pre class="line-numbers language-bash"><code class="language-bash">kubectl apply -f postgres-service.yaml -n postgres-ns<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>验证</strong>：</p><pre class="line-numbers language-bash"><code class="language-bash">kubectl get pods -n postgres-ns --show-labelskubectl get svc -n postgres-ns<span class="token comment" spellcheck="true"># 获取 NodePort</span>NODE_PORT<span class="token operator">=</span><span class="token punctuation">$(</span>kubectl get svc postgres -n postgres-ns -o jsonpath<span class="token operator">=</span><span class="token string">'{.spec.ports[0].nodePort}'</span><span class="token punctuation">)</span><span class="token keyword">echo</span> <span class="token string">"PostgreSQL NodePort: <span class="token variable">$NODE_PORT</span>"</span><span class="token comment" spellcheck="true"># 测试连接（从集群外部）</span>psql -h <span class="token operator">&lt;</span>节点IP<span class="token operator">></span> -p <span class="token variable">$NODE_PORT</span> -U postgres<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="6-构建-Flask-应用镜像"><a href="#6-构建-Flask-应用镜像" class="headerlink" title="6. 构建 Flask 应用镜像"></a><strong>6. 构建 Flask 应用镜像</strong></h2><p>创建 Dockerfile 构建 Flask 应用镜像：</p><pre class="line-numbers language-dockerfile"><code class="language-dockerfile"># 使用官方 Python 运行时作为基础镜像FROM python:3.9-slim# 设置工作目录WORKDIR /app# 先复制依赖文件，利用 Docker 缓存加速构建COPY requirements.txt .# 安装依赖RUN pip install --no-cache-dir -r requirements.txt# 复制整个应用目录COPY . .# 暴露 Flask 默认端口EXPOSE 5000 # 关闭 Flask 调试模式（通过环境变量控制）ENV FLASK_DEBUG=0# 使用 Gunicorn 启动（替代 app.run()）CMD ["gunicorn", "--bind", "0.0.0.0:5000", "flask_movie.app:app"]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>构建镜像</strong>：</p><pre class="line-numbers language-bash"><code class="language-bash">docker build -t flask-movie-app <span class="token keyword">.</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="7-部署-Flask-应用到-Kubernetes"><a href="#7-部署-Flask-应用到-Kubernetes" class="headerlink" title="7. 部署 Flask 应用到 Kubernetes"></a><strong>7. 部署 Flask 应用到 Kubernetes</strong></h2><p>创建 Deployment 部署 Flask 应用：</p><pre class="line-numbers language-yaml"><code class="language-yaml"><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> apps/v1<span class="token key atrule">kind</span><span class="token punctuation">:</span> Deployment<span class="token key atrule">metadata</span><span class="token punctuation">:</span>  <span class="token key atrule">name</span><span class="token punctuation">:</span> flask<span class="token punctuation">-</span>movie  <span class="token key atrule">namespace</span><span class="token punctuation">:</span> postgres<span class="token punctuation">-</span>ns<span class="token key atrule">spec</span><span class="token punctuation">:</span>  <span class="token key atrule">replicas</span><span class="token punctuation">:</span> <span class="token number">1</span>  <span class="token key atrule">selector</span><span class="token punctuation">:</span>    <span class="token key atrule">matchLabels</span><span class="token punctuation">:</span>      <span class="token key atrule">app</span><span class="token punctuation">:</span> flask<span class="token punctuation">-</span>movie  <span class="token key atrule">template</span><span class="token punctuation">:</span>    <span class="token key atrule">metadata</span><span class="token punctuation">:</span>      <span class="token key atrule">labels</span><span class="token punctuation">:</span>        <span class="token key atrule">app</span><span class="token punctuation">:</span> flask<span class="token punctuation">-</span>movie    <span class="token key atrule">spec</span><span class="token punctuation">:</span>      <span class="token key atrule">containers</span><span class="token punctuation">:</span>      <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> flask<span class="token punctuation">-</span>movie        <span class="token key atrule">image</span><span class="token punctuation">:</span> flask<span class="token punctuation">-</span>movie<span class="token punctuation">-</span>app        <span class="token key atrule">imagePullPolicy</span><span class="token punctuation">:</span> Never        <span class="token key atrule">ports</span><span class="token punctuation">:</span>        <span class="token punctuation">-</span> <span class="token key atrule">containerPort</span><span class="token punctuation">:</span> <span class="token number">5000</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>执行命令</strong>：</p><pre class="line-numbers language-bash"><code class="language-bash">kubectl apply -f flask-movie-deployment.yamlkubectl get pods -n postgres-ns -o wide  <span class="token comment" spellcheck="true"># 查看应用 Pod 状态</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="8-为-Flask-应用创建-NodePort-服务"><a href="#8-为-Flask-应用创建-NodePort-服务" class="headerlink" title="8. 为 Flask 应用创建 NodePort 服务"></a><strong>8. 为 Flask 应用创建 NodePort 服务</strong></h2><p>创建 Service 资源将 Flask 应用暴露到集群外部：</p><pre class="line-numbers language-yaml"><code class="language-yaml"><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> v1<span class="token key atrule">kind</span><span class="token punctuation">:</span> Service<span class="token key atrule">metadata</span><span class="token punctuation">:</span>  <span class="token key atrule">name</span><span class="token punctuation">:</span> flask<span class="token punctuation">-</span>movie<span class="token punctuation">-</span>service  <span class="token key atrule">namespace</span><span class="token punctuation">:</span> postgres<span class="token punctuation">-</span>ns<span class="token key atrule">spec</span><span class="token punctuation">:</span>  <span class="token key atrule">selector</span><span class="token punctuation">:</span>    <span class="token key atrule">app</span><span class="token punctuation">:</span> flask<span class="token punctuation">-</span>movie  <span class="token comment" spellcheck="true"># 匹配 Pod 的 label</span>  <span class="token key atrule">ports</span><span class="token punctuation">:</span>    <span class="token punctuation">-</span> <span class="token key atrule">protocol</span><span class="token punctuation">:</span> TCP      <span class="token key atrule">port</span><span class="token punctuation">:</span> <span class="token number">5000      </span><span class="token comment" spellcheck="true"># Service 端口</span>      <span class="token key atrule">targetPort</span><span class="token punctuation">:</span> <span class="token number">5000 </span><span class="token comment" spellcheck="true"># Pod 端口</span>  <span class="token key atrule">type</span><span class="token punctuation">:</span> NodePort      <span class="token comment" spellcheck="true"># 或 LoadBalancer/ClusterIP</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>执行命令</strong>：</p><pre class="line-numbers language-bash"><code class="language-bash">kubectl apply -f flask-movie-service.yaml<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>验证服务</strong>：</p><pre class="line-numbers language-bash"><code class="language-bash">kubectl get svc -n postgres-ns<span class="token comment" spellcheck="true"># 输出示例：</span>NAME                  TYPE       CLUSTER-IP      EXTERNAL-IP   PORT<span class="token punctuation">(</span>S<span class="token punctuation">)</span>          AGEflask-movie-service   NodePort   10.110.185.40   <span class="token operator">&lt;</span>none<span class="token operator">></span>        5000:30000/TCP   11mpostgres              NodePort   10.99.247.133   <span class="token operator">&lt;</span>none<span class="token operator">></span>        5432:32039/TCP   23h<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="9-访问-Flask-应用"><a href="#9-访问-Flask-应用" class="headerlink" title="9. 访问 Flask 应用"></a><strong>9. 访问 Flask 应用</strong></h2><p>通过任意节点 IP 和 NodePort 访问应用：</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 获取集群节点 IP</span>NODE_IP<span class="token operator">=</span><span class="token punctuation">$(</span>kubectl get nodes -o jsonpath<span class="token operator">=</span><span class="token string">'{.items[0].status.addresses[?(@.type=="ExternalIP")].address}'</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 若没有 ExternalIP，使用 InternalIP</span><span class="token keyword">if</span> <span class="token punctuation">[</span> -z <span class="token string">"<span class="token variable">$NODE_IP</span>"</span> <span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token keyword">then</span>  NODE_IP<span class="token operator">=</span><span class="token punctuation">$(</span>kubectl get nodes -o jsonpath<span class="token operator">=</span><span class="token string">'{.items[0].status.addresses[?(@.type=="InternalIP")].address}'</span><span class="token punctuation">)</span><span class="token keyword">fi</span><span class="token keyword">echo</span> <span class="token string">"访问地址: http://<span class="token variable">$NODE_IP</span>:30000"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="10-故障排除"><a href="#10-故障排除" class="headerlink" title="10. 故障排除"></a><strong>10. 故障排除</strong></h2><p>若部署失败，可使用以下命令排查问题：</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 查看 StatefulSet 状态</span>kubectl get statefulset -n postgres-nskubectl describe statefulset postgres -n postgres-ns<span class="token comment" spellcheck="true"># 查看事件日志（按时间排序）</span>kubectl get events -n postgres-ns --sort-by<span class="token operator">=</span><span class="token string">'.metadata.creationTimestamp'</span><span class="token comment" spellcheck="true"># 查看 Pod 详细信息和日志</span>kubectl describe pod <span class="token operator">&lt;</span>pod-name<span class="token operator">></span>kubectl logs <span class="token operator">&lt;</span>pod-name<span class="token operator">></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="11-注意事项"><a href="#11-注意事项" class="headerlink" title="11. 注意事项"></a><strong>11. 注意事项</strong></h2><ol><li><p><strong>镜像拉取策略</strong>：</p><ul><li><code>imagePullPolicy: Never</code> 仅适用于本地已存在的镜像。</li><li>若使用远程镜像仓库，需改为 <code>IfNotPresent</code> 或 <code>Always</code>，并配置镜像仓库认证。</li></ul></li><li><p><strong>数据库连接</strong>：</p><ul><li><p>Flask 应用需配置正确的数据库连接字符串，格式为：</p><pre class="line-numbers language-python"><code class="language-python">postgresql<span class="token punctuation">:</span><span class="token operator">//</span><span class="token operator">&lt;</span>用户名<span class="token operator">></span><span class="token punctuation">:</span><span class="token operator">&lt;</span>密码<span class="token operator">></span>@<span class="token operator">&lt;</span>服务名<span class="token operator">></span><span class="token punctuation">.</span><span class="token operator">&lt;</span>命名空间<span class="token operator">></span><span class="token punctuation">.</span>svc<span class="token punctuation">.</span>cluster<span class="token punctuation">.</span>local<span class="token punctuation">:</span><span class="token operator">&lt;</span>端口<span class="token operator">></span><span class="token operator">/</span><span class="token operator">&lt;</span>数据库名<span class="token operator">></span><span class="token comment" spellcheck="true"># 示例：</span>SQLALCHEMY_DATABASE_URI <span class="token operator">=</span> <span class="token string">'postgresql://postgres:123456@postgres.postgres-ns.svc.cluster.local:5432/mydb'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li></ul></li><li><p><strong>生产环境优化</strong>：</p><ul><li>添加持久化存储（PV/PVC）给 PostgreSQL。</li><li>使用 ConfigMap 管理应用配置。</li><li>添加 Health Check（存活和就绪探针）。</li><li>使用 Ingress 替代 NodePort 暴露服务。</li></ul></li></ol><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h2><p>通过本教程，你学会了：</p><ol><li>在 Kubernetes 中创建命名空间和 Secret。</li><li>使用 StatefulSet 部署有状态应用（PostgreSQL）。</li><li>构建 Flask 应用 Docker 镜像。</li><li>部署 Flask 应用到 Kubernetes。</li><li>基本的故障排查方法。</li></ol><p>后续可扩展内容：添加 Service 暴露 Flask 应用、配置自动扩缩容、集成 CI/CD 流水线。</p>]]></content>
      
      
      <categories>
          
          <category> Kubernetes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 容器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Kubernetes教程--集群部署</title>
      <link href="/2024/kubernetes-jiao-cheng-ji-qun-bu-shu/"/>
      <url>/2024/kubernetes-jiao-cheng-ji-qun-bu-shu/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h2 id="1-环境准备"><a href="#1-环境准备" class="headerlink" title="1. 环境准备"></a>1. 环境准备</h2><h3 id="1-1-系统配置"><a href="#1-1-系统配置" class="headerlink" title="1.1 系统配置"></a>1.1 系统配置</h3><pre class="line-numbers language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 设置主机名</span><span class="token keyword">echo</span> <span class="token string">'master'</span> <span class="token operator">></span> /etc/hostname  <span class="token comment" spellcheck="true"># 在master节点执行</span><span class="token keyword">echo</span> <span class="token string">'node01'</span> <span class="token operator">></span> /etc/hostname  <span class="token comment" spellcheck="true"># 在node01节点执行</span><span class="token keyword">echo</span> <span class="token string">'node02'</span> <span class="token operator">></span> /etc/hostname  <span class="token comment" spellcheck="true"># 在node02节点执行</span><span class="token comment" spellcheck="true"># 配置hosts文件</span><span class="token function">cat</span> <span class="token operator">>></span> /etc/hosts <span class="token operator">&lt;&lt;</span><span class="token string">EOF192.168.137.226 master192.168.137.227 node01192.168.137.228 node02EOF</span><span class="token comment" spellcheck="true"># 关闭防火墙</span>systemctl stop firewalldsystemctl disable firewalld<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="1-2-禁用swap"><a href="#1-2-禁用swap" class="headerlink" title="1.2 禁用swap"></a>1.2 禁用swap</h3><pre class="line-numbers language-bash"><code class="language-bash">swapoff -a<span class="token function">sed</span> -i <span class="token string">'/\&lt;swap\>/ s/^/#/'</span> /etc/fstab<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="2-安装Docker"><a href="#2-安装Docker" class="headerlink" title="2. 安装Docker"></a>2. 安装Docker</h2><pre class="line-numbers language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 安装指定版本Docker</span>yum -y <span class="token function">install</span> docker-ce-19.03.13-3.el8<span class="token comment" spellcheck="true"># 配置Docker</span><span class="token function">tee</span> <span class="token operator">></span> /etc/docker/daemon.json <span class="token operator">&lt;&lt;</span><span class="token string">EOF{  "exec-opts": ["native.cgroupdriver=systemd"],  "log-driver": "json-file",  "log-opts": {    "max-size": "100m"  },  "storage-driver": "overlay2",  "storage-opts": [    "overlay2.override_kernel_check=true"  ],  "registry-mirrors": ["https://docker.registry.cyou",    "https://docker-cf.registry.cyou",    "https://dockercf.jsdelivr.fyi",    "https://docker.jsdelivr.fyi",    "https://dockertest.jsdelivr.fyi",    "https://mirror.aliyuncs.com",    "https://dockerproxy.com",    "https://mirror.baidubce.com",    "https://docker.m.daocloud.io",    "https://docker.nju.edu.cn",    "https://docker.mirrors.sjtug.sjtu.edu.cn",    "https://docker.mirrors.ustc.edu.cn",    "https://mirror.iscas.ac.cn",    "https://docker.rainbond.cc"]}EOF</span><span class="token comment" spellcheck="true"># 启动Docker</span>systemctl <span class="token function">enable</span> dockersystemctl start docker<span class="token function">useradd</span> -m jinli<span class="token comment" spellcheck="true"># 将用户加入docker组</span><span class="token function">usermod</span> -a -G docker jinli<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="3-网络初始化配置"><a href="#3-网络初始化配置" class="headerlink" title="3. 网络初始化配置"></a>3. 网络初始化配置</h2><pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">cat</span> <span class="token operator">></span> /usr/bin/k8s-init.sh <span class="token operator">&lt;&lt;</span><span class="token string">EOF#!/bin/bashiptables -P FORWARD ACCEPTEOF</span><span class="token function">chmod</span> +x /usr/bin/k8s-init.sh<span class="token function">cat</span> <span class="token operator">></span> /usr/lib/systemd/system/k8s-init.service <span class="token operator">&lt;&lt;</span><span class="token string">EOF[Unit]Description=Kubernetes Init TaskAfter=multi-user.target[Service]ExecStart=/usr/bin/k8s-init.sh[Install]WantedBy=multi-user.targetEOF</span>systemctl <span class="token function">enable</span> k8s-initsystemctl start k8s-init<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="4-安装Kubernetes组件"><a href="#4-安装Kubernetes组件" class="headerlink" title="4. 安装Kubernetes组件"></a>4. 安装Kubernetes组件</h2><h3 id="4-1-配置yum源"><a href="#4-1-配置yum源" class="headerlink" title="4.1 配置yum源"></a>4.1 配置yum源</h3><pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">cat</span> <span class="token operator">></span> /etc/yum.repos.d/kubernetes.repo <span class="token operator">&lt;&lt;</span><span class="token string">EOF[kubernetes]name=Kubernetesbaseurl=https://mirrors.aliyuncs.com/kubernetes/yum/repos/kubernetes-el7-x86_64/enabled=1gpgcheck=1gpgkey=https://mirrors.aliyuncs.com/kubernetes/yum/doc/yum-key.gpg       https://mirrors.aliyuncs.com/kubernetes/yum/doc/rpm-package-key.gpgrepo_gpgcheck=1EOF</span>yum clean allyum makecache<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="4-2-安装kubeadm-kubelet和kubectl"><a href="#4-2-安装kubeadm-kubelet和kubectl" class="headerlink" title="4.2 安装kubeadm, kubelet和kubectl"></a>4.2 安装kubeadm, kubelet和kubectl</h3><pre class="line-numbers language-bash"><code class="language-bash">yum <span class="token function">install</span> -y kubelet-1.20.1-0 kubeadm-1.20.1-0 kubectl-1.20.1-0systemctl <span class="token function">enable</span> kubelet<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="4-3-初始化Master节点"><a href="#4-3-初始化Master节点" class="headerlink" title="4.3. 初始化Master节点"></a>4.3. 初始化Master节点</h3><pre class="line-numbers language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 初始化集群</span>kubeadm init \  --kubernetes-version<span class="token operator">=</span>1.20.1 \  --image-repository registry.aliyuncs.com/google_containers \  --pod-network-cidr<span class="token operator">=</span>192.168.2.0/24 \  --service-cidr<span class="token operator">=</span>10.96.0.0/12<span class="token comment" spellcheck="true"># 配置kubectl</span><span class="token function">mkdir</span> -p <span class="token variable">$HOME</span>/.kube<span class="token function">sudo</span> <span class="token function">cp</span> -i /etc/kubernetes/admin.conf <span class="token variable">$HOME</span>/.kube/config<span class="token function">sudo</span> <span class="token function">chown</span> <span class="token variable"><span class="token variable">$(</span><span class="token function">id</span> -u<span class="token variable">)</span></span><span class="token keyword">:</span><span class="token variable"><span class="token variable">$(</span><span class="token function">id</span> -g<span class="token variable">)</span></span> <span class="token variable">$HOME</span>/.kube/config<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="4-4-安装网络插件-Calico"><a href="#4-4-安装网络插件-Calico" class="headerlink" title="4.4. 安装网络插件(Calico)"></a>4.4. 安装网络插件(Calico)</h3><pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">mkdir</span> -p ~/k8s/calico<span class="token function">cd</span> ~/k8s/calicocurl -L https://docs.projectcalico.org/v3.18/manifests/calico.yaml -o calico-v3.18.yaml<span class="token function">sed</span> -i -e <span class="token string">"s?192.168.0.0/16?192.168.2.0/24?g"</span> calico-v3.18.yamlkubectl apply -f calico-v3.18.yaml<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="4-5-加入Worker节点"><a href="#4-5-加入Worker节点" class="headerlink" title="4.5. 加入Worker节点"></a>4.5. 加入Worker节点</h3><p>在master节点获取加入命令：</p><pre class="line-numbers language-bash"><code class="language-bash">kubeadm token create --print-join-command<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>在node01和node02节点执行：</p><pre class="line-numbers language-bash"><code class="language-bash">kubeadm resetkubeadm <span class="token function">join</span> 192.168.137.226:6443 --token <span class="token operator">&lt;</span>token<span class="token operator">></span> --discovery-token-ca-cert-hash sha256:<span class="token operator">&lt;</span>hash<span class="token operator">></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="4-6-配置kube-proxy使用ipvs模式"><a href="#4-6-配置kube-proxy使用ipvs模式" class="headerlink" title="4.6. 配置kube-proxy使用ipvs模式"></a>4.6. 配置kube-proxy使用ipvs模式</h3><pre class="line-numbers language-bash"><code class="language-bash">kubectl edit cm kube-proxy -n kube-system<span class="token comment" spellcheck="true"># 修改mode为ipvs</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="4-7-验证集群状态"><a href="#4-7-验证集群状态" class="headerlink" title="4.7. 验证集群状态"></a>4.7. 验证集群状态</h3><pre class="line-numbers language-bash"><code class="language-bash">kubectl get nodeskubectl get pods -n kube-system<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="3-常见问题排查"><a href="#3-常见问题排查" class="headerlink" title="3. 常见问题排查"></a>3. 常见问题排查</h3><h3 id="3-1-证书错误"><a href="#3-1-证书错误" class="headerlink" title="3.1 证书错误"></a>3.1 证书错误</h3><pre class="line-numbers language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 如果出现x509证书错误</span><span class="token function">rm</span> -rf <span class="token variable">$HOME</span>/.kube<span class="token function">mkdir</span> -p <span class="token variable">$HOME</span>/.kube<span class="token function">sudo</span> <span class="token function">cp</span> -i /etc/kubernetes/admin.conf <span class="token variable">$HOME</span>/.kube/config<span class="token function">sudo</span> <span class="token function">chown</span> <span class="token variable"><span class="token variable">$(</span><span class="token function">id</span> -u<span class="token variable">)</span></span><span class="token keyword">:</span><span class="token variable"><span class="token variable">$(</span><span class="token function">id</span> -g<span class="token variable">)</span></span> <span class="token variable">$HOME</span>/.kube/config<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="3-2-移除节点"><a href="#3-2-移除节点" class="headerlink" title="3.2 移除节点"></a>3.2 移除节点</h3><pre class="line-numbers language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 优雅移除节点</span>kubectl drain node01 --ignore-daemonsets --delete-emptydir-datakubectl delete node node01<span class="token comment" spellcheck="true"># 在节点上清理</span>kubeadm reset<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本教程涵盖了从Kubernetes集群部署的完整流程，包括：</p><ol><li>环境准备和依赖安装</li><li>Kubernetes集群初始化</li><li>网络插件安装</li><li>工作节点加入</li><li>常见问题排查方法</li></ol>]]></content>
      
      
      <categories>
          
          <category> Kubernetes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 容器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>10 基础备份和时间点恢复</title>
      <link href="/2021/10-ji-chu-bei-fen-he-shi-jian-dian-hui-fu/"/>
      <url>/2021/10-ji-chu-bei-fen-he-shi-jian-dian-hui-fu/</url>
      
        <content type="html"><![CDATA[<p>在线数据库备份大致可以分为两类：逻辑备份和物理备份。这两种方法各有优缺点，但逻辑备份的一个缺点是非常耗时，特别是对大型数据库进行备份需要很长时间，而从备份数据恢复到数据库需要更多的时间。相反，可以更快地创建和恢复物理备份，使其成为实际系统中非常重要和有用的特性。</p><p>在PostgreSQL中，从8.0版本开始就有了在线物理完全备份，一个运行的整个数据库集群的快照（即物理备份数据）被称为基本备份。</p><blockquote><p>在7.4或更早的版本中，PostgreSQL只支持逻辑备份（逻辑完整备份和部分备份，以及数据导出）。</p></blockquote><p>时间点恢复（**Point-in-Time Recovery (PITR)**）也从8.0版本开始提供，它是一种使用基本备份和连续归档特性创建的归档日志将数据库集群恢复到任何时间点的功能。例如，即使您犯了一个严重的错误（比如截断所有表），这个特性可以用来将数据库恢复到错误发生之前的状态。</p><p>本章将介绍以下主题:</p><ul><li><p>什么是基本备份</p></li><li><p>PITR如何工作</p></li><li><p>什么是时间线</p></li><li><p>什么是时间线历史文件</p></li></ul><span id="more"></span><p>[TOC]</p><h3 id="10-1-基础备份"><a href="#10-1-基础备份" class="headerlink" title="10.1 基础备份"></a>10.1 基础备份</h3><p>首先，使用底层命令创建基本备份的标准过程如下：</p><p>（1）发出 <code>pg_backup_start</code> 命令（版本14或更早的版本，pg_start_backup）；</p><p>（2）使用您选择的归档命令创建数据库集群的快照；</p><p>（3）发出 <code>pg_backup_stop</code> 命令（版本14或更早的版本，pg_stop_backup）。</p><p>对于数据库系统管理员来说，这个简单的过程很容易使用，因为除了cp命令或类似的归档工具等常用工具外，它不需要任何特殊工具。此外，该过程不需要表锁，所有用户都可以发出查询而不受备份操作的影响。这是相对于其他主要开源RDBMS的巨大优势。</p><p>进行基本备份的一种更简单的方法是使用pg_basebackup实用程序，该实用程序在内部发出上述底层命令。</p><p><img src="/medias/image/fig-10-01.png" alt="图10.1 进行基础备份"></p><p>因为pg_backup_start和pg_backup_stop命令对于理解PITR非常重要，所以我们将在下面的小节中更详细地研究它们。</p><p>pg_backup_start和pg_backup_stop命令定义在：<a href="https://github.com/postgres/postgres/blob/master/src/backend/access/transam/xlogfuncs.c">src/backend/access/transam/xlogfuncs.c</a>。</p><h4 id="10-1-1-pg-backup-start"><a href="#10-1-1-pg-backup-start" class="headerlink" title="10.1.1 pg_backup_start"></a>10.1.1 pg_backup_start</h4><p>pg_backup_start为基本备份做准备。正如第9.8节所讨论的，恢复过程从REDO点开始，因此pg_backup_start命令必须执行一个检查点，以便在开始进行基本备份时显式地创建REDO点。此外，检查点的检查点位置必须保存在pg_control以外的文件中，因为常规检查点可能在备份期间执行多次。pg_backup_start执行以下4个操作：</p><p>（1）强制数据库进入整页写模式。</p><p>（2）切换到当前的WAL段文件（版本8.4或更高版本）。</p><p>（3）做一个检查点。</p><p>（4）创建一个backup_label文件——该文件创建在基本目录的顶层，包含关于基础备份本身的基本信息，例如该检查点的检查点位置。</p><p>第三和第四项操作是该命令的核心；执行第一和第二个操作是为了更可靠地恢复数据库集群。</p><p>backup_label文件包含以下6项（版本11或更高版本为7项）：</p><ul><li><p>CHECKPOINT LOCATION——这是记录该命令创建的检查点的LSN位置。</p></li><li><p>START WAL LOCATION——这不是用在PITR上，而是用在第11章描述的流复制上。它被命名为“START WAL LOCATION”，因为在复制模式下的备服务器在初始启动时只读取该值一次。</p></li><li><p>BACKUP METHOD——这是用于进行基本备份的方法（’pg_backup_start’或’pg_basebackup’）。</p></li><li><p>BACKUP FROM——显示该备份是从主服务器还是从备服务器获取的。</p></li><li><p>START TIME——这是pg_backup_start命令执行时的时间戳。</p></li><li><p>LABEL——这是在pg_backup_start命令中指定的标签。</p></li><li><p>START TIMELINE——这是备份启动的时间线。这是用于完整性检查，已在版本11中引入。</p></li></ul><p>backup_label</p><p>版本16中使用pg_basebackup获取的backup_label文件的实际示例如下：</p><pre class="line-numbers language-bash"><code class="language-bash">postgres<span class="token operator">></span> <span class="token function">cat</span> /usr/local/pgsql/data/backup_labelSTART WAL LOCATION: 0/1B000028 <span class="token punctuation">(</span>file 00000001000000000000001B<span class="token punctuation">)</span>CHECKPOINT LOCATION: 0/1B000060BACKUP METHOD: streamedBACKUP FROM: primarySTART TIME: 2024-1-1 11:45:19 GMTLABEL: pg_basebackup base backupSTART TIMELINE: 1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>正如你可以想象的那样，当你使用这个基础备份恢复一个数据库时，PostgreSQL从backup_label文件中取出<strong>CHECKPOINT LOCATION</strong> ，从相应的归档日志中读取检查点记录，然后，从它的记录中获取REDO点并开始恢复过程。</p><h4 id="10-1-2-pg-backup-stop"><a href="#10-1-2-pg-backup-stop" class="headerlink" title="10.1.2 pg_backup_stop"></a>10.1.2 pg_backup_stop</h4><p>pg_backup_stop执行以下5个操作来完成备份。</p><ol><li><p>如果已被pg_backup_start命令强制更改，则重置为非整页写模式。</p></li><li><p>写一个XLOG记录的备份。</p></li><li><p>切换WAL段文件。</p></li><li><p>创建历史备份文件。该文件包含backup_label文件的内容和执行pg_backup_stop命令时的时间戳。</p></li><li><p>删除backup_label文件。从基础备份恢复时需要备份backup_label文件，复制完成后，在原数据库集群中就不需要备份了。</p></li></ol><blockquote><p>备份历史文件的命名方法如下所示：</p><p>{WAL段}.{基本备份启动时的偏移值}.backup</p></blockquote><h3 id="10-2-时间点恢复如何工作"><a href="#10-2-时间点恢复如何工作" class="headerlink" title="10.2 时间点恢复如何工作"></a>10.2 时间点恢复如何工作</h3><p>图10.2显示了PITR的基本概念。在PITR模式下的PostgreSQL在基本备份上重放归档日志的WAL数据，从pg_backup_start创建的REDO点到您想要恢复的点。在PostgreSQL中，要恢复的点被称为恢复目标。</p><p><img src="/medias/image/fig-10-02.png" alt="图10.2 PITR的基本概念"></p><p>以下是PITR工作原理的描述。</p><p>假设你在2022年11月18日格林尼治时间12:05犯了一个错误。您应该删除数据库集群，并使用之前的基础备份恢复新的数据库集群。</p><p>首先，您需要设置 <code>restore_command</code> 参数的命令，并将 postgresql.conf（版本11或更早，recovery.conf）文件中<code>recovery_target_time</code> 参数的时间设置为您犯错误的时间（在本例中为12:05 GMT）。</p><pre class="line-numbers language-properties"><code class="language-properties"><span class="token comment" spellcheck="true"># Place archive logs under /mnt/server/archivedir directory.</span><span class="token attr-name">restore_command</span> <span class="token punctuation">=</span> <span class="token attr-value">'cp /mnt/server/archivedir/%f %p'</span><span class="token attr-name">recovery_target_time</span> <span class="token punctuation">=</span> <span class="token attr-value">"2022-11-18 12:05 GMT"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>当PostgreSQL启动时，如果在数据库集群中存在<strong>backup_label</strong>和<strong>recovery. signal</strong>文件（版本11或更早，<strong>recovery.conf</strong>），它将进入PITR模式。</p><blockquote><p>recovery.conf/recovery.signal</p><p>recovery.conf在版本12中已经被废除，所有与恢复相关的参数都应写入postgresql.conf中。详见<a href="https://www.postgresql.org/docs/current/runtime-config-wal.html#RUNTIME-CONFIG-WAL-ARCHIVE-RECOVERY">官方文档</a>。</p><p>在版本12或更高版本中，当您从基本备份恢复服务器时，需要在数据库集群目录中创建一个名为recovery.signal的空文件。</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">touch</span> /usr/local/pgsql/data/recovery.signal<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></blockquote><p>PITR过程与9.8章节中描述的正常恢复过程几乎相同。唯一的区别是：</p><p>1 从哪里读取WAL日志?</p><ul><li><p>正常恢复模式——从基目录下的pg_xlog子目录（在版本10或更高版本中是pg_wal子目录）。</p></li><li><p>PITR模式——从配置参数 <code>archive_command</code> 中设置的归档目录。</p></li></ul><p>2 检查点位置从哪里读取?</p><ul><li><p>正常恢复模式——从pg_control文件。</p></li><li><p>PITR模式——从backup_label文件。</p></li></ul><p>PITR流程概述如下：</p><p>（1）PostgreSQL使用 <em>read_backup_label()</em> 内部函数从backup_label文件中读取<strong>CHECKPOINT LOCATION</strong>的值来找到REDO point。</p><p>（2）PostgreSQL从recovery.conf（版本12或更高，postgreSQL .conf）中读取一些参数值；如<code>restore_command</code> 和<code>recovery_target_time</code>。</p><p>（3）PostgreSQL从REDO点开始重放WAL数据，这可以很容易地从<strong>CHECKPOINT LOCATION</strong>的值中获得。通过执行参数<code>resotere_command</code> 中写入的命令，从归档日志中读取WAL数据，并将归档日志从归档区域复制到临时区域（临时区域内复制的日志文件在使用后会被删除）。</p><p>在这个例子中，PostgreSQL从REDO点读取并重放WAL数据到时间戳<strong>2022-11-18 12:05:00</strong>之前的那个点，因为参数<code>recovery_target_time </code>被设置为这个时间戳。如果恢复目标没有设置为recovery.conf（版本12或更高，postgreSQL .conf），PostgreSQL将会重放直到归档日志结束。</p><p>（4）当恢复过程完成时，一个时间线历史文件，例如<strong>00000002.History</strong>在pg_xlog子目录中创建；如果启用了归档日志功能，则在归档目录下也会创建同名文件。该文件的内容和作用将在以下部分进行描述。</p><p>提交和中止操作的记录包含每个操作完成的时间戳（这两个操作的XLOG数据部分分别在xl_xact_commit和xl_xact_abort中定义）。</p><p> xl_xact_commit</p><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">typedef</span> <span class="token keyword">struct</span> xl_xact_commit<span class="token punctuation">{</span>        TimestampTzxact_time<span class="token punctuation">;</span>          <span class="token comment" spellcheck="true">/* time of commit */</span>        uint32          xinfo<span class="token punctuation">;</span>              <span class="token comment" spellcheck="true">/* info flags */</span>        <span class="token keyword">int</span>            nrels<span class="token punctuation">;</span>              <span class="token comment" spellcheck="true">/* number of RelFileNodes */</span>        <span class="token keyword">int</span>            nsubxacts<span class="token punctuation">;</span>          <span class="token comment" spellcheck="true">/* number of subtransaction XIDs */</span>        <span class="token keyword">int</span>            nmsgs<span class="token punctuation">;</span>              <span class="token comment" spellcheck="true">/* number of shared inval msgs */</span>        Oid            dbId<span class="token punctuation">;</span>               <span class="token comment" spellcheck="true">/* MyDatabaseId */</span>        Oid            tsId<span class="token punctuation">;</span>               <span class="token comment" spellcheck="true">/* MyDatabaseTableSpace */</span>        <span class="token comment" spellcheck="true">/* Array of RelFileNode(s) to drop at commit */</span>        RelFileNode     xnodes<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>          <span class="token comment" spellcheck="true">/* VARIABLE LENGTH ARRAY */</span>        <span class="token comment" spellcheck="true">/* ARRAY OF COMMITTED SUBTRANSACTION XIDs FOLLOWS */</span>        <span class="token comment" spellcheck="true">/* ARRAY OF SHARED INVALIDATION MESSAGES FOLLOWS */</span><span class="token punctuation">}</span> xl_xact_commit<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p> xl_xact_abort</p><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">typedef</span> <span class="token keyword">struct</span> xl_xact_abort<span class="token punctuation">{</span>        TimestampTz     xact_time<span class="token punctuation">;</span>          <span class="token comment" spellcheck="true">/* time of abort */</span>        <span class="token keyword">int</span>            nrels<span class="token punctuation">;</span>              <span class="token comment" spellcheck="true">/* number of RelFileNodes */</span>        <span class="token keyword">int</span>             nsubxacts<span class="token punctuation">;</span>          <span class="token comment" spellcheck="true">/* number of subtransaction XIDs */</span>        <span class="token comment" spellcheck="true">/* Array of RelFileNode(s) to drop at abort */</span>        RelFileNode     xnodes<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>          <span class="token comment" spellcheck="true">/* VARIABLE LENGTH ARRAY */</span>        <span class="token comment" spellcheck="true">/* ARRAY OF ABORTED SUBTRANSACTION XIDs FOLLOWS */</span><span class="token punctuation">}</span> xl_xact_abort<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>因此，如果目标时间设置为<code>recovery_target_time</code> 参数，PostgreSQL可以选择是否继续恢复，无论何时它重播XLOG记录的提交或中止动作。当每个动作的XLOG记录被重播时，PostgreSQL会比较目标时间和记录中写入的每个时间戳，如果时间戳超过目标时间，则PITR进程将结束。</p><p>*read_backup_label()*函数在<a href="https://github.com/postgres/postgres/blob/master/src/backend/access/transam/xlog.c">src/backend/access/transam/xlog.c</a>中定义。</p><p>xl_xact_commit结构体和xl_xact_abort结构体在<a href="https://github.com/postgres/postgres/blob/master/src/include/access/xact.h">src/include/access/xact.h</a>中定义。</p><blockquote><p>为什么我们可以使用常见的归档工具来进行基本备份?</p><p>恢复过程是将数据库集群恢复到一致状态的过程，尽管集群是不一致的。由于PITR基于恢复过程，因此即使基本备份是一堆不一致的文件，它也可以恢复数据库集群。这就是为什么我们可以使用常见的归档工具，而不需要文件系统快照功能或特殊工具。</p></blockquote><h3 id="10-3-时间线和时间线历史文件"><a href="#10-3-时间线和时间线历史文件" class="headerlink" title="10.3 时间线和时间线历史文件"></a>10.3 时间线和时间线历史文件</h3><p>PostgreSQL中的时间线用于区分原始数据库集群和恢复后的数据库集群，是PITR的核心概念。在本节中，将描述与时间线相关的两个内容：时间线和时间线历史文件。</p><h4 id="10-3-1-时间线"><a href="#10-3-1-时间线" class="headerlink" title="10.3.1 时间线"></a>10.3.1 时间线</h4><p>每个时间线都有一个对应的<strong>timelineId</strong>，这是一个从1开始的4字节无符号整数。</p><p>为每个数据库集群分配一个单独的timelineId。使用initdb工具创建的原始数据库集群的timelineId为1。每当数据库集群恢复时，timelineId将增加1。例如，在上一节的示例中，从原集群中恢复的集群的timelineId为2。</p><p>图10.3从timelineId的角度说明了PITR过程。首先，我们移除当前的数据库集群，恢复过去所做的基础备份，以便回到恢复的起点，这种情况如图中红色箭头曲线所示。接下来，我们启动PostgreSQL服务器，该服务器通过沿着初始时间线(timelineId 1)跟踪，从pg_backup_start创建的REDO点重放归档日志中的WAL数据，直到恢复目标，这种情况如图中蓝色箭头线所示。然后，一个新的timelineId 2被分配给恢复的数据库集群，PostgreSQL在新的时间线上运行。</p><p><img src="/medias/image/fig-10-03.png" alt="图10.3 原数据库集群与恢复后的数据库集群之间的timelineId关系"></p><p>如第9章所述，WAL段文件名的前8位数字等于创建该段的数据库集群的timelineId。当timelineId被改变时，WAL段文件名也会被修改。</p><p>以WAL段文件为例，重新描述恢复过程。假设我们使用<strong>000000010000000000000009</strong>和<strong>00000001000000000000000A</strong>两个归档日志恢复数据库集群。新恢复的数据库集群被分配为timelineId 2，PostgreSQL从<strong>00000002000000000000000A</strong>创建WAL段。图10.4显示了这种情况。</p><p><img src="/medias/image/fig-10-04.png" alt="图10.3 原数据库集群与恢复后的数据库集群之间的timelineId关系"></p><h4 id="10-3-2-时间轴历史文件"><a href="#10-3-2-时间轴历史文件" class="headerlink" title="10.3.2 时间轴历史文件"></a>10.3.2 时间轴历史文件</h4><p>当一个PITR进程完成时，一个名为<strong>00000002. history</strong>的时间线历史文件在归档目录和pg_xlog子目录（在版本10或更高版本中是pg_wal子目录）下被创建。这个文件记录它从哪个时间轴开始分支。</p><p>该文件的命名规则如下：</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token string">"8-digit new timelineId"</span>.history<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>时间轴历史文件至少包含一行，每行由以下三部分组成：</p><ul><li><p>timelineId——用于恢复的归档日志的timelineId。</p></li><li><p>LSN——发生WAL段切换的LSN位置。</p></li><li><p>reason——对时间线改变原因的通俗易懂的解释。</p></li></ul><p>具体例子如下：</p><pre class="line-numbers language-bash"><code class="language-bash">postgres<span class="token operator">></span> <span class="token function">cat</span> /home/postgres/archivelogs/00000002.history1  0/A000198before 2022-11-20 12:05:00.861324+00<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>含义如下：</p><blockquote><p>数据库集群（timelineId=2）基于timelineId为1的基本备份，通过重放归档日志在’2022-11-20 12:05:00.861324+00’之前的时间进行恢复，直到0/A000198。</p></blockquote><p>通过这种方式，每个时间线历史文件告诉我们单个恢复的数据库集群的完整历史。此外，它也用于PITR过程本身。细节将在下一节中解释。</p><p>时间线历史文件格式在版本9.3更改。版本9.3或更高版本和更早版本的格式如下所示，不详细说明。</p><p>9.3以后版本：</p><pre class="line-numbers language-bash"><code class="language-bash">timelineIdLSN<span class="token string">"reason"</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>9.2之前版本：</p><pre class="line-numbers language-bash"><code class="language-bash">timelineIdWAL_segment<span class="token string">"reason"</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="10-4-基于时间线历史文件的时间点恢复"><a href="#10-4-基于时间线历史文件的时间点恢复" class="headerlink" title="10.4 基于时间线历史文件的时间点恢复"></a>10.4 基于时间线历史文件的时间点恢复</h3><p>时间线历史文件在第二个和后续的PITR流程中起着重要作用。通过尝试第二次恢复，我们将探索如何使用它。</p><p>同样，假设您在timelineId为2的恢复数据库集群中在12:15:00发生了错误。在这种情况下，要恢复数据库集群，你应该创建一个新的recovery.conf，如下所示：</p><pre class="line-numbers language-bash"><code class="language-bash">restore_command <span class="token operator">=</span> <span class="token string">'cp /mnt/server/archivedir/%f %p'</span>recovery_target_time <span class="token operator">=</span> <span class="token string">"2022-11-20 12:15:00 GMT"</span>recovery_target_timeline <span class="token operator">=</span> 2<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>参数<code>recovery_target_time</code> 设置您犯新错误的时间，并将 <code>recovery_target_timeline</code> 设置为2，以便按照其时间轴进行恢复。</p><p>重新启动PostgreSQL服务器并进入PITR模式，在目标时间点沿timelineId 2恢复数据库，如图10.5。</p><p><img src="/medias/image/fig-10-05.png" alt="图10.5 按照时间线id 2在12:15:00恢复数据库"></p><p>（1）PostgreSQL从backup_label文件中读取<strong>CHECKPOINT LOCATION</strong>的值。</p><p>（2）部分参数值从recovery.conf文件中读取，本例中为restore_command、recovery_target_time和recovery_target_timeline。</p><p>（3）PostgreSQL读取时间线历史文件<strong>00000002.History</strong>，它对应于参数recovery_target_timeline的值。</p><p>（4）PostgreSQL通过以下步骤重放WAL数据：</p><ul><li>从REDO点到写入00000002.History文件的LSN ‘0/A000198’。PostgreSQL读取并回放相应timelineId为1的归档日志的WAL数据。</li><li>从LSN ‘0/A000198’之后到时间戳<strong>2022-11-20 12:15:00</strong>之前，PostgreSQL读取并回放timelineId为2的WAL数据（适当的归档日志）。</li></ul><p>（5）当恢复过程完成时，当前的时间轴id将前进到3，并在pg_xlog子目录（版本10或更高版本则是pg_wal子目录）和归档目录中创建一个名为<strong>00000003.History</strong>的新时间线历史文件。</p><pre class="line-numbers language-bash"><code class="language-bash">postgres<span class="token operator">></span> <span class="token function">cat</span> /home/postgres/archivelogs/00000003.history1         0/A000198     before 2022-11-20 12:05:00.861324+002         0/B000078     before 2022-11-20 12:15:00.927133+00<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>当您多次执行PITR时，您应该显式地设置一个timelineId，以便使用适当的时间线历史文件。</p><p>这样，时间线历史文件既是数据库集群的历史日志，又是PITR进程的恢复指令文档。</p>]]></content>
      
      
      <categories>
          
          <category> postgresql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> postgresql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>1 数据库集群、数据库和表</title>
      <link href="/2021/1.shu-ju-ku-ji-qun-shu-ju-ku-he-biao/"/>
      <url>/2021/1.shu-ju-ku-ji-qun-shu-ju-ku-he-biao/</url>
      
        <content type="html"><![CDATA[<p>本章和下一章总结了PostgreSQL的基础知识，以帮助阅读后续章节。</p><span id="more"></span><p>[TOC]</p><p>在本章中，描述了以下主题：</p><ul><li>数据库集群的逻辑结构</li><li>数据库集群的物理结构</li><li>堆表文件的内部布局</li><li>向表中写入和读取数据的方法</li></ul><p>如果您已经熟悉它们，您可以跳过本章。</p><h2 id="1-1-数据库集群的逻辑结构"><a href="#1-1-数据库集群的逻辑结构" class="headerlink" title="1.1 数据库集群的逻辑结构"></a>1.1 数据库集群的逻辑结构</h2><p>一个<strong>数据库集群</strong>是一个集<em>数据库，</em>由PostgreSQL服务器管理。如果您现在第一次听到这个定义，您可能会对此感到疑惑，但是 PostgreSQL 中的术语“数据库集群”<strong>并不</strong>意味着“一组数据库服务器”。PostgreSQL 服务器在单个主机上运行并管理单个数据库集群。</p><p>数据库集群的逻辑结构如图1.1所示。一个<em>数据库</em>是一个集合<em>的数据库对象</em>。在关系数据库理论中，<em>数据库对象</em>是一种用于存储或引用数据的数据结构。一个（堆）<em>表</em>就是一个典型的例子，还有很多，比如索引、序列、视图、函数等等。在 PostgreSQL 中，数据库本身也是数据库对象，在逻辑上彼此分离。所有其他数据库对象（例如，表、索引等）都属于它们各自的数据库。</p><p><img src="/medias/image/fig-1-01.png" alt="图 1.1 数据库集群的逻辑结构"></p><p>PostgreSQL 中的所有数据库对象都由各自的*<em>对象标识符 (OID)*<em>内部管理，它们是无符号的 4 字节整数。根据对象的类型，数据库对象和相应 OID 之间的关系存储在适当的<a href="http://www.postgresql.org/docs/current/static/catalogs.html">系统目录</a>中。例如，数据库和堆表的OID分别存储在</em>pg_database*和</em>pg_class中*，因此您可以通过发出如下查询来找出您想知道的OID：</p><pre class="line-numbers language-sql-monosp"><code class="language-sql-monosp">sampledb =# SELECT datname , oid FROM pg_database WHERE datname = 'sampledb' ;  数据名  |   oid   ----------+-------  sampledb | 16384 ( 1行) sampledb =# SELECT relname , oid FROM pg_class WHERE relname = 'sampletbl' ;   姓名  |   oid   -----------+-------  sampletbl | 18740 （1排）     <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="1-2-数据库集群物理结构"><a href="#1-2-数据库集群物理结构" class="headerlink" title="1.2  数据库集群物理结构"></a>1.2  数据库集群物理结构</h2><p>一个<em>数据库集群</em>基本上是一个称为<strong>基目录的目录</strong>，它包含一些子目录和大量文件。如果您执行<a href="http://www.postgresql.org/docs/current/static/app-initdb.html">initdb</a>实用程序来初始化一个新的数据库集群，则会在指定目录下创建一个基本目录。虽然不是强制性的，但基目录的路径通常设置为环境变量<em>PGDATA</em>。</p><p>图 1.2 显示了 PostgreSQL 中的数据库集群示例。数据库是<em>基</em>子目录下的子目录，每个表和索引（至少）是存储在其所属数据库子目录下的一个文件。还有几个包含特定数据和配置文件的子目录。虽然 PostgreSQL 支持<em>tablespaces</em>，但该术语的含义与其他 RDBMS 不同。PostgreSQL 中的表空间是一个包含基本目录之外的一些数据的目录。</p><p><img src="/medias/image/fig-1-02.png" alt="图 1.2 数据库集群示例"></p><p>在以下小节中，将描述数据库集群的布局、数据库、与表和索引关联的文件以及 PostgreSQL 中的表空间。</p><h3 id="1-2-1-数据库集群布局"><a href="#1-2-1-数据库集群布局" class="headerlink" title="1.2.1 数据库集群布局"></a>1.2.1 数据库集群布局</h3><p>数据库集群的布局在<a href="http://www.postgresql.org/docs/current/static/storage-file-layout.html">官方文档中</a>有描述。部分文档的主要文件和子目录如表1.1所示：</p><p><strong>表1.1 基目录下文件和子目录的布局（来自官方文档）</strong></p><table><thead><tr><th align="left">档案</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">PG_VERSION</td><td align="left">包含 PostgreSQL 主要版本号的文件</td></tr><tr><td align="left">pg_hba.conf</td><td align="left">用于控制 PosgreSQL 客户端身份验证的文件</td></tr><tr><td align="left">pg_ident.conf</td><td align="left">一个控制 PostgreSQL 用户名映射的文件</td></tr><tr><td align="left">postgresql.conf</td><td align="left">设置配置参数的文件</td></tr><tr><td align="left">postgresql.auto.conf</td><td align="left">用于存储在 ALTER SYSTEM（9.4 或更高版本）中设置的配置参数的文件</td></tr><tr><td align="left">postmaster.opts</td><td align="left">记录服务器上次启动时使用的命令行选项的文件</td></tr><tr><td align="left"><strong>子目录</strong></td><td align="left"><strong>描述</strong></td></tr><tr><td align="left">base/</td><td align="left">包含每个数据库子目录的子目录。</td></tr><tr><td align="left">global/</td><td align="left">包含集群范围表的子目录，例如 pg_database 和 pg_control。</td></tr><tr><td align="left">pg_commit_ts/</td><td align="left">包含事务提交时间戳数据的子目录。9.5 或更高版本。</td></tr><tr><td align="left">pg_clog/（9.6 或更早版本）</td><td align="left">包含事务提交状态数据的子目录。它在版本 10 中更名为<em>pg_xact。CLOG</em>将在<a href="http://www.interdb.jp/pg/pgsql05.html#_5.4.">第 5.4 节中</a>描述。</td></tr><tr><td align="left">pg_dynshmem/</td><td align="left">包含动态共享内存子系统使用的文件的子目录。9.4 或更高版本。</td></tr><tr><td align="left">pg_logical/</td><td align="left">包含用于逻辑解码的状态数据的子目录。9.4 或更高版本。</td></tr><tr><td align="left">pg_multixact/</td><td align="left">包含多事务状态数据的子目录（用于共享行锁）</td></tr><tr><td align="left">pg_notify/</td><td align="left">包含 LISTEN/NOTIFY 状态数据的子目录</td></tr><tr><td align="left">pg_repslot/</td><td align="left">包含<a href="http://www.postgresql.org/docs/current/static/warm-standby.html#STREAMING-REPLICATION-SLOTS">复制槽</a> 数据的子目录。9.4 或更高版本。</td></tr><tr><td align="left">pg_serial/</td><td align="left">包含有关已提交的可序列化事务（版本 9.1 或更高版本）的信息的子目录</td></tr><tr><td align="left">pg_snapshots/</td><td align="left">包含导出快照的子目录（版本 9.2 或更高版本）。PostgreSQL 的函数 pg_export_snapshot 在这个子目录中创建一个快照信息文件。</td></tr><tr><td align="left">pg_stat/</td><td align="left">包含统计子系统永久文件的子目录。</td></tr><tr><td align="left">pg_stat_tmp/</td><td align="left">包含统计子系统临时文件的子目录。</td></tr><tr><td align="left">pg_subtrans/</td><td align="left">包含子事务状态数据的子目录</td></tr><tr><td align="left">pg_tblspc/</td><td align="left">包含指向表空间的符号链接的子目录</td></tr><tr><td align="left">pg_twophase/</td><td align="left">包含准备交易的状态文件的子目录</td></tr><tr><td align="left">pg_wal/（版本 10 或更高版本）</td><td align="left">包含 WAL（预写日志）段文件的子目录。它从版本 10 中的<em>pg_xlog</em>重命名。</td></tr><tr><td align="left">pg_xact/（版本 10 或更高版本）</td><td align="left">包含事务提交状态数据的子目录。它在版本 10 中从<em>pg_clog</em>重命名。CLOG 将在<a href="http://www.interdb.jp/pg/pgsql05.html#_5.4.">第 5.4 节中</a>描述。</td></tr><tr><td align="left">pg_xlog/（9.6 或更早版本）</td><td align="left">包含 WAL（预写日志）段文件的子目录。它在版本 10 中更名为<em>pg_wal</em>。</td></tr></tbody></table><h3 id="1-2-2-数据库布局"><a href="#1-2-2-数据库布局" class="headerlink" title="1.2.2 数据库布局"></a>1.2.2 数据库布局</h3><p>数据库是<em>基</em>子目录下的子目录；并且数据库目录名称与相应的 OID 相同。例如，当数据库<em>sampledb</em>的OID为16384时，其子目录名称为16384。</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">cd</span> <span class="token variable">$PGDATA</span>$ <span class="token function">ls</span> -ld base/16384drwx------  213 postgres postgres  7242  8 26 16:33 16384<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="1-2-3-与表和索引相关的文件布局"><a href="#1-2-3-与表和索引相关的文件布局" class="headerlink" title="1.2.3 与表和索引相关的文件布局"></a>1.2.3 与表和索引相关的文件布局</h3><p>每个小于1GB的表或索引是一个单独的文件，存放在它所属的数据库目录下。作为数据库对象的表和索引由单独的 OID 内部管理，而这些数据文件由变量<em>relfilenode 管理</em>。表和索引的relfilenode值基本但<strong>不</strong>总是匹配各自的OID，详细描述如下。</p><p>让我们显示表<em>sampletbl</em>的 OID 和<em>relfilenode</em>：</p><pre class="line-numbers language-sql-monosp"><code class="language-sql-monosp">sampledb=# SELECT relname, oid, relfilenode FROM pg_class WHERE relname = 'sampletbl';  relname  |  oid  | relfilenode-----------+-------+------------- sampletbl | 18740 |       18740 (1 row)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>从上面的结果可以看出，oid 和 relfilenode 的值是相等的。还可以看到表<em>sampletbl</em>的数据文件路径为*’base/16384/18740’*。</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">cd</span> <span class="token variable">$PGDATA</span>$ <span class="token function">ls</span> -la base/16384/18740-rw------- 1 postgres postgres 8192 Apr 21 10:21 base/16384/18740<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>通过发出一些命令（例如，TRUNCATE、REINDEX、CLUSTER）来更改表和索引的 relfilenode 值。例如，如果我们截断表<em>sampletbl</em>，PostgreSQL 会为该表分配一个新的 relfilenode (18812)，删除旧的数据文件 (18740)，并创建一个新的 (18812)。</p><pre class="line-numbers language-sql-monosp"><code class="language-sql-monosp">sampledb=# TRUNCATE sampletbl;TRUNCATE TABLEsampledb=# SELECT relname, oid, relfilenode FROM pg_class WHERE relname = 'sampletbl';  relname  |  oid  | relfilenode-----------+-------+------------- sampletbl | 18740 |       18812 (1 row)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在 9.0 或更高版本中，内置函数<em>pg_relation_filepath</em>很有用，因为该函数返回具有指定 OID 或名称的关系的文件路径名。</p><pre class="line-numbers language-sql-monosp"><code class="language-sql-monosp">sampledb=# SELECT pg_relation_filepath('sampletbl'); pg_relation_filepath ---------------------- base/16384/18812(1 row)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>当表和索引的文件大小超过 1GB 时，PostgreSQL 会创建一个名为 relfilenode.1 的新文件并使用它。如果新文件已填满，将创建下一个名为 relfilenode.2 的新文件，依此类推。</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">cd</span> <span class="token variable">$PGDATA</span>$ <span class="token function">ls</span> -la -h base/16384/19427*-rw------- 1 postgres postgres 1.0G  Apr  21 11:16 data/base/16384/19427-rw------- 1 postgres postgres  45M  Apr  21 11:20 data/base/16384/19427.1<span class="token punctuation">..</span>.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在构建 PostgreSQL 时，可以使用配置选项 –with-segsize 更改表和索引的最大文件大小。</p><p>仔细查看数据库子目录，你会发现每个表都有两个关联的文件，分别以’_fsm’和’_vm’为后缀。那些被称为<strong>空闲空间映射</strong>和<strong>可见性映射</strong>，分别存储空闲空间容量和表文件中每个页面的可见性信息（更多详细信息参见<a href="http://www.interdb.jp/pg/pgsql05.html#_5.3.4.">第 5.3.4</a><a href="http://www.interdb.jp/pg/pgsql06.html#_6.2.">节</a>和<a href="http://www.interdb.jp/pg/pgsql06.html#_6.2.">第 6.2 节</a>）。索引只有单独的可用空间图，没有可见性图。</p><p>一个具体的例子如下所示：</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">cd</span> <span class="token variable">$PGDATA</span>$ <span class="token function">ls</span> -la base/16384/18751*-rw------- 1 postgres postgres  8192 Apr 21 10:21 base/16384/18751-rw------- 1 postgres postgres 24576 Apr 21 10:18 base/16384/18751_fsm-rw------- 1 postgres postgres  8192 Apr 21 10:18 base/16384/18751_vm<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>它们也可以在内部称为每个关系的<strong>分叉</strong>；空闲空间映射是表/索引数据文件的第一个分叉（分叉编号为 1），可见性映射是表数据文件的第二个分叉（分叉编号为 2）。数据文件的fork编号为0。</p><h3 id="1-2-4-表空间"><a href="#1-2-4-表空间" class="headerlink" title="1.2.4 表空间"></a>1.2.4 表空间</h3><p>甲<em>表</em>中PostgreSQL是基本目录之外的附加数据区。该功能已在8.0版本中实现。</p><p>图1.3展示了一个表空间的内部布局，以及与主数据区的关系。</p><p><img src="/medias/image/fig-1-03.png" alt="图 1.3 数据库集群中的一个表空间"></p><p>在您发出<a href="http://www.postgresql.org/docs/current/static/sql-createtablespace.html">CREATE TABLESPACE</a>语句时指定的目录下创建一个表空间，并在该目录下<a href="http://www.postgresql.org/docs/current/static/sql-createtablespace.html">创建</a>特定于版本的子目录（例如，PG_14_202011044）。特定版本的命名方法如下所示。</p><pre><code>PG_'主要版本'_'目录版本号'</code></pre><p>例如，如果您在/home/postgres/tblspc处创建一个表空间new_tblspc，其 oid 为 16386，则会在该表空间下创建一个子目录，例如PG_14_202011044。</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">ls</span> -l /home/postgres/tblspc/total 4drwx------ 2 postgres postgres 4096 Apr 21 10:08 PG_14_202011044<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>表空间目录由来自pg_tblspc子目录的符号链接寻址，链接名称与表空间的 OID 值相同。</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">ls</span> -l <span class="token variable">$PGDATA</span>/pg_tblspc/total 0lrwxrwxrwx 1 postgres postgres 21 Apr 21 10:08 16386 -<span class="token operator">></span> /home/postgres/tblspc<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>如果在表空间下创建新数据库（OID 为 16387），其目录将创建在特定于版本的子目录下。</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">ls</span> -l /home/postgres/tblspc/PG_14_202011044/total 4drwx------ 2 postgres postgres 4096 Apr 21 10:10 16387<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>如果新建表属于基目录下创建的数据库，首先在版本特定的子目录下新建与现有数据库OID同名的目录，然后放置新表文件在创建的目录下。</p><pre class="line-numbers language-sql-monosp"><code class="language-sql-monosp">sampledb=# CREATE TABLE newtbl (.....) TABLESPACE new_tblspc;sampledb=# SELECT pg_relation_filepath('newtbl');             pg_relation_filepath             --------------------------------------------- pg_tblspc/16386/PG_14_202011044/16384/18894<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="1-3-堆表文件的内部布局"><a href="#1-3-堆表文件的内部布局" class="headerlink" title="1.3 堆表文件的内部布局"></a>1.3 堆表文件的内部布局</h2><p>在数据文件内部（堆表和索引，以及空闲空间映射和可见性映射），它被分成固定长度的<strong>页</strong>（或<strong>块</strong>），默认为8192字节（8 KB）。每个文件中的那些页从 0 开始按顺序编号，这些编号称为<strong>块编号</strong>。如果文件已被填满，PostgreSQL 会在文件末尾添加一个新的空页以增加文件大小。</p><p>页面的内部布局取决于数据文件类型。在本节中，将描述表格布局，因为后续章节将需要这些信息。</p><p><img src="/medias/image/fig-1-04.png" alt="图 1.4 堆表文件的页面布局"></p><p>表中的页面包含三种数据，描述如下：</p><ol><li><p><strong>heap tuple(s)</strong> – 堆元组本身就是一个记录数据。它们从页面底部按顺序堆叠。元组的内部结构在<a href="http://www.interdb.jp/pg/pgsql05.html#_5.2.">第5.2节</a>和<a href="http://www.interdb.jp/pg/pgsql09.html">第9章中</a>描述，因为需要PostgreSQL中的并发控制（CC）和WAL知识。</p></li><li><p><strong>行指针（s）</strong> ——行指针有 4 个字节长，并保存一个指向每个堆元组的指针。它也称为<strong>项目指针</strong>。<br>行指针形成一个简单的数组，它起着元组索引的作用。每个索引从 1 开始依次编号，称为<strong>偏移编号</strong>。当一个新的元组被添加到页面时，一个新的行指针也会被推送到数组上以指向新的。</p></li><li><p><strong>标头数据</strong>– 由结构<a href="javascript:void(0)">PageHeaderData</a>定义的标头数据分配在页面的开头。它有 24 字节长，包含有关页面的一般信息。结构的主要变量描述如下。</p></li><li><ul><li><em>pd_lsn</em> – 该变量存储了此页面最后一次更改写入的<em>XLOG</em>记录的 LSN。它是一个 8 字节的无符号整数，与 WAL（Write-Ahead Logging）机制有关。详细信息在<a href="http://www.interdb.jp/pg/pgsql09.html#_9.1.2.">第 9 章</a>中描述。</li><li><em>pd_checksum</em> – 此变量存储此页面的校验和值。（注意这个变量在9.3及以后的版本中是支持的；在早期的版本中，这部分已经存储了页面的timelineId。）</li><li><em>pd_lower, pd_upper</em> – pd_lower 指向行尾指针，pd_upper 指向最新堆元组的开头。</li><li><em>pd_special</em> – 此变量用于索引。在表格内的页面中，它指向页面的末尾。（在索引内页中，它指向特殊空间的开始，即只由索引保存的数据区，根据索引类型如B-tree、GiST、GiN等包含特定数据。）</li></ul></li></ol><p>行指针末尾和最新元组开头之间的空白空间称为<strong>空闲空间</strong>或<strong>空洞</strong>。</p><p>为了标识表中的<strong>元组，</strong>内部使用了*<em>元组标识符 (TID)*<em>。TID 包含一对值：包含元组的页面的</em>块号*，以及指向元组的行指针的</em>偏移量*。其用法的典型示例是索引。请参阅<a href="http://www.interdb.jp/pg/pgsql01.html#_1.4.2.">第 1.4.2 节中的</a>更多详细信息。</p><p>PageHeaderData 结构在<a href="https://github.com/postgres/postgres/blob/master/src/include/storage/bufpage.h">src/include/storage/bufpage.h 中定义</a>。</p><p>在计算机科学领域，这种类型的页面被称为<strong>slotted page</strong>，行指针对应一个<strong>slot array</strong>。</p><p>此外，大小大于约 2 KB（约 8 KB 的 1/4）的堆元组使用称为<strong>TOAST</strong>（超大属性存储技术）的方法进行存储和管理。有关详细信息，请参阅<a href="http://www.postgresql.org/docs/current/static/storage-toast.html">PostgreSQL 文档</a>。</p><h2 id="1-4-编写和读取元组的方法"><a href="#1-4-编写和读取元组的方法" class="headerlink" title="1.4 编写和读取元组的方法"></a>1.4 编写和读取元组的方法</h2><p>在本章的最后，描述了编写和读取堆元组的方法。</p><h3 id="1-4-1-编写堆元组"><a href="#1-4-1-编写堆元组" class="headerlink" title="1.4.1 编写堆元组"></a>1.4.1 编写堆元组</h3><p>假设一个表由一页组成，其中只包含一个堆元组。本页的pd_lower指向第一行指针，行指针和pd_upper都指向第一个堆元组。见图 1.5(a)。</p><p>当插入第二个元组时，它被放置在第一个元组之后。第二行指针被推到第一个行上，它指向第二个元组。pd_lower 更改为指向第二行指针，pd_upper 更改为指向第二个堆元组。见图 1.5(b)。该页内的其他头数据（例如，pd_lsn、pg_checksum、pg_flag）也被重写为适当的值；更多细节在<a href="http://www.interdb.jp/pg/pgsql05.html#_5.3.">第 5.3 节</a>和<a href="http://www.interdb.jp/pg/pgsql09.html">第 9 章</a>中描述。</p><p><img src="/medias/image/fig-1-05.png" alt="图 1.5 编写堆元组"></p><h3 id="1-4-2-读取堆元组"><a href="#1-4-2-读取堆元组" class="headerlink" title="1.4.2 读取堆元组"></a>1.4.2 读取堆元组</h3><p>这里概述了两种典型的访问方法，顺序扫描和 B 树索引扫描：</p><ul><li><strong>顺序扫描</strong>——通过扫描每页中的所有行指针来顺序读取所有页中的所有元组。见图 1.6(a)。</li><li><strong>B 树索引扫描</strong> ——索引文件包含索引元组，每个索引元组由一个索引键和一个指向目标堆元组的 TID 组成。如果找到了带有您要查找的键的索引元组，PostgreSQL 将使用获得的 TID 值读取所需的堆元组。（在B-tree索引中查找索引元组的方法这里不做说明，因为它很常见，这里篇幅有限。参见相关资料。）例如，在图1.6（b）中，TID获得的索引元组的值为’(block = 7, Offset = 2)’。这意味着目标堆元组是表中第 7 页的第 2 个元组，因此 PostgreSQL 可以读取所需的堆元组，而无需在页面中进行不必要的扫描。</li></ul><p><img src="/medias/image/fig-1-06.png" alt="图 1.6 顺序扫描和索引扫描"></p><p> <em>索引内部</em></p><p>本文档不详细解释索引。为了理解它们，我建议阅读下面显示的有价值的帖子：</p><ul><li><a href="https://postgrespro.com/blog/pgsql/3994098">PostgreSQL 中的索引 — 1</a></li><li><a href="https://postgrespro.com/blog/pgsql/4161264">PostgreSQL 中的索引 — 2</a></li><li><a href="https://postgrespro.com/blog/pgsql/4161321">PostgreSQL 中的索引 — 3 (Hash)</a></li><li><a href="https://postgrespro.com/blog/pgsql/4161516">PostgreSQL 中的索引 — 4 (Btree)</a></li><li><a href="https://postgrespro.com/blog/pgsql/4175817">PostgreSQL 中的索引 — 5 (GiST)</a></li><li><a href="https://habr.com/en/company/postgrespro/blog/446624/">PostgreSQL 中的索引 — 6 (SP-GiST)</a></li><li><a href="https://habr.com/en/company/postgrespro/blog/448746/">PostgreSQL 中的索引 — 7 (GIN)</a></li><li><a href="https://habr.com/en/company/postgrespro/blog/452900/">PostgreSQL 中的索引 — 9 (BRIN)</a></li></ul><p>PostgreSQL 还支持 TID-Scan、<a href="https://wiki.postgresql.org/wiki/Bitmap_Indexes">Bitmap-Scan</a>和 Index-Only-Scan。</p><p>TID-Scan 是一种通过使用所需元组的 TID 直接访问元组的方法。例如，要查找表中第 0 页中的第一个元组，请发出以下查询：</p><pre class="line-numbers language-sql-monosp"><code class="language-sql-monosp">sampledb=# SELECT ctid, data FROM sampletbl WHERE ctid = '(0,1)'; ctid  |   data    -------+----------- (0,1) | AAAAAAAAA(1 row)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Index-Only-Scan 将在<a href="http://www.interdb.jp/pg/pgsql07.html">第 7 章</a>详细介绍。</p>]]></content>
      
      
      <categories>
          
          <category> postgresql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> postgresql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>11 流复制</title>
      <link href="/2021/11-liu-fu-zhi/"/>
      <url>/2021/11-liu-fu-zhi/</url>
      
        <content type="html"><![CDATA[<p>同步流复制是在9.1版本中实现的。这是一个单主-多从类型的复制，通常主和从这两个术语分别在PostgreSQL中被称为主和备。</p><span id="more"></span><p>在流复制中，有三种类型的进程协同工作:</p><ul><li>主服务器上的walsender进程向备服务器发送WAL (Write-Ahead Log)数据。</li><li>备服务器上的walreceiver进程接收WAL数据。</li><li>备服务器上的startup进程重放WAL数据。</li></ul><p>walsender和walreceiver使用单个TCP连接进行通信。</p><p>[TOC]</p><h3 id="11-1-启动流复制"><a href="#11-1-启动流复制" class="headerlink" title="11.1 启动流复制"></a>11.1 启动流复制</h3><p>图11.1显示了流复制的启动顺序图：</p><p> <img src="/medias/image/fig-11-01.png" alt="图11.1 复制启动顺序"></p><p>(1) 启动主备服务器。</p><p>(2) 备服务器启动startup进程。</p><p>(3) 备服务器启动walreceiver进程。</p><p>(4) walreceiver向主服务器发送连接请求。如果主服务器没有运行，walreceiver会定期发送这些请求。</p><p>(5) 当主服务器收到连接请求时，启动walsender进程，walsender和walreceiver之间建立TCP连接。</p><p>(6) walreceiver发送备用数据库集群的最新LSN（日志序列号）。这在信息技术领域被称为握手。</p><p>(7) 如果备端最新的LSN小于主端最新的LSN， walsender将前一个LSN的WAL数据发送给后一个LSN。这样的WAL数据是由存储在主服务器的pg_xlog子目录（在版本10或更高版本中为pg_wal子目录）中的WAL段提供的。备服务器重新回放收到的WAL数据。在这个阶段中，备用服务器赶上了主服务器，因此称为追赶（catch-up）。</p><p>(8) 流复制开始工作。</p><p>每个walsender进程保持一个适合于连接的walreceiver或应用程序的工作阶段的状态。以下是walsender进程的可能状态:</p><ul><li><p>startup——从开始walsender到握手结束。见图11.1(5)-(6)。</p></li><li><p>catch-up——在追赶阶段。见图11.1(7)。</p></li><li><p>streaming——当流复制正在工作时。见图11.1(8)。</p></li><li><p>backup—为备份工具（如pg_basebackup实用程序）发送整个数据库集群的文件。</p></li></ul><p><code>pg_stat_replication</code> 视图显示所有正在运行的walsender的状态。一个例子如下:</p><pre class="line-numbers language-bash"><code class="language-bash">testdb<span class="token operator">=</span><span class="token comment" spellcheck="true"># SELECT application_name,state FROM pg_stat_replication;</span> application_name <span class="token operator">|</span>   state------------------+----------- standby1         <span class="token operator">|</span> streaming standby2         <span class="token operator">|</span> streaming pg_basebackup    <span class="token operator">|</span> backup<span class="token punctuation">(</span>3 rows<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如上所示，两个walsender正在运行，为连接的备服务器发送WAL数据，另一个walsender正在运行，为pg_basebackup实用程序发送数据库集群的所有文件。</p><blockquote><p><strong>如果备用服务器长时间处于停止状态后重新启动，会发生什么情况?</strong></p><p>在版本9.3或更早的版本中，如果备服务器所需的主服务器的WAL段已经被回收，备服务器就不能赶上主服务器。对于这个问题没有可靠的解决方案，只能为配置参数<code>wal_keep_segments</code>设置一个较大的值，以减少发生这种情况的可能性。这是一个权宜之计。</p><p>在9.4或更高版本中，可以通过使用复制槽来防止这个问题。复制槽是一个扩展了WAL数据发送灵活性的特性，主要用于逻辑复制，这也为这个问题提供了解决方案——通过暂停回收过程，可以将包含pg_xlog（或pg_wal，如果版本10或更高）下未发送数据的WAL段文件保留在复制槽中。详细信息请参考<a href="http://www.postgresql.org/docs/current/static/warm-standby.html#STREAMING-REPLICATION-SLOTS">官方文档</a>。</p></blockquote><h3 id="11-2-如何进行流复制"><a href="#11-2-如何进行流复制" class="headerlink" title="11.2 如何进行流复制"></a>11.2 如何进行流复制</h3><p>流复制有两个方面：日志传送和数据库同步。日志传送是其中主要的一个方面，因为主服务器在写入WAL (Write-Ahead Log)数据时会将其发送到连接的备服务器。同步复制需要数据库同步，其中主服务器与每个备用服务器通信以同步它们的数据库集群。</p><p>为了准确地理解流复制是如何工作的，我们应该了解一个主服务器如何管理多个备用服务器。在本节中，我们将从简单的一主一备系统开始，然后在下一节中讨论一主多备。</p><h4 id="11-2-1-主备间的通信"><a href="#11-2-1-主备间的通信" class="headerlink" title="11.2.1 主备间的通信"></a>11.2.1 主备间的通信</h4><p>假设备服务器处于同步复制模式，但 <code>hot_standby</code> 配置参数被禁用，<code>wal_level</code>为 replica。主服务器的主要参数如下所示:</p><pre class="line-numbers language-properties"><code class="language-properties"><span class="token attr-name">synchronous_standby_names</span> <span class="token punctuation">=</span> <span class="token attr-value">'standby1'</span><span class="token attr-name">hot_standby</span> <span class="token punctuation">=</span> <span class="token attr-value">off</span><span class="token attr-name">wal_level</span> <span class="token punctuation">=</span> <span class="token attr-value">reprica</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>此外，在第9.5节提到的三个写入WAL数据的触发器中，我们主要关注这里提交的事务。</p><p>假设主服务器上的一个后端进程以自动提交模式发出一条简单的INSERT语句。后端启动事务，发出INSERT语句，然后立即提交事务。让我们进一步探讨如何完成这个提交操作。如图11.2中顺序图所示：</p><p><img src="/medias/image/fig-11-02.png" alt="图11.2 流复制的通信顺序图"></p><p>(1) 后端进程通过执行 <em>XLogInsert()</em> 和 <em>XLogFlush()</em> 函数将WAL数据写入和刷新到WAL段文件中。</p><p>(2) walsender进程将写入WAL段的WAL数据发送给walreceiver进程。</p><p>(3) 后端进程发送WAL数据后，继续等待备服务器的ACK响应。更准确地说，后端进程通过执行内部函数 <em>SyncRepWaitForLSN()</em> 获得一个锁存器，并等待它被释放。</p><p>(4) 备服务器上的walreceiver通过系统调用 <em>write()</em>  将收到的WAL数据写入备服务器的WAL段，并返回一个ACK响应给walsender。</p><p>(5) walreceiver使用系统调用（如*fsync()*）将WAL数据刷新到WAL段，并向walsender返回另一个ACK响应，并通知启动进程WAL数据更新。</p><p>(6) startup进程回放已经写入WAL段的WAL数据。</p><p>(7) walsender在收到walreceiver的ACK响应后，释放后端进程的锁存器，然后，后端进程的提交或中止操作将完成。锁存器释放的时间取决于参数 <code>synchronous_commit</code>。默认是on，当接收到步骤(5)的ACK时，锁存器被释放，而当接收到步骤(4)的ACK时，锁存器是remote_write。</p><p>每个ACK响应将备服务器的内部信息通知给主服务器。它包括以下四个项目：</p><ul><li><p>最近一次写入WAL数据的LSN位置。</p></li><li><p>最近一次WAL数据刷写的LSN位置。</p></li><li><p>在strartup进程中重放最新WAL数据的LSN位置。</p></li><li><p>发送响应时的时间戳。</p></li></ul><p>Walreceiver不仅在写入和刷新WAL数据时返回ACK响应，而且还作为备服务器的心跳定期返回。因此，主服务器总是能够准确地了解所有连接的备服务器的状态。</p><p>执行如下所示的查询，可以显示连接的备服务器的LSN相关信息：</p><pre class="line-numbers language-bash"><code class="language-bash">testdb<span class="token operator">=</span><span class="token comment" spellcheck="true"># SELECT application_name AS host,</span>        write_location AS write_LSN, flush_location AS flush_LSN,         replay_location AS replay_LSN FROM pg_stat_replication<span class="token punctuation">;</span>   host   <span class="token operator">|</span> write_lsn <span class="token operator">|</span> flush_lsn <span class="token operator">|</span> replay_lsn ----------+-----------+-----------+------------ standby1 <span class="token operator">|</span> 0/5000280 <span class="token operator">|</span> 0/5000280 <span class="token operator">|</span> 0/5000280 standby2 <span class="token operator">|</span> 0/5000280 <span class="token operator">|</span> 0/5000280 <span class="token operator">|</span> 0/5000280<span class="token punctuation">(</span>2 rows<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>心跳间隔设置为 <code>wal_receiver_status_interval</code> 参数，默认为10秒。</p></blockquote><h4 id="11-2-2-发生故障时的行为"><a href="#11-2-2-发生故障时的行为" class="headerlink" title="11.2.2 发生故障时的行为"></a>11.2.2 发生故障时的行为</h4><p>在本小节中，描述了当同步备服务器发生故障时主服务器的行为，以及如何处理这种情况。</p><p>即使同步备服务器发生故障，不再能够返回ACK响应，主服务器也会一直等待响应。这意味着不能提交正在运行的事务，也不能启动后续的查询处理。换句话说，所有主服务器操作实际上都停止了（流复制不支持通过超时自动恢复到异步模式的功能）。</p><p>有两种方法可以避免这种情况。其中一种方法是使用多个备服务器来提高系统可用性，另一种是手动从同步模式切换到异步模式，步骤如下：</p><ol><li><p>将参数<code>synchronous_standby_names</code>设置为“空字符”。</p><pre class="line-numbers language-properties"><code class="language-properties"><span class="token attr-name">synchronous_standby_names</span> <span class="token punctuation">=</span> <span class="token attr-value">''</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>执行带reload选项的pg_ctl命令。</p><pre class="line-numbers language-bash"><code class="language-bash">postgres<span class="token operator">></span> pg_ctl -D <span class="token variable">$PGDATA</span> reload<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li></ol><p>上述过程不会影响已连接的客户端。主服务器将继续进行事务处理，同时保留客户端和各自后端进程之间的所有会话。</p><h3 id="11-3-管理多个备用服务器"><a href="#11-3-管理多个备用服务器" class="headerlink" title="11.3 管理多个备用服务器"></a>11.3 管理多个备用服务器</h3><p>在本节中，将描述流复制与多个备服务器的工作方式。</p><h4 id="11-3-1-sync-priority-和-sync-state"><a href="#11-3-1-sync-priority-和-sync-state" class="headerlink" title="11.3.1 sync_priority 和 sync_state"></a>11.3.1 <code>sync_priority</code> 和 <code>sync_state</code></h4><p>主服务器将sync_priority和sync_state属性分配给所有受管理的备服务器，并根据其各自的值处理每个备服务器（主服务器分配这些值，即使它只管理一个备服务器，这在前一节中没有提到）。</p><p><code>sync_priority</code> 表示同步模式下备服务器的优先级。该值越小，优先级越高。而特殊值0表示备服务器处于<strong>异步模式</strong>。备服务器的优先级按照主服务器的配置参数 <code>synchronous_standby_names</code> 中列出的顺序分配。例如，以下配置中，standby1和standby2的优先级分别为1和2。</p><pre class="line-numbers language-properties"><code class="language-properties"><span class="token attr-name">synchronous_standby_names</span> <span class="token punctuation">=</span> <span class="token attr-value">'standby1, standby2'</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>(未在此参数中列出的备用服务器为异步模式，优先级为0)</p><p><code>sync_state</code> 是备服务器的状态。以下是可能的状态:</p><ul><li><strong>sync</strong> 备服务器处于同步模式，是当前正在工作的最高优先级的备服务器。</li><li>**potential **备服务器处于同步模式，并且是当前正在工作的低优先级备服务器。如果当前同步备服务器出现故障，则将此备服务器提升为同步状态。</li><li>**async **备服务器为异步模式(它永远不会处于“sync”或“potential”模式)。</li></ul><p>备服务器的优先级和状态可以通过发出以下查询来显示：</p><pre class="line-numbers language-bash"><code class="language-bash">testdb<span class="token operator">=</span><span class="token comment" spellcheck="true"># SELECT application_name AS host, </span>         sync_priority, sync_state FROM pg_stat_replication<span class="token punctuation">;</span>   host   <span class="token operator">|</span> sync_priority <span class="token operator">|</span> sync_state----------+---------------+------------ standby1 <span class="token operator">|</span>             1 <span class="token operator">|</span> <span class="token function">sync</span> standby2 <span class="token operator">|</span>             2 <span class="token operator">|</span> potential<span class="token punctuation">(</span>2 rows<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="11-3-2-主服务器如何管理多个备服务器"><a href="#11-3-2-主服务器如何管理多个备服务器" class="headerlink" title="11.3.2 主服务器如何管理多个备服务器"></a>11.3.2 主服务器如何管理多个备服务器</h4><p>主服务器只等待来自同步备服务器的ACK响应。换句话说，主服务器只确认同步备服务器对WAL数据的写入和刷新。因此，流复制确保只有同步备服务器与主服务器处于一致和同步的状态。</p><p>图11.3显示了潜在备服务器的ACK响应早于主备服务器的ACK响应返回的情况。在这种情况下，主服务器没有完成当前事务的提交操作，而是继续等待备服务器的ACK响应。当主进程接收到响应时，后端进程释放锁存器并完成当前事务处理。</p><p> <img src="/medias/image/fig-11-03.png" alt="图11.3 管理多个备用服务器"></p><p>standby1和standby2的 <code>sync_state</code> 分别为’sync’和’potential’。</p><ol><li>尽管收到了潜在备服务器的ACK响应，主进程的后端进程仍然继续等待同步备服务器的ACK响应。</li><li>主后端进程收到同步备服务器的ACK响应后，释放锁存器，完成当前事务处理。</li></ol><p>相反，同步备服务器的ACK响应比潜在服务器的更早返回，主服务器立即完成当前事务的提交操作，而不用确保潜在的备服务器是否写入和刷新WAL数据。</p><h4 id="11-3-3-发生故障时的行为"><a href="#11-3-3-发生故障时的行为" class="headerlink" title="11.3.3 发生故障时的行为"></a>11.3.3 发生故障时的行为</h4><p>再次看看当备服务器发生故障时主服务器的行为。</p><p>当潜在或异步备服务器发生故障时，主服务器将终止连接到故障备用服务器的walsender进程，并继续所有处理。换句话说，主服务器的事务处理不会受到任何一种备服务器故障的影响。</p><p>当同步备服务器发生故障时，主服务器终止连接到故障备服务器的walsender进程，并用优先级最高的潜在备服务器替换同步备服务器，见图11.4。与上面描述的故障相反，主服务器上的查询处理将从故障点开始暂停，直到同步备服务器被替换。因此，备服务器的故障检测是提高复制系统可用性的一个非常重要的功能，故障检测将在下一节中描述。</p><p> <img src="/medias/image/fig-11-04.png" alt="图11.4 更换同步备用服务器"></p><p>在任何情况下，如果一个或多个备服务器以同步模式运行，则主服务器始终只保留一个同步备服务器，并且该同步备服务器始终与主服务器保持一致和同步状态。</p><h3 id="11-4-检测备服务器故障"><a href="#11-4-检测备服务器故障" class="headerlink" title="11.4 检测备服务器故障"></a>11.4 检测备服务器故障</h3><p>流复制使用两个常见的故障检测过程，完全不需要任何特殊的硬件。</p><p><strong>1 备服务器进程失败检测</strong></p><p>当检测到walsender和walreceiver之间的连接中断时，主服务器立即判断备服务器或walreceiver进程故障。当底层网络函数因写入或读取walreceiver的套接字接口失败而返回错误时，主服务器也立即确定其失败。</p><p><strong>2 硬件和网络故障检测</strong></p><p>如果walreceiver在 <code>wal_sender_timeout</code> 参数设置的时间内（默认为60秒）没有返回任何内容，则主服务器将确定备服务器故障。与上面描述的故障不同，即使备服务器由于某些故障（例如备服务器的硬件故障、网络故障等）不再能够发送任何响应，也需要一定的时间（最长为wal_sender_timeout秒）来确认主服务器上备服务器的死亡。</p><p>根据故障的类型，通常可以在故障发生后立即检测到，而有时在故障发生和检测到故障之间可能有一段时间延迟。特别是，如果在同步备服务器中发生后一种类型的故障，则主服务器上的所有事务处理都将停止，直到检测到备服务器的故障，即使多个潜在的备服务器可能一直在工作。</p><blockquote><p>在9.2或更早的版本中，参数 <code>wal_sender_timeout</code> 被称为 <code>replication_timeout</code>。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> postgresql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> postgresql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2 进程和内存架构</title>
      <link href="/2021/2.jin-cheng-he-nei-cun-jia-gou/"/>
      <url>/2021/2.jin-cheng-he-nei-cun-jia-gou/</url>
      
        <content type="html"><![CDATA[<p>本章总结了PostgreSQL中的进程架构和内存架构，以帮助阅读后续章节。如果您已经熟悉它们，您可以跳过本章。</p><span id="more"></span><p>[TOC]</p><h2 id="2-1-流程架构"><a href="#2-1-流程架构" class="headerlink" title="2.1 流程架构"></a>2.1 流程架构</h2><p>PostgreSQL 是一个多进程架构的客户端/服务器型关系数据库管理系统，运行在单台主机上。</p><p>多个进程协同管理一个数据库集群的集合通常被称为<em>“PostgreSQL 服务器”</em>，它包含以下类型的进程：</p><ul><li>一个<strong>Postgres的服务器进程</strong>是与数据库集群管理的所有进程的父进程。</li><li>每个<strong>后端进程</strong>处理由连接的客户端发出的所有查询和语句。</li><li>各种<strong>后台进程</strong>为数据库管理执行每个特性的进程（例如，VACUUM 和CHECKPOINT 进程）。</li><li>在<strong>复制相关进程中</strong>，它们执行流式复制。详细信息在<a href="http://www.interdb.jp/pg/pgsql11.html">第 11 章</a>中描述。</li><li>在9.3 版本支持的<strong>后台工作进程中</strong>，它可以执行用户实现的任何处理。此处不详述，请参考<a href="http://www.postgresql.org/docs/current/static/bgworker.html">官方文档</a>。</li></ul><p>在以下小节中，将描述前三种类型的过程的详细信息。</p><p><img src="/medias/image/fig-2-01.png" alt="图 2.1 PostgreSQL 进程架构的一个例子"></p><hr><p>该图展示了一个 PostgreSQL 服务器的进程：一个 postgres 服务器进程、两个后端进程、七个后台进程和两个客户端进程。还说明了数据库集群、共享内存和两个客户端进程。</p><h3 id="2-1-1-Postgres-服务器进程"><a href="#2-1-1-Postgres-服务器进程" class="headerlink" title="2.1.1 Postgres 服务器进程"></a>2.1.1 Postgres 服务器进程</h3><p>如上所述，postgres 服务器进程是 PostgreSQL 服务器中所有进程的父进程。在早期版本中，它被称为“postmaster”。</p><p>通过使用<em>start</em>选项执行<a href="http://www.postgresql.org/docs/current/static/app-pg-ctl.html">pg_ctl</a>实用程序，postgres 服务器进程将启动。然后，它在内存中分配一个共享内存区域，启动各种后台进程，必要时启动复制关联进程和后台工作进程，并等待来自客户端的连接请求。每当收到来自客户端的连接请求时，它就会启动一个后端进程。（然后，启动的后端进程处理连接的客户端发出的所有查询）</p><p>一个postgres服务器进程监听一个网络端口，默认端口是5432。虽然同一台主机上可以运行多个PostgreSQL服务器，但是每个服务器之间应该设置监听不同的端口号，例如5432、5433 ， 等等。</p><h3 id="2-1-2-后端流程"><a href="#2-1-2-后端流程" class="headerlink" title="2.1.2 后端流程"></a>2.1.2 后端流程</h3><p>后端进程，也称为<em>postgres</em>，由 postgres 服务器进程启动并处理由一个连接的客户端发出的所有查询。它通过单个 TCP 连接与客户端通信，并在客户端断开连接时终止。</p><p>由于只允许操作一个数据库，因此在连接到 PostgreSQL 服务器时必须明确指定要使用的数据库。</p><p>PostgreSQL 允许多个客户端同时连接；配置参数<a href="http://www.postgresql.org/docs/current/static/runtime-config-connection.html#GUC-MAX-CONNECTIONS">max_connections</a>控制客户端的最大数量（默认为 100）。</p><p>如果WEB应用等很多客户端频繁重复与PostgreSQL服务器的连接和断开连接，会增加建立连接和创建后端进程的成本，因为PostgreSQL没有实现本地连接池功能，这种情况对数据库服务器的性能有负面影响。为了处理这种情况，通常使用池中间件（<a href="https://pgbouncer.github.io/">pgbouncer</a> 或<a href="http://www.pgpool.net/mediawiki/index.php/Main_Page">pgpool-II</a>）。</p><h3 id="2-1-3-后台进程"><a href="#2-1-3-后台进程" class="headerlink" title="2.1.3 后台进程"></a>2.1.3 后台进程</h3><p>表 2.1 显示了后台进程列表。与 postgres 服务器和后端进程相比，无法简单地解释每个功能，因为这些功能取决于各个特定的功能和 PostgreSQL 内部结构。因此，本章仅作介绍，详细信息将在后面的章节中描述。</p><table><thead><tr><th align="left">过程</th><th align="left">描述</th><th align="left">参考</th></tr></thead><tbody><tr><td align="left">background writer</td><td align="left">在这个过程中，共享缓冲池上的脏页被逐渐定期写入持久性存储（例如，HDD、SSD）（在 9.1 或更早版本中，它还负责检查点过程）</td><td align="left"><a href="http://www.interdb.jp/pg/pgsql08.html#_8.6.">第 8.6 节</a></td></tr><tr><td align="left">checkpointer</td><td align="left">在 9.2 或更高版本的此过程中，执行检查点过程</td><td align="left"><a href="http://www.interdb.jp/pg/pgsql08.html#_8.6.">第 8.6</a><a href="http://www.interdb.jp/pg/pgsql09.html#_9.7.">节</a>、<a href="http://www.interdb.jp/pg/pgsql09.html#_9.7.">第 9.7 节</a></td></tr><tr><td align="left">autovacuum launcher</td><td align="left">定期调用 autovacuum-worker 进程进行清理（更准确地说，它请求为 postgres 服务器创建 autovacuum 工作器）</td><td align="left"><a href="http://www.interdb.jp/pg/pgsql06.html#_6.5.">第 6.5 节</a></td></tr><tr><td align="left">WAL writer</td><td align="left">此过程会定期将 WAL 缓冲区上的 WAL 数据写入并刷新到持久存储</td><td align="left"><a href="http://www.interdb.jp/pg/pgsql09.html#_9.9.">第 9.9 节</a></td></tr><tr><td align="left">statistics collector</td><td align="left">在这个过程中，会收集pg_stat_activity、pg_stat_database等统计信息</td><td align="left"><a href="/2022/stats-collector-jin-cheng/">stats collector进程</a></td></tr><tr><td align="left">logging collector (logger)</td><td align="left">此进程将服务器消息写入日志文件</td><td align="left"></td></tr><tr><td align="left">archiver</td><td align="left">此过程执行归档日志记录</td><td align="left"><a href="http://www.interdb.jp/pg/pgsql09.html#_9.10.">第 9.10 节</a></td></tr></tbody></table><p>在以下示例中，一个 postgres 服务器进程（pid 为 9687）、两个后端进程（pid 为 9697 和 9717）以及表 2.1 中列出的几个后台进程正在运行，另请参见图 2.1。</p><pre class="line-numbers language-bash"><code class="language-bash">postgres<span class="token operator">></span> pstree -p 9687-+<span class="token operator">=</span> 00001 root /sbin/launchd \-+- 09687 postgres /usr/local/pgsql/bin/postgres -D /usr/local/pgsql/data   <span class="token operator">|</span>--<span class="token operator">=</span> 09688 postgres postgres: logger process        <span class="token operator">|</span>--<span class="token operator">=</span> 09690 postgres postgres: checkpointer process        <span class="token operator">|</span>--<span class="token operator">=</span> 09691 postgres postgres: writer process        <span class="token operator">|</span>--<span class="token operator">=</span> 09692 postgres postgres: wal writer process        <span class="token operator">|</span>--<span class="token operator">=</span> 09693 postgres postgres: autovacuum launcher process        <span class="token operator">|</span>--<span class="token operator">=</span> 09694 postgres postgres: archiver process        <span class="token operator">|</span>--<span class="token operator">=</span> 09695 postgres postgres: stats collector process        <span class="token operator">|</span>--<span class="token operator">=</span> 09697 postgres postgres: postgres sampledb 192.168.1.100<span class="token punctuation">(</span>54924<span class="token punctuation">)</span> idle     \--<span class="token operator">=</span> 09717 postgres postgres: postgres sampledb 192.168.1.100<span class="token punctuation">(</span>54964<span class="token punctuation">)</span> idle <span class="token keyword">in</span> transaction  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="2-2-内存架构"><a href="#2-2-内存架构" class="headerlink" title="2.2 内存架构"></a>2.2 内存架构</h2><p>PostgreSQL 中的内存架构可以分为两大类：</p><ul><li>本地内存区域 - 由每个后端进程分配供自己使用。</li><li>共享内存区域 - 由 PostgreSQL 服务器的所有进程使用。</li></ul><p>在以下小节中，将简要介绍这些内容。</p><p><img src="/medias/image/fig-2-02.png" alt="图 2.2 PostgreSQL 中的内存架构 "></p><h3 id="2-2-1-本地存储区"><a href="#2-2-1-本地存储区" class="headerlink" title="2.2.1 本地存储区"></a>2.2.1 本地存储区</h3><p>每个后端进程分配一个本地内存区域用于查询处理；每个区域被分成几个子区域——它们的大小是固定的或可变的。表 2.2 列出了主要的子领域。详细信息将在以下章节中描述。</p><table><thead><tr><th align="left">分区</th><th align="left">描述</th><th align="left">参考</th></tr></thead><tbody><tr><td align="left">work_mem</td><td align="left">Executor 使用此区域通过 ORDER BY 和 DISTINCT 操作对元组进行排序，并通过合并连接和哈希连接操作连接表。</td><td align="left"><a href="http://www.interdb.jp/pg/pgsql03.html">第3章</a></td></tr><tr><td align="left">maintenance_work_mem</td><td align="left">某些类型的维护操作（例如，VACUUM、REINDEX）使用此区域。</td><td align="left"><a href="http://www.interdb.jp/pg/pgsql06.html#_6.1.">第 6.1 节</a></td></tr><tr><td align="left">temp_buffers</td><td align="left">Executor 使用这个区域来存储临时表。</td><td align="left"></td></tr></tbody></table><h3 id="2-2-2-共享内存区"><a href="#2-2-2-共享内存区" class="headerlink" title="2.2.2 共享内存区"></a>2.2.2 共享内存区</h3><p>共享内存区域由 PostgreSQL 服务器在启动时分配。该区域也分为几个固定大小的子区域。表 2.3 列出了主要的子领域。详细信息将在以下章节中描述。</p><table><thead><tr><th align="left">分区</th><th align="left">描述</th><th align="left">参考</th></tr></thead><tbody><tr><td align="left">shared buffer</td><td align="left">PostgreSQL 将表和索引中的页面从持久存储加载到这里，并直接对其进行操作。</td><td align="left"><a href="http://www.interdb.jp/pg/pgsql08.html">第8章</a></td></tr><tr><td align="left">WAL buffer</td><td align="left">为确保服务器故障不会丢失数据，PostgreSQL 支持 WAL 机制。WAL 数据（也称为 XLOG 记录）是 PostgreSQL 中的事务日志；WAL缓冲区是WAL数据写入持久化存储之前的缓冲区。</td><td align="left"><a href="http://www.interdb.jp/pg/pgsql09.html">第9章</a></td></tr><tr><td align="left">commit log</td><td align="left">提交日志（CLOG）为并发控制（CC）机制保存所有事务的状态（例如，in_progress、committed、aborted）。</td><td align="left"><a href="http://www.interdb.jp/pg/pgsql05.html#_5.4.">第 5.4 节</a></td></tr></tbody></table><p>除了它们之外，PostgreSQL 还分配了几个区域，如下所示：</p><ul><li>用于各种访问控制机制的子区域。（例如，信号量、轻量级锁、共享和排他锁等）</li><li>各种后台进程的子区域，例如 checkpointer 和 autovacuum。</li><li>事务处理的子区域，例如保存点和两阶段提交。</li></ul>]]></content>
      
      
      <categories>
          
          <category> postgresql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> postgresql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>3 查询处理</title>
      <link href="/2021/3.cha-xun-chu-li/"/>
      <url>/2021/3.cha-xun-chu-li/</url>
      
        <content type="html"><![CDATA[<p>如官方文档所述，PostgreSQL支持2011年SQL标准所需的大量特性。查询处理是PostgreSQL中最复杂的子系统，它能高效地处理所支持的SQL语句。本章概述了这种查询处理，它特别关注查询优化。</p><span id="more"></span><p>本章由以下三部分组成:</p><ol><li>第3.1节<br>本节概述PostgreSQL中的查询处理。</li><li>第3.2 - 3.4节<br>这一部分解释了获得最优单表查询计划的步骤。在3.2节和3.3节中，我们将分别解释估算成本和创建规划树的过程，3.4节将简要描述执行器进程的操作。</li><li>第3.5 - 3.6节<br>这一部分说明了获取多表查询最优方案的过程。在3.5节中，我们会介绍三种关联方法:嵌套循环、合并和散列关联，3.6节将解释创建多表查询规划树的过程。</li></ol><p>PostgreSQL支持3个技术上有趣且实用的特性，即FDW (Foreign Data wrapper)、并行查询和JIT编译(从版本11开始支持)。前两个将在第4章中介绍。JIT编译超出了本文的范围;具体请参见官方文档。</p><p>[TOC]</p><h2 id="3-1-概述"><a href="#3-1-概述" class="headerlink" title="3.1 概述"></a>3.1 概述</h2><p>在PostgreSQL中，虽然在9.6版本中实现的并行查询使用了多个后台worker进程，但基本上是一个后端进程处理连接的客户端发出的所有查询。该后端由5个子系统组成，如下所示:</p><ol><li>解析器Parser<br>解析器从纯文本的SQL语句生成解析树。</li><li>分析器Analyser<br>分析器对解析树进行语义分析并生成查询树。</li><li>重写Rewriter<br>如果存在这样的规则，重写器将使用存储在规则系统中的规则转换查询树。</li><li>规划器Planner<br>规划器生成能够从查询树中最有效地执行的规划树。</li><li>执行器Executor<br>执行器按照计划树创建的顺序访问表和索引来执行查询。</li></ol><p><img src="/medias/image/fig-3-01.png" alt="图 3.1 查询处理"></p><p>本节将概述这些子系统。由于规划器和执行器非常复杂，下面将详细解释这些函数。</p><p>PostgreSQL的查询处理在官方文档中有详细描述。</p><h3 id="3-1-1-解析器"><a href="#3-1-1-解析器" class="headerlink" title="3.1.1 解析器"></a>3.1.1 解析器</h3><p>解析器生成一个解析树，后续子系统可以从纯文本的SQL语句中读取该解析树。下面给出了一个具体的例子，但没有详细描述。</p><p>让我们考虑下面的查询。</p><pre class="line-numbers language-bash"><code class="language-bash">testdb<span class="token operator">=</span><span class="token comment" spellcheck="true"># SELECT id, data FROM tbl_a WHERE id &lt; 300 ORDER BY data;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>解析树是一棵树，其根节点是在parsenodes.h中定义的SelectStmt结构，图3.2(b)说明了图3.2(a)所示查询的解析树。</p><p><img src="/medias/image/fig-3-02.png" alt="图 3.2 解析树的示例"></p><p>选择查询的元素和解析树的对应元素编号相同。例如，(1)是第一个目标列表中的一个元素，它是表的’id’列，(4)是WHERE子句，以此类推。</p><p>由于解析器在生成解析树时只检查输入的语法，所以它只在查询中有语法错误时返回错误。解析器不检查输入查询的语义。例如，即使查询包含一个不存在的表名，解析器也不会返回错误。语义检查由分析器完成。</p><h3 id="3-1-2-分析器"><a href="#3-1-2-分析器" class="headerlink" title="3.1.2 分析器"></a>3.1.2 分析器</h3><p>analyzer对解析器生成的解析树进行语义分析，并生成查询树。</p><p>查询树的根是定义在parsenodes.h中的查询结构。该结构包含相应查询的元数据，例如该命令的类型(SELECT、INSERT或其他)和几个叶子，每个叶结点构成一个链表或树，保存着各个子句的数据。</p><p>图3-3展示了前一小节中图3.2(a)所示查询的查询树。</p><p><img src="/medias/image/fig-3-03.png" alt="图 3.3 查询树的示例"></p><p>上面的查询树简要描述如下。</p><p>targetlist是此查询结果的列的列表。在这个例子中，这个列表由两列组成:<code>id</code>和<code>data</code>。如果输入的查询树使用<code>∗</code>(星号)，分析器将显式地将其替换为所有列。范围表是此查询中使用的关系列表。在这个例子中，这个表保存了表<code>tbl_a</code>的信息，例如这个表的oid和这个表的名称。join树存储FROM子句和WHERE子句。sort子句是SortGroupClause的一个列表。查询树的详细信息在官方文档中描述。</p><h3 id="3-1-3-重写器"><a href="#3-1-3-重写器" class="headerlink" title="3.1.3 重写器"></a>3.1.3 重写器</h3><p>重写器是实现规则系统的系统，必要时根据pg_rules系统目录中存储的规则对查询树进行转换。规则系统本身是一个有趣的系统，但为避免本章太长，这里省略了对规则系统和重写器的描述。</p><p><strong>视图</strong><br>PostgreSQL中的视图是使用规则系统实现的。当通过CREATE view命令定义视图时，相应的规则将自动生成并存储在目录中。</p><p>假定已经定义了以下视图，对应的规则存储在pg_rules系统目录中。</p><pre class="line-numbers language-bash"><code class="language-bash">sampledb<span class="token operator">=</span><span class="token comment" spellcheck="true"># CREATE VIEW employees_list </span>sampledb-<span class="token comment" spellcheck="true">#      AS SELECT e.id, e.name, d.name AS department </span>sampledb-<span class="token comment" spellcheck="true">#            FROM employees AS e, departments AS d WHERE e.department_id = d.id;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>当发出包含如下所示视图的查询时，解析器会创建如图3.4(a)所示的解析树。</p><pre class="line-numbers language-bash"><code class="language-bash">sampledb<span class="token operator">=</span><span class="token comment" spellcheck="true"># SELECT * FROM employees_list;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>在此阶段，重写器将范围表节点处理为子查询的解析树，这是存储在pg_rules中的相应视图。</p><p><img src="/medias/image/fig-3-04.png" alt="图 3.4重写阶段的一个例子"></p><blockquote><p>由于PostgreSQL使用这种机制实现视图，因此直到9.2版本也不能更新视图。从9.3版本支持更新，尽管如此，更新视图有许多限制。这些细节在官方文档中有描述。</p></blockquote><h3 id="3-1-4-计划器和执行器"><a href="#3-1-4-计划器和执行器" class="headerlink" title="3.1.4 计划器和执行器"></a>3.1.4 计划器和执行器</h3><p>规划器从重写器接收一个查询树，并生成一个执行器可以最有效地处理的(查询)规划树。</p><p>PostgreSQL中的规划器是基于纯代价优化的，它不支持基于规则的优化和提示。规划器是RDBMS中最复杂的子系统，因此本章后续章节将对规划器进行概述。</p><blockquote><p><strong>pg_hint_plan</strong><br>PostgreSQL不支持SQL中的规划器提示，而且永远也不会支持。如果您想在查询中使用提示，则值得考虑pg_hint_plan的扩展。详情请参阅官方网站。</p></blockquote><p>与其他RDBMS一样，PostgreSQL中的EXPLAIN命令显示规划树本身。一个具体的例子如下所示。</p><pre class="line-numbers language-bash"><code class="language-bash">testdb<span class="token operator">=</span><span class="token comment" spellcheck="true"># EXPLAIN SELECT * FROM tbl_a WHERE id &lt; 300 ORDER BY data;</span>                          QUERY PLAN                           --------------------------------------------------------------- Sort  <span class="token punctuation">(</span>cost<span class="token operator">=</span>182.34<span class="token punctuation">..</span>183.09 rows<span class="token operator">=</span>300 width<span class="token operator">=</span>8<span class="token punctuation">)</span>   Sort Key: data   -<span class="token operator">></span>  Seq Scan on tbl_a  <span class="token punctuation">(</span>cost<span class="token operator">=</span>0.00<span class="token punctuation">..</span>170.00 rows<span class="token operator">=</span>300 width<span class="token operator">=</span>8<span class="token punctuation">)</span>         Filter: <span class="token punctuation">(</span>id <span class="token operator">&lt;</span> 300<span class="token punctuation">)</span><span class="token punctuation">(</span>4 rows<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在图3.5所示的平面图树显示了这个结果。</p><p><img src="/medias/image/fig-3-05.png" alt="图 3.5 一个简单的规划树以及规划树和EXPLAIN命令结果之间的关系"></p><p>规划树由称为规划节点的元素组成，它连接到PlannedStmt结构的plantree链表。这些元素定义在plannodes.h中。详情将在3.3.3节(和3.5.4.2节)中解释。</p><p>每个计划节点都有执行器需要处理的信息，并且在单表查询的情况下，执行者从计划树的末尾一直处理到根。</p><p>例如，图3.5所示的规划树是一个排序节点和顺序扫描节点的列表，因此执行器会顺序扫描表 tbl_a，然后对得到的结果排序。</p><p>执行器通过<a href="https://www.interdb.jp/pg/pgsql08.html">第 8 章</a>描述的缓冲管理器来读写数据库集群中的表和索引。在处理查询时，执行器会使用一些预先分配的内存区，如temp_buffers和work_mem，并在必要时创建临时文件。</p><p>此外，在访问元组时，PostgreSQL使用并发控制机制来维护运行事务的一致性和隔离性。并发控制机制将在<a href="https://www.interdb.jp/pg/pgsql05.html">第 5 章</a>中描述。</p><p><img src="/medias/image/fig-3-06.png" alt="图 3.6执行器、缓冲区管理器和临时文件之间的关系"></p><h2 id="3-2-单表查询的代价估算"><a href="#3-2-单表查询的代价估算" class="headerlink" title="3.2 单表查询的代价估算"></a>3.2 单表查询的代价估算</h2><p>PostgreSQL的查询优化是基于成本的。成本是无量纲的值，这些不是绝对的性能指标，而是比较操作的相对性能的指标。成本由<a href="https://github.com/postgres/postgres/blob/master/src/backend/optimizer/path/costsize.c">costsize.c</a>中定义的函数估计。执行器执行的所有操作都有相应的代价函数。例如，顺序扫描和索引扫描的开销分别由cost_seqscan()和cost_index()估计。</p><p>在PostgreSQL中，有三种成本：启动成本、运行成本和总成本。总成本是启动和运行成本的总和。因此只有启动和运行成本是独立估计的。</p><ol><li>启动成本是在获取第一个元组之前花费的成本。例如，索引扫描节点的启动开销就是读取索引页以访问目标表中的第一个元组的开销。</li><li>运行开销是获取所有元组的开销。</li><li>总成本是启动成本和运行成本的总和。</li></ol><p>EXPLAIN命令显示每个操作的启动成本和总成本。最简单的例子如下所示:</p><pre class="line-numbers language-bash"><code class="language-bash">testdb<span class="token operator">=</span><span class="token comment" spellcheck="true"># EXPLAIN SELECT * FROM tbl;</span>                       QUERY PLAN                        --------------------------------------------------------- Seq Scan on tbl  <span class="token punctuation">(</span>cost<span class="token operator">=</span>0.00<span class="token punctuation">..</span>145.00 rows<span class="token operator">=</span>10000 width<span class="token operator">=</span>8<span class="token punctuation">)</span><span class="token punctuation">(</span>1 row<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在第4行，该命令显示顺序扫描的信息。在成本部分，有两个值，0.00和145.00。在本例中，启动和总成本分别为0.00和145.00。在本节中，我们将详细探讨如何估计顺序扫描、索引扫描和排序操作。</p><p>在下面的解释中，我们使用一个特定的表和一个索引，如下所示：</p><pre class="line-numbers language-bash"><code class="language-bash">testdb<span class="token operator">=</span><span class="token comment" spellcheck="true"># CREATE TABLE tbl (id int PRIMARY KEY, data int);</span>testdb<span class="token operator">=</span><span class="token comment" spellcheck="true"># CREATE INDEX tbl_data_idx ON tbl (data);</span>testdb<span class="token operator">=</span><span class="token comment" spellcheck="true"># INSERT INTO tbl SELECT generate_series(1,10000),generate_series(1,10000);</span>testdb<span class="token operator">=</span><span class="token comment" spellcheck="true"># ANALYZE;</span>testdb<span class="token operator">=</span><span class="token comment" spellcheck="true"># \d tbl</span>      Table <span class="token string">"public.tbl"</span> Column <span class="token operator">|</span>  Type   <span class="token operator">|</span> Modifiers --------+---------+----------- <span class="token function">id</span>     <span class="token operator">|</span> integer <span class="token operator">|</span> not null data   <span class="token operator">|</span> integer <span class="token operator">|</span> Indexes:    <span class="token string">"tbl_pkey"</span> PRIMARY KEY, btree <span class="token punctuation">(</span>id<span class="token punctuation">)</span>    <span class="token string">"tbl_data_idx"</span> btree <span class="token punctuation">(</span>data<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="3-2-1-顺序扫描"><a href="#3-2-1-顺序扫描" class="headerlink" title="3.2.1 顺序扫描"></a>3.2.1 顺序扫描</h3><p>顺序扫描的开销由cost_seqscan()函数估算。在本节中，我们将探讨如何估计以下查询的顺序扫描开销。</p><pre class="line-numbers language-bash"><code class="language-bash">testdb<span class="token operator">=</span><span class="token comment" spellcheck="true"># SELECT * FROM tbl WHERE id &lt; 8000;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>在顺序扫描中，启动成本等于0，运行成本由以下等式定义：</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token string">'run cost'</span><span class="token operator">=</span><span class="token string">'cpu run cost'</span>+<span class="token string">'disk run cost'</span>            <span class="token operator">=</span><span class="token punctuation">(</span>cpu_tuple_cost+cpu_operator_cost<span class="token punctuation">)</span>×Ntuple+seq_page_cost×Npage<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>其中seq_page_cost、cpu_tuple_cost和cpu_operator_cost在postgresql.conf文件中设置，默认值分别为1.0、0.01和0.0025，<br> Ntuple and Npage 分别是这个表中所有元组的数目和所有页的数目，可以使用以下查询来显示这些编号：</p><pre class="line-numbers language-bash"><code class="language-bash">testdb<span class="token operator">=</span><span class="token comment" spellcheck="true"># SELECT relpages, reltuples FROM pg_class WHERE relname = 'tbl';</span> relpages <span class="token operator">|</span> reltuples ----------+-----------       45 <span class="token operator">|</span>     10000<span class="token punctuation">(</span>1 row<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-bash"><code class="language-bash">Ntuple<span class="token operator">=</span>10000,Npage<span class="token operator">=</span>10000,<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>因此</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token string">'run cost'</span><span class="token operator">=</span><span class="token punctuation">(</span>0.01+0.0025<span class="token punctuation">)</span>×10000+1.0×45<span class="token operator">=</span>170.0<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>最终</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token string">'total cost'</span><span class="token operator">=</span>0.0+170.0<span class="token operator">=</span>170.0<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>为了确认，上面查询的EXPLAIN命令的结果如下所示：</p><pre class="line-numbers language-bash"><code class="language-bash">testdb<span class="token operator">=</span><span class="token comment" spellcheck="true"># EXPLAIN SELECT * FROM tbl WHERE id &lt; 8000;</span>                       QUERY PLAN                       -------------------------------------------------------- Seq Scan on tbl  <span class="token punctuation">(</span>cost<span class="token operator">=</span>0.00<span class="token punctuation">..</span>170.00 rows<span class="token operator">=</span>8000 width<span class="token operator">=</span>8<span class="token punctuation">)</span>   Filter: <span class="token punctuation">(</span>id <span class="token operator">&lt;</span> 8000<span class="token punctuation">)</span><span class="token punctuation">(</span>2 rows<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在第4行中，我们可以发现启动成本和总成本分别为0.00和170.00，估计通过扫描所有行将选择8000行(元组)。</p><p>在第5行中，显示了顺序扫描的过滤器<code>filter:(id &lt; 8000)</code>。更准确地说，它被称为表级过滤器谓词(table level filter predicate)。注意，这种类型的过滤器在读取表中的所有元组时使用，它不会缩小扫描表页的范围。</p><p>从运行成本估算中可以理解，PostgreSQL假设所有页面都将从存储中读取，也就是说，PostgreSQL不考虑扫描的页面是否在共享缓冲区中。</p><h2 id="3-3-创建单表查询的规划树"><a href="#3-3-创建单表查询的规划树" class="headerlink" title="3.3 创建单表查询的规划树"></a>3.3 创建单表查询的规划树</h2><p>由于规划器的处理非常复杂，本节将描述最简单的过程，即如何创建单表查询的规划树。3.6节将介绍更复杂的处理，即如何创建多表查询的规划树。</p><p>PostgreSQL中的规划器执行如下三个步骤：</p><ol><li><p>进行预处理。</p></li><li><p>通过估计所有可能的访问路径的开销来获得最廉价的访问路径。</p></li><li><p>从最廉价的路径创建规划树。</p></li></ol><p>访问路径是用于估算成本的处理单元，例如，顺序扫描、索引扫描、排序和各种连接操作都有对应的路径。访问路径仅在规划器中用于创建规划树。访问路径最基本的数据结构是在relationship.h中定义的路径结构，它对应于顺序扫描。所有其他访问路径都基于它。细节将在以下解释中描述。</p><p>为了处理上述步骤，规划器在内部创建一个PlannerInfo结构，并保存查询树、查询中包含的关系信息、访问路径等。在本节中，我们将通过具体的例子描述如何从查询树创建规划树。</p><h3 id="3-3-1-预处理"><a href="#3-3-1-预处理" class="headerlink" title="3.3.1 预处理"></a>3.3.1 预处理</h3><p>在创建规划树之前，规划器会对存储在PlannerInfo结构中的查询树进行一些预处理。</p><p>虽然预处理涉及很多步骤，但本节只讨论单表查询的主要预处理。其他预处理操作将在3.6节介绍。</p><ol><li><p>简化目标列表、限制子句等。<br>例如，子句c中定义的eval_const_expressions()函数将<code>2 + 2</code>重写为<code>4</code>。</p></li><li><p>布尔表达式。<br>例如，<code>NOT (NOT a)</code>被重写为<code>a</code>。</p></li><li><p>扁平化AND/OR表达。<br>AND和OR在SQL标准中是二元运算符，然而，在PostgreSQL内部，它们是n元运算符，规划器总是假设所有嵌套的AND和OR表达式都是扁平化的。给一个具体的例子，考虑一个布尔表达式<code>(id = 1) OR (id = 2) OR (id = 3)</code>。图3 - 9(a)展示了使用二元运算符时查询树的一部分。运算符使用三进制运算符将树扁平化。参见图3.9(b)。</p></li></ol><p><img src="/medias/image/fig-3-09.png" alt="图 3.9 一个扁平化和/或表达式的例子"></p><h3 id="3-3-2-获取最廉价的访问路径"><a href="#3-3-2-获取最廉价的访问路径" class="headerlink" title="3.3.2 获取最廉价的访问路径"></a>3.3.2 获取最廉价的访问路径</h3><p>为了得到最廉价的访问路径，规划器估计所有可能的访问路径的开销，并选择最廉价的路径。更具体地说，规划器执行以下操作:</p><ol><li><p>创建一个RelOptInfo结构来存储访问路径和相应的开销。<br>RelOptInfo结构由make_one_rel()函数创建，保存在PlannerInfo结构的simple_rel_array中。参见图3.10。在初始状态下，RelOptInfo保存了baserestrictinfo和indexlist(如果存在相关的索引);baserestrictinfo存储了查询的WHERE子句，indexlist存储了目标表的相关索引。</p></li><li><p>估计所有可能的访问路径的开销，并将访问路径添加到RelOptInfo结构中。处理的细节如下:</p><p>创建路径，估计顺序扫描的开销，并将估计的开销写入路径。然后，该路径被添加到RelOptInfo结构的路径列表中。</p><p>如果存在与目标表相关的索引，则创建索引访问路径，估计所有索引扫描成本，并将估计的成本写入路径。然后，将索引路径添加到路径列表中。</p><p>如果位图扫描可以完成，则创建位图扫描路径，估计所有位图扫描开销，并将估计的开销写入路径中。然后，位图扫描路径被添加到路径列表中。</p></li><li><p>获取RelOptInfo结构的路径列表中最便宜的访问路径。</p></li><li><p>如有必要，预估限制、订购和登记fdd成本。</p></li></ol><h4 id="3-3-2-1-示例1"><a href="#3-3-2-1-示例1" class="headerlink" title="3.3.2.1 示例1"></a>3.3.2.1 示例1</h4><p>首先，我们探索一个简单的无索引单表查询，这个查询包含WHERE和ORDER BY子句。</p><pre class="line-numbers language-bash"><code class="language-bash">testdb<span class="token operator">=</span><span class="token comment" spellcheck="true"># \d tbl_1</span>     Table <span class="token string">"public.tbl_1"</span> Column <span class="token operator">|</span>  Type   <span class="token operator">|</span> Modifiers --------+---------+----------- <span class="token function">id</span>     <span class="token operator">|</span> integer <span class="token operator">|</span>  data   <span class="token operator">|</span> integer <span class="token operator">|</span> testdb<span class="token operator">=</span><span class="token comment" spellcheck="true"># SELECT * FROM tbl_1 WHERE id &lt; 300 ORDER BY data;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>图 3-10和图 3-11描述了规划器在这个例子中的执行情况。</p><p><img src="/medias/image/fig-3-10.png" alt="图 3.10如何获取示例1中的最便宜路径"></p><p>(1) 创建一个RelOptInfo结构，并将其存储在PlannerInfo的simple_rel_array中。</p><p>(2) 在RelOptInfo的baserestrictinfo中添加WHERE子句。<br>在initsplan.c中定义的distribute_restrictinfo_to_rels()函数将WHERE子句’ id &lt; 300 ‘添加到baserestrictinfo。此外，RelOptInfo的indexlist是NULL，因为目标表没有相关的索引。</p><p>(3) 通过planner.c中定义的standard_qp_callback()函数，将用于排序的pathkey添加到PlannerInfo的sort_pathkeys中。<br>Pathkey是一个表示路径排序顺序的数据结构。在这个例子中，“data”列作为pathkey被添加到sort_pathkeys中，因为这个查询包含一个ORDER BY子句，它的列是’ data ‘。</p><p>(4) 创建一个路径结构，使用cost_seqscan函数估计顺序扫描的开销，并将估计的开销写入路径。然后，通过pathnode.c中定义的add_path()函数将路径添加到RelOptInfo中。如前所述，Path结构包含启动成本和总成本，由cost_seqscan函数估算，依此类推。</p><p>在这个例子中，规划器只估计顺序扫描的开销，因为目标表没有索引;因此，自动确定最便宜的访问路径。</p><p><img src="/medias/image/fig-3-11.png" alt="图 3.11如何得到示例1中的最便宜路径(从图3-10继续)"></p><p>(5) 创建一个新的RelOptInfo结构来按过程处理订单。注意，新的RelOptInfo没有baserestrictinfo，即WHERE子句的信息。</p><p>(6) 创建一个排序路径并将其添加到新的RelOptInfo，然后，将顺序扫描路径链接到排序路径的子路径。SortPath结构由两个路径结构组成:路径和子路径;路径存储了排序操作本身的信息，子路径存储了价格最低的路径。请注意，顺序扫描路径的<code>parent</code>项保存了到旧的RelOptInfo的链接，旧的RelOptInfo将WHERE子句存储在其baserestrictinfo中。因此，在下一阶段，即创建一个规划树，规划器可以创建一个包含WHERE子句的顺序扫描节点作为“过滤器”，即使新的RelOptInfo没有baserestrictinfo。</p><p>根据得到的最便宜访问路径，生成规划树。详情见3.3.3节。</p><h4 id="3-3-2-2-示例2"><a href="#3-3-2-2-示例2" class="headerlink" title="3.3.2.2 示例2"></a>3.3.2.2 示例2</h4><p>接下来，我们探索另一个具有两个索引的单表查询;这个查询包含一个WHERE子句。</p><pre class="line-numbers language-bash"><code class="language-bash">testdb<span class="token operator">=</span><span class="token comment" spellcheck="true"># \d tbl_2</span>     Table <span class="token string">"public.tbl_2"</span> Column <span class="token operator">|</span>  Type   <span class="token operator">|</span> Modifiers --------+---------+----------- <span class="token function">id</span>     <span class="token operator">|</span> integer <span class="token operator">|</span> not null data   <span class="token operator">|</span> integer <span class="token operator">|</span> Indexes:    <span class="token string">"tbl_2_pkey"</span> PRIMARY KEY, btree <span class="token punctuation">(</span>id<span class="token punctuation">)</span>    <span class="token string">"tbl_2_data_idx"</span> btree <span class="token punctuation">(</span>data<span class="token punctuation">)</span>testdb<span class="token operator">=</span><span class="token comment" spellcheck="true"># SELECT * FROM tbl_2 WHERE id &lt; 240;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>图3.12到图3.14描述了规划器在这个例子中的执行情况。</p><p>(1) 创建一个RelOptInfo结构。<br>(2) 在baserestrictinfo中添加WHERE子句，并将目标表的索引添加到indexlist中。<br>在这个例子中，在baserestrictinfo中添加了WHERE子句’ id &lt; 240 ‘，在RelOptInfo的索引列表中添加了两个索引tbl_2_pkey和tbl_2_data_idx。</p><p>(3) 创建一个路径，估计顺序扫描的开销，并将该路径添加到RelOptInfo的路径列表中。</p><p><img src="/medias/image/fig-3-12.png" alt="图 3.12 如何获取示例2中的最廉价的路径。"></p><p><img src="/medias/image/fig-3-13.png" alt="图 3.13如何得到示例2中的最便宜路径(从图3-12继续)。"></p><p>(4) 创建一个IndexPath，估计索引扫描的开销，并使用add_path()函数将IndexPath添加到RelOptInfo的路径列表中。在这个例子中，因为有两个索引，tbl_2_pkey和tbl_2_data_idx，所以这些索引是按顺序处理的。首先处理Tbl_2_pkey。为tbl_2_pkey创建一个IndexPath，并估计启动成本和总成本。在这个例子中，tbl_2_pkey是与列’ id ‘相关的索引，WHERE子句包含列’ id ‘;因此，WHERE子句存储在IndexPath的indexclause中。请注意，当添加访问路径到路径列表时，add_path()函数按总代价的排序顺序添加路径。在这个例子中，索引扫描的总开销小于顺序扫描的总开销;因此，该索引路径插入到顺序扫描路径之前。</p><p>(5) 创建另一个IndexPath，估计其他索引扫描的开销，并将索引路径添加到RelOptInfo的路径列表中。接下来，为tbl_2_data_idx创建一个IndexPath，估算成本并将其添加到路径列表中。在这个例子中，没有与tbl_2_data_idx索引相关的WHERE子句;因此，索引子句为NULL。</p><blockquote><p>注意，add_path()函数并不总是添加路径。由于该操作的复杂性，这里省略了细节。具体请参见add_path()函数的注释。</p></blockquote><p>(6) 创建一个新的RelOptInfo结构。<br>(7) 将最便宜的路径添加到新的RelOptInfo的路径列表中。<br>在这个例子中，最便宜的路径是使用索引tbl_2_pkey的索引路径;因此，它的路径被添加到新的RelOptInfo的路径列表中。</p><p><img src="/medias/image/fig-3-14.png" alt="图 3.14 如何得到示例2中的最便宜路径(从图3-13继续)。"></p>]]></content>
      
      
      <categories>
          
          <category> postgresql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> postgresql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>6 vacuum进程</title>
      <link href="/2021/6.vacuum-jin-cheng/"/>
      <url>/2021/6.vacuum-jin-cheng/</url>
      
        <content type="html"><![CDATA[<p>vacuum进程是一种便于PostgreSQL持久运行的维护过程。它的两个主要任务是删除死元组和冻结事务id。</p><span id="more"></span><p>为了去除死元组，清理过程有两种模式，即并发vacuum和vacuum full。并发VACUUM删除表文件每个页面的死元组，并且在此进程运行时，其他事务可以读取表。相反，vacuum full在整个文件中删除死元组并对活元组进行碎片整理，在vacuum full运行时，其他事务不能访问表。</p><blockquote><p>尽管vacuum进程对于PostgreSQL来说是必不可少的，但与其他功能相比，它的功能改进一直很缓慢。例如，在8.0版本之前，这个进程必须手动执行（使用psql实用程序或使用cron守护进程），它是在2005年实现autovacuum守护进程时实现的。</p><p>由于vacuum工作涉及扫描整个表，这是一个昂贵的过程。在8.4(2009)版本中，引入了可见性地图(VM)来提高删除死元组的效率。在9.6(2016)版本中，通过增强VM改进了冻结过程。</p></blockquote><p>第6.1节概述了VACUUM过程，后面的部分将描述以下内容。</p><ul><li>可见性地图(VM)</li><li>冻结处理</li><li>删除不必要的阻塞文件</li><li>autovacuum守护进程</li><li>vacuum full</li></ul><p>[TOC]</p><h2 id="6-1-vacuum概述"><a href="#6-1-vacuum概述" class="headerlink" title="6.1 vacuum概述"></a>6.1 vacuum概述</h2><p>vacuum进程对数据库中的指定表或所有表执行以下任务。</p><ol><li><p>删除死亡元组</p><p>为每个页面删除死元组并对活元组进行碎片整理。</p><p>删除指向死元组的索引元组。</p></li><li><p>冻结旧的txids</p><p>必要时冻结元组的旧txids。</p><p>更新冻结的txid相关的系统目录（pg_database和pg_class）。</p><p>如果可能的话，移除不必要的clog。</p></li><li><p>其他</p><p>更新已处理表的FSM和VM。</p><p>更新一些统计信息（pg_stat_all_tables等）。</p></li></ol><p>本文假定读者熟悉以下术语：死亡元组、冻结txid、FSM和clog。 如果你不熟悉，请参阅 第 5 章，VM将在6.2节中介绍。</p><p>下面的伪代码描述了vacuum进程。</p><p>伪代码：并行vacuum</p><pre class="line-numbers language-c"><code class="language-c"><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>  FOR each <span class="token function">table</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span>       Acquire ShareUpdateExclusiveLock lock <span class="token keyword">for</span> the target table          <span class="token comment" spellcheck="true">/* The first block */</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span>       Scan all pages to get all dead tuples<span class="token punctuation">,</span> and freeze old tuples <span class="token keyword">if</span> <span class="token function">necessary</span> <span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span>       Remove the index tuples that point to the respective dead tuples <span class="token keyword">if</span> exists          <span class="token comment" spellcheck="true">/* The second block */</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span>       FOR each page of the <span class="token function">table</span><span class="token punctuation">(</span><span class="token number">6</span><span class="token punctuation">)</span>            Remove the dead tuples<span class="token punctuation">,</span> and Reallocate the live tuples in the <span class="token function">page</span><span class="token punctuation">(</span><span class="token number">7</span><span class="token punctuation">)</span>            Update FSM and VM           END FOR          <span class="token comment" spellcheck="true">/* The third block */</span><span class="token punctuation">(</span><span class="token number">8</span><span class="token punctuation">)</span>       Clean up <span class="token function">indexes</span><span class="token punctuation">(</span><span class="token number">9</span><span class="token punctuation">)</span>       Truncate the last page <span class="token keyword">if</span> <span class="token function">possible</span><span class="token punctuation">(</span><span class="token number">10</span>       Update both the statistics and system catalogs of the target table           Release ShareUpdateExclusiveLock lock       END FOR        <span class="token comment" spellcheck="true">/* Post-processing */</span><span class="token punctuation">(</span><span class="token number">11</span><span class="token punctuation">)</span>  Update statistics and system <span class="token function">catalogs</span><span class="token punctuation">(</span><span class="token number">12</span><span class="token punctuation">)</span>  Remove both unnecessary files and pages of the clog <span class="token keyword">if</span> possible<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol><li><p>从指定的表中获取每个表。</p></li><li><p>获取表的 <code>ShareUpdateExclusiveLock</code> 锁，该锁允许从其他事务中读取数据。</p></li><li><p>扫描所有页面，获取所有死元组，必要时冻结旧元组。</p></li><li><p>如果存在，删除指向相应死亡元组的索引元组。</p></li><li><p>对表格的每一页执行步骤(6)和(7)。</p></li><li><p>删除死元组，重新分配页面中的活元组。</p></li><li><p>分别更新目标表的FSM和VM。</p></li><li><p>使用 <code>index_vacuum_cleanup()@indexam.c</code> 函数清理索引。</p></li><li><p>如果最后一页没有任何元组，则截断最后一页。</p></li><li><p>更新目标表中与vacuum处理相关的统计数据和系统目录。</p></li><li><p>更新与vacuum处理有关的统计数据和系统目录。</p></li><li><p>如果可能，删除不必要的文件和clog页。</p></li></ol><p>这个伪代码有两个部分：每个表的循环和后处理。内环可以分为三个块，每个块都有独立的任务。</p><p>下面概述了这三个块和后处理。</p><blockquote><p><strong>并行的选项</strong></p><p>VACUUM命令从版本13开始就支持 <code>PARALLEL</code> 选项，如果设置了该选项并且创建了多个索引，则它将并行处理清空索引和清理索引阶段。注意，该特性仅在VACUUM命令中有效，autovacuum不支持它。</p></blockquote><h3 id="6-1-1-第一块"><a href="#6-1-1-第一块" class="headerlink" title="6.1.1 第一块"></a>6.1.1 第一块</h3><p>该块执行冻结处理并删除指向死元组的索引元组。</p><p>首先，PostgreSQL扫描一个目标表，建立一个死元组列表，如果可能的话冻结旧元组。列表存储在本地内存的<a href="https://www.postgresql.org/docs/current/static/runtime-config-resource.html#GUC-MAINTENANCE-WORK-MEM">maintenance_work_mem</a> 中。冻结处理将在6.3节中介绍。</p><p>扫描完成后，PostgreSQL通过引用死元组列表删除索引元组。这个过程在内部被称为“清理阶段”。不用说，这个过程是昂贵的。在版本10或更早的版本中，总是执行清理阶段。在版本11或更高版本中，如果目标索引是B-tree，则是否执行清理阶段由配置参数 <a href="https://www.postgresql.org/docs/devel/static/runtime-config-resource.html#RUNTIME-CONFIG-INDEX-VACUUM">vacuum_cleanup_index_scale_factor</a> 决定，请参见该参数的详细说明。</p><p>当 <code>maintenance_work_mem</code> 已满且扫描未完成时，PostgreSQL将继续执行下一个任务，即步骤4到7，然后返回步骤3，进行剩余扫描。</p><h3 id="6-1-2-第二块"><a href="#6-1-2-第二块" class="headerlink" title="6.1.2 第二块"></a>6.1.2 第二块</h3><p>这个块会删除死元组，并逐页更新FSM和VM。图6.1给出了一个例子：</p><p><img src="/medias/image/fig-6-01-167673093401620.png" alt="图6.1 删除死元组"></p><p>假设表包含三个页面，我们关注第0页(即第一页)。这个页面有三个元组，Tuple_2是一个死元组(图6.1(1))。在这种情况下，PostgreSQL删除Tuple_2并重新排序剩余的元组以修复碎片，然后更新该页的FSM和VM(图6.1(2))。PostgreSQL继续这个过程直到最后一页。</p><p>注意，不必要的行指针不会被删除，它们将在将来被重用。因为，如果删除行指针，则必须更新关联索引的所有索引元组。</p><h3 id="6-1-3-第三块"><a href="#6-1-3-第三块" class="headerlink" title="6.1.3 第三块"></a>6.1.3 第三块</h3><p>第三个块在删除索引之后执行清理，并且还更新与每个目标表的vacuum进程相关的统计信息和系统目录。此外，如果最后一页没有元组，则从表文件中截断它。</p><h3 id="6-1-4-后处理"><a href="#6-1-4-后处理" class="headerlink" title="6.1.4 后处理"></a>6.1.4 后处理</h3><p>当vacuum进程完成时，PostgreSQL会更新一些与vacuum进程相关的统计数据和系统目录，并尽可能删除不必要的clog(6.4章节)。vacuum进程使用环形缓冲器，如第 8.5 节所述，因此处理过的页面不会缓存在共享缓冲区中。</p><h2 id="6-2-可见性地图"><a href="#6-2-可见性地图" class="headerlink" title="6.2 可见性地图"></a>6.2 可见性地图</h2><blockquote><p>vacuum进程是昂贵的，因此，在8.4版中引入了VM以降低这一成本。</p></blockquote><p>VM的基本概念很简单，每个表都有一个单独的可见性映射，用于保存表文件中每个页面的可见性。页面的可见性决定了每个页面是否有死元组，vacuum进程可以跳过没有死元组的页面。</p><p>图 6.2 显示了VM的使用情况。假设表由三页组成，第0页和第2页包含死元组，而第1页不包含。该表的VM保存了关于哪些页面包含死元组的信息。在这种情况下，vacuum进程通过引用VM的信息跳过第一页。</p><p><img src="/medias/image/fig-6-02.png" alt="图 6.2 VM的使用方式 "></p><p>每个VM由一个或多个8KB的页面组成，该文件以 <code>VM</code> 后缀存储。以relfilenode为18751的表文件为例，其中 <code>FSM</code> (18751_fsm)和 <code>VM</code> (18751_vm)文件如下所示。</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">cd</span> <span class="token variable">$PGDATA</span>$ <span class="token function">ls</span> -la base/16384/18751*-rw------- 1 postgres postgres  8192 Apr 21 10:21 base/16384/18751-rw------- 1 postgres postgres 24576 Apr 21 10:18 base/16384/18751_fsm-rw------- 1 postgres postgres  8192 Apr 21 10:18 base/16384/18751_vm<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="6-2-1-VM增强"><a href="#6-2-1-VM增强" class="headerlink" title="6.2.1 VM增强"></a>6.2.1 VM增强</h3><p>9.6版本对VM进行了增强，提高了冻结处理的效率。新的VM显示页面可见性，以及关于元组在每个页面中是否冻结的信息(6.3.3章节)。</p><h2 id="6-3-冻结处理"><a href="#6-3-冻结处理" class="headerlink" title="6.3 冻结处理"></a>6.3 冻结处理</h2><p>冻结处理有两种模式，根据特定条件以任何一种模式执行。为方便起见，这些模式被称为<strong>惰性模式</strong>和<strong>急切模式</strong>。</p><p>冻结处理通常以惰性模式运行，但是，当满足特定条件时，就会运行急切模式。在惰性模式下，冻结处理仅使用目标表的相应 VM 扫描包含死元组的页面。相比之下，急切模式会扫描所有页面，无论每个页面是否包含死元组，它还会更新与冻结处理相关的系统目录，并尽可能删除不必要的clog页面和文件。</p><h3 id="6-3-1-惰性模式"><a href="#6-3-1-惰性模式" class="headerlink" title="6.3.1 惰性模式"></a>6.3.1 惰性模式</h3><p>当开始冻结处理时，PostgreSQL 计算 freezeLimit_txid 并冻结 t_xmin 小于 freezeLimit txid 的元组。</p><p>freezeLimit_txid 定义如下：</p><pre class="line-numbers language-bash"><code class="language-bash">freezeLimit_txid<span class="token operator">=</span><span class="token punctuation">(</span>OldestXmin−vacuum_freeze_min_age<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>在那里最旧的XminOldestXmin是当前正在运行的事务中最旧的 txid。例如，如果在执行 VACUUM 命令时三个事务（txids 100、101 和 102）正在运行， 最旧的XminOldestXmin 是 100。如果不存在其他事务， 最旧的XminOldestXmin是执行这个 VACUUM 命令的 txid。在这里，<a href="https://www.postgresql.org/docs/current/static/runtime-config-client.html#GUC-VACUUM-FREEZE-MIN-AGE">vacuum_freeze_min_age</a>是一个配置参数（默认为 50,000,000）。</p><p>一个具体示例。在这里，Table_1 由三个页面组成，每个页面有三个元组。执行 VACUUM 命令时，当前 txid 为 50,002,500，没有其他事物。在这种情况下，最旧的XminOldestXmin是 50,002,500；因此，freezeLimit_txid 为 2500。冻结处理如下执行。</p><p><strong>在惰性模式下冻结元组</strong></p><p><img src="/medias/image/fig-6-03-167673167640625.png" alt="图 7 在惰性模式下冻结元组"></p><ul><li><p>第0页：</p><p>三个元组被冻结，因为所有 t_xmin 值都小于 freezeLimit txid。此外，由于死元组，在此vacuum过程中删除了 Tuple_1。</p></li><li><p>第1页：</p><p>参考VM跳过此页。</p></li><li><p>第2页：</p><p>Tuple_7 和 Tuple_8 被冻结；Tuple_7 被删除。</p></li></ul><p>在完成vacuum过程之前，更新与vacuum相关的统计信息，例如 <a href="https://www.postgresql.org/docs/current/static/monitoring-stats.html#PG-STAT-ALL-TABLES-VIEW">pg_stat_all_tables</a>的n_live_tup、n_dead_tup、last_vacuum、vacuum_count等。</p><p>如上例所示，惰性模式可能无法完全冻结元组，因为它可以跳过页面。</p><h3 id="6-3-2-急切模式"><a href="#6-3-2-急切模式" class="headerlink" title="6.3.2 急切模式"></a>6.3.2 急切模式</h3><p>急切模式弥补了惰性模式的缺陷。它扫描所有页面以检查表中的所有元组，更新相关的系统目录，并尽可能删除不必要的clog页面和文件。</p><p>当满足以下条件时执行急切模式。</p><pre class="line-numbers language-bash"><code class="language-bash">pg_database.datfrozenxid<span class="token operator">&lt;</span><span class="token punctuation">(</span>OldestXmin−vacuum_freeze_table_age<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>在上述条件中， pg_database.datfrozenxid代表<a href="https://www.postgresql.org/docs/current/static/catalog-pg-database.html">pg_database</a>系统目录的列，并保存每个数据库最旧的冻结 txid，细节在后面描述。因此，我们假设所有 pg_database.datfrozenxid 的值为 1821（这是 9.5 版新数据库集群安装后的初始值）。 <a href="https://www.postgresql.org/docs/current/static/runtime-config-client.html#GUC-VACUUM-FREEZE-TABLE-AGE">vacuum_freeze_table_age</a>是一个配置参数（默认为 150,000,000）。</p><p>下图显示了一个具体示例。在 Table_1 中，Tuple_1 和 Tuple_7 都被删除了。Tuple_10 和 Tuple_11 已插入到第二页。执行 VACUUM 命令时，当前 txid 为 150,002,000，没有其他事物。因此，OldestXmin 为 150,002,000，freezeLimit txid 为 100,002,000。在这种情况下，满足上述条件，因为1821&lt;(150002000−150000000)，因此，冻结处理在急切模式下执行如下。</p><p>（注意这是 9.5 或更早版本的行为）</p><p><strong>急切模式下冻结旧的元组（9.5 或更早版本）</strong></p><p><img src="/medias/image/fig-6-04-167673167640626.png" alt="图 8 在 Eager 模式下冻结旧的元组（9.5 或更早版本）"></p><ul><li><p>第0页：</p><p>Tuple_2 和 Tuple_3 已被检查，即使所有元组都已被冻结。</p></li><li><p>第1页：</p><p>此页面中的三个元组已被冻结，因为所有 t_xmin 值都小于 freezeLimit txid。请注意，在惰性模式下会跳过此页面。</p></li><li><p>第2页：</p><p>Tuple_10 已被冻结，Tuple_11 没有。</p></li></ul><p>冻结每个表后，更新目标表的pg_class.relfrozenxid。pg_class是一个系统目录，每个 pg_class.relfrozenxid 列都保存着对应表的最新冻结 xid。本例中，Table_1 的 pg_class.relfrozenxid 更新为当前的 freezeLimit txid（即 100,002,000），这意味着 Table_1 中所有t_xmin 小于 100,002,000 的元组都被冻结。</p><p>在完成vacuum过程之前，pg_database.datfrozenxid 会根据需要进行更新。每个 pg_database.datfrozenxid 列保存对应数据库中的最小 pg_class.relfrozenxid。例如，如果只有 Table_1 在急切模式下被冻结，则该数据库的 pg_database.datfrozenxid 不会更新，因为其他关系（从当前数据库中可以看到的其他表和系统目录）的 pg_class.relfrozenxid 没有更改。如果当前数据库中的所有关系都在急切模式下被冻结，则更新数据库的 pg_database.datfrozenxid，因为该数据库的所有关系的 pg_class.relfrozenxid 都更新为当前的 freezeLimit txid。</p><p><strong>pg_database.datfrozenxid 和 pg_class.relfrozenxid(s) 之间的关系</strong></p><p><img src="/medias/image/fig-6-05-167673167640627.png" alt="图 9 pg_database.datfrozenxid 和 pg_class.relfrozenxid(s) 之间的关系"></p><p><em>如何显示 pg_class.relfrozenxid 和 pg_database.datfrozenxid</em></p><p>在下文中，第一个查询显示了“testdb”数据库中所有可见关系的 relfrozenxid，第二个查询显示了“testdb”数据库的 pg_database.datfrozenxld。</p><pre class="line-numbers language-sql-monosp"><code class="language-sql-monosp">testdb=# VACUUM table_1;VACUUMtestdb=# SELECT n.nspname as "Schema", c.relname as "Name", c.relfrozenxid             FROM pg_catalog.pg_class c             LEFT JOIN pg_catalog.pg_namespace n ON n.oid = c.relnamespace             WHERE c.relkind IN ('r','')                   AND n.nspname <> 'information_schema' AND n.nspname !~ '^pg_toast'                   AND pg_catalog.pg_table_is_visible(c.oid)                   ORDER BY c.relfrozenxid::text::bigint DESC;   Schema   |            Name         | relfrozenxid ------------+-------------------------+-------------- public     | table_1                 |    100002000 public     | table_2                 |         1846 pg_catalog | pg_database             |         1827 pg_catalog | pg_user_mapping         |         1821 pg_catalog | pg_largeobject          |         1821... pg_catalog | pg_transform            |         1821(57 rows)testdb=# SELECT datname, datfrozenxid FROM pg_database WHERE datname = 'testdb'; datname | datfrozenxid ------------------------+-------------- testdb                  |         1821(1 row)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><em>冻结选项</em></p><p>带有 <code>FREEZE</code> 选项的 VACUUM 命令强制冻结指定表中的所有 txid，这是在急切模式下执行的。但是，freezeLimit 设置为 OldestXmin（不是“OldestXmin - Vacuum_freeze_min_age”）。例如，当 txid 5000 执行 VACUUM FULL 命令且没有其他正在运行的事务时，OldesXmin 设置为 5000，小于 5000 的 txid 将被冻结。</p><h3 id="6-3-3-在急切模式下改进冻结处理"><a href="#6-3-3-在急切模式下改进冻结处理" class="headerlink" title="6.3.3 在急切模式下改进冻结处理"></a><strong>6.3.3 在急切模式下改进冻结处理</strong></h3><p>9.5 或更早版本中的急切模式效率不高，因为总是扫描所有页面。例如，在上节示例中，即使第 0 页中的所有元组都被冻结，也会扫描第 0 页。</p><p>为了解决这个问题，9.6 版本对 VM 和冻结过程进行了改进，新 VM 具有关于是否所有元组在每个页面中都被冻结的信息。当以急切模式执行冻结处理时，可以跳过仅包含冻结元组的页面。</p><p>冻结此表时，参考VM信息跳过第0页。冻结第 1 页后，更新关联的 VM 信息，因为该页的所有元组都已冻结。</p><p><strong>在急切模式下冻结旧的元组（9.6 或更高版本）</strong></p><p><img src="/medias/image/fig-6-06-167673167640628.png" alt="图 10 在 Eager 模式下冻结旧的元组（9.6 或更高版本）"></p><h2 id="6-4-删除不必要的阻塞文件"><a href="#6-4-删除不必要的阻塞文件" class="headerlink" title="6.4 删除不必要的阻塞文件"></a>6.4 删除不必要的阻塞文件</h2><p>当 pg_database.datfrozenxid 更新时，PostgreSQL 会尝试删除不必要的clog文件。请注意，相应的clog页面也会被删除。</p><p>下图显示了一个示例。如果最小 pg_database.datfrozenxid 包含在 clog 文件“0002”中，则可以删除旧文件（“0000”和“0001”），因为存储在这些文件中的所有事务都可以被视为整个数据库集群中的冻结 txid。</p><p><strong>删除不必要的阻塞文件和页面</strong></p><p><img src="/medias/image/fig-6-07-167673167640629.png" alt="图 11 删除不必要的阻塞文件和页面"></p><p><em>pg_database.datfrozenxid 和 clog 文件</em></p><p>下面显示了 pg_database.datfrozenxid 和 clog 文件的实际输出：</p><pre class="line-numbers language-sql-monosp"><code class="language-sql-monosp">$ psql testdb -c "SELECT datname, datfrozenxid FROM pg_database"  datname  | datfrozenxid -----------+-------------- template1 |      7308883 template0 |      7556347 postgres  |      7339732 testdb    |      7506298(4 rows)$ ls -la -h data/pg_xact/    # In version 9.6 or earlier, "ls -la -h data/pg_clog/"total 316Kdrwx------  2 postgres postgres   28 Dec 29 17:15 .drwx------ 20 postgres postgres 4.0K Dec 29 17:13 ..-rw-------  1 postgres postgres 256K Dec 29 17:15 0006-rw-------  1 postgres postgres  56K Dec 29 17:15 0007<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="6-5-autovacuum守护进程"><a href="#6-5-autovacuum守护进程" class="headerlink" title="6.5 autovacuum守护进程"></a>6.5 autovacuum守护进程</h2><p>vacuum处理已通过 autovacuum 守护进程自动化，因此 PostgreSQL 的操作变得异常简单。</p><p>autovacuum 守护进程定期调用几个 autovacuum_worker 进程。默认情况下，它每 1 分钟唤醒一次（由<a href="https://www.postgresql.org/docs/current/static/runtime-config-autovacuum.html#GUC-AUTOVACUUM-NAPTIME">autovacuum_naptime</a>定义），并调用三个 worker（由<a href="https://www.postgresql.org/docs/current/static/runtime-config-autovacuum.html#GUC-AUTOVACUUM-MAX-WORKERS">autovacuum_max_works</a>定义）。</p><p>由 autovacuum 调用的 autovacuum worker 并行的对各个表同时执行真空处理，对数据库活动的影响最小。</p><h2 id="6-6-VACUUM-FULL"><a href="#6-6-VACUUM-FULL" class="headerlink" title="6.6 VACUUM FULL"></a>6.6 VACUUM FULL</h2><p>尽管并行 VACUUM 对于操作是必不可少的，但这还不够。例如，即使删除了许多死元组，它也无法减小表大小。</p><p>如图显示了一个极端的例子。假设一个表由三页组成，每页包含六个元组，执行以下 DELETE 命令删除元组，执行 VACUUM 命令删除死元组：</p><p><strong>并行 VACUUM 缺点的示例</strong><img src="/medias/image/fig-6-08-167673167640730.png" alt="图 12 显示（并发）VACUUM 缺点的示例"></p><pre class="line-numbers language-sql-monosp"><code class="language-sql-monosp">testdb=# DELETE FROM tbl WHERE id % 6 != 0;testdb=# VACUUM tbl;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>删除死元组，但是，表大小并没有减少。这既浪费了磁盘空间，又对数据库性能产生了负面影响。例如，在上面的示例中，当读取表中的三个元组时，必须从磁盘加载三个页面。</p><p>为了应对这种情况，PostgreSQL 提供了 VACUUM FULL 模式。下图显示了该模式的概要。</p><p><strong>VACUUM FULL 模式的概要</strong></p><p><img src="/medias/image/fig-6-09-167673167640731.png" alt="图 13 Full VACUUM 模式的概要"></p><ol><li><p>新建表文件：图 (1)</p><p>当对一个表执行 VACUUM FULL 命令时，PostgreSQL 首先获取该表的 AccessExclusiveLock 锁，并创建一个大小为 8 KB 的新表文件。AccessExclusiveLock 锁不允许访问。</p></li><li><p>将活动元组复制到新表中：图 (2)</p><p>PostgreSQL 仅将旧表文件中的活动元组复制到新表中。</p></li><li><p>删除旧文件，重建索引，更新统计、FSM、VM：图(3)</p><p>复制所有活动元组后，PostgreSQL 删除旧文件，重建所有关联的表索引，更新该表的 FSM 和 VM，并更新关联的统计信息和系统目录。</p></li></ol><p>VACUUM FULL 的伪代码如下所示：</p><p><em>伪代码：VACUUM FULL</em></p><pre class="line-numbers language-sql"><code class="language-sql"><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>  <span class="token keyword">FOR</span> each <span class="token keyword">table</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span>       Acquire AccessExclusiveLock <span class="token keyword">lock</span> <span class="token keyword">for</span> the <span class="token keyword">table</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span>       <span class="token keyword">Create</span> <span class="token number">a</span> new <span class="token keyword">table</span> <span class="token keyword">file</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span>       <span class="token keyword">FOR</span> each live tuple <span class="token operator">in</span> the old <span class="token keyword">table</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span>            Copy the live tuple <span class="token keyword">to</span> the new <span class="token keyword">table</span> <span class="token keyword">file</span><span class="token punctuation">(</span><span class="token number">6</span><span class="token punctuation">)</span>            Freeze the tuple <span class="token keyword">IF</span> necessary            <span class="token keyword">END</span> <span class="token keyword">FOR</span><span class="token punctuation">(</span><span class="token number">7</span><span class="token punctuation">)</span>        Remove the old <span class="token keyword">table</span> <span class="token keyword">file</span><span class="token punctuation">(</span><span class="token number">8</span><span class="token punctuation">)</span>        Rebuild <span class="token keyword">all</span> indexes<span class="token punctuation">(</span><span class="token number">9</span><span class="token punctuation">)</span>        <span class="token keyword">Update</span> FSM <span class="token operator">and</span> VM<span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span>      <span class="token keyword">Update</span> <span class="token keyword">statistics</span>           <span class="token keyword">Release</span> AccessExclusiveLock <span class="token keyword">lock</span>      <span class="token keyword">END</span> <span class="token keyword">FOR</span><span class="token punctuation">(</span><span class="token number">11</span><span class="token punctuation">)</span>  Remove unnecessary clog files <span class="token operator">and</span> pages <span class="token keyword">if</span> possib  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>使用 VACUUM FULL 命令时应考虑两点。</p><ol><li>当 VACUUM FULL 正在处理时，没有用户可以访问（读/写）表。</li><li>最多临时使用表磁盘空间的两倍，因此，在处理一个巨大的表时，需要检查剩余的磁盘容量。</li></ol><p><em>我应该什么时候做 VACUUM FULL？</em></p><p>不幸的是，当您应该执行“VACUUM FULL”时，没有最佳实践。然而，扩展<a href="https://www.postgresql.org/docs/current/static/pgfreespacemap.html">pg_freespacemap</a>可能会给你很好的建议。</p><p>以下查询显示了您想知道的表的平均可用空间比率。</p><pre class="line-numbers language-sql-monosp"><code class="language-sql-monosp">testdb=# CREATE EXTENSION pg_freespacemap;CREATE EXTENSIONtestdb=# SELECT count(*) as "number of pages",       pg_size_pretty(cast(avg(avail) as bigint)) as "Av. freespace size",       round(100 * avg(avail)/8192 ,2) as "Av. freespace ratio"       FROM pg_freespace('accounts'); number of pages | Av. freespace size | Av. freespace ratio -----------------+--------------------+---------------------            1640 | 99 bytes           |                1.21(1 row)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如上结果，您可以发现可用空间很少。</p><p>如果你删除几乎元组并执行 VACUUM 命令，你会发现几乎页是空格的。</p><pre class="line-numbers language-sql-monosp"><code class="language-sql-monosp">testdb=# DELETE FROM accounts WHERE aid %10 != 0 OR aid < 100;DELETE 90009testdb=# VACUUM accounts;VACUUMtestdb=# SELECT count(*) as "number of pages",      pg_size_pretty(cast(avg(avail) as bigint)) as "Av. freespace size",      round(100 * avg(avail)/8192 ,2) as "Av. freespace ratio"      FROM pg_freespace('accounts');number of pages | Av. freespace size | Av. freespace ratio -----------------+--------------------+---------------------           1640 | 7124 bytes         |               86.97(1 row)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>以下查询检查指定表的每一页的可用空间比率。</p><pre class="line-numbers language-sql-monosp"><code class="language-sql-monosp">testdb=# SELECT *, round(100 * avail/8192 ,2) as "freespace ratio"                FROM pg_freespace('accounts'); blkno | avail | freespace ratio -------+-------+-----------------     0 |  7904 |           96.00     1 |  7520 |           91.00     2 |  7136 |           87.00     3 |  7136 |           87.00     4 |  7136 |           87.00     5 |  7136 |           87.00....<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>执行 VACUUM FULL 后，可以发现表文件已经被压实。</p><pre class="line-numbers language-sql-monosp"><code class="language-sql-monosp">testdb=# VACUUM FULL accounts;VACUUMtestdb=# SELECT count(*) as "number of blocks",       pg_size_pretty(cast(avg(avail) as bigint)) as "Av. freespace size",       round(100 * avg(avail)/8192 ,2) as "Av. freespace ratio"       FROM pg_freespace('accounts'); number of pages | Av. freespace size | Av. freespace ratio -----------------+--------------------+---------------------             164 | 0 bytes            |                0.00(1 row)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> postgresql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> postgresql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>5 并发控制</title>
      <link href="/2021/5.bing-fa-kong-zhi/"/>
      <url>/2021/5.bing-fa-kong-zhi/</url>
      
        <content type="html"><![CDATA[<p>并发控制是一种机制，当多个事务在数据库中并发运行时，它保持原子性和隔离性，这是ACID的两个属性。</p><span id="more"></span><p>[TOC]</p><blockquote><p>共有三种广泛的并发控制技术，即多版本并发控制(MVCC)、严格两阶段锁定(S2PL) 和乐观并发控制(OCC)，每种技术都有许多变体。在 MVCC 中，每个写操作都会创建一个新版本的数据项，同时保留旧版本。当一个事务读取一个数据项时，系统会选择其中一个版本来确保单个事务的隔离。MVCC的主要优点是 ‘<em>读不阻塞写，写不阻塞读</em>‘，相比之下，例如，基于S2PL的系统必须在写入器写入项目时阻止读取器，因为写入器获得了该项目的排它锁。PostgreSQL和一些RDBMS使用称为快照隔离(SI)的MVCC变体。</p><p>为了实现 SI，一些 RDBMS，例如 Oracle，使用回滚段。写入新数据项时，将旧版本项写入回滚段，随后将新项覆盖到数据区。PostgreSQL 使用一种更简单的方法。一个新的数据项被直接插入到相关的表格页面中，在读取项目时，PostgreSQL通过应用可见性检查规则来选择适当版本的项目以响应单个事务。</p><p>SI不允许ANSI SQL-92标准中定义的三种异常，即<em>脏读</em>、<em>不可重复读</em>和<em>幻读</em>。但是，SI 无法实现真正的可序列化，因为它允许序列化异常，例如<em>Write Skew</em>和<em>Read-only Transaction Skew</em>。请注意，基于经典可串行化定义的 ANSI SQL-92 标准并不等同于现代理论中的定义。为了解决这个问题，Serializable Snapshot Isolation(SSI)从9.1版开始添加。SSI可以检测序列化异常并解决此类异常引起的冲突。因此，PostgreSQL9.1及更高版本提供了真正的 SERIALIZABLE隔离级别。（另外，SQL Server也使用SSI，Oracle仍然只使用SI）</p></blockquote><p>本章包括以下四个部分：</p><p><strong>第 1 部分：</strong>第 5.1—5.3 本部分提供理解后续部分所需的基本信息。</p><p>第 5.1 节和第 5.2 节分别描述了事务ID和元组结构，5.3 节展示了如何插入、删除和更新元组。</p><p><strong>第 2 部分：</strong>第 5.4— 5.6 这部分说明了实现并发控制机制所需的关键特性。</p><p>5.4、5.5 和 5.6 节描述了提交日志（clog），它分别保存了所有事务状态、事务快照和可见性检查规则。</p><p><strong>第 3 部分：</strong>第 5.7—5.9 这部分通过具体的例子来描述PostgreSQL中的并发控制。</p><p>5.7 节描述了可见性检查，本节还展示了如何防止ANSI SQL标准中定义的三个异常，第 5.8 节描述了防止丢失更新，第 5.9 节简要描述了SSI。</p><p><strong>第 4 部分：</strong>第 5.10 节。这部分描述了永久运行并发控制机制所需的几个维护过程。维护过程是通过vacuum处理来执行的，这在<a href="http://www.interdb.jp/pg/pgsql06.html">第 6 章</a>中进行了描述。</p><p>本章重点介绍 PostgreSQL 独有的主题，尽管有许多与并发控制相关的主题。注意死锁预防和锁模式的描述被省略（更多信息请参考<a href="https://www.postgresql.org/docs/current/static/explicit-locking.html">官方文档</a>）。</p><p><strong>PostgreSQL 中的事务隔离级别</strong></p><p>PostgreSQL 实现的事务隔离级别如下表所述：</p><table><thead><tr><th align="left">隔离级别</th><th align="left">脏读</th><th align="left">不可重复读</th><th align="left">幻读</th><th align="left">序列化异常</th></tr></thead><tbody><tr><td align="left">读已提交</td><td align="left">不可能</td><td align="left">可能</td><td align="left">可能</td><td align="left">可能</td></tr><tr><td align="left">可重复读</td><td align="left">不可能</td><td align="left">不可能</td><td align="left">在 PG 中不可能(在ANSI SQL中可能)，见<a href="http://www.interdb.jp/pg/pgsql05.html#_5.7.2.">第 5.7.2 节</a></td><td align="left">可能</td></tr><tr><td align="left">可序列化</td><td align="left">不可能</td><td align="left">不可能</td><td align="left">不可能</td><td align="left">不可能</td></tr></tbody></table><blockquote><p>可重复读在9.0及更早版本中，此级别已用作“SERIALIZABLE”，因为它不允许ANSI SQL-92标准中定义的三个异常。但是，随着9.1版中SSI的实现，此级别已更改为“可重复读”并引入了真正的可序列化级别。</p></blockquote><p>PostgreSQL对DML（数据操作语言，例如 SELECT、UPDATE、INSERT、DELETE）使用SSI，对DDL（数据定义语言，例如 CREATE TABLE 等）使用2PL。</p><h2 id="5-1-事务ID"><a href="#5-1-事务ID" class="headerlink" title="5.1 事务ID"></a>5.1 事务ID</h2><p>每当事务开始时，事务管理器都会分配一个唯一标识符，称为事务ID(txid)。PostgreSQL的txid是一个 32位无符号整数，大约为42 亿。如果在事务开始后执行内置的txid_current()函数，该函数将返回当前的txid，如下所示。</p><pre class="line-numbers language-bash"><code class="language-bash">testdb<span class="token operator">=</span><span class="token comment" spellcheck="true"># BEGIN;</span>BEGINtestdb<span class="token operator">=</span><span class="token comment" spellcheck="true"># SELECT txid_current();</span> txid_current --------------          100<span class="token punctuation">(</span>1 row<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>PostgreSQL 保留了以下三个特殊的 txid：</p><ul><li><p><strong>0</strong>表示无效的txid。</p></li><li><p><strong>1</strong>表示Bootstrap txid，仅用于数据库集群的初始化。</p></li><li><p><strong>2</strong>表示Frozen txid，在<a href="http://www.interdb.jp/pg/pgsql05.html#_5.10.1">第 5.10.1 节</a>中描述。</p></li></ul><p>txid可以相互比较。例如，在txid 100的观察下，大于100的txids是’未来的’，在txid 100中是’不可见’的；小于100的txid 是’’过去的’，并且是’可见的’（图 5.1 a）。</p><p><img src="/medias/image/fig-5-01.png" alt="图 5.1 PostgreSQL中的事务ID"></p><p>由于实际系统中txid空间不足，PostgreSQL将txid空间视为一个圆圈。之前的21亿事务是’过去的’，接下来的21亿交易是’’未来的’（图 5.1 b）。在<a href="http://www.interdb.jp/pg/pgsql05.html#_5.10.1.">第 5.10.1 节</a>中描述了所谓的txid环绕问题。</p><p>注意，没有为BEGIN命令分配txid。在PostgreSQL中，当执行完BEGIN命令后执行第一个命令时，事务管理器会分配一个tixd，然后它的事务就开始了。</p><h2 id="5-2-元组结构"><a href="#5-2-元组结构" class="headerlink" title="5.2 元组结构"></a>5.2 元组结构</h2><p>表页中的堆元组分为普通数据元组和TOAST元组，本节仅描述普通的元组。</p><p>一个堆元组由三部分组成，即 HeapTupleHeaderData结构、NULL位图和用户数据（图 5.2）。</p><p><img src="/medias/image/fig-5-02.png" alt="图 5.2 元组结构"></p><p>HeapTupleHeaderData 结构在<a href="https://github.com/postgres/postgres/blob/ee943004466418595363d567f18c053bae407792/src/include/access/htup_details.h">src/include/access/htup_details.h</a>中定义。<a href="void(0)">HeapTupleHeaderData</a>结构包含七个字段，后续部分只说四个字段。</p><ul><li><p><strong>t_xmin</strong>保存插入此元组的事务的txid。</p></li><li><p><strong>t_xmax</strong>保存删除或更新此元组的事务的txid。如果此元组尚未删除或更新，则t_xmax设置为0，这意味着 INVALID。</p></li><li><p><strong>t_cid</strong>保存着command id（cid），意思是从0开始的当前事务内执行此命令之前执行了多少条SQL命令。例如，假设我们在单个事务中执行三个INSERT命令：’BEGIN;INSERT ;INSERT;INSERT;COMMIT;’。如果第一个命令插入这个元组，t_cid 设置为 0，如果第二个命令插入这个，t_cid设置为1，依此类推。</p></li><li><p><strong>t_ctid</strong>保存指向自身或新元组的元组标识符 (tid)。<a href="http://www.interdb.jp/pg/pgsql01.html#_1.3.">第 1.3 节</a>中描述的tid用于标识表中的元组，当这个元组更新时，这个元组的t_ctid指向新的元组，否则t_ctid 指向自身。</p></li></ul><h2 id="5-3-插入、删除和更新元组"><a href="#5-3-插入、删除和更新元组" class="headerlink" title="5.3 插入、删除和更新元组"></a>5.3 插入、删除和更新元组</h2><p>本节介绍如何插入、删除和更新元组。然后简要的描述了用于插入和更新元组的<em>自由空间映射（FSM）</em>。</p><p>为了关注元组，下面没有表示页眉和行指针。图 5.3 显示了如何表示元组的示例。</p><p><img src="/medias/image/fig-5-03.png" alt="图 5.3 元组的表示"></p><h3 id="5-3-1-插入"><a href="#5-3-1-插入" class="headerlink" title="5.3.1 插入"></a>5.3.1 插入</h3><p>通过插入操作，一个新的元组被直接插入到目标表的一页中（图 5.4）。</p><p><img src="/medias/image/fig-5-04.png" alt="图 5.4 插入元组"></p><p>假设一个tuple被一个 txid 为 99 的事务插入到一个页面中。在这种情况下，插入的tuple的header字段设置如下。</p><p>Tuple_1：</p><ul><li><p><strong>t_xmin</strong>设置为 99，因为该元组由txid 99插入。</p></li><li><p><strong>t_xmax</strong>设置为 0，因为此元组尚未删除或更新。</p></li><li><p><strong>t_cid</strong>设置为 0，因为该元组是txid 99插入的第一个元组。</p></li><li><p><strong>t_ctid</strong>设置为 (0,1)，它指向自身，因为这是最新的元组。</p></li></ul><p><strong>页面检查</strong></p><p>PostgreSQL 提供了一个扩展 <em>pageinspect</em>，它是一个贡献模块，用于显示数据库页面的内容。</p><pre class="line-numbers language-bash"><code class="language-bash">testdb<span class="token operator">=</span><span class="token comment" spellcheck="true"># CREATE EXTENSION pageinspect;</span>CREATE EXTENSIONtestdb<span class="token operator">=</span><span class="token comment" spellcheck="true"># CREATE TABLE tbl (data text);</span>CREATE TABLEtestdb<span class="token operator">=</span><span class="token comment" spellcheck="true"># INSERT INTO tbl VALUES('A');</span>INSERT 0 1testdb<span class="token operator">=</span><span class="token comment" spellcheck="true"># SELECT lp as tuple, t_xmin, t_xmax, t_field3 as t_cid, t_ctid </span>                FROM heap_page_items<span class="token punctuation">(</span>get_raw_page<span class="token punctuation">(</span><span class="token string">'tbl'</span>, 0<span class="token punctuation">))</span><span class="token punctuation">;</span> tuple <span class="token operator">|</span> t_xmin <span class="token operator">|</span> t_xmax <span class="token operator">|</span> t_cid <span class="token operator">|</span> t_ctid -------+--------+--------+-------+--------     1 <span class="token operator">|</span>     99 <span class="token operator">|</span>      0 <span class="token operator">|</span>     0 <span class="token operator">|</span> <span class="token punctuation">(</span>0,1<span class="token punctuation">)</span><span class="token punctuation">(</span>1 row<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="5-3-2-删除"><a href="#5-3-2-删除" class="headerlink" title="5.3.2 删除"></a>5.3.2 删除</h3><p>在删除操作中，目标元组被逻辑删除。执行DELETE命令的txid的值设置为元组的t_xmax（图 5.5）。</p><p><img src="/medias/image/fig-5-05.png" alt="图 5.5 元组删除"></p><p>假设Tuple_1被txid 111删除，此时Tuple_1的header字段设置如下。</p><p>Tuple_1：</p><ul><li><strong>t_xmax</strong>设置为 111。</li></ul><p>如果提交了 txid 111，则不再需要 Tuple_1。通常，不需要的元组在 PostgreSQL中被称为<strong>死亡元组</strong>，死亡元组最终应该从页面中删除。清理死元组称为<strong>VACUUM</strong>处理，在<a href="http://www.interdb.jp/pg/pgsql06.html">第 6 章</a>中介绍。</p><h3 id="5-3-3-更新"><a href="#5-3-3-更新" class="headerlink" title="5.3.3 更新"></a>5.3.3 更新</h3><p>在更新操作中，PostgreSQL在逻辑上删除最新的元组并插入一个新元组（图 5.6）。</p><p><img src="/medias/image/fig-5-06.png" alt="图 5.6 元组删除"></p><p>假设由 txid 99插入的行被 txid 100更新了两次。</p><p>当执行第一个UPDATE 命令时，通过将 txid 100 设置为 t_xmax 逻辑删除Tuple_1，然后插入Tuple_2。然后，将Tuple_1的 t_ctid 重写为指向 Tuple_2。Tuple_1 和 Tuple_2 的头域如下。</p><p>Tuple_1：</p><ul><li><strong>t_xmax</strong>设置为 100。</li><li><strong>t_ctid</strong>从 (0, 1) 改写为 (0, 2)。</li></ul><p>Tuple_2：</p><ul><li><strong>t_xmin</strong>设置为 100。</li><li><strong>t_xmax</strong>设置为 0。</li><li><strong>t_cid</strong>设置为 0。</li><li><strong>t_ctid</strong>设置为 (0,2)。</li></ul><p>当执行第二个UPDATE命令时，与第一个UPDATE命令一样，逻辑上删除Tuple_2 并插入Tuple_3。Tuple_2和Tuple_3 的头域如下。</p><p>Tuple_2：</p><ul><li><strong>t_xmax</strong>设置为 100。</li><li><strong>t_ctid</strong>从 (0, 2) 改写为 (0, 3)。</li></ul><p>Tuple_3：</p><ul><li><strong>t_xmin</strong>设置为 100。</li><li><strong>t_xmax</strong>设置为 0。</li><li><strong>t_cid</strong>设置为 1。</li><li><strong>t_ctid</strong>设置为 (0,3)。</li></ul><p>与删除操作一样，如果 txid 100被提交，Tuple_1和 Tuple_2将是死元组，如果 txid 100被中止，Tuple_2 和 Tuple_3 将是死元组。</p><h3 id="5-3-4-Free-Space-Map"><a href="#5-3-4-Free-Space-Map" class="headerlink" title="5.3.4 Free Space Map"></a>5.3.4 Free Space Map</h3><p>在插入堆表或索引元组时，PostgreSQL使用对应表或索引的 <strong>FSM</strong> 来选择可以插入它的页面。</p><p>如<a href="http://www.interdb.jp/pg/pgsql01.html#_1.2.3.">第 1.2.3 节</a>所述，所有表和索引都有各自的FSM，每个FSM将有关每个页面的<strong>可用空间容量的信息</strong>存储在相应的表或索引文件中。所有FSM都以后缀’fsm’存储，如有必要，它们会加载到共享内存中。</p><p><a href="https://www.postgresql.org/docs/current/static/pgfreespacemap.html">pg_freespacemap</a> 扩展提供指定表或者索引的空闲空间。以下查询显示指定表中每个页面的可用空间比例。</p><pre class="line-numbers language-bash"><code class="language-bash">testdb<span class="token operator">=</span><span class="token comment" spellcheck="true"># CREATE EXTENSION pg_freespacemap;</span>CREATE EXTENSIONtestdb<span class="token operator">=</span><span class="token comment" spellcheck="true"># SELECT *, round(100 * avail/8192 ,2) as "freespace ratio"</span>                FROM pg_freespace<span class="token punctuation">(</span><span class="token string">'accounts'</span><span class="token punctuation">)</span><span class="token punctuation">;</span> blkno <span class="token operator">|</span> avail <span class="token operator">|</span> freespace ratio -------+-------+-----------------     0 <span class="token operator">|</span>  7904 <span class="token operator">|</span>           96.00     1 <span class="token operator">|</span>  7520 <span class="token operator">|</span>           91.00     2 <span class="token operator">|</span>  7136 <span class="token operator">|</span>           87.00     3 <span class="token operator">|</span>  7136 <span class="token operator">|</span>           87.00     4 <span class="token operator">|</span>  7136 <span class="token operator">|</span>           87.00     5 <span class="token operator">|</span>  7136 <span class="token operator">|</span>           87.00<span class="token punctuation">..</span><span class="token punctuation">..</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="5-4-提交日志（clog）"><a href="#5-4-提交日志（clog）" class="headerlink" title="5.4. 提交日志（clog）"></a>5.4. 提交日志（clog）</h2><p>PostgreSQL在<strong>Commit Log <strong>（通常称为</strong>clog</strong>）中保存事务的状态，分配给共享内存，并在整个事务处理过程中使用。本节介绍PostgreSQL中事务的状态，clog如何运行，以及clog的维护。</p><h3 id="5-4-1-事务状态"><a href="#5-4-1-事务状态" class="headerlink" title="5.4.1 事务状态"></a>5.4.1 事务状态</h3><p>PostgreSQL定义了四种事务状态，即IN_PROGRESS、COMMITTED、ABORTED和SUB_COMMITTED。前三个状态是显而易见的。例如，当一个事务在进行中时，它的状态是 IN_PROGRES 等。SUB_COMMITTED 用于子事务，本文省略其说明。</p><h3 id="5-4-2-clog的运作"><a href="#5-4-2-clog的运作" class="headerlink" title="5.4.2 clog的运作"></a>5.4.2 clog的运作</h3><p>clog由共享内存中的一个或多个8KB页组成，clog在逻辑上形成一个阵列，数组的索引对应各自的事务id，数组中的每一项都保存着对应的事务id的状态。图 5.7 显示了clog及其运作方式。</p><p><img src="/medias/image/fig-5-07.png" alt="图 5.7 clog如何运作"></p><hr><ul><li><p><strong>T1：</strong> txid 200提交，txid 200的状态从IN_PROGRESS 更改为COMMITTED。</p></li><li><p><strong>T2：</strong> txid 201中止，txid 201的状态从IN_PROGRESS 更改为ABORTED。</p></li></ul><p>当前txid前进并且clog无法再存储它时，会附加一个新页面。</p><p>当需要事务的状态时，调用内部函数，这些函数读取CLOG并返回请求事务的状态。（也可以在<a href="http://www.interdb.jp/pg/pgsql05.html#_5.7.1">第 5.7.1 节</a>中看看 <em>Hint Bits</em>）</p><h3 id="5-4-3-clog的维护"><a href="#5-4-3-clog的维护" class="headerlink" title="5.4.3 clog的维护"></a>5.4.3 clog的维护</h3><p>当PostgreSQL关闭或checkpoint进程运行时，clog的数据被写入存储在<strong>pg_clog</strong>子目录下的文件中。</p><blockquote><p>pg_clog将在版本10中重命名为pg_xact</p></blockquote><p>这些文件被命名为<em>0000</em>、<em>0001</em>等。最大文件大小为 256 KB，当clog使用8页（第一页到第八页，总大小为64 KB）时，将其数据写入0000（64 KB），以37页（296 KB）写入数据分为 0000 和 0001，其大小分别为 256 KB 和 40 KB。</p><p>当PostgreSQL启动时，存储在pg_clog的文件中的数据被加载以初始化clog。clog的大小不断增加，因为每当CLOG被填满时都会附加一个新页面。但是，并非clog中的所有数据都是必需的。<a href="http://www.interdb.jp/pg/pgsql06.html">第 6 章</a>中描述的vacuum处理会定期删除此类旧数据（clog页面和文件），有关删除clog数据的详细信息在<a href="http://www.interdb.jp/pg/pgsql06.html#_6.4">第 6.4 节</a>中描述。</p><h2 id="5-5-事务快照"><a href="#5-5-事务快照" class="headerlink" title="5.5. 事务快照"></a>5.5. 事务快照</h2><p>事务快照是存储有关所有事务是否活跃的信息，在一定的时间点为单个事务的数据集。这里的活动事务意味着它正在进行中或尚未开始。</p><p>PostgreSQL内部将事务快照的文本表示格式定义为’<strong>100:100</strong>‘。例如，’<strong>100:100</strong>‘表示小于99的txid不活跃，等于或大于100的txid是活跃的。在下面的描述中，使用了这种方便的表示形式。如果您不熟悉它，请参阅以下。</p><blockquote><p> 内置函数 txid_current_snapshot 及其文本表示格式</p></blockquote><p>函数<a href="http://www.postgresql.org/docs/current/static/functions-info.html#FUNCTIONS-TXID-SNAPSHOT">txid_current_snapshot</a>显示当前事务的快照。</p><pre class="line-numbers language-bash"><code class="language-bash">testdb<span class="token operator">=</span><span class="token comment" spellcheck="true"># SELECT txid_current_snapshot();</span> txid_current_snapshot ----------------------- 100:104:100,102<span class="token punctuation">(</span>1 row<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>txid_current_snapshot的文本表示为’<strong>xmin:xmax:xip_list</strong>‘，组件描述如下。</p><p>xmin</p><ul><li>仍处于活动状态的最早txid。所有较早的事务要么被提交并可见，要么回滚并死亡。</li></ul><p>xmax</p><ul><li>第一个尚未分配的txid。截至快照时，所有大于或等于此值的 txid 尚未启动，因此不可见。</li></ul><p>xip_list</p><ul><li>快照时的活动txid。该列表仅包括xmin和xmax之间的活动txid。</li></ul><p>例如，在快照’<strong>100:104:100,102</strong>‘中，xmin 为“100”，xmax 为“104”，而 xip_list 为“100:102:”。</p><p>下面给出两个具体的例子：</p><p><img src="/medias/image/fig-5-08.png" alt="图 5.8 事务快照表示的示例"></p><p>第一个例子是’<strong>100:100</strong>‘。该快照的含义如下（图 5.8(a)）：</p><ul><li><p>等于或小于 99 的 txid不活跃，因为 xmin 是 100。</p></li><li><p>等于或大于 100 的 txid是活跃的，因为 xmax 是 100。</p></li></ul><p>第二个例子是’<strong>100:104:100,102</strong>‘。该快照的含义如下（图 5.8(b)）：</p><ul><li><p>等于或小于99的txid不活跃。</p></li><li><p>等于或大于104的txid是活跃的。</p></li><li><p>txid 100和102处于活跃状态，因为它们存在于xip列表中，而 txid 101和103未处于活跃状态。</p></li></ul><p>事务快照由事务管理器提供。在READ COMMITTED隔离级别中，每当执行 SQL 命令时，事务都会获取快照；否则（REPEATABLE READ 或 SERIALIZABLE），事务仅在执行第一个 SQL 命令时获取快照。获取的事务快照用于元组的可见性检查，这在<a href="http://www.interdb.jp/pg/pgsql05.html#_5.7">第 5.7 节</a>中描述。</p><p>当使用获取的快照进行可见性检查时，快照中的<em>活动</em>事务必须被视为<em>进行中，</em> 即使它们实际上已被提交或中止。此规则很重要，因为它会导致READ COMMITTED 和 REPEATABLE READ（或 SERIALIZABLE）之间的行为不同。我们将在以下各节中反复提及此规则。</p><p>在本节的其余部分，事务管理器和事务使用特定场景图 5.9 进行描述。</p><p><img src="/medias/image/fig-5-09.png" alt="图 5.9 事务管理器和事务"></p><p>事务管理器始终保存有关当前正在运行的事务的信息。假设三个事务依次启动，Transaction_A和Transaction_B的隔离级别为READ COMMITTED，Transaction_C的隔离级别为REPEATABLE READ。</p><p><strong>T1：</strong></p><ul><li>Transaction_A启动并执行第一个SELECT命令。在执行第一条命令时，Transaction_A请求了这一刻的txid和快照。在这种情况下，事务管理器分配txid 200，并返回事务快照“200:200:”。</li></ul><p><strong>T2：</strong></p><ul><li>Transaction_B 启动并执行第一个SELECT命令。事务管理器分配 txid 201，并返回事务快照“200:200:”，因为 Transaction_A (txid 200) 正在进行中。因此，从Transaction_B无法看到Transaction_A。</li></ul><p><strong>T3：</strong></p><ul><li>Transaction_C启动并执行第一个SELECT命令。事务管理器分配txid 202，返回事务快照’200:200:’，因此从Transaction_C看不到Transaction_A和Transaction_B。</li></ul><p><strong>T4：</strong></p><ul><li>Transaction_A已提交。事务管理器删除有关此事务的信息。</li></ul><p><strong>T5：</strong></p><ul><li>Transaction_B和Transaction_C执行各自的SELECT命令。</li><li>Transaction_B需要事务快照，因为它处于READ COMMITTED级别。在这种情况下，Transaction_B获得新快照“201:201:”，因为Transaction_A (txid 200) 已提交。因此，Transaction_A不再对Transaction_B不可见。</li><li>Transaction_C不需要事务快照，因为它处于REPEATABLE READ级别并使用获取的快照，即’200:200:’。因此，Transaction_A对Transaction_C仍然不可见。</li></ul><h2 id="5-6-可见性检查规则"><a href="#5-6-可见性检查规则" class="headerlink" title="5.6 可见性检查规则"></a>5.6 可见性检查规则</h2><p>可见性检查规则是一组规则，用于使用元组的t_xmin和t_xmax、clog和获取的事务快照来确定每个元组是可见还是不可见。这些规则太复杂，无法详细解释。因此，本文档显示了后续描述所需的最少规则。在下文中，我们省略了与子事务相关的规则并忽略了关于t_ctid的讨论，即我们不考虑在一个事务中更新超过两次的元组。</p><p>选择的规则数为十个，可以分为三种情况。</p><h3 id="5-6-1-t-xmin的状态为ABORTED"><a href="#5-6-1-t-xmin的状态为ABORTED" class="headerlink" title="5.6.1 t_xmin的状态为ABORTED"></a>5.6.1 t_xmin的状态为ABORTED</h3><p>t_xmin状态为ABORTED的元组始终<em>不可见</em>（规则 1），因为插入此元组的事务已中止。</p><pre class="line-numbers language-c"><code class="language-c"> <span class="token comment" spellcheck="true">/* t_xmin status == ABORTED */</span>Rule <span class="token number">1</span><span class="token punctuation">:</span> IF t_xmin status is <span class="token string">'ABORTED'</span> THEN            RETURN <span class="token string">'Invisible'</span>        END IF<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>该规则明确表示为以下数学表达式。</p><ul><li><strong>规则 1：</strong>如果 Status(t_xmin) = ABORTED ⇒ Invisible</li></ul><h3 id="5-6-2-t-xmin-的状态是IN-PROGRESS"><a href="#5-6-2-t-xmin-的状态是IN-PROGRESS" class="headerlink" title="5.6.2 t_xmin 的状态是IN_PROGRESS"></a>5.6.2 t_xmin 的状态是IN_PROGRESS</h3><p>t_xmin状态为IN_PROGRESS的元组基本上是<em>不可见的</em>（规则 3 和 4），除非在一种情况下。</p><pre class="line-numbers language-c"><code class="language-c"> <span class="token comment" spellcheck="true">/* t_xmin status == IN_PROGRESS */</span>              IF t_xmin status is <span class="token string">'IN_PROGRESS'</span> THEN                   IF t_xmin <span class="token operator">=</span> current_txid THENRule <span class="token number">2</span><span class="token punctuation">:</span>              IF t_xmax <span class="token operator">=</span> INVALID THEN                  RETURN <span class="token string">'Visible'</span>Rule <span class="token number">3</span><span class="token punctuation">:</span>              ELSE  <span class="token comment" spellcheck="true">/* this tuple has been deleted or updated by the current transaction itself. */</span>                  RETURN <span class="token string">'Invisible'</span>                         END IFRule <span class="token number">4</span><span class="token punctuation">:</span>        ELSE   <span class="token comment" spellcheck="true">/* t_xmin ≠ current_txid */</span>                  RETURN <span class="token string">'Invisible'</span>                   END IF             END IF<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如果这个元组被另一个事务插入并且t_xmin的状态是IN_PROGRESS，这个元组显然是<em>不可见的</em>（规则4）。</p><p>如果 t_xmin 等于当前的 txid（即这个元组是由当前事务插入的）并且 t_xmax不是INVALID，那么这个元组是<em>不可见的，</em> 因为它已经被当前事务更新或删除了（规则 3）。</p><p>异常条件是该元组由当前事务插入并且t_xmax 为INVALID 的情况。在这种情况下，这个元组必须从当前事务中<em>可见</em>（规则 2），因为这个元组是当前事务本身插入的元组。</p><ul><li><p><strong>规则 2：</strong>如果 Status(t_xmin) = IN_PROGRESS ∧ t_xmin = current_txid ∧ t_xmax = INVAILD ⇒ 可见</p></li><li><p><strong>规则 3：</strong>如果 Status(t_xmin) = IN_PROGRESS ∧ t_xmin = current_txid ∧ t_xmax ≠ INVAILD ⇒ 不可见</p></li><li><p><strong>规则 4：</strong>如果 Status(t_xmin) = IN_PROGRESS ∧ t_xmin ≠ current_txid ⇒ 不可见</p></li></ul><h3 id="5-6-3-t-xmin的状态是COMMITTED"><a href="#5-6-3-t-xmin的状态是COMMITTED" class="headerlink" title="5.6.3 t_xmin的状态是COMMITTED"></a>5.6.3 t_xmin的状态是COMMITTED</h3><p>t_xmin 状态为COMMITTED 的元组是 <em>可见的</em>（规则 6,8 和 9），但在三种情况下除外。</p><pre class="line-numbers language-c"><code class="language-c"> <span class="token comment" spellcheck="true">/* t_xmin status == COMMITTED */</span>            IF t_xmin status is <span class="token string">'COMMITTED'</span> THENRule <span class="token number">5</span><span class="token punctuation">:</span>      IF t_xmin is active in the obtained transaction snapshot THEN                      RETURN <span class="token string">'Invisible'</span>Rule <span class="token number">6</span><span class="token punctuation">:</span>      ELSE IF t_xmax <span class="token operator">=</span> INVALID OR status of t_xmax is <span class="token string">'ABORTED'</span> THEN                      RETURN <span class="token string">'Visible'</span>                 ELSE IF t_xmax status is <span class="token string">'IN_PROGRESS'</span> THENRule <span class="token number">7</span><span class="token punctuation">:</span>           IF t_xmax <span class="token operator">=</span>  current_txid THEN                            RETURN <span class="token string">'Invisible'</span>Rule <span class="token number">8</span><span class="token punctuation">:</span>           ELSE  <span class="token comment" spellcheck="true">/* t_xmax ≠ current_txid */</span>                            RETURN <span class="token string">'Visible'</span>                      END IF                 ELSE IF t_xmax status is <span class="token string">'COMMITTED'</span> THENRule <span class="token number">9</span><span class="token punctuation">:</span>           IF t_xmax is active in the obtained transaction snapshot THEN                            RETURN <span class="token string">'Visible'</span>Rule <span class="token number">10</span><span class="token punctuation">:</span>         ELSE                            RETURN <span class="token string">'Invisible'</span>                      END IF                 END IF            END IF<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>规则 6 很明显，因为t_xmax是INVALID 或 ABORTED。三个例外条件以及规则8和9描述如下。</p><p>第一个异常条件是t_xmin在获取的事务快照中<em>处于活动状态</em>（规则 5）。在这种情况下，这个元组是<em>不可见的，</em> 因为 t_xmin 应该被视为进行中。</p><p>第二个例外条件是t_xmax是当前的txid（规则 7）。在这种情况下，与规则3一样，此元组是<em>不可见的，</em> 因为它已被此事务本身更新或删除。</p><p>相反，如果t_xmax的状态是IN_PROGRESS并且t_xmax不是当前的txid（规则 8），则元组是<em>可见的，</em> 因为它没有被删除。</p><p>第三个异常条件是t_xmax的状态为COMMITTED且t_xmax在获取的交易快照中不活跃（规则10）。在这种情况下，这个元组是<em>不可见的，</em> 因为它已经被另一个事务更新或删除了。</p><p>相反，如果t_xmax的状态为COMMITTED但 t_xmax 在获得的事务快照中处于活动状态（规则 9），则元组是<em>可见的，</em>因为t_xmax应被视为进行中。</p><ul><li><p><strong>规则 5：</strong>如果 Status(t_xmin) = COMMITTED ∧ Snapshot(t_xmin) = active ⇒ Invisible</p></li><li><p><strong>规则 6：</strong>如果 Status(t_xmin) = COMMITTED ∧ (t_xmax = INVALID ∨ Status(t_xmax) = ABORTED) ⇒ 可见</p></li><li><p><strong>规则 7：</strong>如果 Status(t_xmin) = COMMITTED ∧ Status(t_xmax) = IN_PROGRESS ∧ t_xmax = current_txid ⇒ 不可见</p></li><li><p><strong>规则 8：</strong>如果 Status(t_xmin) = COMMITTED ∧ Status(t_xmax) = IN_PROGRESS ∧ t_xmax ≠ current_txid ⇒ 可见</p></li><li><p><strong>规则 9：</strong>如果 Status(t_xmin) = COMMITTED ∧ Status(t_xmax) = COMMITTED ∧ Snapshot(t_xmax) = active ⇒ Visible</p></li><li><p><strong>规则 10：</strong>如果 Status(t_xmin) = COMMITTED ∧ Status(t_xmax) = COMMITTED ∧ Snapshot(t_xmax) ≠ active ⇒ Invisible</p></li></ul><hr><h2 id="5-7-可见性检查"><a href="#5-7-可见性检查" class="headerlink" title="5.7 可见性检查"></a>5.7 可见性检查</h2><p>本节描述PostgreSQL如何执行可见性检查，即如何选择给定事务中适当版本的堆元组。本节还介绍了 PostgreSQL如何防止ANSI SQL-92 标准中定义的异常：脏读、可重复读和幻读。</p><h3 id="5-7-1-可见性检查"><a href="#5-7-1-可见性检查" class="headerlink" title="5.7.1 可见性检查"></a>5.7.1 可见性检查</h3><p><img src="/medias/image/fig-5-10.png" alt="图 5.10 描述可见性检查的场景"></p><p>在图 5.10 所示的场景中，SQL 命令按以下时间顺序执行。</p><ul><li><p><strong>T1：</strong>开始事务（txid 200）</p></li><li><p><strong>T2：</strong>开始事务（txid 201）</p></li><li><p><strong>T3：</strong>执行txid 200和201的SELECT命令</p></li><li><p><strong>T4：</strong>执行txid 200的UPDATE命令</p></li><li><p><strong>T5：</strong>执行txid 200和201的SELECT命令</p></li><li><p><strong>T6：</strong>提交txid 200</p></li><li><p><strong>T7：</strong>执行txid 201的SELECT命令</p></li></ul><p>为了简化描述，假设只有两个事务，即txid 200和201。txid 200的隔离级别为READ COMMITTED，txid 201的隔离级别为READ COMMITTED或REPEATABLE READ。</p><p>我们探索SELECT命令如何对每个元组执行可见性检查。</p><p><strong>T3的SELECT命令：</strong></p><p>在 T3 时，表<em>tbl中</em>只有一个Tuple_1并且它是由<strong>规则 6</strong><em>可见</em>的；因此，两个事务中的 SELECT 命令都返回“Jekyll”。</p><ul><li>Rule6(Tuple_1) ⇒ 状态(t_xmin:199) = COMMITTED ∧ t_xmax = INVALID ⇒ 可见</li></ul><pre class="line-numbers language-bash"><code class="language-bash">testdb<span class="token operator">=</span><span class="token comment" spellcheck="true"># -- txid 200</span>testdb<span class="token operator">=</span><span class="token comment" spellcheck="true"># SELECT * FROM tbl;</span>  name  -------- Jekyll<span class="token punctuation">(</span>1 row<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-bash"><code class="language-bash">testdb<span class="token operator">=</span><span class="token comment" spellcheck="true"># -- txid 201</span>testdb<span class="token operator">=</span><span class="token comment" spellcheck="true"># SELECT * FROM tbl;</span>  name  -------- Jekyll<span class="token punctuation">(</span>1 row<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>T5的SELECT命令：</strong></p><p>首先，我们探索txid 200执行的SELECT 命令。 Tuple_1 在<strong>规则 7 中</strong>不可见， Tuple_2 在<strong>规则 2 中</strong>可见；因此，这个 SELECT 命令返回 ‘Hyde’。</p><ul><li><p>Rule7(Tuple_1): Status(t_xmin:199) = COMMITTED ∧ Status(t_xmax:200) = IN_PROGRESS ∧ t_xmax:200 = current_txid:200 ⇒ 不可见</p></li><li><p>Rule2(Tuple_2): Status(t_xmin:200) = IN_PROGRESS ∧ t_xmin:200 = current_txid:200 ∧ t_xmax = INVAILD ⇒ 可见</p></li></ul><pre class="line-numbers language-bash"><code class="language-bash">testdb<span class="token operator">=</span><span class="token comment" spellcheck="true"># -- txid 200</span>testdb<span class="token operator">=</span><span class="token comment" spellcheck="true"># SELECT * FROM tbl;</span> name ------ Hyde<span class="token punctuation">(</span>1 row<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>另一方面，在txid 201执行的SELECT命令中，Tuple_1在<strong>Rule 8中</strong>可见，Tuple_2在<strong>Rule 4中</strong>不可见；因此，这个 SELECT命令返回 ‘Jekyll’。</p><ul><li><p>Rule8(Tuple_1): Status(t_xmin:199) = COMMITTED ∧ Status(t_xmax:200) = IN_PROGRESS ∧ t_xmax:200 ≠ current_txid:201 ⇒ 可见</p></li><li><p>Rule4(Tuple_2)：状态(t_xmin:200) = IN_PROGRESS ∧ t_xmin:200 ≠ current_txid:201 ⇒ 不可见</p></li></ul><pre class="line-numbers language-bash"><code class="language-bash">testdb<span class="token operator">=</span><span class="token comment" spellcheck="true"># -- txid 201</span>testdb<span class="token operator">=</span><span class="token comment" spellcheck="true"># SELECT * FROM tbl;</span>  name  -------- Jekyll<span class="token punctuation">(</span>1 row<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如果更新的元组在提交之前从其他事务中可见，则它们被称为<strong>脏读</strong>，也称为<strong>wr-conflicts</strong>。但是，如上所示，在 PostgreSQL 中的任何隔离级别都不会发生脏读。</p><p><strong>T7的SELECT命令：</strong></p><p>下面分别介绍T7的SELECT命令在两个隔离级别下的行为。</p><p>首先，我们探索 txid 201 何时处于 READ COMMITTED 级别。在这种情况下，txid 200 被视为已提交，因为事务快照是’201:201:’<em>。因此，Tuple_1是</em>看不见的由第10和Tuple_2是可见由第6，和SELECT命令返回“Hyde”。</p><ul><li><p>Rule10(Tuple_1): Status(t_xmin:199) = COMMITTED ∧ Status(t_xmax:200) = COMMITTED ∧ Snapshot(t_xmax:200) ≠ active ⇒ Invisible</p></li><li><p>Rule6(Tuple_2): Status(t_xmin:200) = COMMITTED ∧ t_xmax = INVALID ⇒ 可见</p></li></ul><pre class="line-numbers language-bash"><code class="language-bash">testdb<span class="token operator">=</span><span class="token comment" spellcheck="true"># -- txid 201 (READ COMMITTED)</span>testdb<span class="token operator">=</span><span class="token comment" spellcheck="true"># SELECT * FROM tbl;</span> name ------ Hyde<span class="token punctuation">(</span>1 row<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>请注意，在提交 txid 200 之前和之后执行的 SELECT 命令的结果是不同的。这通常称为<strong>不可重复读取</strong>。</p><p>相反，当 txid 201 处于 REPEATABLE READ 级别时，txid 200 必须被视为 IN_PROGRESS，因为事务快照是“200:200:”。因此，Tuple_1是<em>可见</em>由<strong>规则9</strong>和Tuple_2是<em>看不见的</em>由<strong>规则5</strong>，和SELECT命令返回“化身”。请注意，不可重复读取不会发生在可重复读取（和可序列化）级别。</p><ul><li><p>Rule9(Tuple_1): Status(t_xmin:199) = COMMITTED ∧ Status(t_xmax:200) = COMMITTED ∧ Snapshot(t_xmax:200) = active ⇒ Visible</p></li><li><p>Rule5(Tuple_2): Status(t_xmin:200) = COMMITTED ∧ Snapshot(t_xmin:200) = active ⇒ Invisible</p></li></ul><pre class="line-numbers language-bash"><code class="language-bash">testdb<span class="token operator">=</span><span class="token comment" spellcheck="true"># -- txid 201 (REPEATABLE READ)</span>testdb<span class="token operator">=</span><span class="token comment" spellcheck="true"># SELECT * FROM tbl;</span>  name  -------- Jekyll<span class="token punctuation">(</span>1 row<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><em>Hint Bits</em></p><p>为了获取事务的状态，PostgreSQL 内部提供了三个函数，即 TransactionIdIsInProgress、TransactionIdDidCommit 和 TransactionIdDidAbort。实现这些功能是为了减少对阻塞的频繁访问，例如缓存。但是，如果在检查每个元组时执行它们，就会出现瓶颈。</p><p>为了解决这个问题，PostgreSQL使用了<em>提示位</em>，如下所示。</p><pre class="line-numbers language-c"><code class="language-c"><span class="token macro property">#<span class="token directive keyword">define</span> HEAP_XMIN_COMMITTED       0x0100   </span><span class="token comment" spellcheck="true">/* t_xmin committed */</span><span class="token macro property">#<span class="token directive keyword">define</span> HEAP_XMIN_INVALID         0x0200   </span><span class="token comment" spellcheck="true">/* t_xmin invalid/aborted */</span><span class="token macro property">#<span class="token directive keyword">define</span> HEAP_XMAX_COMMITTED       0x0400   </span><span class="token comment" spellcheck="true">/* t_xmax committed */</span><span class="token macro property">#<span class="token directive keyword">define</span> HEAP_XMAX_INVALID         0x0800   </span><span class="token comment" spellcheck="true">/* t_xmax invalid/aborted */</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>在读取或写入元组时，如果可能，PostgreSQL会将提示位设置为元组的t_informask。例如，假设PostgreSQL检查元组的t_xmin状态并获得状态COMMITTED。在这种情况下，PostgreSQL为元组的t_infomask设置一个提示位 HEAP_XMIN_COMMITTED。如果提示位已设置，则不再需要 TransactionIdDidCommit 和 TransactionIdDidAbort。因此，PostgreSQL可以有效地检查每个元组的t_xmin和t_xmax的状态。</p><h3 id="5-7-2-PostgreSQL的REPEATABLE-READ级别中的幻读"><a href="#5-7-2-PostgreSQL的REPEATABLE-READ级别中的幻读" class="headerlink" title="5.7.2 PostgreSQL的REPEATABLE READ级别中的幻读"></a>5.7.2 PostgreSQL的REPEATABLE READ级别中的幻读</h3><p>ANSI SQL-92标准中定义的REPEATABLE READ允许<strong>Phantom Reads</strong>。但是，PostgreSQL的实现不允许它们。原则上，SI不允许幻读。</p><p>假设两个事务，即Tx_A 和Tx_B，正在并发运行。它们的隔离级别是READ COMMITTED和REPEATABLE READ，它们的txids分别是100和101。首先，Tx_A插入一个元组。然后，它被提交。插入元组的t_xmin为100。接下来，Tx_B执行SELECT命令；然而，Tx_A插入的元组在<strong>规则 5 中</strong>是<em>不可见</em>的。因此，不会发生幻读。</p><ul><li>Rule5(new tuple): Status(t_xmin:100) = COMMITTED ∧ Snapshot(t_xmin:100) = active ⇒ Invisible</li></ul><pre class="line-numbers language-bash"><code class="language-bash">testdb<span class="token operator">=</span><span class="token comment" spellcheck="true"># -- Tx_A: txid 100</span>testdb<span class="token operator">=</span><span class="token comment" spellcheck="true"># START TRANSACTION</span>testdb-<span class="token comment" spellcheck="true">#  ISOLATION LEVEL READ COMMITTED;</span>START TRANSACTIONtestdb<span class="token operator">=</span><span class="token comment" spellcheck="true"># INSERT tbl(id, data) </span>                VALUES <span class="token punctuation">(</span>1,<span class="token string">'phantom'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>INSERT 1 testdb<span class="token operator">=</span><span class="token comment" spellcheck="true"># COMMIT;</span>COMMIT<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-bash"><code class="language-bash">testdb<span class="token operator">=</span><span class="token comment" spellcheck="true"># -- Tx_B: txid 101</span>testdb<span class="token operator">=</span><span class="token comment" spellcheck="true"># START TRANSACTION</span>testdb-<span class="token comment" spellcheck="true">#  ISOLATION LEVEL REPEATABLE READ;</span>START TRANSACTIONtestdb<span class="token operator">=</span><span class="token comment" spellcheck="true"># SELECT txid_current();</span> txid_current--------------          101<span class="token punctuation">(</span>1 row<span class="token punctuation">)</span>testdb<span class="token operator">=</span><span class="token comment" spellcheck="true"># SELECT * FROM tbl WHERE id=1;</span> <span class="token function">id</span> <span class="token operator">|</span> data ----+------<span class="token punctuation">(</span>0 rows<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="5-8-防止丢失更新"><a href="#5-8-防止丢失更新" class="headerlink" title="5.8 防止丢失更新"></a>5.8 防止丢失更新</h2><p>一个丢失的更新，也被称为WW冲突，是发生在并发事务更新同一行的异常，它必须在可重复读和可系列化级别都被阻止（请注意，READ COMMITTED级别不需要防止丢失更新）。本节描述PostgreSQL如何防止丢失更新并显示示例。</p><h3 id="5-8-1-并发UPDATE命令的行为"><a href="#5-8-1-并发UPDATE命令的行为" class="headerlink" title="5.8.1 并发UPDATE命令的行为"></a>5.8.1 并发UPDATE命令的行为</h3><p>当执行UPDATE命令时，函数ExecUpdate被内部调用。ExecUpdate的伪代码如下所示：</p><p><em>伪代码：ExecUpdate</em></p><pre class="line-numbers language-c"><code class="language-c"><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>  FOR each row that will be updated by this UPDATE <span class="token function">command</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span>       WHILE true               <span class="token comment" spellcheck="true">/* The First Block */</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span>            IF the target row is being updated <span class="token function">THEN</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span>              WAIT <span class="token keyword">for</span> the termination of the transaction that updated the target <span class="token function">row</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span>              <span class="token function">IF</span> <span class="token punctuation">(</span>the status of the terminated transaction is COMMITTED<span class="token punctuation">)</span>                          <span class="token function">AND</span> <span class="token punctuation">(</span>the isolation level of this transaction is REPEATABLE READ or SERIALIZABLE<span class="token punctuation">)</span> <span class="token function">THEN</span><span class="token punctuation">(</span><span class="token number">6</span><span class="token punctuation">)</span>                       ABORT this transaction  <span class="token comment" spellcheck="true">/* First-Updater-Win */</span>                  <span class="token function">ELSE</span> <span class="token punctuation">(</span><span class="token number">7</span><span class="token punctuation">)</span>                           GOTO <span class="token function">step</span> <span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span>                  END IF               <span class="token comment" spellcheck="true">/* The Second Block */</span><span class="token punctuation">(</span><span class="token number">8</span><span class="token punctuation">)</span>            ELSE IF the target row has been updated by another concurrent transaction <span class="token function">THEN</span><span class="token punctuation">(</span><span class="token number">9</span><span class="token punctuation">)</span>              <span class="token function">IF</span> <span class="token punctuation">(</span>the isolation level of this transaction is READ COMMITTED <span class="token function">THEN</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span>                       UPDATE the target row                  <span class="token function">ELSE</span><span class="token punctuation">(</span><span class="token number">11</span><span class="token punctuation">)</span>                       ABORT this transaction  <span class="token comment" spellcheck="true">/* First-Updater-Win */</span>                  END IF               <span class="token comment" spellcheck="true">/* The Third Block */</span>                ELSE  <span class="token comment" spellcheck="true">/* The target row is not yet modified or has been updated by a terminated transaction. */</span><span class="token punctuation">(</span><span class="token number">12</span><span class="token punctuation">)</span>              UPDATE the target row                END IF           END WHILE       END FOR <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>(1) 获取将被此 UPDATE 命令更新的每一行。</p><p>(2) 重复下面的过程，直到目标行被更新（或者这个事务被中止）。</p><p>(3) 如果目标行<em>正在更新</em>，则进行步骤(3)；否则，继续执行步骤（8）。</p><p>(4) 等待更新目标行的事务终止，因为 PostgreSQL在 SI 中使用<em>first-updater-win</em>方案。</p><p>(5) 如果更新目标行的事务状态为COMMITTED，且该事务的隔离级别为REPEATABLE READ（或SERIALIZABLE），则进行步骤（6）；否则，继续执行步骤（7）。</p><p>(6) 中止此事务以防止丢失更新。</p><p>(7) 继续步骤(2)，尝试在下一轮更新目标行。</p><p>(8) 如果目标行已被另一个并发事务更新，则进行步骤(9)；否则，继续执行步骤（12）。</p><p>(9) 如果该事务的隔离级别为READ COMMITTED，则进行步骤(10)；否则，继续执行步骤（11）。</p><p>(10) UPDATE目标行，进入步骤(1)。</p><p>(11) 中止此事务以防止丢失更新。</p><p>(12) UPDATE目标行，因为目标行还没有被修改或者已经被终止的事务更新，即存在ww-conflict，所以继续步骤(1)。</p><p>此函数为每个目标行执行更新操作。它有一个while循环来更新每一行，while循环内部根据图5.11所示的条件分支为三个块。</p><p><img src="/medias/image/fig-5-11.png" alt="图 5.11 ExecUpdate 中的三个内部块"></p><p>[1]正在更新目标行</p><ul><li><p>“正在更新”意味着该行被另一个并发事务更新，并且其事务尚未终止。在这种情况下，当前事务必须等待更新目标行的事务终止，因为PostgreSQL的SI使用<strong>first-updater-win</strong>方案。例如，假设事务Tx_A和Tx_B同时运行，并且Tx_B尝试更新一行；然而，Tx_A已经更新它并且仍在进行中。在这种情况下，Tx_B等待Tx_A 的终止。</p></li><li><p>更新目标行的事务提交后，继续进行当前事务的更新操作。如果当前事务处于READ COMMITTED级别，则更新目标行；否则（REPEATABLE READ 或 SERIALIZABLE），当前事务将立即中止以防止丢失更新。</p></li></ul><p>[2]目标行已被并发事务更新（图5.11[2]）</p><ul><li>当前事务尝试更新目标元组；但是，另一个并发事务已更新目标行并已提交。在这种情况下，如果当前事务处于READ COMMITTED级别，则会更新目标行；否则，当前事务将立即中止以防止丢失更新。</li></ul><p>[3] 没有冲突（图5.11[3]）</p><ul><li>当没有冲突时，当前事务可以更新目标行。</li></ul><blockquote><p><em>第一个更新者获胜/第一个提交者获胜</em></p><p>PostgreSQL的基于SI的并发控制采用了<em>first-updater-win</em>方案。相比之下，如下一节所述，PostgreSQL的SSI使用第<em>一个提交者获胜的</em>方案。</p></blockquote><h3 id="5-8-2-例子"><a href="#5-8-2-例子" class="headerlink" title="5.8.2 例子"></a>5.8.2 例子</h3><p>下面显示了三个示例。第一和第二示例显示了目标行正在更新时的行为，第三示例显示了更新目标行时的行为。</p><p><strong>示例 1：</strong></p><p>事务Tx_A和Tx_B更新同一个表中的同一行，它们的隔离级别是READ COMMITTED。</p><pre class="line-numbers language-bash"><code class="language-bash">testdb<span class="token operator">=</span><span class="token comment" spellcheck="true"># -- Tx_A</span>testdb<span class="token operator">=</span><span class="token comment" spellcheck="true"># START TRANSACTION</span>testdb-<span class="token comment" spellcheck="true">#    ISOLATION LEVEL READ COMMITTED;</span>START TRANSACTIONtestdb<span class="token operator">=</span><span class="token comment" spellcheck="true"># UPDATE tbl SET name = 'Hyde';</span>UPDATE 1testdb<span class="token operator">=</span><span class="token comment" spellcheck="true"># COMMIT;</span>COMMIT<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-bash"><code class="language-bash">testdb<span class="token operator">=</span><span class="token comment" spellcheck="true"># -- Tx_B</span>testdb<span class="token operator">=</span><span class="token comment" spellcheck="true"># START TRANSACTION</span>testdb-<span class="token comment" spellcheck="true">#    ISOLATION LEVEL READ COMMITTED;</span>START TRANSACTIONtestdb<span class="token operator">=</span><span class="token comment" spellcheck="true"># UPDATE tbl SET name = 'Utterson';</span>    ↓     ↓ this transaction is being blocked    ↓ UPDATE 1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Tx_B 执行如下。</p><p>1）执行UPDATE命令后，Tx_B应该等待Tx_A的终止，因为目标元组正在被Tx_A更新（ExecUpdate中的步骤（4））。</p><p>2）提交Tx_A后，Tx_B尝试更新目标行（ExecUpdate 中的步骤（7））。</p><p>3）在第二轮ExecUpdate中，目标行被Tx_B再次更新（ExecUpdate中的步骤（2），（8），（9），（10））。</p><p><strong>示例 2：</strong></p><p>Tx_A 和 Tx_B 更新同一个表中的同一行，它们的隔离级别分别为 READ COMMITTED和REPEATABLE READ。</p><pre class="line-numbers language-bash"><code class="language-bash">testdb<span class="token operator">=</span><span class="token comment" spellcheck="true"># -- Tx_A</span>testdb<span class="token operator">=</span><span class="token comment" spellcheck="true"># START TRANSACTION</span>testdb-<span class="token comment" spellcheck="true">#    ISOLATION LEVEL READ COMMITTED;</span>START TRANSACTIONtestdb<span class="token operator">=</span><span class="token comment" spellcheck="true"># UPDATE tbl SET name = 'Hyde';</span>UPDATE 1testdb<span class="token operator">=</span><span class="token comment" spellcheck="true"># COMMIT;</span>COMMIT<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-bash"><code class="language-bash">testdb<span class="token operator">=</span><span class="token comment" spellcheck="true"># -- Tx_B</span>testdb<span class="token operator">=</span><span class="token comment" spellcheck="true"># START TRANSACTION</span>testdb-<span class="token comment" spellcheck="true">#    ISOLATION LEVEL REPEATABLE READ;</span>START TRANSACTIONtestdb<span class="token operator">=</span><span class="token comment" spellcheck="true"># UPDATE tbl SET name = 'Utterson';</span>    ↓     ↓ this transaction is being blocked    ↓ERROR:couldn't serialize access due to concurrent update<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Tx_B 的行为描述如下。</p><p>1）执行UPDATE命令后，Tx_B应该等待Tx_A的终止（ExecUpdate中的步骤（4））。</p><p>2）Tx_A提交后，Tx_B被中止解决冲突，因为目标行已经更新，并且这个事务的隔离级别是REPEATABLE READ（ExecUpdate中的步骤（5）和（6））。</p><p><strong>示例 3：</strong></p><p>Tx_B (REPEATABLE READ) 尝试更新已由提交的Tx_A更新的目标行。在这种情况下，Tx_B被中止（ExecUpdate 中的步骤 (2)、(8)、(9) 和 (11)）。</p><pre class="line-numbers language-bash"><code class="language-bash">testdb<span class="token operator">=</span><span class="token comment" spellcheck="true"># -- Tx_A</span>testdb<span class="token operator">=</span><span class="token comment" spellcheck="true"># START TRANSACTION</span>testdb-<span class="token comment" spellcheck="true">#    ISOLATION LEVEL READ COMMITTED;</span>START TRANSACTIONtestdb<span class="token operator">=</span><span class="token comment" spellcheck="true"># UPDATE tbl SET name = 'Hyde';</span>UPDATE 1testdb<span class="token operator">=</span><span class="token comment" spellcheck="true"># COMMIT;</span>COMMIT<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-bash"><code class="language-bash">testdb<span class="token operator">=</span><span class="token comment" spellcheck="true"># -- Tx_B</span>testdb<span class="token operator">=</span><span class="token comment" spellcheck="true"># START TRANSACTION</span>testdb-<span class="token comment" spellcheck="true">#    ISOLATION LEVEL REPEATABLE READ;</span>START TRANSACTIONtestdb<span class="token operator">=</span><span class="token comment" spellcheck="true"># SELECT * FROM tbl;</span>  name  -------- Jekyll<span class="token punctuation">(</span>1 row<span class="token punctuation">)</span>testdb<span class="token operator">=</span><span class="token comment" spellcheck="true"># UPDATE tbl SET name = 'Utterson';</span>ERROR:couldn't serialize access due to concurrent update<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="5-9-可序列化快照隔离"><a href="#5-9-可序列化快照隔离" class="headerlink" title="5.9 可序列化快照隔离"></a>5.9 可序列化快照隔离</h2><p>自 9.1 版以来，可序列化快照隔离 (SSI) 已嵌入到 SI 中，以实现真正的SERIALIZABLE隔离级别。由于SSI的解释并不简单，所以只解释了一个大纲。有关详细信息，请参阅[<a href="http://www.interdb.jp/pg/pgsql05.html#_5.ref.2">2]</a>。</p><p>在下文中，以下所示的技术术语不加定义地使用。如果您不熟悉这些术语，请参阅 [ <a href="http://www.interdb.jp/pg/pgsql05.html#_5.ref.1">1</a> , <a href="http://www.interdb.jp/pg/pgsql05.html#_5.ref.3">3</a> ]。</p><ul><li><p><em>优先级图</em>（也称为<em>依赖图</em>和<em>序列化图）</em></p></li><li><p><em>序列化异常</em>（例如<em>Write-Skew）</em></p></li></ul><h3 id="5-9-1-SSI-实施的基本策略"><a href="#5-9-1-SSI-实施的基本策略" class="headerlink" title="5.9.1 SSI 实施的基本策略"></a>5.9.1 SSI 实施的基本策略</h3><p>如果在优先级图中存在一些冲突产生的循环，就会出现序列化异常。这可以使用最简单的异常来解释，即Write-Skew。</p><p>图 5.12(1) 显示了一个时间表。这里，Transaction_A读取Tuple_B，Transaction_B读取Tuple_A。然后，Transaction_A 写入Tuple_A，Transaction_B写入Tuple_B。在这种情况下，有两个rw-conflicts，它们在这个调度的优先级图中形成一个循环，如图 5.12（2）所示。因此，这个调度有一个序列化异常，即Write-Skew。</p><p><img src="/medias/image/fig-5-12.png" alt="图 5.12 Write-Skew 调度及其优先级图"></p><p>从概念上讲，存在三种类型的冲突：wr-conflicts（脏读）、ww-conflicts（丢失更新）和 rw-conflicts。但是，不需要考虑wr-和ww-conflicts，因为如前几节所示，PostgreSQL可以防止此类冲突。因此，PostgreSQL中的 SSI 实现只需要考虑 rw-conflicts。</p><p>PostgreSQL对SSI的实现采取了以下策略：</p><ol><li><p>将事务访问的所有对象（元组、页面、关系）记录为 SIREAD 锁。</p></li><li><p>每当写入任何堆或索引元组时，使用SIREAD锁检测rw冲突。</p></li><li><p>如果通过检查检测到的rw-conflicts 检测到序列化异常，则中止事务。</p></li></ol><h3 id="5-9-2-在-PostgreSQL-中实现-SSI"><a href="#5-9-2-在-PostgreSQL-中实现-SSI" class="headerlink" title="5.9.2 在 PostgreSQL 中实现 SSI"></a>5.9.2 在 PostgreSQL 中实现 SSI</h3><p>为了实现上述策略，PostgreSQL 实现了很多功能和数据结构。但是，这里我们仅使用两种数据结构：<strong>SIREAD 锁</strong>和<strong>rw-conflicts</strong>来描述 SSI 机制。它们存储在共享内存中。</p><p>为简单起见，本文档中省略了一些重要的数据结构，例如 SERIALIZABLEXACT。因此，CheckTargetForConflictOut、CheckTargetForConflictIn和PreCommit_CheckForSerializationFailure等函数的解释也极其简化。例如，我们指出哪些函数检测冲突；但是，没有详细说明如何检测冲突。如果想了解详细内容，请参考源代码：predicate.c。</p><p><strong>SIREAD 锁：</strong></p><ul><li><p>SIREAD 锁，内部称为谓词锁，是一对对象和（虚拟）txid，用于存储有关谁访问了哪个对象的信息。请注意，省略了虚拟 txid 的描述。使用 txid 而不是虚拟 txid 来简化以下说明。</p></li><li><p>SIREAD 锁由 CheckTargetForConflictsOut 函数创建，每当在 SERIALIZABLE 模式下执行一个 DML 命令时。例如，如果 txid 100 读取给定表的 Tuple_1，则会创建一个 SIREAD 锁 {Tuple_1, {100}}。如果另一个事务，例如 txid 101，读取 Tuple_1，则 SIREAD 锁更新为 {Tuple_1, {100,101}}。请注意，在读取索引页时也会创建 SIREAD 锁，因为当应用<a href="http://www.interdb.jp/pg/pgsql07.html#_7.2.">第 7.2 节</a>中描述的<a href="https://www.postgresql.org/docs/current/static/indexes-index-only-scans.html">仅索引扫描</a>功能时，只读取索引页而不读取表页。</p></li><li><p>SIREAD 锁具有三个级别：元组、页面和关系。如果创建了单个页面内所有元组的 SIREAD 锁，它们将聚合到该页面的单个 SIREAD 锁中，并释放（移除）关联元组的所有 SIREAD 锁，以减少内存空间。对于所有读取的页面也是如此。</p></li><li><p>为索引创建 SIREAD 锁时，会从头创建页级 SIREAD 锁。使用顺序扫描时，无论是否存在索引和/或 WHERE 子句，都会从头创建关系级 SIREAD 锁。请注意，在某些情况下，此实现可能会导致序列化异常的误报检测。详细信息在第 5.9.4 节中描述。</p></li></ul><p><strong>rw-冲突：</strong></p><ul><li><p>rw-conflict 是一个 SIREAD 锁和两个读写 SIREAD 锁的 txid 的三元组。</p></li><li><p>每当在 SERIALIZABLE 模式下执行 INSERT、UPDATE 或 DELETE 命令时，都会调用 CheckTargetForConflictsIn 函数，并在通过检查 SIREAD 锁检测冲突时创建 rw-conflicts。</p></li><li><p>例如，假设 txid 100 读取 Tuple_1，然后 txid 101 更新 Tuple_1。在这种情况下，由 txid 101 中的 UPDATE 命令调用的 CheckTargetForConflictsIn 函数检测到 txid 100 和 101 之间与 Tuple_1 的 rw-冲突，然后创建一个 rw-conflict {r=100, w=101, {Tuple_1}}。</p></li></ul><p>CheckTargetForConflictOut 和 CheckTargetForConflictIn 函数，以及在 SERIALIZABLE 模式下执行 COMMIT 命令时调用的 PreCommit_CheckForSerializationFailure 函数，都使用创建的 rw-conflicts 检查序列化异常。如果他们检测到异常，则仅提交第一个提交的事务，其他事务将中止（通过<strong>先提交者获胜</strong>方案）。</p><h3 id="5-9-3-SSI的表现"><a href="#5-9-3-SSI的表现" class="headerlink" title="5.9.3 SSI的表现"></a>5.9.3 SSI的表现</h3><p>在这里，我们描述了SSI 如何解决 Write-Skew 异常。我们使用一个简单的表<em>tbl，</em>如下所示：</p><pre class="line-numbers language-bash"><code class="language-bash">testdb<span class="token operator">=</span><span class="token comment" spellcheck="true"># CREATE TABLE tbl (id INT primary key, flag bool DEFAULT false);</span>testdb<span class="token operator">=</span><span class="token comment" spellcheck="true"># INSERT INTO tbl (id) SELECT generate_series(1,2000);</span>testdb<span class="token operator">=</span><span class="token comment" spellcheck="true"># ANALYZE tbl;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>事务Tx_A和Tx_B执行以下命令（图 5.13）。</p><p><img src="/medias/image/fig-5-13.png" alt="图 5.13 写偏斜场景"></p><p>假设所有命令都使用索引扫描。因此，当这些命令被执行时，它们会读取堆元组和索引页，每一个都包含指向相应堆元组的索引元组。见图 5.14。</p><p><img src="/medias/image/fig-5-14.png" alt="图 5.14 图5.13所示场景中索引与表的关系"></p><ul><li><p><strong>T1：</strong> Tx_A 执行 SELECT 命令。该命令读取一个堆元组 (Tuple_2000) 和一页主键 (Pkey_2)。</p></li><li><p><strong>T2：</strong> Tx_B 执行 SELECT 命令。该命令读取一个堆元组 (Tuple_1) 和一页主键 (Pkey_1)。</p></li><li><p><strong>T3：</strong> Tx_A 执行 UPDATE 命令来更新 Tuple_1。</p></li><li><p><strong>T4：</strong> Tx_B 执行 UPDATE 命令来更新 Tuple_2000。</p></li><li><p><strong>T5：</strong> Tx_A 提交。</p></li><li><p><strong>T6：</strong> Tx_B 提交；但是，它由于写倾斜异常而中止。</p></li></ul><p>图 5.15 展示了 PostgreSQL 如何检测和解决上述场景中描述的 Write-Skew 异常。</p><p><img src="/medias/image/fig-5-15.png" alt="图 5.15 SIREAD 锁和 rw 冲突，以及图 5.13 所示场景的时间表"></p><p><strong>T1：</strong></p><ul><li><p>在执行 Tx_A 的 SELECT 命令时，CheckTargetForConflictsOut 创建 SIREAD 锁。在这种情况下，该函数创建两个 SIREAD 锁：L1 和 L2。</p></li><li><p>L1 和 L2 分别与 Pkey_2 和 Tuple_2000 相关联。</p></li></ul><p><strong>T2：</strong></p><ul><li><p>在执行 Tx_B 的 SELECT 命令时，CheckTargetForConflictsOut 创建两个 SIREAD 锁：L3 和 L4。</p></li><li><p>L3 和 L4 分别与 Pkey_1 和 Tuple_1 相关联。</p></li></ul><p><strong>T3：</strong></p><ul><li><p>执行Tx_A的UPDATE命令时，在ExecUpdate前后都会调用CheckTargetForConflictsOut和CheckTargetForConflictsIN。</p></li><li><p>在这种情况下，CheckTargetForConflictsOut 什么也不做。</p></li><li><p>CheckTargetForConflictsIn 创建 rw-conflict C1，也就是 Tx_B 和 Tx_A 之间 Pkey_1 和 Tuple_1 的冲突，因为 Pkey_1 和 Tuple_1 都被 Tx_B 读取，被 Tx_A 写入。</p></li></ul><p><strong>T4：</strong></p><ul><li><p>在执行Tx_B的UPDATE命令时，CheckTargetForConflictsIn创建了rw-conflict C2，即Tx_A和Tx_B之间Pkey_2和Tuple_2000的冲突。</p></li><li><p>在这个场景中，C1 和 C2 在优先级图中创建了一个循环；因此，Tx_A 和 Tx_B 处于不可串行化状态。但是，事务 Tx_A 和 Tx_B 尚未提交，因此 CheckTargetForConflictsIn 不会中止 Tx_B。请注意，发生这种情况是因为 PostgreSQL 的 SSI 实现基于<em>先提交者获胜</em>方案。</p></li></ul><p><strong>T5：</strong></p><ul><li>当 Tx_A 尝试提交时，会调用 PreCommit_CheckForSerializationFailure。此函数可以检测序列化异常，并在可能的情况下执行提交操作。在这种情况下，Tx_A 已提交，因为 Tx_B 仍在进行中。</li></ul><p><strong>T6：</strong></p><ul><li>当 Tx_B 尝试提交时，PreCommit_CheckForSerializationFailure 检测到序列化异常并且 Tx_A 已经提交；因此，Tx_B 被中止。</li></ul><p>此外，如果在 Tx_A 提交后（在<strong>T5 处</strong>）由 Tx_B 执行 UPDATE 命令，则 Tx_B 会立即中止，因为 Tx_B 的 UPDATE 命令调用的 CheckTargetForConflictsIn 检测到序列化异常（图 5.16（1））。</p><p>如果在<strong>T6</strong>执行 SELECT 命令而不是 COMMIT ，Tx_B 会立即中止，因为 Tx_B 的 SELECT 命令调用的 CheckTargetForConflictsOut 检测到序列化异常（图 5.16（2））。</p><p><img src="/medias/image/fig-5-16.png" alt="图 5.16 其他 Write-Skew 场景"></p><p>这个<a href="https://wiki.postgresql.org/wiki/SSI"> Wiki</a>解释了几个更复杂的异常。</p><h3 id="5-9-4-误报序列化异常"><a href="#5-9-4-误报序列化异常" class="headerlink" title="5.9.4 误报序列化异常"></a>5.9.4 误报序列化异常</h3><p>在SERIALIZABLE模式下，始终完全保证并发事务的可序列化性，因为永远不会检测到假阴性序列化异常。但是，在某些情况下，可以检测到假阳性异常；因此，用户在使用SERIALIZABLE模式时应牢记这一点。下面介绍PostgreSQL检测误报异常的情况。</p><p>图 5.17 显示了发生假阳性序列化异常的场景。</p><p><img src="/medias/image/fig-5-17.png" alt="图 5.16 其他 Write-Skew 场景"></p><p>使用顺序扫描时，如SIREAD锁的解释中所述，PostgreSQL创建了一个关系级别的SIREAD锁。图 5.18(1) 显示了 PostgreSQL 使用顺序扫描时的 SIREAD 锁和 rw-conflicts。在这种情况下，将创建与 tbl 的 SIREAD 锁相关联的 rw-conflicts C1 和 C2，并且它们在优先级图中创建一个循环。因此，检测到假阳性写入倾斜异常（即使没有冲突，Tx_A 或 Tx_B 也将中止）。</p><p><img src="/medias/image/fig-5-18.png" alt="图 5.18 假阳性异常 (1) – 使用顺序扫描"></p><p>即使在使用索引扫描时，如果事务 Tx_A 和 Tx_B 获得相同的索引 SIREAD 锁，PostgreSQL 也会检测到误报异常。图 5.19 显示了这种情况。假设索引页Pkey_1包含两个索引项，一个指向Tuple_1，另一个指向Tuple_2。当 Tx_A 和 Tx_B 分别执行 SELECT 和 UPDATE 命令时，Pkey_1 被 Tx_A 和 Tx_B 读写。在这种情况下，rw-conflicts C1 和 C2，两者都与 Pkey_1 相关联，在优先级图中创建一个循环；因此，检测到了假阳性 Write-Skew 异常。（如果 Tx_A 和 Tx_B 获得不同索引页的 SIREAD 锁，则不会检测到误报并且可以提交两个事务。）</p><p><img src="/medias/image/fig-5-19.png" alt="图 5.19 假阳性异常 (2) – 使用相同索引页的索引扫描"></p><hr><h2 id="5-10-所需的维护进程"><a href="#5-10-所需的维护进程" class="headerlink" title="5.10 所需的维护进程"></a>5.10 所需的维护进程</h2><p>PostgreSQL的并发控制机制需要以下维护流程：</p><ol><li><p>删除指向相应死元组的索引元组以及死元组</p></li><li><p>去除clog的不必要部分</p></li><li><p>冻结旧的txids</p></li><li><p>更新FSM、VM和统计信息</p></li></ol><p><a href="http://www.interdb.jp/pg/pgsql05.html#_5.3.2.">第5.3.2节</a>和<a href="http://www.interdb.jp/pg/pgsql05.html#_5.4.3.">第5.4.3节</a>分别解释了对第一个和第二个过程的需求。第三个过程与事务id回绕问题有关，在下面的小节中简要描述。</p><p>在PostgreSQL中，<strong>VACUUM</strong>处理负责这些进程。<a href="http://www.interdb.jp/pg/pgsql06.html">第 6 章</a>描述了vacuum进程。</p><h3 id="5-10-1-冻结处理"><a href="#5-10-1-冻结处理" class="headerlink" title="5.10.1 冻结处理"></a>5.10.1 冻结处理</h3><p>在这里，我们描述txid环绕问题。</p><p>假设插入tuple Tuple_1，txid为100，即Tuple_1的t_xmin为100，服务器已经运行了很长时间，Tuple_1没有被修改。当前的txid为21亿+100，并且执行了SELECT 命令。这时候Tuple_1是<em>可见的，</em>因为txid 100是<em>过去的</em>。然后，执行相同的 SELECT 命令；因此，当前的txid是21亿+101。但是，由于txid 100<em>在未来</em>（图 5.20），因此 Tuple_1<em>不再可见</em>。这就是PostgreSQL 中所谓的<em>事务环绕问题</em>。</p><p><img src="/medias/image/fig-5-20.png" alt="图 5.20 环绕问题"></p><p>为了解决这个问题，PostgreSQL引入了一个叫做 <em>freeze txid</em> 的概念，并实现了一个叫做<em>FREEZE</em>的过程。</p><p>在PostgreSQL中，一个冻结的txid，它是一个特殊的保留txid 2，被定义为总是比所有其他txid旧。换句话说，冻结的txid始终处于非活动状态且可见。</p><p>冻结过程由vacuum进程调用。如果t_xmin值早于当前txid减去 <a href="https://www.postgresql.org/docs/current/static/runtime-config-client.html#GUC-VACUUM-FREEZE-MIN-AGE">vacuum_freeze_min_age</a>（默认值为 5000 万），则冻结进程会扫描所有表文件并将元组的t_xmin重写为冻结的 txid 。这在<a href="http://www.interdb.jp/pg/pgsql06.html">第 6 章</a>有更详细的解释。</p><p>例如，如图5.21a)所示，当前txid为5000万，冻结过程由VACUUM命令调用。在这种情况下，Tuple_1和Tuple_2 的t_xmin都被重写为 2。</p><p>在版本9.4或更高版本中，将元组的t_infomask字段设置为XMIN_FROZEN，而不是将元组的t_xmin重写为冻结的 txid（图 5.21 b）。</p><p><img src="/medias/image/fig-5-21.png" alt="图 5.21 冻结过程"></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><p>[1] Abraham Silberschatz、Henry F. Korth 和 S. Sudarshan，“<a href="https://www.amazon.com//dp/0073523321">数据库系统概念</a>”，McGraw-Hill Education，ISBN-13：978-0073523323</p></li><li><p>[2] Dan RK Ports 和 Kevin Grittner ，“ <a href="https://drkp.net/papers/ssi-vldb12.pdf">PostgreSQL 中的可序列化快照隔离</a>”，VDBL 2012</p></li><li><p>[3] Thomas M. Connolly 和 Carolyn E. Begg，“<a href="https://www.amazon.com/dp/0321523067">数据库系统</a>”，Pearson，ISBN-13：978-0321523068</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> postgresql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> postgresql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>8 缓冲区管理器</title>
      <link href="/2021/8.huan-chong-qu-guan-li-qi/"/>
      <url>/2021/8.huan-chong-qu-guan-li-qi/</url>
      
        <content type="html"><![CDATA[<p>缓冲区管理器管理着共享内存和持久存储之间的数据传输，它会对 DBMS 的性能有着重要的影响。PostgreSQL 的缓冲区管理器十分高效。</p><span id="more"></span><p>[TOC]</p><p>本章介绍了 PostgreSQL 的缓冲区管理器。图8.1展示了缓冲区管理器存储和后端进程之间的关系，后续部分描述以下内容：</p><ul><li>缓冲区管理器的结构</li><li>缓冲区管理器的锁</li><li>缓冲区管理器的工作原理</li><li>环形缓冲区</li><li>脏页刷盘</li></ul><p><img src="/medias/image/fig-8-01.png" alt="图8.1 缓冲区管理器存储和后端进程之间的关系"></p><h2 id="8-1-概览"><a href="#8-1-概览" class="headerlink" title="8.1 概览"></a>8.1 概览</h2><p>本节介绍了为理解后续章节所需的关键概念。</p><h3 id="8-1-1-缓冲区管理器的结构"><a href="#8-1-1-缓冲区管理器的结构" class="headerlink" title="8.1.1 缓冲区管理器的结构"></a>8.1.1 缓冲区管理器的结构</h3><p>PostgreSQL缓冲区管理器由缓冲表、缓冲区描述符和缓冲池组成，这些将在下一节中介绍。缓冲池层存储数据着数据文件页面，如表</p><p>页和索引页，以及相应的<a href="https://jinlid.github.io/2021/8.huan-chong-qu-guan-li-qi/#_5.3.4">自由空间映射</a>和<a href="https://jinlid.github.io/2021/6.vacuum-jin-cheng/#_6.2">可见性映射</a>的页面。缓冲池是一个数组，数据的每个槽中存储数据文件的一页。缓冲池数组的序</p><p>号索引称为<strong>buffer_id</strong>。第<a href="https://jinlid.github.io/2021/8.huan-chong-qu-guan-li-qi/#8.2">8.2</a>、<a href="https://jinlid.github.io/2021/8.huan-chong-qu-guan-li-qi/#8.3">8.3节</a>描述了缓冲区管理器的内部细节。</p><h3 id="8-1-2-缓冲区标签（Buffer-Tag）"><a href="#8-1-2-缓冲区标签（Buffer-Tag）" class="headerlink" title="8.1.2 缓冲区标签（Buffer Tag）"></a>8.1.2 缓冲区标签（Buffer Tag）</h3><p>PostgreSQL中的每个数据文件页面都可以分配唯一的标签，即<strong>缓冲区标签</strong>。当缓冲区管理器收到请求时，PostgreSQL会用到</p><p>目标页面的缓冲区标签。</p><p>缓冲区标签有五个值：</p><ul><li>specOid：包含目标页的关系所属表空间的OID。</li><li>dbOid：包含目标页面的关系所属数据库的OID。</li><li>relNumber：包含目标页面的关系文件的编号。</li><li>blockNum：关系中目标页的块号。</li><li>forkNum：页面所属关系的分支。表、自由空间映射和可见性映射的分支分别定义为 0、1 和 2。</li></ul><p>例如，缓冲区标签 ‘{16821, 16384, 37721, 0, 7}’ 标识位于表的第7号页面，其中OID和分叉号分别为37721和0。该表包含在OID为 16384</p><p>的数据库中，位于OID为16821的表空间下。</p><p>类似地，缓冲区标签 ‘{16821, 16384, 37721, 1, 3}’ 标识位于自由空间映射的第3号页面，其OID和分支分别为37721和1。</p><h3 id="8-1-3-后端进程如何读取数据页"><a href="#8-1-3-后端进程如何读取数据页" class="headerlink" title="8.1.3 后端进程如何读取数据页"></a>8.1.3 后端进程如何读取数据页</h3><p>本小节描述了后端进程如何从缓冲区管理器中读取数据页（图 8.2）。</p><p><img src="/medias/image/fig-8-02.png" alt="图8.2 后端如何从缓冲区管理器读取页面"></p><ol><li>当读取表或索引页时，后端进程向缓冲区管理器发送请求，请求中带有目标页面的 <code>buffer_tag</code> 。</li><li>缓冲区管理器会根据 <code>buffer_tag</code> 返回一个 <code>buffer_id</code>，即目标页面存储在数组中的槽位的序号。如果请求的页面没有存储在缓冲池中，那么缓冲管理器会将页面从持久存储位置加载到其中一个缓冲池槽位中，然后再返回该槽位的 <code>buffer_ID</code>。</li><li>后端进程访问 <code>buffer_ID</code> 的槽位（以读取需要的页面）。</li></ol><p>当后端进程修改缓冲池中的页面时（例如向页面插入元组），这种尚未刷新到持久存储，但已被修改的页面被称为<strong>脏页</strong>。</p><p>第<a href="https://jinlid.github.io/2021/8.huan-chong-qu-guan-li-qi/#_8.4.">8.4 节</a>描述了缓冲区管理器的工作原理。</p><h3 id="8-1-4-页面置换算法"><a href="#8-1-4-页面置换算法" class="headerlink" title="8.1.4 页面置换算法"></a>8.1.4 页面置换算法</h3><p>当所有缓冲池槽位都被占用，并且未包含所请求的页面时，缓冲管理器必须在缓冲池中选择一个页面逐出，用于放置被请求的页面。在计</p><p>算机科学领域，选择页面的算法被称为<strong>页面置换算法</strong>，并且所选择的页面被称为<strong>受害者页面</strong>。</p><p>自计算机科学出现以来，针对页面置换算法的研究一直在进行。许多置换算法被提出，PostgreSQL从8.1版本开始使用<strong>时钟扫描</strong>算法。比</p><p>起以前版本中使用的 LRU 算法更简单高效。</p><p><a href="https://jinlid.github.io/2021/8.huan-chong-qu-guan-li-qi/#_8.4.4">8.4.4 节</a>将描述时钟扫描的细节。</p><h3 id="8-1-5-脏页刷盘"><a href="#8-1-5-脏页刷盘" class="headerlink" title="8.1.5 脏页刷盘"></a>8.1.5 脏页刷盘</h3><p>脏页最终应该被刷新到存储中，然而缓冲区管理器需要额外帮助才能执行此任务。在PostgreSQL中，<strong>checkpointer</strong>和</p><p><strong>background writer</strong>这两个后台进程负责此任务。</p><p>第<a href="https://jinlid.github.io/2021/8.huan-chong-qu-guan-li-qi/#_8.6">8.6 节</a>描述了checkpointer和background writer。</p><blockquote><p>PostgreSQL版本15及更早版本不支持直接I/O，尽管已经对此进行了讨论。请参阅<a href="http://www.postgresql.org/message-id/529E267F.4050700@agliodbs.com">这篇</a>关于pgsql-ML的文章和<a href="http://lwn.net/Articles/580542/">这篇文章</a>。</p><p>在版本 16 中，添加了<a href="https://www.postgresql.org/docs/16/runtime-config-developer.html#GUC-DEBUG-IO-DIRECT">debug-io-direct选项</a>。该选项供开发人员改进PostgreSQL中直接I/O的使用。如果开发顺利的话，Direct I/O将在不久的将来正式支持。</p></blockquote><h2 id="8-2-缓冲区管理器的结构"><a href="#8-2-缓冲区管理器的结构" class="headerlink" title="8.2 缓冲区管理器的结构"></a>8.2 缓冲区管理器的结构</h2><p>PostgreSQL缓冲管理器由三层组成，即<strong>缓冲表层</strong>、<strong>缓冲区描述符层</strong>和<strong>缓冲池层</strong>（图 8.3）。</p><ul><li><p><strong>缓冲表层</strong>：是一个散列表，它存储着页面的 <code>buffer_tags</code> 与描述符的 <code>buffer_id</code> 之间的映射关系。</p></li><li><p><strong>缓冲区描述符层</strong>：是一个由缓冲区描述符组成的数组。每个描述符与缓冲池槽一一对应，并保存着相应槽的元数据。请注意，为了方便起见，采用术语“缓冲区描述符层”，并且仅在本文档中使用。</p></li><li><p><strong>缓冲池层</strong>：是一个数组，每个槽都存储一个数据文件页。数组槽的索引称为<strong>buffer_id</strong>。</p></li></ul><p><img src="/medias/image/fig-8-03.png" alt="图8.3 缓冲区管理器的三层结构"></p><p>这些层将在以下小节中详细描述。</p><h3 id="8-2-1-缓冲表"><a href="#8-2-1-缓冲表" class="headerlink" title="8.2.1 缓冲表"></a>8.2.1 缓冲表</h3><p>缓冲区表在逻辑上可以分为三个部分：散列函数、散列桶槽和数据项（图 8.4）。</p><p>内置的散列函数将 <code>buffer_tag</code> 映射到散列桶槽。即使散列桶槽数大于缓冲池槽数，也可能发生冲突。因此，缓冲表使用<strong>链表的分离链</strong></p><p><strong>接</strong>方法来解决冲突。当数据项映射到同一个桶槽时，该方法将这些数据项存储在同一个链表中，如图8.4所示。</p><p><img src="/medias/image/fig-8-04.png" alt="图8.4 缓冲表"></p><p>数据项包含两个值：页面的 <code>buffer_tag</code> 和包含页面元数据的描述符的 <code>buffer_id</code>。例如，数据项 Tag_A, id=1 表示 buffer_id=1对应的</p><p>缓冲区描述符中，存储着页面 Tag_A 的元数据。</p><blockquote><p> 散列函数</p><p>散列函数是由<a href="https://doxygen.postgresql.org/dynahash_8c.html#ae802f2654df749ae0e0aadf4b5c5bcbd">calc_bucket()</a>和 <a href="https://doxygen.postgresql.org/rege__dfa_8c.html#a6aa3a27e7a0fc6793f3329670ac3b0cb">hash()</a>组合而成。 以下是用伪函数的表示的形式。</p><pre class="line-numbers language-c"><code class="language-c">uint32 bucket_slot <span class="token operator">=</span> <span class="token function">calc_bucket</span><span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token function">hash</span><span class="token punctuation">(</span>BufferTag buffer_tag<span class="token punctuation">)</span><span class="token punctuation">,</span> uint32 bucket_size<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></blockquote><p>暂时还没有对数据项的查找、插入和删除进行解释。这些常见的操作将在以下部分进行详细说明。</p><h3 id="8-2-2-缓冲区描述符"><a href="#8-2-2-缓冲区描述符" class="headerlink" title="8.2.2 缓冲区描述符"></a>8.2.2 缓冲区描述符</h3><p>本节介绍缓冲区描述符的结构，下一节介绍缓冲区描述符层。</p><p>缓冲区描述符存储着页面的元数据，这些与缓冲区描述符相应的页面保存在缓冲池槽中。缓冲区描述符的结构由BufferDesc结构定义。主</p><p>要字段如下所示：</p><ul><li><p><strong>tag</strong> 保存着目标页面的buffer_tag，该页面存储在相应的缓冲池槽中，缓冲区标签在第 8.1节中给出 。</p></li><li><p><strong>buffer_id</strong> 标识了缓冲区描述符，相当于对应缓冲池槽的buffer_id。</p></li><li><p>**refcount **保存当前访问相关页面的 PostgreSQL 进程数。它也称为钉数。当 PostgreSQL 进程访问相应页面时，其引用计数必须加1（refcount++）。访问页面结束后，其引用计数必须减1（refcount–）。当引用计数为零时，即页面当前并未被访问时，则该页将取钉；否则它会被钉住。</p></li><li><p>**usage_count **保存着相应页面加载至相应缓冲池槽后的访问次数。usage_count 会在页面置换算法中被用到，见第8.4.4节。</p></li><li><p><strong>context_lock</strong>和<strong>io_in_progress_lock</strong> 是轻量级锁，用于控制对相关页面的访问。这些字段将在第 8.3.2 节中描述。</p></li><li><p>flags 用于保存相关页面的状态，主要状态如下：</p><ul><li><strong>脏位</strong> 指明相应页面是否为脏页。</li><li><strong>有效位</strong> 指明相应页面是否可以被读写（有效）。例如，如果该位被设置为 <code>valid</code>， 那就意味着对应的缓冲池槽中存储着一个页面，而该描述符中保存着该页面的元数据，因而可以对该页面进行读写。反之如果有效位被设置为 <code>invalid</code>，那就意味着该描述符中并没有保存任何元数据，即对应的页面无法读写，缓冲区管理器可能正在将该页面换出。</li><li>**io进行标记位 **指明缓冲区管理器是否正在从存储读/写相应页面。换句话说，该位指示是否有一个进程持有该描述符上的 io_in_progress_lock。</li></ul></li><li><p><strong>freeNext</strong> 是一个指针，指向下一个描述符，并以此构成一个空闲列表（freelist），这将在下一小节中描述。</p></li></ul><p>结构<code>BufferDesc</code>在<a href="https://github.com/postgres/postgres/blob/master/src/include/storage/buf_internals.h">src/include/storage/buf_internals.h </a>中定义。</p><p>为了简化后续章节的描述，这里定义了三个描述符状态：</p><ul><li><strong>空</strong>：当相应的缓冲池槽不存储页面，即 <code>refcount</code>和 <code>usage_count</code>都是0，该描述符的状态为空。</li><li><strong>钉住</strong>：当相应的缓冲池槽中存储着页面，且有PostgreSQL进程正在访问的相应页面（即 <code>refcount</code>和 <code>usage_count</code>都大于或等于1），该缓冲区描述符的钉住。</li><li><strong>未钉住</strong>：当对应的缓冲池槽存储页面，但没有PostgreSQL进程访问相应页面时（即 <code>usage_count</code>大于等于1，但 <code>refcount</code>为0），这个缓冲区描述符的状态为未钉住。</li></ul><p>每个描述符都处于上述状态之一。描述符的状态会根据特定条件而变化，这将在下一小节中描述。</p><p>缓冲区描述符的状态由彩色框表示。</p><ul><li>（白色）<em>空</em></li><li>（蓝色）<em>钉住</em></li><li>（水蓝色）未钉住</li></ul><p>此外，脏页用 <strong>X</strong>表示。例如，未钉住的脏描述符由 X 表示。</p><h3 id="8-2-3-缓冲区描述符层"><a href="#8-2-3-缓冲区描述符层" class="headerlink" title="8.2.3 缓冲区描述符层"></a>8.2.3 缓冲区描述符层</h3><p>缓冲区描述符的集合构成一个数组。在本文档中，该数组被称为<strong>缓冲区描述符层</strong>。</p><p>当 PostgreSQL 服务器启动时，所有缓冲区描述符的状态都为空。在 PostgreSQL 中，这些描述符构成了一个名为<strong>freelist</strong>的链表，缓冲</p><p>区管理器的初始化状态如图 8.5所示。</p><p><img src="/medias/image/fig-8-05.png" alt="图8.5 缓冲区管理器初始化状态"></p><blockquote><p>注意，在PostgreSQL中的 freelist 是从完全不同于Oracle中的 freelist 的概念。PostgreSQL 的 freelist 只是空缓冲区描述符的链</p><p>表。在<a href="http://www.interdb.jp/pg/pgsql05.html#_5.3.4.">5.3.4 节</a>中已描述，PostgreSQL中与Oracle中的freelist相对应的对象是空闲空间映射（FSM）。</p></blockquote><p>图 8.6 展示了第一个页面是如何加载的。</p><ol><li>从 <code>freelist</code> 的头部取一个空描述符，并将其钉住，即将refcount和usage_count增加1。</li><li>在缓冲表中插入新项，该缓冲表项保存了页面 buffer_tag 与所获描述符 buffer_id 之间的关系。</li><li>将新页面从存储器加载至相应的缓冲池槽中。</li><li>将新页面的元数据保存至所获取的描述符中。</li></ol><p>第二页和后续页面的加载方式类似。第 8.4.2 节提供了其他详细信息。</p><p><img src="/medias/image/fig-8-06.png" alt="图8.6 加载第一页"></p><p>从 freelist 中摘出的描述符始终保存着页面的元数据。换句话说，仍然在使用的非空描述符不会返还到 freelist 中。但当发生以下任一情</p><p>况时，描述符状态变为“空”，并被重新添加至 freelist  中：</p><ol><li>相关表或索引已被删除。</li><li>相关数据库已被删除。</li><li>相关表或索引已经被 VACUUM FULL 命令清理。</li></ol><blockquote><p> 为什么使用 freelist 来维护空描述符？</p><p>保留 freelist 的原因是为了立即获取第一个描述符。这是内存动态分配的常见做法。请参阅<a href="https://en.wikipedia.org/wiki/Free_list">此说明</a>。</p></blockquote><p>缓冲区描述符层包含一个32 位无符号的整数变量，即<strong>nextVictimBuffer</strong>。该变量用于第 8.4.4 节中描述的页面置换算法。</p><h3 id="8-2-4-缓冲池"><a href="#8-2-4-缓冲池" class="headerlink" title="8.2.4 缓冲池"></a>8.2.4 缓冲池</h3><p>缓冲池只是一个用于存储关系数据文件（例如表和索引）页面的简单数组。缓冲池数组的序号索引也就是 <code>buffer_id</code>。</p><p>缓冲池槽的大小为8KB，等于一个页面的大小。因此，每个槽都能存储整个页面。</p><h2 id="8-3-缓冲区管理器锁"><a href="#8-3-缓冲区管理器锁" class="headerlink" title="8.3 缓冲区管理器锁"></a>8.3 缓冲区管理器锁</h2><p>缓冲区管理器会出于不同的目的使用各式各样的锁，本节将介绍后续章节中所必备的一些锁。</p><blockquote><p>注意，本节中描述的锁是缓冲区管理器同步机制的一部分。它们与SQL语句和SQL操作中的锁没有任何关系。</p></blockquote><h3 id="8-3-1-缓冲表锁"><a href="#8-3-1-缓冲表锁" class="headerlink" title="8.3.1 缓冲表锁"></a>8.3.1 缓冲表锁</h3><p><strong>BufMappingLock</strong>保护整个缓冲表的数据完整性。它是一种轻量级的锁，有共享模式和独占模式。在缓冲区表中搜索条目时，后端进</p><p>程会持有共享的 BufMappingLock。插入或删除条目时，后端进程持有独占的 BufMappingLock。</p><p>BufMappingLock 会被分成多个分区，以减少缓冲表中的争用（默认为 128 个分区）。每个 BufMappingLock 分区都保护着一部分相应</p><p>的散列桶槽。</p><p>图 8.7 是一个典型的 BufMappingLock 分区示例。两个后端进程可以同时持有各自分区的 BufMappingLock 独占锁，以便插入新的数据</p><p>项。如果 BufMappingLock 是系统级的锁，那么其中一个进程就需要等待另一个进程完成处理。</p><p><img src="/medias/image/fig-8-07.png" alt="图8.7 两个进程同时获取相应分区的 BufMappingLock独占锁，以插入新数据项"></p><p>缓冲表也需要许多其他锁。例如，在缓冲表内部使用自旋锁（spin lock）来删除数据项。然而，本章不需要这些锁的其他相关知识，因此</p><p>这里省略了对其他锁的介绍。</p><blockquote><p>在 9.4 版本之前，BufMappingLock 默认被拆分为 16 个独立的锁。</p></blockquote><h3 id="8-3-2-缓冲区描述符相关的锁"><a href="#8-3-2-缓冲区描述符相关的锁" class="headerlink" title="8.3.2 缓冲区描述符相关的锁"></a>8.3.2 缓冲区描述符相关的锁</h3><p>每个缓冲区描述符都会用到内容锁（<strong>content_lock</strong>）与IO进行锁（<strong>io_in_progress_lock</strong>）这两个轻量级锁，以控制对相应缓冲池槽页</p><p>面的访问。当检查或更改描述符本身字段的值时，就会用到自旋锁。</p><h4 id="8-3-2-1-内容锁"><a href="#8-3-2-1-内容锁" class="headerlink" title="8.3.2.1 内容锁"></a>8.3.2.1 内容锁</h4><p>内容锁（content_lock）是一个典型的强制限制访问的锁。它有共享和独占两种模式。当读取页面时，后端进程以共享模式获取页面相应</p><p>缓冲区描述符中的 content lock。执行下列操作之一时，则会获取独占模式的 content lock。</p><p>但是，在执行以下操作之一时会获得一个独占的 content_lock：</p><ul><li><p>将行（即元组）插入页面，或更改页面中元组的  t_xmin/t_xmax 字段（t_xmin 和 t_xmax 在第 5.2 节中介绍，简单地说，这些字段</p><p>会在相关元组被删除或更新行时发生更改） 。</p></li><li><p>物理移除元组，或压紧页面上的空闲空间（由清理过程和HOT执行，分别在第6章和第7章中有介绍过）。</p></li><li><p>冻结页面中的元组（冻结过程在第 5.10.1节和第 6.3节中有过介绍）。</p></li></ul><p>官方<a href="https://github.com/postgres/postgres/blob/master/src/backend/storage/buffer/README">README</a> 文件包含了更多的细节。</p><h4 id="8-3-2-2-IO进行锁"><a href="#8-3-2-2-IO进行锁" class="headerlink" title="8.3.2.2 IO进行锁"></a>8.3.2.2 IO进行锁</h4><p>IO进行锁（io_in_progress_lock） 用于等待缓冲区上的 I/O 完成。当 PostgreSQL 进程加载/写入页面数据时，该进程在访问页面期间持</p><p>有相应描述符上独占的 io_in_progress_lock。</p><h4 id="8-3-2-3-自旋锁"><a href="#8-3-2-3-自旋锁" class="headerlink" title="8.3.2.3 自旋锁"></a>8.3.2.3 自旋锁</h4><p>当检查或更改标记字段或其他字段时，例如 refcount 和 usage_count，会使用自旋锁。下面是两个使用自旋锁的具体例子：</p><ol><li><p>钉住缓冲区描述符.</p><p>获取缓冲区描述符上的自旋锁。</p><p>将其 refcount 和 usage_count 的值加1。</p><p>释放自旋锁。</p><pre class="line-numbers language-c-monosp"><code class="language-c-monosp">LockBufHdr(bufferdesc);    /* Acquire a spinlock */bufferdesc->refcont++;bufferdesc->usage_count++;UnlockBufHdr(bufferdesc); /* Release the spinlock */<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>将脏位设置为”1“。</p><p>获取缓冲区描述符上的自旋锁。</p><p>使用位操作将脏位置设置为“1”。</p><p>释放自旋锁。</p><pre class="line-numbers language-c"><code class="language-c"><span class="token macro property">#<span class="token directive keyword">define</span> BM_DIRTY             (1 &lt;&lt; 0)    </span><span class="token comment" spellcheck="true">/* 数据需要回写 */</span><span class="token macro property">#<span class="token directive keyword">define</span> BM_VALID             (1 &lt;&lt; 1)    </span><span class="token comment" spellcheck="true">/* 数据有效 */</span><span class="token macro property">#<span class="token directive keyword">define</span> BM_TAG_VALID         (1 &lt;&lt; 2)    </span><span class="token comment" spellcheck="true">/* 已经分配了TAG */</span><span class="token macro property">#<span class="token directive keyword">define</span> BM_IO_IN_PROGRESS    (1 &lt;&lt; 3)    </span><span class="token comment" spellcheck="true">/* 正在进行读写 */</span><span class="token macro property">#<span class="token directive keyword">define</span> BM_JUST_DIRTIED      (1 &lt;&lt; 5)    </span><span class="token comment" spellcheck="true">/* 开始写之后数据刚被修改 */</span><span class="token function">LockBufHdr</span><span class="token punctuation">(</span>bufferdesc<span class="token punctuation">)</span><span class="token punctuation">;</span>bufferdesc<span class="token operator">-></span>flags <span class="token operator">|</span><span class="token operator">=</span> BM_DIRTY<span class="token punctuation">;</span><span class="token function">UnlockBufHdr</span><span class="token punctuation">(</span>bufferdesc<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>其他标记位也是通过相同的方式来设置的。</p></li></ol><blockquote><p>用原子操作替换缓冲区管理器的自旋锁</p><p>在 9.6 版本中，缓冲区管理器的自旋锁将被替换为原子操作。可以参考<a href="https://commitfest.postgresql.org/9/408/">commitfest </a>中提交日志的内容。如果想了解详细信息，请参</p><p>阅<a href="http://www.postgresql.org/message-id/flat/2400449.GjM57CE0Yg@dinodell#2400449.GjM57CE0Yg@dinodell">此讨论</a>。</p></blockquote><h2 id="8-4-缓冲区管理器的工作原理"><a href="#8-4-缓冲区管理器的工作原理" class="headerlink" title="8.4 缓冲区管理器的工作原理"></a>8.4 缓冲区管理器的工作原理</h2><p>本节介绍缓冲区管理器的工作原理。当后端进程想要访问所需页面时，它会调用 <em>ReadBufferExtended</em> 函数。</p><p>函数 <em>ReadBufferExtended</em> 的行为因场景而异，在逻辑上具体可以分为三种情况。每种情况都将用一小节介绍。第8.4.4节将介绍</p><p>PostgreSOL中基于时钟扫描的页面置换算法。</p><h3 id="8-4-1-访问存储在缓冲池中的页面"><a href="#8-4-1-访问存储在缓冲池中的页面" class="headerlink" title="8.4.1 访问存储在缓冲池中的页面"></a>8.4.1 访问存储在缓冲池中的页面</h3><p>当从缓冲池槽中的页面里读取行时，PostgreSQL 进程获取相应缓冲区描述符的共享 content_lock，因而缓冲池槽可以同时被多个进程读</p><p>取。</p><p>当向页面插入（及更新、删除）行时，该 postgres 后端进程获取相应缓冲区描述符的独占 content_lock （注意，这里必须将相应页面的脏位置设为”1”）。</p><p>访问完页面后，相应缓冲区描述符的引用计数值减1。</p><p>图8.8是访问存储在缓冲池中的页面示意图。</p><p><img src="/medias/image/fig-8-08.png" alt="图8.8 访问存储在缓冲池中的页面"></p><p>我们来介绍最简单的情况，即所需页面已经存储在缓冲池中。在这种情况下，缓冲区管理器会执行以下步骤：</p><ol><li>创建所需页面的 buffer_tag（在本例中 buffer_tag 是’Tag_C’），并使用散列函数计算与描述符相对应的散列桶槽。</li><li>获取相应散列桶槽分区上的 <em>BufMappingLock</em> 共享锁。</li><li>查找标签为’Tag_C’的条目，并从条目中获取buffer_id。本例中buffer_id为2。</li><li>将buffer_id=2的缓冲区描述符钉住，即将描述符的 refcount 和usage_count增加1。</li><li>释放 BufMappingLock。</li><li>访问 bufferid=2 的缓冲池槽。</li></ol><h3 id="8-4-2-将页面从存储加载到空槽"><a href="#8-4-2-将页面从存储加载到空槽" class="headerlink" title="8.4.2 将页面从存储加载到空槽"></a>8.4.2 将页面从存储加载到空槽</h3><p>图 8.9 是将页面从存储加载到空槽的示意图。</p><p><img src="/medias/image/fig-8-09.png" alt="图8.9 将页面从存储加载到空槽"></p><p>在第二种情况下，假设所需页面不在缓冲池中，且 freelist 中有空闲元素（空描述符）。</p><p>这时，缓冲区管理器将执行以下步骤：</p><ol><li><p>查找缓冲区表（本节假设页面不存在，找不到对应页面）。</p><p>第一，创建所需页面的buffer_tag（本例中buffer_tag 为’Tag_E’）并计算其散列桶槽。</p><p>第二，以共享模式获取相应分区上的 BufMappingLock。</p><p>第三，查找缓冲区表（根据假设，这里没找到）。</p><p>第四，释放 BufMappingLock。</p></li><li><p>从 freelist 中获取空缓冲区描述符，并将其钉住。在本例中所获的描述符 buffer_id=4。</p></li><li><p>以独占模式获取相应分区的 BufMappingLock （此锁将在步骤(6)中被释放）。</p></li><li><p>创建一条新的缓冲表数据项：buffer_tag=’Tag_E，buffer id=4，并将其插入缓冲区表中。</p></li><li><p>将页面数据从存储加载至 buffer_id=4 的缓冲池槽中，如下所示:</p><p>第一，以排他模式获取相应描述符的 io_in_progress_lock。</p><p>第二，将相应描述符的 IO_IN_PROGRESS 标记位设置为1，以防其他进程访问。</p><p>第三，将所需的页面数据从存储加载到缓冲池插槽中。</p><p>第四，更改相应描述符的状态，将 IO_IN_PROGRESS 标记位设置为”0”，且VALID标记位设置为”1”。</p><p>第五，释放 io_in_progress_lock。</p></li><li><p>释放相应分区的 BufMappingLock。</p></li><li><p>访问 bufferid=4 的缓冲池槽。</p></li></ol><h3 id="8-4-3-将页面从存储加载到受害者缓冲池槽"><a href="#8-4-3-将页面从存储加载到受害者缓冲池槽" class="headerlink" title="8.4.3 将页面从存储加载到受害者缓冲池槽"></a>8.4.3 将页面从存储加载到受害者缓冲池槽</h3><p>在这种情况下，假设所有缓冲池槽位都被页面占用，且未存储所需的页面。图 8.10、图8.11是将页面从存储加载到受害者缓冲池槽的示意</p><p>图。</p><p><img src="/medias/image/fig-8-10.png" alt="图8.10 将页面从存储加载到受害者缓冲池槽"></p><p><img src="/medias/image/fig-8-11.png" alt="图8.11 将页面从存储加载到受害者缓冲池槽（接图8.10）"></p><p>缓冲区管理器将执行以下步骤：</p><ol><li><p>创建所需页面的 buffer_tag 并查找缓冲表。在本例中假设 buffer_tag 是’Tag_M’（且相应的页面在缓冲区中找不到）。</p></li><li><p>使用时钟扫描算法选择一个受害者缓冲池槽位，从缓冲表中获取包含着受害者槽位 buffer_id 的旧表项，并在缓冲区描述符层将受害</p><p>者槽位的缓冲区描述符钉住。本例中受害者槽的 buffer_id=5，旧表项为 ‘Tag_F’，id = 5。时钟扫描将在下一节介绍。</p></li><li><p>如果受害者页面是脏页，则将其刷盘（write &amp; fsnc），否则进入步骤4。</p><p>在使用新数据覆盖脏页之前，必须将脏页写入存储中。脏页的刷盘步骤如下:</p><p>第一，获取 buffer_id=5 描述符上的共享 content_lock 和独占 io_in_progress_lock 。</p><p>第二，更改相应描述符的状态：相应 IO_IN_PROCESS 位设置为”1”，JUST_DIRTIED 位设置为”0”。</p><p>第三,根据具体情况，调用 <em>XLogFlush()</em> 函数将WAL缓冲区上的 WAL数据写入当前 WAL段文件（WAL和XLogFlush函数将在第9章中介绍）。</p><p>第四，将受害者页面的数据刷盘至存储中。</p><p>第五，更改相应描述符的状态：将 IO_IN_PROCESS 位设置为”0,将VALID位设置为”1”。</p><p>第六，释放 io_in_progress_lock 和 content_lock。</p></li><li><p>以排他模式获取缓冲区表中旧表项所在分区上的 BufMappingLock。</p></li><li><p>获取新表项所在分区上的 BufMappingLock，并将新表项插入缓冲表：</p><p>第一，创建新表项：由 buffer_tag=’Tag M’与受害者的 buffer_id 组成的新表项。</p><p>第二，以独占模式获取新表项所在分区上的 BufMappingLock。</p><p>第三，将新表项插入缓冲区表中。</p></li><li><p>从缓冲表中删除旧表项，并释放旧表项所在分区的 BufMappingLock。</p></li><li><p>将目标页面数据从存储加载至受害者槽位，然后用 buffer_id=5 更新描述符的标识字段，将脏位设置为0，并按流程初始化其他标记</p><p>位。</p></li><li><p>释放新表项所在分区上的 BufMappingLock。</p></li><li><p>访问 buffer_id=5 对应的缓冲区槽位。</p></li></ol><h3 id="8-4-4-页替换算法：时钟扫描"><a href="#8-4-4-页替换算法：时钟扫描" class="headerlink" title="8.4.4 页替换算法：时钟扫描"></a>8.4.4 页替换算法：时钟扫描</h3><p>本节的其余部分介绍了 <strong>时钟扫描</strong>算法。该算法是NFU（Not Frequently Used）算法的变体，开销较低，能高效地选出较少使用的页面。</p><p>我们将缓冲区描述符想象为一个循环列表，如图8.12所示。缓冲区描述符为黑色或灰色的方框，框中的数字显示每个描述符的 </p><p>usage_count。而 nextVictimBuffer 是一个32位的无符号整型变量，它总是指向某个缓冲区描述符并按顺时针顺序旋转。</p><p><img src="/medias/image/fig-8-12.png" alt="图8.12 时钟扫描 "></p><p>伪代码：时钟扫描<br>WHILE true</p><ol><li><p>获取 nextVictimBuffer 指向的候选缓冲区描述符。</p></li><li><p>如果候选描述符未被钉住，则进入步骤3，否则进入步骤4。</p></li><li><p>如果候选描述符的 usage_count 为0，则选择该描述符对应的槽作为受害者，并进入步骤5，否则将此描述符的 usage_count 减1，</p><p>并继续执行步骤4。</p></li><li><p>将 nextVictimBuffer 迭代至下一个描述符（如果到末尾则回绕至头部）并返回步骤1，重复直到找到受害者。</p></li><li><p>返回受害者的 buffer_id。</p></li></ol><p>该算法的伪代码与算法描述如下：</p><ol><li><p>nextVictimBuffer 指向第一个描述符(buffer_id=1)，但因为该描述符被钉住了，所以跳过。</p></li><li><p>nextVictimBuffer 指向第二个描述符(buffer_id=2)，该描述符未被钉住，但其 usage_count 为2，因此该描述符的 usage_count 将减</p><p>1,而nextVictimBuffer 选代至第三个候选描述符。</p></li><li><p>nextVictimBuffer 指向第三个描述符(buffer_id=3)，该描述符未被钉住，但其 usage_count=0，因而成为本轮的受害者。</p></li><li><p>当 nextVictimBuffer 扫过未钉住的描述符时，其 usage_count 会减1。因此只要缓冲池中存在未钉住的描述符，该算法总能在旋转若于次 nextVictimBuffer 后，找到一个 usage_count 为0的受害者。</p></li></ol><h2 id="8-5-环形缓冲器"><a href="#8-5-环形缓冲器" class="headerlink" title="8.5 环形缓冲器"></a>8.5 环形缓冲器</h2><p>在读取或写入大表时，PostgreSQL会使用<strong>环形缓冲区</strong>而不是缓冲池。环形缓冲器是一个很小的临时缓冲区域。当满足下列任一条件时，</p><p>PostgreSQL 将在共享内存中分配一个环形缓冲区。</p><ol><li><p>批量读取，当扫描关系读取数据的大小超过缓冲池的四分之一时，环形缓冲区的大小为256 KB。</p></li><li><p>批量写入，当执行下列的 SQL 命令时。环形缓冲区大小为16 MB。</p><p>COPY FROM</p><p>CREATE TABLE AS</p><p>CREATE MATERIALIZED VIEW 或 REFRESH MATERIALIZED VIEW 命令</p><p>ALTER TABLE</p></li><li><p>清理过程，当自动清理守护进程执行清理过程时，环形缓冲区的大小为256 KB。</p></li></ol><p>分配的环形缓冲区将在使用后立即释放。环形缓冲区的好处显而易见，如果后端进程在不使用环形缓冲区的情况下读取大表，则所有存储</p><p>在缓冲池中的页面都会被移除，这会导致缓存命中率降低。环形缓冲区可以避免此问题。</p><blockquote><p>为什么批量读取和清理过程的默认环形缓冲区大小为256KB</p><p>源代码中缓冲区管理器目录下的 <a href="https://github.com/postgres/postgres/blob/master/src/backend/storage/buffer/README">README</a>中解释了这个问题。</p><p>顺序扫描使用 256KB的环形缓冲区，它足够小，因而能放入L2缓存中，从而使得操作系统缓存到共享缓冲区的页面传输变得高效。</p><p>通常更小一点也可以，但环形缓冲区需要足够大到能同时容纳扫描中被钉住的所有页面。</p></blockquote><h2 id="8-6-脏页刷盘"><a href="#8-6-脏页刷盘" class="headerlink" title="8.6 脏页刷盘"></a>8.6 脏页刷盘</h2><p>除了置换受害者页面之外，检查点进程和后台写入器进程也会将脏页刷盘至存储中。尽管两个进程都具有相同的功能（脏页刷盘），但是</p><p>它们有着不同的角色和行为。</p><p>检查点进程将检查点记录写入WAL段文件，并在检查点开始时进行脏页刷盘。第9.7节介绍了检查点和检查点开始的时机。</p><p>后台写入器的目的是通过少量多次的脏页刷盘，减少检查点带来的密集写入的影响。后台写入器会一点点地将脏页落盘，尽可能减少对数</p><p>据库活动造成的影响。在默认情况下，后台写入器每 200ms被唤醒一次（由参数 <code>bgwriter_delay</code> 定义），且最多刷写 </p><p><code>bgwriter_lrumaxpages</code> 个页面（默认为100个页面）。</p><blockquote><p>为什么检查点进程与后台写入器相分离</p><p>在 9.1及更低版本中，后台写入器会规律性地执行检查点进程。在 9.2 版本中，检查点进程从后台写入被单独剥离出来。原因在一篇</p><p>题为“将检查点进程与后台写入器相分离”的提案中有介绍。下面是一些摘录：</p><p>当前（在 2011 年）后台写入器进程既执行后台写入，又负责检查点，还处理一些其他的职责。这意味着我们没法在不停止后台写入</p><p>的情况下执行检查点最终的 fsync。因此，在同一个进程中做两件事会有负面的性能影响。</p><p>此外，在9.2版本中，我们的一个目标是通过将轮询循环替换为锁存器，从而降低功耗。bgwriter 中的循环复杂度太高了，以至于无</p><p>法找到一种简单的使用锁存器的方法。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> postgresql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> postgresql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>7 仅堆元组和仅索引扫描</title>
      <link href="/2021/7.jin-dui-yuan-zu-he-jin-suo-yin-sao-miao/"/>
      <url>/2021/7.jin-dui-yuan-zu-he-jin-suo-yin-sao-miao/</url>
      
        <content type="html"><![CDATA[<p>本章描述了与索引扫描相关的两个特性，它们是仅堆元组和仅索引扫描。</p><span id="more"></span><p>[TOC]</p><h2 id="7-1-仅堆元组（热）"><a href="#7-1-仅堆元组（热）" class="headerlink" title="7.1 仅堆元组（热）"></a>7.1 仅堆元组（热）</h2><p>HOT 在 8.3 版中实现，当更新的行存储在与存储旧行的同一表页中时，以有效地使用索引和表的页。HOT 还减少了 VACUUM 处理的必要性。</p><p>本章简单介绍HOT，HOT的细节在源代码目录下的<a href="https://github.com/postgres/postgres/blob/master/src/backend/access/heap/README.HOT">README.HOT</a>中有描述。首先，第 7.1.1 节描述了如何在没有 HOT 的情况下更新行，以阐明解决的问题。接下来，第 7.1.2 节描述了 HOT 的执行方式。</p><h3 id="7-1-1-更新没有-HOT-的行"><a href="#7-1-1-更新没有-HOT-的行" class="headerlink" title="7.1.1 更新没有 HOT 的行"></a>7.1.1 更新没有 HOT 的行</h3><p>假设表tbl有两列：id和data；id是tbl的主键。</p><pre class="line-numbers language-sql-monosp"><code class="language-sql-monosp">testdb=# \d tbl                Table "public.tbl" Column |  Type   | Collation | Nullable | Default --------+---------+-----------+----------+--------- id     | integer |           | not null |  data   | text    |           |          | Indexes:    "tbl_pkey" PRIMARY KEY, btree (id)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>表tbl有 1000 个元组；id 为1000的最后一个元组存储在表的第 5 页。索引元组指向对应的最后一个元组，其键是1000，tid是’(5,1)’。参见图 7.1(a)。</p><p><img src="/medias/image/fig-7-01.png" alt="图 7.1 更新没有 HOT 的行"></p><p>我们考虑如何在没有 HOT 的情况下更新最后一个元组。</p><pre class="line-numbers language-sql-monosp"><code class="language-sql-monosp">testdb=# UPDATE tbl SET data = 'B' WHERE id = 1000;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>在这种情况下，PostgreSQL 不仅会在索引页中插入新的表元组，还会插入新的索引元组。参见图 7.1(b)。</p><p>索引元组的插入会消耗索引页空间，索引元组的插入和清空成本都很高。HOT 减少了这些问题的影响。</p><h3 id="7-1-2-HOT-表现如何"><a href="#7-1-2-HOT-表现如何" class="headerlink" title="7.1.2 HOT 表现如何"></a>7.1.2 HOT 表现如何</h3><p>当一行被 HOT 更新时，如果更新后的行存储在与旧行的同一个表页中，PostgreSQL 不会插入相应的索引元组并将 HEAP_HOT_UPDATED 位和 HEAP_ONLY_TUPLE 位设置为旧的 t_informask2 字段元组和新元组，分别参见图7.2 和 7.3。</p><p><img src="/medias/image/fig-7-02.png" alt="图 7.2 用 HOT 更新一行"></p><p>例如，在这种情况下，“Tuple_1”和“Tuple_2”分别设置为 HEAP_HOT_UPDATED 位和 HEAP_ONLY_TUPLE 位。</p><p>此外，HEAP_HOT_UPDATED 和 HEAP_ONLY_TUPLE 位的使用与<em>修剪</em>和<em>碎片整理</em>过程无关，下文将介绍这些过程。</p><p><img src="/medias/image/fig-7-03.png" alt="图 7.3 HEAP_HOT_UPDATED 和 HEAP_ONLY_TUPLE 位"></p><p>下面介绍PostgreSQL在HOT更新元组后，如何使用索引扫描访问更新后的元组。参见图 7.4(a)。</p><p><img src="/medias/image/fig-7-04.png" alt="图 7.4 修剪线指针"></p><p>(1) 找到指向目标元组的索引元组。</p><p>(2) 访问从获取索引元组指向的行指针’[1]’。</p><p>(3) 读取“Tuple_1”。</p><p>(4) 通过’Tuple_1’的t_ctid读取’Tuple_2’。</p><p>在这种情况下，PostgreSQL 读取两个元组，’Tuple_1’ 和 ‘Tuple_2’，并使用<a href="http://www.interdb.jp/pg/pgsql05.html">第 5 章</a>中描述的并发控制机制决定哪个是可见的。</p><p>但是，如果删除表页中的死元组，则会出现问题。例如，在图 7.4(a) 中，如果 ‘Tuple_1’ 因为它是一个死元组而被删除，则无法从索引中访问 ‘Tuple_2’。</p><p>为了解决这个问题，PostgreSQL 在适当的时候将指向旧元组的行指针重定向到指向新元组的行指针。在 PostgreSQL 中，这种处理称为<strong>pruning</strong>。图 7.4(b) 描述了 PostgreSQL 如何在修剪后访问更新的元组。</p><p>(1) 找到索引元组。</p><p>(2) 访问从获取索引元组指向的行指针’[1]’。</p><p>(3) 通过重定向的行指针访问指向’Tuple_2’的行指针’[2]’。</p><p>(4) 读取从行指针’[2]’指向的’Tuple_2’。</p><p>如果可能，将在执行 SELECT、UPDATE、INSERT 和 DELETE 等 SQL 命令时执行修剪处理。具体的执行时序在本章中不做描述，因为它非常复杂。<a href="https://github.com/postgres/postgres/blob/master/src/backend/access/heap/README.HOT">README.HOT</a> 文件中描述了详细信息。</p><p>如果可能，PostgreSQL 会在适当的时间删除死元组，就像在修剪过程中一样。在 PostgreSQL 的文档中，这种处理称为<strong>碎片整理</strong>。图 7.5 描述了 HOT 的碎片整理。</p><p><img src="/medias/image/fig-7-05.png" alt="图 7.5 死元组的碎片整理"></p><p>请注意，碎片整理的成本低于正常 VACUUM 处理的成本，因为碎片整理不涉及删除索引元组。</p><p>因此，使用 HOT 减少了索引页和表的消耗；这也减少了 VACUUM 处理必须处理的元组数量。因此，HOT 对性能有很好的影响，因为它最终通过更新和 VACUUM 处理的必要性减少了索引元组的插入次数。</p><p><em>HOT 不可用的情况</em></p><p>为了清楚地了解 HOT 的性能，这里描述了 HOT 不可用的情况。</p><ol><li><p>当更新的元组存储在另一个页面中时，该页面没有存储旧的元组，指向该元组的索引元组也被插入到索引页面中。参见图 7.6(a)。</p></li><li><p>当索引元组的键值更新时，新的索引元组被插入到索引页中。参见图 7.6(b)。</p></li></ol><p><img src="/medias/image/fig-7-06.png" alt="图 7.6 HOT 不可用的情况"></p><p> <em>HOT相关统计</em></p><p><a href="https://www.postgresql.org/docs/current/static/monitoring-stats.html#PG-STAT-ALL-TABLES-VIEW">pg_stat_all_tables</a>所述视图提供为每个表的统计值。另请参阅此<a href="https://github.com/s-hironobu/pg_stats">扩展名</a>。</p><h2 id="7-2-仅索引扫描"><a href="#7-2-仅索引扫描" class="headerlink" title="7.2 仅索引扫描"></a>7.2 仅索引扫描</h2><p>为了降低 I/O（输入/输出）成本，当 SELECT 语句的所有目标条目都包含在索引键。几乎所有商业 RDBMS 都提供这种技术，例如 DB2 和 Oracle。PostgreSQL 从 9.2 版本开始引入了这个选项。</p><p>下面通过一个具体的例子，说明PostgreSQL中的 <code>index-only</code> 扫描是如何进行的。</p><p>该示例的假设解释如下：</p><ul><li>表定义</li></ul><p>我们有一个表tbl，其定义如下所示：</p><pre class="line-numbers language-sql-monosp"><code class="language-sql-monosp">testdb=# \d tbl      Table "public.tbl" Column |  Type   | Modifiers --------+---------+----------- id     | integer |  name   | text    |  data   | text    | Indexes:    "tbl_idx" btree (id, name)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>索引</li></ul><p>表 tbl 有一个索引 tbl_idx，它由两列组成：id 和 name。</p><ul><li>元组</li></ul><p>tbl 已经插入了元组。</p><p>Tuple_18，其id为18，名称为Queen，存储在第0页。</p><p>Tuple_19，其id为19，名称为BOSTON，存储在第1页。</p><ul><li>可见性</li></ul><p>第 0 页中的所有元组始终可见；第1页中的元组并不总是可见的。注意，每个页面的可见性存储在对应的可见性图中，可见性图在<a href="http://www.interdb.jp/pg/pgsql06.html#_6.2.">第6.2 节</a>中描述。</p><p>让我们探讨一下 PostgreSQL 在执行以下 SELECT 命令时如何读取元组。</p><pre class="line-numbers language-sql-monosp"><code class="language-sql-monosp">testdb=# SELECT id, name FROM tbl WHERE id BETWEEN 18 and 19; id |  name   ----+-------- 18 | Queen 19 | Boston(2 rows)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>此查询从表的两列获取数据：id 和name，索引tbl_idx 由这些列组成。因此，当使用索引扫描时，乍一看似乎不需要访问表页，因为索引元组包含必要的数据。实际上，PostgreSQL 原则上必须检查元组的可见性，索引元组没有任何有关事务的信息，例如堆元组的 <code>t_xmin</code> 和 <code>t_xmax</code>，这在<a href="http://www.interdb.jp/pg/pgsql05.html#_5.2.">第5.2节 </a>中进行描述了。因此，PostgreSQL 必须访问表数据来检查索引元组中数据的可见性，这有点本末倒置。</p><p>为了避免这种困境，PostgreSQL 使用了目标表的可见性映射。如果存储在一个页面中的所有元组都可见，则PostgreSQL使用索引元组的键，不访问索引元组指向的表页来检查其可见性；否则，PostgreSQL 从索引元组中读取指向的表元组，并检查元组的可见性，这是普通的过程。</p><p>本例中不需要访问Tuple_18，因为存储Tuple_18的第0页是可见的，即第0页中包含Tuple_18的所有元组都是可见的。相比之下，需要访问Tuple_19来处理并发控制，因为第一页的可见性是不可见的。参见图 7.7。</p><p><img src="/medias/image/fig-7-07.png" alt="图 7.7 仅索引扫描如何执行"></p>]]></content>
      
      
      <categories>
          
          <category> postgresql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> postgresql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>9 预写日志—WAL</title>
      <link href="/2021/9.yu-xie-ri-zhi-wal/"/>
      <url>/2021/9.yu-xie-ri-zhi-wal/</url>
      
        <content type="html"><![CDATA[<p><strong>事务日志</strong>是数据库的重要组成部分，因为所有的数据库管理系统都要求即使发生系统故障也不丢失任何数据。它是数据库系统中所有更改操作的历史日志，以确保没有由于故障（例如电源故障）或其他导致服务器崩溃的服务器故障而丢失数据。由于日志包含有关已执行的每个事务的足够信息，因此数据库服务器应该能够通过在服务器崩溃的情况下，重新回放事务日志中的更改操作来恢复数据库集群。</p><span id="more"></span><p>[TOC]</p><p>在计算机科学领域，<strong>WAL</strong>是 <strong>Write Ahead Logging</strong> 的首字母缩写，它是一种将更改操作都写入事务日志的协议或规则，而在PostgreSQL中，WAL是 <strong>Write Ahead Log</strong> 的首字母缩写。</p><p>WAL机制在7.1版本中首次实现，以减轻服务器崩溃的影响。这也成为可能的执行点即时恢复（PITR）和流复制（SR），这两者将分别在<a href="https://jinlid.github.io/2021/10-ji-chu-bei-fen-he-shi-jian-dian-hui-fu/">第10</a>和<a href="https://jinlid.github.io/2021/11-liu-fu-zhi/">第11章</a>中介绍。</p><p>尽管了解WAL机制对于使用PostgreSQL的系统集成和管理至关重要，但由于该机制的复杂性，无法对其描述进行简要总结。所以对PostgreSQL中WAL的完整解释如下：第一部分已经提供了WAL的整体图，介绍了一些重要的概念和关键词。在随后的部分中，将描述以下主题：</p><ul><li><p>WAL（事务日志）的逻辑结构和物理结构</p></li><li><p>WAL数据内部布局</p></li><li><p>WAL数据的写入</p></li><li><p>WAL写进程</p></li><li><p>检查点处理</p></li><li><p>数据库恢复处理</p></li><li><p>管理WAL段文件</p></li><li><p>连续归档</p></li></ul><h2 id="9-1-概述"><a href="#9-1-概述" class="headerlink" title="9.1 概述"></a>9.1 概述</h2><p>我们先来看看WAL机制的概况。为了澄清WAL一直在处理的问题，第一小节显示了如果PostgreSQL没有实现WAL发生崩溃时会发生什么，第二小节介绍了一些关键概念，并展示了本章主要主题的概述、WAL数据的编写和数据库恢复处理。最后一小节完成了WAL的概述，添加了另一个关键概念。</p><p>在本节中，为了简化描述，使用了仅包含一页的表TABLE_A。</p><h3 id="9-1-1-没有-WAL-的插入操作"><a href="#9-1-1-没有-WAL-的插入操作" class="headerlink" title="9.1.1 没有 WAL 的插入操作"></a>9.1.1 没有 WAL 的插入操作</h3><p>如<a href="https://jinlid.github.io/2021/8.huan-chong-qu-guan-li-qi/">第 8 章</a>所述，为了提供对关系页面的高效访问，每个DBMS都实现了共享缓冲池。</p><p>假设我们在没有实现WAL特性的PostgreSQL上的TABLE_A中插入了一些数据元组；这种情况如图 9.1 所示。</p><p><img src="/medias/image/fig-9-01.png" alt="图 9.1 没有 WAL 的插入操作"></p><p>(1) 发出第一条INSERT语句，PostgreSQL将TABLE_A的页面从数据库集群加载到内存共享缓冲池中，并在页面中插入一个元组。该页面不会立即写入数据库集群。（修改后的页面通常称为<strong>脏页</strong>）</p><p>(2) 发出第二条INSERT语句，PostgreSQL在缓冲池上的页中插入一个新元组。此页尚未写入存储。</p><p>(3) 如果操作系统或PostgreSQL服务器因停电等任何原因出现故障，所有插入的数据都会丢失。</p><p>因此，没有WAL的数据库容易受到系统故障的影响。</p><blockquote><p>在引入 WAL 之前，PostgreSQL通过在每次更改内存中的页面时发出同步系统调用来同步写入磁盘，以确保持久性。因此，INSERT和UPDATE等修改命令的性能非常差。</p></blockquote><h3 id="9-1-2-插入操作和数据库恢复"><a href="#9-1-2-插入操作和数据库恢复" class="headerlink" title="9.1.2 插入操作和数据库恢复"></a>9.1.2 插入操作和数据库恢复</h3><p>为了在不影响性能的情况下处理上述系统故障，PostgreSQL支持WAL。</p><p>PostgreSQL将所有的修改作为历史数据写入持久存储，为失败做准备。在PostgreSQL中，历史数据被称为<strong>XLOG记录</strong>或<strong>WAL数据</strong>。</p><p>XLOG记录通过插入、删除或提交等更改操作写入内存中的<strong>WAL缓冲区</strong>。当事务提交/中止时，它们会立即写入存储上的<strong>WAL段文件</strong>（准确的说，XLOG记录的写入可能在其他情况下发生，具体将在<a href="https://jinlid.github.io/2021/9.yu-xie-ri-zhi-wal#_9.5">9.5 节</a>中描述）。XLOG 记录的<strong>LSN</strong>（日志序列号，LSN用作记录XLOG中的唯一ID）表示其记录在事务日志上的写入位置。</p><p>当我们考虑数据库系统如何恢复时，可能会有一个问题；PostgreSQL从什么时候开始恢复？答案是<strong>REDO点</strong>；也就是最近一次<strong>checkpoint</strong>启动时写入XLOG记录的位置（PostgreSQL中的checkpoint在<a href="https://jinlid.github.io/2021/9.yu-xie-ri-zhi-wal#_9.7">9.7节</a>有介绍）。事实上，数据库恢复处理与检查点处理密切相关，这两者是密不可分的。</p><blockquote><p>WAL和checkpoint进程在7.1版本中同时实现。</p></blockquote><p>主要关键字和概念的介绍刚刚结束，下面就是用WAL插入元组的说明，参见图9.2和以下说明。（另请参阅<a href="http://www.slideshare.net/suzuki_hironobu/fig-902">此幻灯片</a>）</p><p><img src="/medias/image/fig-9-02.png" alt="图 9.2 使用 WAL 进行插入操作"></p><p>符号 <code>TABLE_A's LSN</code> 显示了 TABLE_A 的页头中 <code>pd_lsn</code> 的值，<code>page's LSN</code> 一样。</p><p>(1) checkpointer，一个后台进程，周期性地执行checkpoint。每当检查点启动时，它都会将一个名为检查点的XLOG记录写入当前WAL段，该记录包含最新REDO点的位置。</p><p>(2) 发出第一条INSERT语句，PostgreSQL将 TABLE_A 的页面加载到共享缓冲池中，在页面中插入一个元组，在位置 <code>LSN_1</code> 处创建并写入这条语句的XLOG记录到WAL缓冲区，并更新 TABLE_A 的 LSN从 <code>LSN_0</code> 到 <code>LSN_1</code>。</p><p>在这个例子中，这个XLOG记录的是<strong>一对header-data和完整元组</strong>。</p><p>(3) 当这个事务提交时，PostgreSQL会创建这个提交操作的XLOG记录并将其写入WAL缓冲区，然后，将WAL缓冲区上的所有XLOG记录写入 <code>LSN_1</code> 并刷新到WAL段文件。</p><p>(4) 发出第二条INSERT语句，PostgreSQL在页面中插入一个新的元组，创建这个元组的XLOG记录并将其写入 <code>LSN_2</code> 处的WAL缓冲区，并将 TABLE_A 的 LSN 从 <code>LSN_1</code> 更新为 <code>LSN_2</code>。</p><p>(5) 当这条语句的事务提交时，PostgreSQL以与步骤(3) 中相同的方式进行操作。</p><p>(6) 想象一下，什么时候可能发生系统故障。即使共享缓冲池上的所有数据都丢失了，页面的所有修改也已作为历史数据写入WAL段文件。</p><p>以下说明显示了如何将我们的数据库集群恢复到崩溃前的状态。不需要做任何特别的事情，因为PostgreSQL会通过重新启动自动进入恢复模式。参见图 9.3（和这张<a href="http://www.slideshare.net/suzuki_hironobu/fig-903">幻灯片</a>）。PostgreSQL将从REDO点依次读取和重放相应 WAL段文件中的XLOG记录。</p><p><img src="/medias/image/fig-9-03.png" alt="图 9.3 使用 WAL 进行数据库恢复"></p><p>(1) PostgreSQL从相应的WAL段文件中读取第一个INSERT语句的XLOG记录，将 TABLE_A 的页面从数据库集群加载到共享缓冲池中。</p><p>(2) 在尝试重放XLOG记录之前，PostgreSQL会比较XLOG记录的LSN与对应页面的LSN，原因将在<a href="https://jinlid.github.io/2021/9.yu-xie-ri-zhi-wal#_9.8">9.8 节</a>中说明。重放XLOG记录的规则如下所示：</p><p>如果XLOG记录的LSN大于页面的LSN，则将XLOG记录的数据部分插入到页面中，并将页面的LSN更新为 XLOG记录的LSN。如果XLOG记录的LSN较小，则读取下一个WAL数据。</p><p>在此示例中，由于XLOG记录的LSN ( <code>LSN_1</code> ) 大于 TABLE_A 的LSN ( <code>LSN_0</code> )，因此重放 XLOG记录；然后，TABLE_A 页面更改到<code>LSN_1</code>。</p><p>(3) PostgreSQL以同样的方式重放剩余的XLOG记录。</p><p>PostgreSQL通过按照这种时间顺序的方式重放WAL段文件的XLOG记录来恢复自身，显然，PostgreSQL的XLOG记录的是<strong>REDO log</strong>。</p><blockquote><p>PostgreSQL不支持UNDO日志。</p><p>虽然写XLOG记录肯定要花费一定的成本，但与写整个修改过的页面相比，这不算什么。</p></blockquote><h3 id="9-1-3-整页写入"><a href="#9-1-3-整页写入" class="headerlink" title="9.1.3 整页写入"></a>9.1.3 整页写入</h3><p>如果操作系统发生故障，假设存储上 TABLE_A 的页面数据已损坏，而后台写入进程一直在写入脏页面，由于无法在损坏的页面上重放XLOG记录，我们需要一个额外的功能。</p><p>PostgreSQL支持称为<strong>整页写入</strong>的功能来处理此类故障。如果启用，PostgreSQL在每个检查点后每个页面的第一次更改期间，写入一对<strong>header-data和整个页面</strong>作为XLOG记录，默认启用。在PostgreSQL中，这样一个包含整个页面的XLOG记录被称为<strong>备份块</strong>。</p><p>启用了整页写入，让我们再次描述元组的插入。参见图 9.4 和以下说明。</p><p><img src="/medias/image/fig-9-04.png" alt="图 9.4 整页写"></p><p>(1) checkpointer启动一个checkpoint进程。</p><p>(2) 在第一条INSERT语句的插入中，虽然PostgreSQL的操作方式和上一小节几乎一样，但是这个XLOG记录是这个页面的备份块（即它包含了整个页面），因为这是在最新的检查点之后第一次写入此页面。</p><p>(3) 当这个事务提交时，PostgreSQL以与上一小节相同的方式运行。</p><p>(4) 在第二条INSERT语句的插入中，由于这条XLOG记录不是备份块，PostgreSQL的操作方式与上一小节相同。</p><p>(5) 当这条语句的事务提交时，PostgreSQL以与上一小节相同的方式运行。</p><p>(6) 为了证明整页写入的有效性，这时我们考虑在后台写入器一直将脏页面写入硬盘时，由于操作系统发生故障，存储上的 TABLE_A 页面已损坏的情况。</p><p>重启PostgreSQL服务器以修复损坏的集群，参见图 9.5 和以下说明。</p><p><img src="/medias/image/fig-9-05.png" alt="图 9.5 使用备份块进行数据库恢复"></p><p>(1) PostgreSQL读取第一个INSERT语句的XLOG记录，并将损坏的 TABLE_A 页面从数据库集群加载到共享缓冲池中。在这个例子中，XLOG记录是一个备份块，因为按照整页写的写规则，每页的第一个XLOG记录总是它的备份块。</p><p>(2) 当一个XLOG记录是它的备份块时，应用另一个重放规则：不管两个LSN的值如何，记录的数据部分（即页面本身）都将被覆盖到页面上，并且页面的LSN更新到XLOG记录的LSN。</p><p>在此示例中，PostgreSQL将记录的数据部分覆盖到损坏的页面，并将 TABLE_A 的LSN更新为 <code>LSN_1</code> 。通过这种方式，损坏的页面由其备份块恢复。</p><p>(3) 由于第二条XLOG记录是一个非备份块，PostgreSQL的操作方式与上一小节中的指令相同。</p><p>即使发生了一些数据写入失败，PostgreSQL也可以恢复（当然，如果发生文件系统或媒体故障，则这不适用）。</p><h2 id="9-2-事务日志和WAL段文件"><a href="#9-2-事务日志和WAL段文件" class="headerlink" title="9.2 事务日志和WAL段文件"></a>9.2 事务日志和WAL段文件</h2><p>从逻辑上讲，PostgreSQL将XLOG记录写入事务日志中，事务日志是一个8字节长（16 ExaByte）的虚拟文件。</p><p>由于事务日志的容量实际上是无限的，因此可以说8字节的地址空间足够大，我们不可能处理8字节长度的容量的文件。因此，PostgreSQL中的事务日志默认分为16 MB的文件，每个文件称为<strong>WAL段</strong>，参见图 9.6。</p><p><strong>WAL段文件大小</strong></p><blockquote><p>在版本11或更高版本中，当通过initdb命令创建PostgreSQL集群时，可以使用<a href="https://www.postgresql.org/docs/11/static/app-initdb.html">–wal-segsize</a>选项配置 WAL 段文件的大小。</p></blockquote><p><img src="/medias/image/fig-9-06.png" alt="图 9.6 事务日志和 WAL 段文件"></p><p>WAL段文件名是16进制的 24 位数字，命名规则如下：</p><p>WAL segment file name=timelineId+(uint32)LSN−116M∗256+(uint32)(LSN−116M)%256</p><p><strong>时间线ID</strong></p><p>PostgreSQL的WAL包含<strong>时间线ID</strong>（4 字节无符号整数）的概念，用于<a href="https://jinlid.github.io/2021/10-ji-chu-bei-fen-he-shi-jian-dian-hui-fu/">第 10 章</a> 中描述的时间点恢复（PITR）。</p><p>第一个WAL段文件是 00000001 00000000 00000001。如果第一个已被写入XLOG记录，则将提供第二个 00000001 00000000 00000002。后继文件按升序依次使用，00000001 00000000 000000FF填满后，将提供下一个00000001 00000001 00000000。这样，每当最后2位结转时，中间的8位数字就加一，依此类推。</p><p><em>pg_xlogfile_name / pg_walfile_name</em></p><p>使用内置函数<em>pg_xlogfile_name</em>（版本 9.6 或更早版本）或<em>pg_walfile_name</em>（版本 10 或更高版本），我们可以找到包含指定LSN的WAL段文件名，一个例子如下所示：</p><pre class="line-numbers language-bash"><code class="language-bash">testdb<span class="token operator">=</span><span class="token comment" spellcheck="true"># SELECT pg_xlogfile_name('1/00002D3E');  # In version 10 or later, "SELECT pg_walfile_name('1/00002D3E');"</span>     pg_xlogfile_name     -------------------------- 000000010000000100000000<span class="token punctuation">(</span>1 row<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="9-3-WAL段内部布局"><a href="#9-3-WAL段内部布局" class="headerlink" title="9.3 WAL段内部布局"></a>9.3 WAL段内部布局</h2><p>默认情况下，WAL段是一个16MB的文件，它在内部被分成8192字节 (8KB) 的页面。第一个页面具有由结构 <em>XLogLongPageHeaderData</em>定义的标题数据，而所有其他页面的标题由结构 <em>XLogPageHeaderData</em> 定义的页面信息。在页头之后，XLOG记录从头开始按降序写入每一页。参见图9.7。</p><p><img src="/medias/image/fig-9-07.png" alt="图 9.7 WAL 段文件的内部布局"></p><p>结构体 XLogLongPageHeaderData 和XLogPageHeaderData在<a href="https://github.com/postgres/postgres/blob/master/src/include/access/xlog_internal.h">src/include/access/xlog_internal.h</a>中定义。因为以下介绍中不需要这两种结构，所以省略了对这两种结构的解释。</p><h2 id="9-4-XLOG-Record的内部布局"><a href="#9-4-XLOG-Record的内部布局" class="headerlink" title="9.4 XLOG Record的内部布局"></a>9.4 XLOG Record的内部布局</h2><p>XLOG Record包括通用标题部分和每个相关联的数据部分。第一部分描述头结构，剩下的两个小节分别解释了9.4或更早版本和9.5版本中数据部分的结构（数据格式在9.5版本中发生了变化）。</p><h3 id="9-4-1-XLOG-Record的头部分"><a href="#9-4-1-XLOG-Record的头部分" class="headerlink" title="9.4.1 XLOG Record的头部分"></a>9.4.1 XLOG Record的头部分</h3><p>所有XLOG记录都有一个由结构体 <code>XLogRecord</code> 定义的通用头部分。在9.4及更早版本的结构体如下所示，在9.5版本中有所更改。</p><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">typedef</span> <span class="token keyword">struct</span> XLogRecord<span class="token punctuation">{</span>   uint32          xl_tot_len<span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">/* total len of entire record */</span>   TransactionId   xl_xid<span class="token punctuation">;</span>       <span class="token comment" spellcheck="true">/* xact id */</span>   uint32          xl_len<span class="token punctuation">;</span>       <span class="token comment" spellcheck="true">/* total len of rmgr data */</span>   uint8           xl_info<span class="token punctuation">;</span>      <span class="token comment" spellcheck="true">/* flag bits, see below */</span>   RmgrId          xl_rmid<span class="token punctuation">;</span>      <span class="token comment" spellcheck="true">/* resource manager for this record */</span>   <span class="token comment" spellcheck="true">/* 2 bytes of padding here, initialize to zero */</span>   XLogRecPtr      xl_prev<span class="token punctuation">;</span>      <span class="token comment" spellcheck="true">/* ptr to previous record in log */</span>   pg_crc32        xl_crc<span class="token punctuation">;</span>       <span class="token comment" spellcheck="true">/* CRC for this record */</span><span class="token punctuation">}</span> XLogRecord<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>除了两个变量，大部分变量都是显而易见的，不需要描述。</p><p><strong>xl_rmid</strong>和<strong>xl_info</strong>是相关变量的资源管理器，这是与WAL相关的操作集合的写入及XLOG记录重放功能等。资源管理器的数量随着每个PostgreSQL版本的增加而增加，版本10包含以下内容：</p><table><thead><tr><th align="left">Operation</th><th align="left">Resource manager</th></tr></thead><tbody><tr><td align="left">Heap tuple operations</td><td align="left">RM_HEAP, RM_HEAP2</td></tr><tr><td align="left">Index operations</td><td align="left">RM_BTREE, RM_HASH, RM_GIN, RM_GIST, RM_SPGIST, RM_BRIN</td></tr><tr><td align="left">Sequence operations</td><td align="left">RM_SEQ</td></tr><tr><td align="left">Transaction operations</td><td align="left">RM_XACT, RM_MULTIXACT, RM_CLOG, RM_XLOG, RM_COMMIT_TS</td></tr><tr><td align="left">Tablespace operations</td><td align="left">RM_SMGR, RM_DBASE, RM_TBLSPC, RM_RELMAP</td></tr><tr><td align="left">replication and hot standby operations</td><td align="left">RM_STANDBY, RM_REPLORIGIN, RM_GENERIC_ID, RM_LOGICALMSG_ID</td></tr></tbody></table><p>以下是资源管理器在以下工作方式的一些代表性示例：</p><ul><li><p>如果发出INSERT语句，则其XLOG记录的头变量 <code>xl_rmid</code> 和 <code>xl_info</code> 分别设置为<code>RM_HEAP</code> 和<code>XLOG_HEAP_INSERT</code>。恢复数据库集群时，根据 <code>xl_info</code> 选择的 <code>RM_HEAP</code> 的函数 <em>heap_xlog_insert()</em> 重放这条XLOG记录。</p></li><li><p>UPDATE语句类似，但XLOG记录的头变量 <code>xl_info</code> 设置为 <code>XLOG_HEAP_UPDATE</code>，并且 <code>RM_HEAP</code> 的函数 <em>heap_xlog_update()</em> 在数据库恢复时重放其记录。</p></li><li><p>当事务提交时，其XLOG记录的头变量 <code>xl_rmid</code> 和 <code>xl_info</code> 分别设置为 <code>RM_XACT</code> 和<code>XLOG_XACT_COMMIT</code>。在恢复数据库集群时，函数 <em>xact_redo_commit()</em> 会重放这条记录。</p></li></ul><p>在 9.5 或更高版本中， XLogRecord结构体删除了一个变量 (xl_len) 以优化XLOG记录格式，从而将大小减少了几个字节。</p><p>XLogRecord结构体在9.4或更早版本<a href="https://github.com/postgres/postgres/blob/REL9_4_STABLE/src/include/access/xlog.h">src/include/access/xlog.h</a>中定义，9.5或更高版本在<a href="https://github.com/postgres/postgres/blob/master/src/include/access/xlogrecord.h">src/include/access/xlogrecord.h</a>中定义。</p><p><em>heap_xlog_insert</em> 和 <em>heap_xlog_update</em> 在<a href="https://github.com/postgres/postgres/blob/master/src/backend/access/heap/heapam.c">src/backend/access/heap/heapam.c </a>中定义；而函数 <em>xact_redo_commit</em> 在<a href="https://github.com/postgres/postgres/blob/master/src/backend/access/transam/xact.c">src/backend/access/transam/xact.c</a>中定义。</p><h3 id="9-4-2-XLOG-Record的数据部分（9-4-或更早版本）"><a href="#9-4-2-XLOG-Record的数据部分（9-4-或更早版本）" class="headerlink" title="9.4.2 XLOG Record的数据部分（9.4 或更早版本）"></a>9.4.2 XLOG Record的数据部分（9.4 或更早版本）</h3><p>XLOG Record的数据部分分为备份块（整页）和非备份块（按不同数据操作）。</p><p><img src="/medias/image/fig-9-08.png" alt="图 9.8 XLOG 记录示例（9.4 或更早版本）"></p><p>XLOG Record的内部布局在下面使用一些具体示例进行描述。</p><h4 id="9-4-2-1-备份块"><a href="#9-4-2-1-备份块" class="headerlink" title="9.4.2.1 备份块"></a>9.4.2.1 备份块</h4><p>备份块如图 9.8(a) 所示。它由两个数据结构和一个数据对象组成，如下所示：</p><ol><li><p>XLogRecord结构体（头部分）</p></li><li><p>BkpBlock结构体</p></li><li><p>除了FSM之外的整个页面</p></li></ol><p>该BkpBlock包含数据库集群中找出这个页面的变量（即包含此页面的关系的<code>relfilenode</code>和叉号，和这个页面的块号），开始位置，这个页面上的可用空间的长度。</p><h4 id="9-4-2-2-非备份块"><a href="#9-4-2-2-非备份块" class="headerlink" title="9.4.2.2 非备份块"></a>9.4.2.2 非备份块</h4><p>在非备份块中，数据部分的布局因每个操作而异。这里，以INSERT语句的XLOG记录为例进行说明。见图9.8(b)。在这种情况下，INSERT语句的XLOG记录由两个数据结构和一个数据对象组成，如下所示：</p><ol><li><p>XLogRecord结构体（头部分）</p></li><li><p>xl_heap_insert结构体</p></li><li><p>插入的元组–准确地说，从元组中删除了几个字节</p></li></ol><p>结构体 <code>xl_heap_insert</code> 包含用于标识数据库集群中插入的元组的变量（即包含该元组的表的<em>relfilenode</em>以及该元组的<em>tid</em>），以及该元组的<strong>可见性标志</strong>。</p><p>从插入的元组中删除几个字节的原因在<code>xl_heap_header</code>结构体的源代码注释中有描述：</p><blockquote><p>我们不会在WAL中存储插入或更新的元组的整个固定部分（HeapTupleHeaderData）；我们可以通过重构WAL记录中其他地方可用的字段来节省一些字节，或者可能只是不需要重构。</p></blockquote><p>Checkpoint记录的XLOG记录很简单，见图 9.8(c)。它由两种数据结构组成，如下所示：</p><ol><li><p>XLogRecord结构体（头部分）</p></li><li><p>包含检查点信息的检查点结构（请参阅<a href="https://jinlid.github.io/2021/9.yu-xie-ri-zhi-wal/#_9.7">第 9.7 节</a>中的更多详细信息）</p></li></ol><p><code>xl_heap_header</code>结构体在<a href="https://github.com/postgres/postgres/blob/master/src/include/access/htup.h">src/include/access/htup.h</a>中定义，而CheckPoint结构体在<a href="https://github.com/postgres/postgres/blob/master/src/include/catalog/pg_control.h">src/include/catalog/pg_control.h</a>中定义。</p><h3 id="9-4-3-XLOG-Record的数据部分（9-5-或更高版本）"><a href="#9-4-3-XLOG-Record的数据部分（9-5-或更高版本）" class="headerlink" title="9.4.3 XLOG Record的数据部分（9.5 或更高版本）"></a>9.4.3 XLOG Record的数据部分（9.5 或更高版本）</h3><p>在 9.4 或更早的版本中，XLOG 记录没有通用的格式，因此每个资源管理器都必须定义自己的格式。在这种情况下，维护源代码和实现与 WAL 相关的新功能变得越来越困难。为了解决这个问题，9.5 版本中引入了一种不依赖于资源管理器的通用结构化格式。</p><p>XLOG 记录的数据部分可以分为两部分：头部和数据。见图 9.9。</p><p><img src="/medias/image/fig-9-09.png" alt="图 9.9 常见的 XLOG 记录格式"></p><p>Header 部分包含零个或多个 <code>XLogRecordBlockHeaders</code> 和零个或一个<code>XLogRecordDataHeaderShort</code>（或 XLogRecordDataHeaderLong）；它必须至少包含其中之一。当其记录存储整页图像（即备份块）时， <code>XLogRecordBlockHeader</code> 包括<code>XLogRecordBlockImageHeader</code>，如果其块被压缩，则还包括 <code>XLogRecordBlockCompressHeader</code>。</p><p>数据部分由零个或多个块数据和零个或一个主数据组成，分别对应于 <code>XLogRecordBlockHeader(s)</code> 和 <code>XLogRecordDataHeader</code>。</p><p><strong>WAL 压缩</strong></p><p>在 9.5 或更高版本中，可以通过设置参数（ <code>wal_compression=enable</code> ）使用 LZ 压缩方法压缩 XLOG 记录中的整页图像。在这种情况下，将添加结构 <code>XLogRecordBlockCompressHeader</code>。</p><p>此功能有两个优点和一个缺点。优点是减少写入记录的 I/O 成本并抑制 WAL 段文件的消耗。缺点是需要消耗大量 CPU 资源进行压缩。</p><p><img src="/medias/image/fig-9-10.png" alt="图 9.10 XLOG 记录示例（9.5 版或更高版本）"></p><p>下面显示了一些具体示例，如上一小节所示。</p><h4 id="9-4-3-1-备份块"><a href="#9-4-3-1-备份块" class="headerlink" title="9.4.3.1 备份块"></a>9.4.3.1 备份块</h4><p>INSERT 语句创建的备份块如图 9.10(a)所示。它由四种数据结构和一个数据对象组成，如下所示：</p><ol><li><p>XLogRecord结构体（头部分）</p></li><li><p>XLogRecordBlockHeader结构体包括一个 XLogRecordBlockImageHeader</p></li><li><p>XLogRecordDataHeaderShort结构体</p></li><li><p>一个备份块（块数据）</p></li><li><p>xl_heap_insert结构体（主数据）</p></li></ol><p>XLogRecordBlockHeader 包含用于标识数据库集群中的块的变量（relfilenode<em>、</em>分叉号<em>和</em>块号）；XLogRecordImageHeader 包含这个块的长度和偏移量（这两个头结构一起可以存储9.4版本之前使用的BkpBlock的相同数据）。</p><p>XLogRecordDataHeaderShort 存储 xl_heap_insert结构体的长度，它是记录的主要数据。</p><p>包含整页图像的 XLOG 记录的主要数据，除了在某些特殊情况下（例如在逻辑解码和推测插入中）外不使用。重放这条记录时忽略它，这是冗余数据，将来可能会改进。</p><p>此外，备份块记录的主要数据取决于创建它们的语句。例如，UPDATE 语句附加 <code>xl_heap_lock</code>或 <code>xl_heap_updated</code>。</p><h4 id="9-4-3-2-非备份块"><a href="#9-4-3-2-非备份块" class="headerlink" title="9.4.3.2 非备份块"></a>9.4.3.2 非备份块</h4><p>接下来，将描述由 INSERT 语句创建的非备份块记录（另请参见图 9.10（b））。它由四种数据结构和一个数据对象组成，如下所示：</p><ol><li><p>XLogRecord结构体（头部分）</p></li><li><p>XLogRecordBlockHeader结构体</p></li><li><p>XLogRecordDataHeaderShort结构体</p></li><li><p>插入的元组（准确地说，是一个xl_heap_header结构体和一个插入的数据整体）</p></li><li><p>xl_heap_insert结构体（主数据）</p></li></ol><p>XLogRecordBlockHeader 包含三个值（relfilenode<em>、</em>fork number和block number）来指定插入元组的块，以及插入元组的数据部分的长度。XLogRecordDataHeaderShort 包含新的xl_heap_insert结构体的长度，是这条记录的主要数据。</p><p>新的xl_heap_insert只包含两个值：<strong>块内此元组的偏移量</strong>和<strong>可见性标志</strong>；它变得非常简单，因为 XLogRecordBlockHeader 存储了旧数据中包含的大部分数据。</p><p>作为最后一个例子，检查点记录如图 9.10(c) 所示。它由三个数据结构组成，如下所示：</p><ol><li><p>XLogRecord结构体（头部分）</p></li><li><p>XLogRecordDataHeaderShort结构体包含主数据长度</p></li><li><p>CheckPoint结构体（主数据）</p></li></ol><p>xl_heap_header结构体定义在<a href="https://github.com/postgres/postgres/blob/master/src/include/access/htup.h">src/include/access/htup.h</a>中，CheckPoint结构体定义在<a href="https://github.com/postgres/postgres/blob/master/src/include/catalog/pg_control.h">src/include/catalog/pg_control.h</a>中。</p><p>虽然新的格式对我们来说有点复杂，但它是为资源管理器的解析器设计的，而且许多类型的 XLOG 记录的大小通常比以前的要小。主要结构尺寸见图9.8 和 9.10，因此您可以计算这些记录的大小并相互比较（新检查点的大小比前一个大，但包含更多变量）。</p><h2 id="9-5-XLOG-记录的编写"><a href="#9-5-XLOG-记录的编写" class="headerlink" title="9.5 XLOG 记录的编写"></a>9.5 XLOG 记录的编写</h2><p>完成了热身练习，现在我们可以开始理解XLOG记录的编写了。因此，我将在本节中尽可能准确地解释它。</p><p>首先，发出以下语句来探索PostgreSQL内部：</p><pre class="line-numbers language-bash"><code class="language-bash">testdb<span class="token operator">=</span><span class="token comment" spellcheck="true"># INSERT INTO tbl VALUES ('A');</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>通过发出上述语句，调用内部函数 <em>exec_simple_query()<em>；</em>exec_simple_query()</em> 的伪代码如下所示：</p><pre class="line-numbers language-c"><code class="language-c"><span class="token function">exec_simple_query</span><span class="token punctuation">(</span><span class="token punctuation">)</span> @postgres<span class="token punctuation">.</span><span class="token function">c</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token function">ExtendCLOG</span><span class="token punctuation">(</span><span class="token punctuation">)</span> @clog<span class="token punctuation">.</span>c                  <span class="token comment" spellcheck="true">/* Write the state of this transaction                                           * "IN_PROGRESS" to the CLOG.                                           */</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span> <span class="token function">heap_insert</span><span class="token punctuation">(</span><span class="token punctuation">)</span>@heapam<span class="token punctuation">.</span>c                <span class="token comment" spellcheck="true">/* Insert a tuple, creates a XLOG record,                                           * and invoke the function XLogInsert.                                           */</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span> <span class="token function">XLogInsert</span><span class="token punctuation">(</span><span class="token punctuation">)</span> @xlog<span class="token punctuation">.</span><span class="token function">c</span> <span class="token punctuation">(</span><span class="token number">9.5</span> or later<span class="token punctuation">,</span> xloginsert<span class="token punctuation">.</span>c<span class="token punctuation">)</span>                                          <span class="token comment" spellcheck="true">/* Write the XLOG record of the inserted tuple                                           *  to the WAL buffer, and update page's pd_lsn.                                           */</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span> <span class="token function">finish_xact_command</span><span class="token punctuation">(</span><span class="token punctuation">)</span> @postgres<span class="token punctuation">.</span>c     <span class="token comment" spellcheck="true">/* Invoke commit action.*/</span>         <span class="token function">XLogInsert</span><span class="token punctuation">(</span><span class="token punctuation">)</span> @xlog<span class="token punctuation">.</span><span class="token function">c</span>  <span class="token punctuation">(</span><span class="token number">9.5</span> or later<span class="token punctuation">,</span> xloginsert<span class="token punctuation">.</span>c<span class="token punctuation">)</span>                                          <span class="token comment" spellcheck="true">/* Write a XLOG record of this commit action                                            * to the WAL buffer.                                           */</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span> <span class="token function">XLogWrite</span><span class="token punctuation">(</span><span class="token punctuation">)</span> @xlog<span class="token punctuation">.</span>c                   <span class="token comment" spellcheck="true">/* Write and flush all XLOG records on                                            * the WAL buffer to WAL segment.                                           */</span><span class="token punctuation">(</span><span class="token number">6</span><span class="token punctuation">)</span> <span class="token function">TransactionIdCommitTree</span><span class="token punctuation">(</span><span class="token punctuation">)</span> @transam<span class="token punctuation">.</span>c  <span class="token comment" spellcheck="true">/* Change the state of this transaction                                            * from "IN_PROGRESS" to "COMMITTED" on the CLOG.                                           */</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在下面的段落中，将解释每一行伪代码以理解XLOG记录的写入，另请参见图9.11和9.12。</p><p>(1) <em>ExtendCLOG()</em> 函数将这个事务<code>IN_PROGRESS</code>的状态写入CLOG（内存中）。</p><p>(2) <em>heap_insert()</em> 函数在共享缓冲池上的目标页中插入一个堆元组，创建该页的XLOG记录，并调用 <em>XLogInsert()</em> 函数。</p><p>(3) XLogInsert() 函数在 <code>LSN_1</code>写出由 <em>heap_insert()</em> 创建的XLOG记录到WAL缓冲区，然后更新页面的pd_lsn从<code>LSN_0</code>更改为<code>LSN_1</code>。</p><p>(4) 调用 <em>finish_xact_command()</em> 函数提交此事务，创建该提交动作的XLOG记录，然后在<code>LSN_2</code> 将 <em>XLogInsert()</em> 函数的记录写入到在WAL缓冲区。</p><p><img src="/medias/image/fig-9-11.png" alt="图 9.11 XLOG 记录的写入序列"></p><p>这些 XLOG记录的格式为9.4版。</p><p>(5) <em>XLogWrite()</em> 函数将WAL缓冲区上的所有XLOG记录写入并刷新到WAL段文件中。</p><p>如果参数 <code>wal_sync_method</code>设置为<code>open_sync</code> 或 <code>open_datasync</code>，则记录被同步写入，因为该函数使用 <em>open()</em> 系统调用指定标志<code>O_SYNC</code>或<code>O_DSYNC</code>写入所有记录。如果参数设置为<code>fsync</code>、<code>fsync_writethrough</code>或<code>fdatasync</code>，则相应的系统调用 – *fsync()<em>、</em>fcntl()<em>和 <code>F_FULLFSYNC</code> 选项或</em>fdatasync()*——将被处理。在任何情况下，都确保所有XLOG记录都写入存储。</p><p>(6) *TransactionIdCommitTree()*函数将CLOG上的此事务的状态从<code>N_PROGRESS</code>更改为<code>COMMITTED</code>。</p><p><img src="/medias/image/fig-9-12.png" alt="图 9.12 XLOG 记录的写入顺序（接图 9.11）"></p><p>在上面的例子中，commit动作导致了XLOG记录写入WAL段，但是当发生以下任何一种情况时，也会导致这种写入：</p><ol><li><p>一个正在运行的事务已提交或已中止。</p></li><li><p>WAL缓冲区已经填满了许多已写入的元组（WAL缓冲区大小设置为参数<a href="https://www.postgresql.org/docs/current/static/runtime-config-wal.html#GUC-WAL-BUFFERS">wal_buffers</a>）。</p></li><li><p>WAL writer进程定期写入。</p></li></ol><p>如果发生上述之一，则WAL缓冲区上的所有WAL记录都将写入WAL段文件，无论它们的事务是否已提交。</p><p>DML（数据操作语言）操作写入XLOG记录是理所当然的，但非DML操作也是如此。如上所述，提交操作写入包含已提交事务id的XLOG记录。另一个示例可能是检查点操作，用于写入包含此检查点的基本信息的XLOG记录。此外，SELECT语句在特殊情况下会创建XLOG记录，尽管通常不会创建。例如，如果HOT(Heap Only Tuple)在SELECT语句处理过程中删除了不必要的元组并对页面中的必要元组进行碎片整理，则将修改页面的XLOG记录写入WAL缓冲区。</p><h2 id="9-6-WAL写入进程"><a href="#9-6-WAL写入进程" class="headerlink" title="9.6 WAL写入进程"></a>9.6 WAL写入进程</h2><p>WAL writer是一个后台进程，它会定期检查WAL缓冲区并将所有未写入的XLOG记录写入WAL段。这个过程的目的是为了避免XLOG记录的突发写入。如果没有开启这个进程，当一次提交大量数据时，XLOG记录的写入可能会遇到瓶颈。</p><p>WAL writer默认工作，不能被禁用。检查间隔设置为配置参数 <code>wal_writer_delay</code>，默认值为200毫秒。</p><h2 id="9-7-PostgreSQL中的检查点处理"><a href="#9-7-PostgreSQL中的检查点处理" class="headerlink" title="9.7 PostgreSQL中的检查点处理"></a>9.7 PostgreSQL中的检查点处理</h2><p>在PostgreSQL中，checkpointer（后台）进程执行checkpoint；当以下情况之一发生时，其进程开始：</p><ol><li><p>参数<code>checkpoint_timeout</code> 设置的间隔时间自上一个检查点已经过去（默认间隔为5 分钟）。</p></li><li><p>在9.4或更早版本中，参数 <code>checkpoint_segments</code> 设置的WAL段文件的数量（默认数量为 3）自上一个检查点以来已被消耗。</p></li><li><p>在9.5或更高版本中，pg_xlog中的WAL段文件的总大小已超过参数 <code>max_wal_size</code> 的值（默认值为 1GB）。</p></li><li><p>PostgreSQL服务器在smart或fast模式下停止。</p></li><li><p>当超级用户手动发出CHECKPOINT命令时，也会做。</p></li></ol><blockquote><p>在9.1或更早版本中（<a href="https://jinlid.github.io/2021/8.huan-chong-qu-guan-li-qi/#_8.6">第 8.6 节</a>中所述），后台写入进程同时执行checkpinting and dirty-page writing。</p></blockquote><p>在以下小节中，将描述检查点的概要和保存当前检查点元数据的pg_control文件。</p><h3 id="9-7-1-检查点处理概要"><a href="#9-7-1-检查点处理概要" class="headerlink" title="9.7.1 检查点处理概要"></a>9.7.1 检查点处理概要</h3><p>Checkpoint进程用在两个方面：数据库恢复的准备，以及共享缓冲池上脏页的清理。本节重点介绍其内部处理。参见图9.13和以下说明。</p><p><img src="/medias/image/fig-9-13.png" alt="图 9.13 PostgreSQL 检查点的内部处理"></p><p>(1) 一个checkpoint进程开始后，REDO点被存入内存；REDO点是最近一次checkpoint启动时写入XLOG记录的位置，是数据库恢复的起点。</p><p>(2) checkpoint记录写入WAL缓冲区。记录的数据部分由结构<a href="void(0)">CheckPoint</a>定义，它包含几个变量，例如在步骤 (1) 中存储的REDO点。此外，写入检查点记录的位置字面上称为<strong>检查点</strong>。</p><p>(3) 共享内存中的所有数据（例如<a href="https://jinlid.github.io/2021/5.bing-fa-kong-zhi/5.4.3">clog</a>的内容等）都被刷新到存储中。</p><p>(4) 共享缓冲池上的所有脏页被逐渐写入并刷新到存储中。</p><p>(5) <strong>pg_control</strong>文件更新。该文件包含检查点的基本信息，例如检查点记录写入的位置。</p><p>从数据库恢复的角度总结上面的描述，检查点创建包含REDO点的检查点记录，并将检查点位置等存储到pg_control文件中。因此，PostgreSQL能够通过从pg_control文件提供的REDO点重放WAL数据来恢复自身。</p><h3 id="9-7-2-pg-control-文件"><a href="#9-7-2-pg-control-文件" class="headerlink" title="9.7.2 pg_control 文件"></a>9.7.2 pg_control 文件</h3><p>由于pg_control文件包含检查点的基本信息，因此它对于数据库恢复当然是必不可少的。如果损坏或无法读取，将无法获得起点，从而无法启动恢复过程。</p><p>pg_control文件存储了40多个条目，下一节中需要的3个项目如下所示：</p><ul><li><strong>状态</strong>： 最近一次检查点开始时数据库服务器的状态。共有七种状态：<strong>启动</strong>是系统正在启动的状态；<strong>shut down</strong>是系统被shutdown命令正常关闭的状态；<strong>生产中</strong>是系统正在运行的状态，等等。</li><li><strong>最新检查点位置</strong>：最新检查点记录的LSN位置。</li><li><strong>先前检查点位置</strong>：先前检查点记录的LSN位置。</li></ul><p>详细信息如下：</p><p>一个pg_control文件存放在data-directory下的global子目录中；可以使用<strong>pg_controldata</strong>实用程序查看其内容。</p><pre class="line-numbers language-bash"><code class="language-bash">postgres<span class="token operator">></span> pg_controldata  /usr/local/pgsql/datapg_control version number:            937Catalog version number:               201405111Database system identifier:           6035535450242021944Database cluster state:               <span class="token keyword">in</span> productionpg_control last modified:             Mon Nov 22 15:16:38 2021Latest checkpoint location:           0/C000F48Prior checkpoint location:            0/C000E70<span class="token punctuation">..</span>. snip <span class="token punctuation">..</span>.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>PostgreSQL 11 中的删除先前检查点，PostgreSQL11或更高版本将只存储包含最新检查点或更新的WAL段；将不会存储包含先前检查点的旧段文件，以减少用于在 pg_xlog(pg_wal) 子目录下保存WAL段文件的磁盘空间。具体信息查看<a href="http://www.postgresql-archive.org/Remove-secondary-checkpoint-tt5989050.html">此文 </a>。</p></blockquote><h2 id="9-8-PostgreSQL中的数据库恢复"><a href="#9-8-PostgreSQL中的数据库恢复" class="headerlink" title="9.8 PostgreSQL中的数据库恢复"></a>9.8 PostgreSQL中的数据库恢复</h2><p>PostgreSQL实现了基于重做日志的恢复功能。如果数据库服务器崩溃，PostgreSQL会通过从REDO点顺序重放 WAL段文件中的XLOG记录来恢复数据库集群。</p><p>到本节为止，我们已经多次讨论过数据库恢复，我将描述有关恢复的两件事，还没有解释。</p><p>首先是PostgreSQL如何开始恢复过程。当PostgreSQL启动时，它首先读取pg_control文件。以下是从该点开始恢复处理的详细信息。参见图 9.14和以下说明。</p><p><img src="/medias/image/fig-9-14.png" alt="图 9.14 恢复过程的详细信息"></p><p>(1) PostgreSQL在启动时读取pg_control文件的所有项。如果<strong>状态</strong>项在<strong>in production</strong>，PostgreSQL将进入恢复模式，因为这意味着数据库没有正常停止；如果为 <strong>shut down</strong>，它将进入正常启动模式。</p><p>(2) PostgreSQL从相应的WAL段文件中读取最新的checkpoint记录，该记录的位置写在pg_control文件中，并从该记录中获取REDO点。如果最新的检查点记录无效，PostgreSQL会读取它之前的记录。如果两个记录都不可读，它会放弃自行恢复。</p><p>(3) 数据库从REDO点开始依次读取和重放XLOG记录，直到它们到达最新WAL段的最后一点。当一个XLOG记录被重放时，如果它是一个备份块，它会在相应表的页面上被覆盖，而不管它的LSN是什么。否则，仅当该记录的LSN大于相应页面的 <code>pd_lsn</code> 时，才会重放（非备份块的）XLOG记录。</p><p>第二点是关于LSN的比较：为什么要比较非备份块的LSN和对应page的<code>pd_lsn</code>。与前面的示例不同，再次使用特定示例进行解释，需要强调在两个LSN之间进行比较。见图9.15 和 9.16（为了简化描述，省略了WAL缓冲区）。</p><p><img src="/medias/image/fig-9-15.png" alt="图 9.15 后台编写器工作期间的插入操作"></p><p>(1) PostgreSQL在 TABLE_A 中插入一个元组，并将 <code>LSN_1</code> 写入XLOG记录。</p><p>(2) 后台写入进程将 TABLE_A 的页面写入存储。此时，该页面的 <code>pd_lsn</code> 改为 <code>LSN_1</code>。</p><p>(3) PostgreSQL在 TABLE_A 中插入一个新元组，并在 <code>LSN_2</code> 处写入一条XLOG记录。修改后的页面还没有写入存储。</p><p>与概述中的示例不同，在这种情况下，TABLE_A 的页面已被写入存储。</p><p>使用 <code>immediate-mode</code> 关闭，然后启动。</p><p><img src="/medias/image/fig-9-16.png" alt="图 9.16 数据库恢复"></p><p>(1) PostgreSQL加载第一个XLOG记录和 TABLE_A 的页面，但不重放它，因为该记录的LSN不大于 TABLE_A 的LSN（两个值都是<code>LSN_1</code>）。其实一看就明白了，不需要重播。</p><p>(2) 接下来，PostgreSQL重放第二条XLOG记录，因为该记录的LSN ( <code>LSN_2</code> ) 大于当前 TABLE_A 的LSN ( <code>LSN_1</code> )。</p><p>从这个例子可以看出，如果非备份块的重放顺序不正确或非备份块重放多次，数据库集群将不再一致。总之，非备份块的重放操作不是幂等的。因此，为了保持正确的重放顺序，当且仅当其LSN大于相应页面的 <code>pd_lsn</code> 时，非备份块记录才应重放。</p><p>另一方面，由于备份块的重做操作是幂等的，无论其LSN是多少，备份块都可以重放任意次数。</p><h2 id="9-9-WAL段文件管理"><a href="#9-9-WAL段文件管理" class="headerlink" title="9.9 WAL段文件管理"></a>9.9 WAL段文件管理</h2><p>PostgreSQL将XLOG记录写入存储在pg_xlog子目录（在版本10或更高版本中为pg_wal子目录）中的WAL段文件之一，如果旧的已填满，则切换到新的。WAL文件的数量取决于几个配置参数以及服务器活动。此外，他们的管理策略在9.5版本中得到了改进。</p><p>在以下小节中，将描述WAL段文件的切换和管理。</p><h3 id="9-9-1-WAL段开关"><a href="#9-9-1-WAL段开关" class="headerlink" title="9.9.1 WAL段开关"></a>9.9.1 WAL段开关</h3><p>WAL段切换发生在以下情况之一时：</p><ol><li><p>WAL段已填满。</p></li><li><p>函数<em>pg_switch_xlog</em>被执行。</p></li><li><p><code>archive_mode</code>已启用，并且已超过设置为<code>archive_timeout</code>的时间。</p></li></ol><p>切换后的文件通常会被回收（重命名和重用）以备将来使用，但如果没有必要，它可能会在以后删除。</p><h3 id="9-9-2-9-5或更高版本中的WAL段管理"><a href="#9-9-2-9-5或更高版本中的WAL段管理" class="headerlink" title="9.9.2 9.5或更高版本中的WAL段管理"></a>9.9.2 9.5或更高版本中的WAL段管理</h3><p>每当检查点开始时，PostgreSQL都会估计并准备下一个检查点周期所需的WAL段文件的数量。此类估计是根据先前检查点周期中消耗的文件数进行的。它们是从包含先前REDO点的段开始计算的，其值介于 <code>min_wal_size</code>（默认为 80 MB，即5个文件）和 <code>max_wal_size</code>（1 GB，即64个文件）之间。如果检查点启动，必要的文件将被保留或回收，而不必要的文件将被删除。</p><p>具体示例如图9.17所示。假设checkpoint开始前有6个文件，WAL_3包含了之前的REDO点（10及之前版本；11及之后版本，REDO点），PostgreSQL估计需要5个文件。在这种情况下，WAL_1将重命名为WAL_7以进行回收，而WAL_2将被删除。</p><p>可以删除比包含先前重做点的文件更旧的文件，因为从<a href="https://jinlid.github.io/2021/9.yu-xie-ri-zhi-wal/#_9.8">第 9.8 节</a>中描述的恢复机制中可以清楚地看出，它们永远不会被使用。</p><p><img src="/medias/image/fig-9-17.png" alt="图 9.17 在检查点回收和删除 WAL 段文件"></p><p>如果由于WAL活动激增而需要更多文件，则将创建新文件，而WAL文件的总大小小于 <code>max_wal_size</code>。例如，在图9.18中，如果WAL_7已被填满，则新创建WAL_8。</p><p><img src="/medias/image/fig-9-18.png" alt="图 9.18 创建 WAL 段文件"></p><p>WAL文件的数量根据服务器活动自适应地变化。如果WAL数据写入量不断增加，WAL段文件的估计数量以及WAL文件的总大小也会逐渐增加。在相反的情况下（即 WAL 数据写入量减少），这些减少。</p><p>如果WAL文件的总大小超过<code>max_wal_size</code>，将启动检查点。图9.19说明了这种情况。通过检查点，将创建一个新的重做点，最后一个重做点将是前一个；然后不必要的旧文件将被回收。这样，PostgreSQL将始终只保存数据库恢复所需的WAL段文件。</p><p><img src="/medias/image/fig-9-19.png" alt="图 9.19 检查点和回收 WAL 段文件"></p><p>配置参数 <code>wal_keep_segments</code>和<strong>复制槽</strong>功能也会影响WAL段文件的数量。</p><h3 id="9-9-3-9-4或更早版本中的WAL段管理"><a href="#9-9-3-9-4或更早版本中的WAL段管理" class="headerlink" title="9.9.3 9.4或更早版本中的WAL段管理"></a>9.9.3 9.4或更早版本中的WAL段管理</h3><p>WAL段文件的数量主要由以下三个参数控制：<code>checkpoint_segments</code>、<code>checkpoint_completion_target</code> 和 <code>wal_keep_segments</code>。它的数量通常超过((2+checkpoint_completion_target)×checkpoint_segments+1)或者 (checkpoint_segments+wal_keep_segments+1)(checkpoint_segments+wal_keep_segments+1) 文件。这个数字可能会暂时达到(3×checkpoint_segments+1)，(3×checkpoint_segments+1) 文件取决于服务器活动。 复制插槽也影响他们的数目。</p><p>如<a href="https://jinlid.github.io/2021/9.yu-xie-ri-zhi-wal/#_9.7">第 9.7 节</a>所述，当<code>checkpoint_segments</code>文件的数量已被消耗时，就会发生检查点过程。因此可以保证WAL文件中总是包含两个或更多的REDO点，因为文件的数量总是大于2个checkpoint_segments。 如果超时发生也是如此。因此，PostgreSQL将始终拥有恢复所需的足够的WAL段文件（有时超过必要的）。</p><p>在 9.4 或更早版本中，参数 <code>checkpoint_segments</code> 令人头疼。如果设置的小，checkpoint会频繁出现，导致性能下降，而设置的大，WAL文件总是需要巨大的磁盘空间，其中一些并不总是必要的。</p><p>在 9.5 版本中，WAL文件的管理策略有所改进，并且<code>checkpoint_segments</code>已过时。因此，上述权衡问题也得到了解决。</p><h2 id="9-10-连续归档和归档日志"><a href="#9-10-连续归档和归档日志" class="headerlink" title="9.10 连续归档和归档日志"></a>9.10 连续归档和归档日志</h2><p>连续归档是在WAL段切换时将WAL段文件复制到归档区的功能，由<strong>归档进程</strong>执行。复制的文件称为存档日志。此功能通常用于<a href="https://jinlid.github.io/2021/10-ji-chu-bei-fen-he-shi-jian-dian-hui-fu/">第 10 章</a>所述的物理热备份和PITR（Point-in-Time Recovery）。</p><p>归档区的路径设置为配置参数 <code>archive_command</code>。例如，使用以下参数，每次每个段切换时，WAL段文件都会复制到目录 <code>/home/postgres/archives/</code>：</p><pre class="line-numbers language-properties"><code class="language-properties"><span class="token attr-name">archive_command</span> <span class="token punctuation">=</span> <span class="token attr-value">'cp %p /home/postgres/archives/%f'</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>其中，占位符<code>%p</code>是复制的WAL段，而<code>%f</code>是存档日志。</p><p><img src="/medias/image/fig-9-20.png" alt="图 9.20 持续归档"></p><hr><p>当 WAL 段文件WAL_7被切换时，该文件被复制到归档区作为Archive log 7。</p><p>参数<code>archive_command</code>可以设置任何Unix命令和工具，因此您可以通过设置scp命令或任何文件备份工具代替普通的copy命令将归档日志传输到其他主机。</p><p>PostgreSQL不会清理创建的归档日志，因此您在使用此功能时应该正确管理日志。如果您什么都不做，归档日志的数量将继续增加。</p><p><a href="http://www.postgresql.org/docs/current/static/pgarchivecleanup.html">pg_archivecleanup</a> 工具是针对归档日志管理的有效工具之一。</p><p>此外，unix 命令<code>find</code>可用于删除存档日志，以下命令删除三天前创建的归档日志。</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">find</span> /home/postgres/archives -mtime +3d -exec <span class="token function">rm</span>  -f <span class="token punctuation">{</span><span class="token punctuation">}</span> \<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> postgresql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> postgresql </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
