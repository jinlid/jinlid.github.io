<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>第三章--SQL调优</title>
      <link href="/2026/3.sql-diao-you/"/>
      <url>/2026/3.sql-diao-you/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h2 id="3-1-调优的思想"><a href="#3-1-调优的思想" class="headerlink" title="3.1 调优的思想"></a>3.1 调优的思想</h2><p>磐维数据库提供了多种手段，用于定位查询执行缓慢的根本原因。</p><p>数据库后台会自动分析表结构、收集统计信息，并通过自动清理（Auto Vacuum）构建数据直方图。自动清理机制主要用于回收磁盘空间、更新表统计信息，以及执行其他维护任务（如防止事务 ID 回卷）。表统计信息是磐维数据库选择最优执行计划的核心依据，它会综合评估 IO 开销与 CPU 成本，从而生成成本最低的执行策略。</p><p>同时，磐维数据库支持通过 <code>EXPLAIN</code> 命令，直观地查看查询的执行计划，帮助开发者理解数据库的执行逻辑。</p><p>对于初学者而言，非常有效的调优思路是：<strong>用多种方式编写同一查询，并对比执行结果</strong>。例如，<code>NOT IN</code> 结构在某些场景下可以改写为 <code>LEFT JOIN</code> 或 <code>NOT EXISTS</code>；<code>IN</code> 结构也可以重写为 <code>INNER JOIN</code> 或 <code>EXISTS</code>。通过多种写法的实践，开发者可以更清晰地理解不同语法结构的适用场景，以及在何种条件下某种结构会更具优势。</p><h2 id="3-2-了解SQL生命周期"><a href="#3-2-了解SQL生命周期" class="headerlink" title="3.2 了解SQL生命周期"></a>3.2 了解SQL生命周期</h2><p>SQL 语句从输入到执行完成，需经过多个核心数据库模块的协同处理，其中最关键的三大模块的是：</p><ul><li><strong>解析器（Parser）</strong></li><li><strong>优化器（Optimizer）</strong></li><li><strong>执行器（Executor）</strong></li></ul><p>SQL 语句的完整执行流程，可通过下图清晰理解：</p><p> <img src="/medias/image/image-20260212113724380.png" alt="image-20260212113724380"></p><h3 id="解析器（Parser）"><a href="#解析器（Parser）" class="headerlink" title="解析器（Parser）"></a>解析器（Parser）</h3><p>解析器的核心职责是校验 SQL 语句的有效性，确保其符合数据库的执行标准，具体会从两个维度进行严格验证：</p><p>一是<strong>语法验证</strong>，检查 SQL 关键字拼写、语句结构是否遵循 SQL 语言规范，避免出现语法错误；二是<strong>语义验证</strong>，确认语句中引用的表、列、函数等数据库对象真实存在，且用户具备相应的访问权限。</p><p>校验通过后，解析器会将人类易读的 SQL 语句，转换为数据库可识别、可处理的内部表示形式——<strong>语法树</strong>（又称解析树、查询树）。简单来说，SQL 语句是面向人类的“高级表达”，而语法树则是面向数据库的“逻辑蓝图”，清晰呈现了语句所需操作的数据库对象及逻辑关系。</p><h3 id="优化器（Optimizer）"><a href="#优化器（Optimizer）" class="headerlink" title="优化器（Optimizer）"></a>优化器（Optimizer）</h3><p>语法树仅定义了“要做什么”，而优化器的核心作用，是决定“怎么做最高效”——即针对给定的语法树，筛选出最优的数据获取算法，生成执行效率最高的方案。</p><p>数据的获取依赖具体的访问路径，优化器会全面评估多种遍历和操作选项，核心决策点包括：</p><ul><li>访问方法选择：为每个引用的表，确定采用表扫描（全表遍历）还是索引扫描（基于索引快速定位）；</li><li>索引选择：若采用索引扫描，需筛选出最适配当前查询、能最快获取结果集的索引；</li><li>连接策略选择：对于多表连接（含表、视图、公共表表达式等），选择最优连接类型（如嵌套循环连接、哈希连接、合并连接）；</li><li>连接顺序决策：尤其是嵌套循环连接，表的连接顺序会直接影响执行效率，需优先确定高效顺序。</li></ul><p>优化器最终筛选出的访问路径组合，会被组装成一份详细的“执行指南”——<strong>执行计划</strong>。值得注意的是，可能的执行计划组合数量极为庞大，找到最优方案需要消耗一定的系统资源，因此优化器会有固定的时间预算，避免因过度优化导致事务响应延迟。</p><p>目前主流数据库采用的优化决策算法，是<strong>基于成本的优化器（Cost-Based Optimizer, CBO）</strong>。每种数据库物理操作（如表扫描、索引查询）都对应可估算的资源成本，数据库会预先存储表大小、数据基数（列值唯一性程度）等统计信息，以此计算每个操作所需的 CPU 周期和 I/O 次数，最终选择总成本最低、执行时间最短的执行计划。</p><p>由于生成最优执行计划是资源密集型操作，为提升重复 SQL 的执行效率，多数数据库提供了<strong>执行计划缓存</strong>——将已生成的优质执行计划缓存起来，后续相同 SQL 可直接复用，无需重复优化。</p><p>但执行计划缓存也存在一定挑战：一是需确保缓存的计划在数据分布、表结构变化后仍保持最优；二是每个计划会占用一定内存，数据库通常采用固定大小缓存，通过“最少使用淘汰”策略为新计划腾出空间；三是 DDL 语句（如建表、改列）可能导致缓存计划过时，需单独进程验证计划有效性；四是需筛选优质计划缓存，避免劣质计划被反复使用，进而影响应用整体性能。</p><h3 id="执行器（Executor）"><a href="#执行器（Executor）" class="headerlink" title="执行器（Executor）"></a>执行器（Executor）</h3><p>优化器生成的执行计划，最终会传递给执行器，由执行器负责落地执行——按照执行计划的步骤，获取目标数据并构建最终结果集，返回给客户端。</p><p>执行过程中，执行器会协同两个核心引擎：一是<strong>存储引擎</strong>，根据执行计划的要求，从磁盘或内存中加载所需数据；二是<strong>事务引擎</strong>，保障当前事务的数据完整性（如原子性、一致性），避免执行过程中出现数据异常。</p><p>简单来说，执行计划就像一份动态生成的“运行脚本”，明确告知执行器每一步该读取哪些数据、如何处理数据，而执行器的核心职责，就是严格执行这份脚本，确保高效、准确地返回查询结果。</p><h2 id="3-3-如何编写优质SQL"><a href="#3-3-如何编写优质SQL" class="headerlink" title="3.3 如何编写优质SQL"></a>3.3 如何编写优质SQL</h2><p>在数据库性能优化实践中，<strong>编写高效 SQL 语句</strong>是最基础也最有效的调优手段。在多数客户项目中，我们发现大量 SQL 未能充分发挥数据库的性能潜力，其核心问题常见如下。</p><h3 id="3-3-1-避免在-SELECT-语句中滥用子查询"><a href="#3-3-1-避免在-SELECT-语句中滥用子查询" class="headerlink" title="3.3.1 避免在 SELECT 语句中滥用子查询"></a>3.3.1 避免在 SELECT 语句中滥用子查询</h3><p>新手常犯的典型错误是将子查询视为独立的 “黑盒” 数据块，割裂了子查询内部逻辑与外部处理逻辑的联系，导致查询效率低下。</p><p>反例：滥用子查询</p><pre class="line-numbers language-sql"><code class="language-sql"><span class="token keyword">SELECT</span> tract_id<span class="token punctuation">,</span>       <span class="token punctuation">(</span><span class="token keyword">SELECT</span> <span class="token function">COUNT</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">)</span> <span class="token keyword">FROM</span> census<span class="token punctuation">.</span>facts <span class="token keyword">AS</span> F <span class="token keyword">WHERE</span> F<span class="token punctuation">.</span>tract_id <span class="token operator">=</span> T<span class="token punctuation">.</span>tract_id<span class="token punctuation">)</span> <span class="token keyword">AS</span> num_facts<span class="token punctuation">,</span>       <span class="token punctuation">(</span><span class="token keyword">SELECT</span> <span class="token function">COUNT</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">)</span>        <span class="token keyword">FROM</span> census<span class="token punctuation">.</span>lu_fact_types <span class="token keyword">AS</span> Y        <span class="token keyword">WHERE</span> Y<span class="token punctuation">.</span>fact_type_id <span class="token operator">IN</span> <span class="token punctuation">(</span>            <span class="token keyword">SELECT</span> fact_type_id            <span class="token keyword">FROM</span> census<span class="token punctuation">.</span>facts F            <span class="token keyword">WHERE</span> F<span class="token punctuation">.</span>tract_id <span class="token operator">=</span> T<span class="token punctuation">.</span>tract_id        <span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">AS</span> num_fact_types<span class="token keyword">FROM</span> census<span class="token punctuation">.</span>lu_tracts <span class="token keyword">AS</span> T<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这种写法将子查询当作独立黑盒，多次扫描关联表，在大数据量场景下性能极差。</p><p>正例：合并子查询，使用关联查询</p><pre class="line-numbers language-sql"><code class="language-sql"><span class="token keyword">SELECT</span> T<span class="token punctuation">.</span>tract_id<span class="token punctuation">,</span>       <span class="token function">COUNT</span><span class="token punctuation">(</span><span class="token number">f</span><span class="token punctuation">.</span>fact_type_id<span class="token punctuation">)</span> <span class="token keyword">AS</span> num_facts<span class="token punctuation">,</span>       <span class="token function">COUNT</span><span class="token punctuation">(</span><span class="token keyword">DISTINCT</span> fact_type_id<span class="token punctuation">)</span> <span class="token keyword">AS</span> num_fact_types<span class="token keyword">FROM</span> census<span class="token punctuation">.</span>lu_tracts <span class="token keyword">AS</span> T<span class="token keyword">LEFT</span> <span class="token keyword">JOIN</span> census<span class="token punctuation">.</span>facts <span class="token keyword">AS</span> F <span class="token keyword">ON</span> T<span class="token punctuation">.</span>tract_id <span class="token operator">=</span> F<span class="token punctuation">.</span>tract_id<span class="token keyword">GROUP</span> <span class="token keyword">BY</span> T<span class="token punctuation">.</span>tract_id<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>通过关联查询与聚合操作，将多次子查询合并为单次扫描，显著提升执行效率。</p><blockquote><p><strong>建议</strong>：子查询并非绝对禁止，但应与主语句通盘考虑，优先通过关联查询、聚合操作等方式替代不必要的子查询，避免 “黑盒式” 子查询滥用。</p></blockquote><hr><h3 id="3-3-2-尽量避免使用-SELECT-语法"><a href="#3-3-2-尽量避免使用-SELECT-语法" class="headerlink" title="3.3.2 尽量避免使用 SELECT * 语法"></a>3.3.2 尽量避免使用 SELECT * 语法</h3><p><code>SELECT *</code> 会导致不必要的数据读取和网络传输，尤其在磐维数据库中，还会触发以下隐藏问题：</p><ol><li><strong>TOAST 机制开销</strong>：磐维数据库使用 TOAST（The Oversized-Attribute Storage Technique）存储超大字段（如文本、二进制对象），这些数据存储在辅助表中。<code>SELECT *</code> 会强制读取所有字段，导致多次关联操作，显著拖慢查询速度。</li><li><strong>视图性能陷阱</strong>：当视图定义包含复杂运算或多表关联时，<code>SELECT * FROM 视图</code> 会触发视图中所有关联和计算，即使查询仅需少数字段，也会导致全量运算。</li></ol><p><strong>性能对比示例</strong></p><p>假设基于反例子查询创建视图：</p><pre class="line-numbers language-sql"><code class="language-sql"><span class="token keyword">CREATE</span> <span class="token operator">OR</span> REPLACE <span class="token keyword">VIEW</span> vw_stats <span class="token keyword">AS</span><span class="token keyword">SELECT</span> tract_id<span class="token punctuation">,</span>       <span class="token punctuation">(</span><span class="token keyword">SELECT</span> <span class="token function">COUNT</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">)</span> <span class="token keyword">FROM</span> census<span class="token punctuation">.</span>facts <span class="token keyword">AS</span> F <span class="token keyword">WHERE</span> F<span class="token punctuation">.</span>tract_id <span class="token operator">=</span> T<span class="token punctuation">.</span>tract_id<span class="token punctuation">)</span> <span class="token keyword">AS</span> num_facts<span class="token punctuation">,</span>       <span class="token punctuation">(</span><span class="token keyword">SELECT</span> <span class="token function">COUNT</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">)</span>        <span class="token keyword">FROM</span> census<span class="token punctuation">.</span>lu_fact_types <span class="token keyword">AS</span> Y        <span class="token keyword">WHERE</span> Y<span class="token punctuation">.</span>fact_type_id <span class="token operator">IN</span> <span class="token punctuation">(</span>            <span class="token keyword">SELECT</span> fact_type_id            <span class="token keyword">FROM</span> census<span class="token punctuation">.</span>facts F            <span class="token keyword">WHERE</span> F<span class="token punctuation">.</span>tract_id <span class="token operator">=</span> T<span class="token punctuation">.</span>tract_id        <span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">AS</span> num_fact_types<span class="token keyword">FROM</span> census<span class="token punctuation">.</span>lu_tracts <span class="token keyword">AS</span> T<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><code>SELECT tract_id FROM vw_stats;</code>：仅需 21 毫秒，因为优化器可判断无需访问复杂计算字段。</li><li><code>SELECT * FROM vw_stats;</code>：耗时飙升至 681 毫秒，触发了所有子查询和关联运算。</li></ul><blockquote><p><strong>建议</strong>：始终明确列出所需字段，避免 <code>SELECT *</code>。这不仅能减少 IO 和网络开销，还能让磐维优化器更精准地生成执行计划，尤其在处理大表和复杂视图时，性能差异会被无限放大。</p></blockquote><h2 id="3-4-如何捕获劣质SQL"><a href="#3-4-如何捕获劣质SQL" class="headerlink" title="3.4 如何捕获劣质SQL"></a>3.4 如何捕获劣质SQL</h2><p>PanWeiDB提供了丰富的性能诊断体系，涵盖性能视图、等待事件、活跃会话分析、历史会话回溯及操作系统级监控等能力。本指南将系统化讲解各类诊断手段的使用方法、适用场景及实操案例，帮助 DBA 快速定位性能瓶颈、优化 SQL 执行效率。</p><h3 id="3-4-1-性能视图：性能诊断的核心数据源"><a href="#3-4-1-性能视图：性能诊断的核心数据源" class="headerlink" title="3.4.1 性能视图：性能诊断的核心数据源"></a>3.4.1 性能视图：性能诊断的核心数据源</h3><p>数据库内置丰富的系统性能视图，是获取数据库运行状态、定位性能问题的基础。这些视图涵盖资源使用、SQL 执行、锁等待、会话状态等全维度数据，适用于实时监控、问题排查、性能基线分析等场景。</p><h4 id="3-4-1-1-核心性能视图分类及用途"><a href="#3-4-1-1-核心性能视图分类及用途" class="headerlink" title="3.4.1.1 核心性能视图分类及用途"></a>3.4.1.1 核心性能视图分类及用途</h4><table><thead><tr><th align="center">视图名称</th><th align="center">核心用途</th><th align="center">典型使用场景</th></tr></thead><tbody><tr><td align="center"><code>pg_stat_activity</code></td><td align="center">实时展示所有活跃 / 非活跃会话的状态、执行的 SQL、资源消耗等</td><td align="center">定位阻塞会话、查看当前运行的慢 SQL、识别空闲会话占用资源</td></tr><tr><td align="center"><code>pg_thread_wait_status</code></td><td align="center">展示会话等待事件详情，包括等待类型、阻塞会话 ID、等待时长等</td><td align="center">分析会话阻塞关系、定位锁等待 / IO 等待等性能瓶颈</td></tr><tr><td align="center"><code>dbe_perf.local_active_session</code></td><td align="center">采样存储活跃会话的统计信息（内存级实时数据）</td><td align="center">分析近期资源消耗高的会话、SQL 及等待事件</td></tr><tr><td align="center"><code>dbe_perf.statement</code></td><td align="center">记录所有执行过的 SQL 语句的统计信息（执行次数、耗时、IO 等）</td><td align="center">识别高频 / 高耗时 SQL、分析 SQL 执行效率</td></tr><tr><td align="center"><code>dbe_perf.get_global_full_sql_by_timestamp</code></td><td align="center">按时间范围查询慢 SQL 详细信息（脱敏）</td><td align="center">离线诊断历史慢 SQL、回溯 SQL 执行计划和资源消耗</td></tr><tr><td align="center"><code>snapshot.snapshot</code></td><td align="center">存储 WDR 快照元数据（ID、采集时间、类型）</td><td align="center">生成 WDR 报告、确认快照有效性</td></tr></tbody></table><h4 id="3-4-1-2-常用查询示例"><a href="#3-4-1-2-常用查询示例" class="headerlink" title="3.4.1.2 常用查询示例"></a>3.4.1.2 常用查询示例</h4><p><strong>（1）查看当前所有活跃会话</strong></p><pre class="line-numbers language-sql"><code class="language-sql"><span class="token keyword">SELECT</span>     pid <span class="token keyword">AS</span> session_id<span class="token punctuation">,</span>    usename <span class="token keyword">AS</span> user_name<span class="token punctuation">,</span>    datname <span class="token keyword">AS</span> db_name<span class="token punctuation">,</span>    client_addr <span class="token keyword">AS</span> client_ip<span class="token punctuation">,</span>    state<span class="token punctuation">,</span>    query <span class="token keyword">AS</span> sql_text<span class="token punctuation">,</span>    <span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> query_start <span class="token keyword">AS</span> execute_duration  <span class="token comment" spellcheck="true">-- 执行时长</span><span class="token keyword">FROM</span> pg_stat_activity<span class="token keyword">WHERE</span> state <span class="token operator">&lt;></span> <span class="token string">'idle'</span>  <span class="token comment" spellcheck="true">-- 排除空闲会话</span><span class="token keyword">ORDER</span> <span class="token keyword">BY</span> execute_duration <span class="token keyword">DESC</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>（2）统计各数据库的会话数</strong></p><pre class="line-numbers language-sql"><code class="language-sql"><span class="token keyword">SELECT</span>     datname <span class="token keyword">AS</span> db_name<span class="token punctuation">,</span>    <span class="token function">count</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">)</span> <span class="token keyword">AS</span> session_count<span class="token punctuation">,</span>    <span class="token function">sum</span><span class="token punctuation">(</span><span class="token keyword">CASE</span> <span class="token keyword">WHEN</span> state <span class="token operator">&lt;></span> <span class="token string">'idle'</span> <span class="token keyword">THEN</span> <span class="token number">1</span> <span class="token keyword">ELSE</span> <span class="token number">0</span> <span class="token keyword">END</span><span class="token punctuation">)</span> <span class="token keyword">AS</span> active_session_count<span class="token keyword">FROM</span> pg_stat_activity<span class="token keyword">GROUP</span> <span class="token keyword">BY</span> datname<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="3-4-2-等待事件：定位资源竞争的关键"><a href="#3-4-2-等待事件：定位资源竞争的关键" class="headerlink" title="3.4.2 等待事件：定位资源竞争的关键"></a>3.4.2 等待事件：定位资源竞争的关键</h3><p>等待事件是数据库会话在获取资源（锁、IO、CPU、内存）时的等待状态，是分析性能瓶颈的核心维度。通过等待事件可精准定位锁阻塞、IO 瓶颈、CPU 争用等问题。</p><h4 id="3-4-2-1-常用等待事件分类"><a href="#3-4-2-1-常用等待事件分类" class="headerlink" title="3.4.2.1 常用等待事件分类"></a>3.4.2.1 常用等待事件分类</h4><table><thead><tr><th align="center">等待事件类型</th><th align="center">典型事件名称</th><th align="center">含义及常见原因</th></tr></thead><tbody><tr><td align="center">LOCK_EVENT</td><td align="center">relation_lock、tuple_lock</td><td align="center">表 / 行锁等待，通常由长事务、未提交事务、高并发写入导致</td></tr><tr><td align="center">IO_EVENT</td><td align="center">data_file_read、data_file_write</td><td align="center">数据文件读写等待，通常由磁盘 IO 性能差、表扫描过多、索引缺失导致</td></tr><tr><td align="center">LWLOCK_EVENT</td><td align="center">buffer_content_lock</td><td align="center">轻量级锁等待，通常由高并发访问同一数据块、内存不足导致</td></tr><tr><td align="center">STATUS</td><td align="center">idle_in_transaction</td><td align="center">事务内空闲等待，通常由应用未及时提交 / 回滚事务导致</td></tr></tbody></table><h4 id="3-4-2-2-捕获等待事件的实操方法"><a href="#3-4-2-2-捕获等待事件的实操方法" class="headerlink" title="3.4.2.2 捕获等待事件的实操方法"></a>3.4.2.2 捕获等待事件的实操方法</h4><p><strong>（1）查看当前会话的等待事件</strong></p><pre class="line-numbers language-sql"><code class="language-sql"><span class="token keyword">SELECT</span>     sessionid<span class="token punctuation">,</span>    wait_status <span class="token keyword">AS</span> wait_status<span class="token punctuation">,</span>    wait_event <span class="token keyword">AS</span> wait_event<span class="token punctuation">,</span>    block_sessionid <span class="token keyword">AS</span> blocked_by<span class="token punctuation">,</span>    lockmode <span class="token keyword">AS</span> lockmode<span class="token keyword">FROM</span> pg_thread_wait_status<span class="token keyword">WHERE</span> block_sessionid <span class="token operator">&lt;></span> <span class="token number">0</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">-- 仅查看被阻塞的会话</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>（2）统计最近 5 分钟最耗资源的等待事件</strong></p><pre class="line-numbers language-sql"><code class="language-sql"><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>（3）定位锁阻塞的根源 SQL</strong></p><pre class="line-numbers language-sql"><code class="language-sql"><span class="token keyword">WITH</span> t_lock <span class="token keyword">AS</span> <span class="token punctuation">(</span>    <span class="token keyword">SELECT</span>         <span class="token number">a</span><span class="token punctuation">.</span>relation::regclass <span class="token keyword">AS</span> table_name<span class="token punctuation">,</span>        <span class="token number">a</span><span class="token punctuation">.</span>mode <span class="token keyword">AS</span> lock_mode<span class="token punctuation">,</span>        <span class="token number">a</span><span class="token punctuation">.</span>pid <span class="token keyword">AS</span> hold_pid<span class="token punctuation">,</span>        <span class="token number">b</span><span class="token punctuation">.</span>query <span class="token keyword">AS</span> hold_sql<span class="token punctuation">,</span>        <span class="token number">c</span><span class="token punctuation">.</span>pid <span class="token keyword">AS</span> wait_pid<span class="token punctuation">,</span>        <span class="token number">d</span><span class="token punctuation">.</span>query <span class="token keyword">AS</span> wait_sql    <span class="token keyword">FROM</span> pg_locks <span class="token number">a</span>    <span class="token keyword">JOIN</span> pg_stat_activity <span class="token number">b</span> <span class="token keyword">ON</span> <span class="token number">a</span><span class="token punctuation">.</span>pid <span class="token operator">=</span> <span class="token number">b</span><span class="token punctuation">.</span>pid <span class="token operator">AND</span> <span class="token number">a</span><span class="token punctuation">.</span>granted <span class="token operator">=</span> <span class="token boolean">true</span>    <span class="token keyword">JOIN</span> pg_locks <span class="token number">c</span> <span class="token keyword">ON</span> <span class="token number">a</span><span class="token punctuation">.</span>relation <span class="token operator">=</span> <span class="token number">c</span><span class="token punctuation">.</span>relation <span class="token operator">AND</span> <span class="token number">c</span><span class="token punctuation">.</span>granted <span class="token operator">=</span> <span class="token boolean">false</span>    <span class="token keyword">JOIN</span> pg_stat_activity <span class="token number">d</span> <span class="token keyword">ON</span> <span class="token number">c</span><span class="token punctuation">.</span>pid <span class="token operator">=</span> <span class="token number">d</span><span class="token punctuation">.</span>pid<span class="token punctuation">)</span><span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> t_lock<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="3-4-3-活跃会话：实时捕获劣质-SQL"><a href="#3-4-3-活跃会话：实时捕获劣质-SQL" class="headerlink" title="3.4.3 活跃会话：实时捕获劣质 SQL"></a>3.4.3 活跃会话：实时捕获劣质 SQL</h3><p>活跃会话分析聚焦<strong>当前正在运行</strong>的会话，可实时捕获耗时高、资源消耗大的劣质 SQL，适用于解决突发性能问题（如 CPU 100%、查询卡顿）。</p><h4 id="3-4-3-1-捕获当前-TOP-耗时-SQL"><a href="#3-4-3-1-捕获当前-TOP-耗时-SQL" class="headerlink" title="3.4.3.1 捕获当前 TOP 耗时 SQL"></a>3.4.3.1 捕获当前 TOP 耗时 SQL</h4><pre class="line-numbers language-sql"><code class="language-sql"><span class="token keyword">SELECT</span>     application_name <span class="token keyword">as</span> app<span class="token punctuation">,</span>    pid <span class="token keyword">AS</span> session_id<span class="token punctuation">,</span>    usename <span class="token keyword">AS</span> user_name<span class="token punctuation">,</span>    query <span class="token keyword">AS</span> sql_text<span class="token punctuation">,</span>    <span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> query_start <span class="token keyword">AS</span> execute_time<span class="token punctuation">,</span>    state<span class="token keyword">FROM</span> pg_stat_activity<span class="token keyword">WHERE</span> state <span class="token operator">&lt;></span> <span class="token string">'idle'</span><span class="token keyword">ORDER</span> <span class="token keyword">BY</span> execute_time <span class="token keyword">DESC</span><span class="token keyword">LIMIT</span> <span class="token number">10</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">-- 取TOP 10 最长执行SQL</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="3-4-3-2-分析活跃会话的资源消耗分布"><a href="#3-4-3-2-分析活跃会话的资源消耗分布" class="headerlink" title="3.4.3.2 分析活跃会话的资源消耗分布"></a>3.4.3.2 分析活跃会话的资源消耗分布</h4><pre class="line-numbers language-sql"><code class="language-sql"><span class="token comment" spellcheck="true">-- 最近5分钟耗资源的会话及对应的等待事件</span><span class="token keyword">SELECT</span>     sessionid<span class="token punctuation">,</span>    start_time<span class="token punctuation">,</span>    event<span class="token punctuation">,</span>    <span class="token function">count</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">)</span> <span class="token keyword">AS</span> event_count<span class="token punctuation">,</span>    <span class="token function">SUM</span><span class="token punctuation">(</span><span class="token function">count</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">OVER</span> <span class="token punctuation">(</span><span class="token keyword">PARTITION</span> <span class="token keyword">BY</span> sessionid<span class="token punctuation">)</span> <span class="token keyword">AS</span> total_event_count  <span class="token comment" spellcheck="true">-- 会话总等待次数</span><span class="token keyword">FROM</span> <span class="token punctuation">(</span>    <span class="token keyword">SELECT</span>         sessionid<span class="token punctuation">,</span>        start_time<span class="token punctuation">,</span>        event<span class="token punctuation">,</span>        <span class="token function">COUNT</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">)</span>    <span class="token keyword">FROM</span> dbe_perf<span class="token punctuation">.</span>local_active_session    <span class="token keyword">WHERE</span> sample_time <span class="token operator">></span> <span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> interval <span class="token string">'5 minutes'</span>    <span class="token keyword">GROUP</span> <span class="token keyword">BY</span> sessionid<span class="token punctuation">,</span> start_time<span class="token punctuation">,</span> event<span class="token punctuation">)</span> t<span class="token keyword">ORDER</span> <span class="token keyword">BY</span> total_event_count <span class="token keyword">DESC</span><span class="token punctuation">,</span> event_count <span class="token keyword">DESC</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="3-4-3-3-紧急处理：终止异常会话"><a href="#3-4-3-3-紧急处理：终止异常会话" class="headerlink" title="3.4.3.3 紧急处理：终止异常会话"></a>3.4.3.3 紧急处理：终止异常会话</h4><p>若发现长时间运行的异常会话（如死循环 SQL、大表全表扫描），可通过以下命令终止：</p><pre class="line-numbers language-sql"><code class="language-sql"><span class="token comment" spellcheck="true">-- 终止指定会话（替换为实际session_id）</span><span class="token keyword">SELECT</span> pg_terminate_backend<span class="token punctuation">(</span><span class="token number">12345</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="3-4-4-会话历史：回溯历史劣质-SQL"><a href="#3-4-4-会话历史：回溯历史劣质-SQL" class="headerlink" title="3.4.4 会话历史：回溯历史劣质 SQL"></a>3.4.4 会话历史：回溯历史劣质 SQL</h3><p>活跃会话仅能分析实时状态，而会话历史可回溯<strong>已完成</strong>的 SQL 执行情况，从 CPU、IO、耗时等多维度识别历史劣质 SQL，适用于分析周期性性能问题、优化历史慢查询。</p><h4 id="3-4-4-1-基于-WDR-报告分析历史-SQL"><a href="#3-4-4-1-基于-WDR-报告分析历史-SQL" class="headerlink" title="3.4.4.1 基于 WDR 报告分析历史 SQL"></a>3.4.4.1 基于 WDR 报告分析历史 SQL</h4><p>WDR（Workload Diagnosis Report）是分析历史会话 / SQL 的核心工具，基于两次快照的对比数据，生成 SUMMARY（摘要）和 DETAIL（详情）级报告，覆盖 SQL 执行统计、资源消耗、等待事件等维度。</p><p><strong>（1）WDR 报告生成完整流程</strong></p><pre class="line-numbers language-sql"><code class="language-sql"><span class="token comment" spellcheck="true">-- 步骤1：检查快照是否开启</span><span class="token keyword">SELECT</span> current_setting<span class="token punctuation">(</span><span class="token string">'enable_wdr_snapshot'</span><span class="token punctuation">)</span> <span class="token keyword">AS</span> wdr_snapshot_status<span class="token punctuation">;</span><span class="token comment" spellcheck="true">-- 步骤2：查看已有快照（获取snapshot_id）</span><span class="token keyword">SELECT</span> snapshot_id<span class="token punctuation">,</span> start_ts<span class="token punctuation">,</span> end_ts <span class="token keyword">FROM</span> <span class="token keyword">snapshot</span><span class="token punctuation">.</span><span class="token keyword">snapshot</span> <span class="token keyword">ORDER</span> <span class="token keyword">BY</span> start_ts <span class="token keyword">DESC</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">-- 步骤3：手动创建快照（可选，需SYSADMIN权限）</span><span class="token keyword">SELECT</span> create_wdr_snapshot<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">-- 步骤4：生成集群级全量WDR报告（替换为实际快照ID）</span><span class="token keyword">SELECT</span> generate_wdr_report<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token string">'all'</span><span class="token punctuation">,</span> <span class="token string">'cluster'</span><span class="token punctuation">,</span> <span class="token boolean">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">-- 步骤5：将报告导出为HTML文件（gsql终端执行）</span>\<span class="token number">a</span> \t \o <span class="token operator">/</span>home<span class="token operator">/</span>om<span class="token operator">/</span>panweidb_wdr_report<span class="token punctuation">.</span>html  <span class="token comment" spellcheck="true">-- 输出到文件</span><span class="token keyword">SELECT</span> generate_wdr_report<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token string">'all'</span><span class="token punctuation">,</span> <span class="token string">'cluster'</span><span class="token punctuation">,</span> <span class="token boolean">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\o \<span class="token number">a</span> \t  <span class="token comment" spellcheck="true">-- 恢复输出</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>（2）WDR 报告核心维度解读</strong></p><table><thead><tr><th align="center">报告模块</th><th align="center">核心指标</th><th align="center">分析重点</th></tr></thead><tbody><tr><td align="center">SQL Statistics</td><td align="center">Elapsed Time、CPU Time、Executions</td><td align="center">总耗时 TOP SQL、单次执行耗时 TOP SQL、高频执行 SQL</td></tr><tr><td align="center">IO Profile</td><td align="center">Physical Reads、Logical Reads</td><td align="center">物理读 / 逻辑读高的 SQL（通常为全表扫描、索引缺失）</td></tr><tr><td align="center">Time Model</td><td align="center">CPU Time、IO Time、Network Time</td><td align="center">SQL 耗时分布（CPU 瓶颈 / IO 瓶颈 / 网络瓶颈）</td></tr></tbody></table><h4 id="3-4-4-2-基于慢-SQL-接口回溯历史-SQL"><a href="#3-4-4-2-基于慢-SQL-接口回溯历史-SQL" class="headerlink" title="3.4.4.2 基于慢 SQL 接口回溯历史 SQL"></a>3.4.4.2 基于慢 SQL 接口回溯历史 SQL</h4><p>数据库支持按时间范围查询慢 SQL 详情（含执行计划、资源消耗），无需复现即可离线诊断。</p><pre class="line-numbers language-sql"><code class="language-sql"><span class="token comment" spellcheck="true">-- 查询指定时间范围内的慢SQL（脱敏）</span><span class="token keyword">SELECT</span>     node_name<span class="token punctuation">,</span>    db_name<span class="token punctuation">,</span>    user_name<span class="token punctuation">,</span>    query <span class="token keyword">AS</span> sql_text<span class="token punctuation">,</span>    start_time<span class="token punctuation">,</span>    finish_time<span class="token punctuation">,</span>    finish_time <span class="token operator">-</span> start_time <span class="token keyword">AS</span> execute_duration<span class="token punctuation">,</span>    query_plan <span class="token keyword">AS</span> execution_plan  <span class="token comment" spellcheck="true">-- 执行计划</span><span class="token keyword">FROM</span> DBE_PERF<span class="token punctuation">.</span>get_global_full_sql_by_timestamp<span class="token punctuation">(</span>    <span class="token string">'2026-02-01 00:00:00'</span><span class="token punctuation">,</span>  <span class="token comment" spellcheck="true">-- 开始时间</span>    <span class="token string">'2026-02-01 23:59:59'</span>   <span class="token comment" spellcheck="true">-- 结束时间</span><span class="token punctuation">)</span><span class="token keyword">WHERE</span> finish_time <span class="token operator">-</span> start_time <span class="token operator">></span> interval <span class="token string">'10 seconds'</span>  <span class="token comment" spellcheck="true">-- 筛选执行超10秒的SQL</span><span class="token keyword">ORDER</span> <span class="token keyword">BY</span> execute_duration <span class="token keyword">DESC</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="3-4-5-操作系统级性能监控"><a href="#3-4-5-操作系统级性能监控" class="headerlink" title="3.4.5 操作系统级性能监控"></a>3.4.5 操作系统级性能监控</h3><p>数据库性能问题常与操作系统资源（CPU、内存、IO、网络）相关，需结合 OS 级命令定位底层瓶颈。更多参见第六章监控命令。</p><h3 id="3-4-5-1-CPU-监控"><a href="#3-4-5-1-CPU-监控" class="headerlink" title="3.4.5.1 CPU 监控"></a>3.4.5.1 CPU 监控</h3><p><strong>（1）查看 PanWeiDB 进程 CPU 占用</strong></p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 查看PanWeiDB进程</span><span class="token function">ps</span> -ef <span class="token operator">|</span> <span class="token function">grep</span> panweidb <span class="token operator">|</span> <span class="token function">grep</span> -v <span class="token function">grep</span><span class="token comment" spellcheck="true"># 实时监控CPU占用</span><span class="token function">top</span> -p <span class="token variable"><span class="token variable">`</span>pidof panweidb<span class="token variable">`</span></span> -d 1  <span class="token comment" spellcheck="true"># 每秒刷新</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>（2）按线程维度监控 CPU</strong></p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 查看PanWeiDB线程的CPU占用</span><span class="token function">top</span> -H -p <span class="token variable"><span class="token variable">`</span>pidof panweidb<span class="token variable">`</span></span><span class="token comment" spellcheck="true"># 统计各进程CPU占比</span>pidstat -p <span class="token variable"><span class="token variable">`</span>pidof panweidb<span class="token variable">`</span></span> 1 5  <span class="token comment" spellcheck="true"># 每1秒采样，共5次</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="3-4-5-2-IO-监控"><a href="#3-4-5-2-IO-监控" class="headerlink" title="3.4.5.2 IO 监控"></a>3.4.5.2 IO 监控</h4><p><strong>（1）监控数据库IO使用</strong></p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 监控PanWeiDB进程的IO使用率</span>iotop -p <span class="token variable"><span class="token variable">`</span>pidof panweidb<span class="token variable">`</span></span><span class="token comment" spellcheck="true"># 查看磁盘IO统计</span>iostat -x 2<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>（2）定位高 IO 文件</strong></p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 查看PanWeiDB数据目录下的文件读写情况</span>pidstat -d -p <span class="token variable"><span class="token variable">`</span>pidof panweidb<span class="token variable">`</span></span> 1 5<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h4 id="3-4-5-3-内存监控"><a href="#3-4-5-3-内存监控" class="headerlink" title="3.4.5.3 内存监控"></a>3.4.5.3 内存监控</h4><p><strong>（1）查看 PanWeiDB 进程内存占用</strong></p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 查看进程内存（RES为实际物理内存）</span><span class="token function">ps</span> aux <span class="token operator">|</span> <span class="token function">grep</span> panweidb <span class="token operator">|</span> <span class="token function">grep</span> -v <span class="token function">grep</span> <span class="token operator">|</span> <span class="token function">awk</span> <span class="token string">'{print <span class="token variable">$2</span>, <span class="token variable">$4</span>, <span class="token variable">$6</span>, <span class="token variable">$11</span>}'</span><span class="token comment" spellcheck="true"># 实时监控内存使用</span><span class="token function">free</span> -h -s 1  <span class="token comment" spellcheck="true"># 每秒刷新，展示总内存、已用、可用</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>（2）检查交换分区使用（内存不足会触发 swap）</strong></p><pre class="line-numbers language-bash"><code class="language-bash">swapon --show  <span class="token comment" spellcheck="true"># 查看swap分区</span><span class="token function">vmstat</span> 1 5     <span class="token comment" spellcheck="true"># 查看si/so列（swap读/写），非0表示内存不足</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h4 id="3-4-5-4-网络监控"><a href="#3-4-5-4-网络监控" class="headerlink" title="3.4.5.4 网络监控"></a>3.4.5.4 网络监控</h4><pre class="line-numbers language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 查看网络连接（PanWeiDB默认端口5432）</span><span class="token function">netstat</span> -anp <span class="token operator">|</span> <span class="token function">grep</span> 5432 <span class="token operator">|</span> <span class="token function">wc</span> -l  <span class="token comment" spellcheck="true"># 统计连接数</span><span class="token comment" spellcheck="true"># 监控网络流量</span>iftop -i eth0  <span class="token comment" spellcheck="true"># 监控eth0网卡流量</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ol><li><strong>性能视图</strong>是 PanWeiDB 性能诊断的基础，可实时获取会话、SQL、锁等状态，适用于快速定位实时问题；</li><li><strong>等待事件</strong>聚焦资源竞争，是区分锁阻塞、IO 瓶颈、CPU 争用的核心手段；</li><li><strong>活跃会话</strong>分析实时劣质 SQL，<strong>会话历史（WDR / 慢 SQL）</strong> 回溯历史性能问题，两者结合可覆盖全场景 SQL 优化；</li><li><strong>OS 级监控命令</strong>是定位底层资源瓶颈的关键，需结合数据库层面分析才能完整定位性能问题。</li></ol><p>通过以上诊断手段的组合使用，可系统化定位数据库的性能瓶颈，从 SQL 优化、索引调整、参数配置、硬件资源等维度实现性能提升。</p><h2 id="3-5-统计信息"><a href="#3-5-统计信息" class="headerlink" title="3.5 统计信息"></a>3.5 统计信息</h2><p>查询优化器的核心能力高度依赖<strong>统计信息</strong>的准确性。本文将系统讲解 PanWeiDB 统计信息的核心概念、收集机制、配置要点，以及如何通过优化统计信息大幅提升查询性能。</p><hr><h3 id="3-5-1-统计信息核心概念"><a href="#3-5-1-统计信息核心概念" class="headerlink" title="3.5.1 统计信息核心概念"></a>3.5.1 统计信息核心概念</h3><p>统计信息是数据库优化器判断「如何执行查询」的关键依据 —— 它描述了表、列的数据分布特征，优化器基于这些数据估算执行成本，选择最优执行计划（如索引扫描 vs 全表扫描）。</p><p><strong>核心术语定义</strong></p><table><thead><tr><th>术语</th><th>定义</th></tr></thead><tbody><tr><td>基数（Cardinality）</td><td>列 / 表中唯一值的数量（<code>stadistinct</code>），或查询返回的预估行数。</td></tr><tr><td>选择率（Selectivity）</td><td>查询条件筛选出的行数占总行数的比例（0~1），是优化器决策的核心指标。</td></tr><tr><td>直方图（Histogram）</td><td>对非高频值的数据分布进行分桶统计，每个桶包含近似相等比例的行，用于估算范围查询（&gt;、&lt;、BETWEEN）的选择率。</td></tr><tr><td>MCV（Most Common Values）</td><td>列中出现频率最高的数值及其占比，覆盖大部分高频值的分布特征。</td></tr></tbody></table><p><strong>数据库收集的核心统计信息</strong></p><p>执行 <code>ANALYZE</code> 时，数据库会为每列收集以下关键统计信息，这些信息主要存储在 <code>pg_statistic</code> 系统表中：</p><ul><li><strong>唯一值数量</strong>：列中不同值的估算值（<code>stadistinct</code>）；</li><li><strong>平均数据宽度</strong>：列值的平均字节大小（<code>stawidth</code>），用于估算内存 / 磁盘占用；</li><li><strong>NULL 值占比</strong>：列中 NULL 值的比例（<code>stanullfrac</code>）；</li><li><strong>MCV 及频率</strong>：高频值列表 + 各自占比（覆盖大部分数据的分布）；</li><li><strong>直方图边界</strong>：非 MCV 数据的分桶边界（<code>histogram_bounds</code>），描述长尾数据分布。</li></ul><hr><h3 id="3-5-2-统计信息收集机制"><a href="#3-5-2-统计信息收集机制" class="headerlink" title="3.5.2 统计信息收集机制"></a>3.5.2 统计信息收集机制</h3><p>数据库统计信息的收集与更新，核心依赖 <code>ANALYZE</code> 语句，其触发时机和操作方式如下：</p><p><strong>何时收集统计信息</strong></p><ul><li>建议在执行了大批量插入 / 删除操作后，例行对表或全库执行 <code>ANALYZE</code> 语句更新统计信息。</li><li>对于在批处理脚本或者存储过程中生成的中间表，也需要在完成数据生成之后显式地调用 <code>ANALYZE</code>。</li><li>对于表中多个列有相关性，且查询中有同时基于这些列的条件或分组操作的情况，可尝试收集多列统计信息，以便查询优化器可以更准确地估算行数，并生成更有效的执行计划。</li></ul><p><strong>如何收集统计信息</strong></p><p><code>ANALYZE</code> 语句可收集与数据库中表内容相关的统计信息，统计结果存储在系统表 <code>PG_STATISTIC</code> 中。查询优化器会使用这些统计数据，以生成最有效的执行计划。</p><pre class="line-numbers language-sql"><code class="language-sql"><span class="token comment" spellcheck="true">-- 更新单张表的统计信息</span><span class="token keyword">ANALYZE</span> tablename<span class="token punctuation">;</span><span class="token comment" spellcheck="true">-- 更新全库统计信息</span><span class="token keyword">ANALYZE</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">-- 收集 tablename 表的 col_1、col_2 列的多列统计信息</span><span class="token keyword">ANALYZE</span> tablename <span class="token punctuation">(</span>col_1<span class="token punctuation">,</span> col_2<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">-- 添加 tablename 表的 col_1、col_2 列的多列统计信息声明</span><span class="token keyword">ALTER</span> <span class="token keyword">TABLE</span> tablename <span class="token keyword">ADD</span> <span class="token keyword">STATISTICS</span> <span class="token punctuation">(</span>col_1<span class="token punctuation">,</span> col_2<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>统计信息对应视图</strong></p><p><code>PG_STATISTIC</code> 系统表存储有关该数据库中表和索引列的统计数据，需要有系统管理员权限才可以访问此系统表。该视图需要授权访问，核心字段如下：</p><table><thead><tr><th>名称</th><th>类型</th><th>描述</th></tr></thead><tbody><tr><td>starelid</td><td>oid</td><td>所描述的字段所属的表或者索引</td></tr><tr><td>starelkind</td><td>char</td><td>所属对象的类型</td></tr><tr><td>staattnum</td><td>smallint</td><td>所描述的字段在表中的编号，从 1 开始</td></tr><tr><td>stainherit</td><td>Boolean</td><td>是否统计有继承关系的对象</td></tr><tr><td>stanullfrac</td><td>real</td><td>该字段中为 NULL 的记录的比率</td></tr><tr><td>stawidth</td><td>integer</td><td>非 NULL 记录的平均存储宽度，以字节计</td></tr><tr><td>stadistinct</td><td>real</td><td>标识全局统计信息中所有 DN 上字段里唯一的非 NULL 数据值的数目</td></tr><tr><td>stakindN</td><td>smallint</td><td>一个编码，表示这种类型的统计存储在 <code>pg_statistic</code> 行的第 n 个 “槽位”</td></tr><tr><td>staopN</td><td>oid</td><td>一个用于生成这些存储在第 n 个 “槽位” 的统计信息的操作符</td></tr><tr><td>stanumbers</td><td>real[]</td><td>第 n 个 “槽位” 类型的字段数据值，如果该槽位类型不存储任何数据值，则就是 NULL</td></tr></tbody></table><hr><h3 id="3-5-3-统计信息进阶优化"><a href="#3-5-3-统计信息进阶优化" class="headerlink" title="3.5.3 统计信息进阶优化"></a>3.5.3 统计信息进阶优化</h3><p><strong>调整统计目标</strong></p><p>统计目标控制 <code>ANALYZE</code> 采样的精细度，默认 <code>default_statistics_target = 100</code>（1~10000）：</p><pre class="line-numbers language-sql"><code class="language-sql"><span class="token comment" spellcheck="true">-- 全局调整</span><span class="token keyword">ALTER</span> SYSTEM <span class="token keyword">SET</span> default_statistics_target <span class="token operator">=</span> <span class="token number">200</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">-- 单列精细调整（针对低频但重要的列）</span><span class="token keyword">ALTER</span> <span class="token keyword">TABLE</span> facilities <span class="token keyword">ALTER</span> <span class="token keyword">COLUMN</span> city <span class="token keyword">SET</span> <span class="token keyword">STATISTICS</span> <span class="token number">500</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>注意</strong>：不建议直接设为最大值（10000），会导致 <code>ANALYZE</code> 耗时增加、磁盘占用上升，建议仅对核心列调优。</p><p><strong>多列统计信息</strong></p><p>当表中多个列存在相关性，且查询中同时基于这些列进行过滤或分组时，单列统计信息可能导致优化器估算偏差。此时可通过收集多列统计信息，让优化器更准确地判断选择率：</p><pre class="line-numbers language-sql"><code class="language-sql"><span class="token comment" spellcheck="true">-- 收集多列统计信息</span><span class="token keyword">ANALYZE</span> tablename <span class="token punctuation">(</span>col1<span class="token punctuation">,</span> col2<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><strong>总结</strong></p><ol><li>统计信息是优化器的「决策依据」，核心包含基数、选择率、MCV、直方图四大维度，主要存储在 <code>pg_statistic</code> 系统表中；</li><li>统计信息通过 <code>ANALYZE</code> 语句收集，在大批量数据变更、中间表生成后应及时更新；</li><li>多列统计信息可解决列相关性导致的估算偏差，大幅提升查询性能；</li><li>调优统计信息需结合 <code>EXPLAIN ANALYZE</code> 验证效果，避免盲目调高统计目标。</li></ol><p>通过合理配置统计信息、创建多列统计，仅需几行 SQL 即可让数据库优化器做出更智能的决策，显著降低查询执行时间，充分发挥数据库性能潜力。</p><h2 id="3-6-解读执行计划"><a href="#3-6-解读执行计划" class="headerlink" title="3.6 解读执行计划"></a>3.6 解读执行计划</h2><h3 id="初识EXPLAIN的困惑"><a href="#初识EXPLAIN的困惑" class="headerlink" title="初识EXPLAIN的困惑"></a>初识EXPLAIN的困惑</h3><p>每个新晋DBA接触数据库时学到的第一个命令就是”EXPLAIN”。但第一次尝试理解它的输出时，往往会遇到令人困惑的情况：</p><pre class="line-numbers language-sql"><code class="language-sql">Sort  <span class="token punctuation">(</span>cost<span class="token operator">=</span><span class="token number">238.32</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token number">240.39</span> <span class="token keyword">rows</span><span class="token operator">=</span><span class="token number">826</span> width<span class="token operator">=</span><span class="token number">961</span><span class="token punctuation">)</span>   Sort <span class="token keyword">Key</span>: n<span class="token punctuation">.</span>nspname<span class="token punctuation">,</span> p<span class="token punctuation">.</span>proname<span class="token punctuation">,</span> <span class="token punctuation">(</span>pg_get_function_arguments<span class="token punctuation">(</span>p<span class="token punctuation">.</span>oid<span class="token punctuation">)</span><span class="token punctuation">)</span>   <span class="token operator">-</span><span class="token operator">></span>  <span class="token keyword">Hash</span> <span class="token keyword">Join</span>  <span class="token punctuation">(</span>cost<span class="token operator">=</span><span class="token number">1.25</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token number">198.30</span> <span class="token keyword">rows</span><span class="token operator">=</span><span class="token number">826</span> width<span class="token operator">=</span><span class="token number">961</span><span class="token punctuation">)</span>         <span class="token keyword">Hash</span> Cond: <span class="token punctuation">(</span>p<span class="token punctuation">.</span>pronamespace <span class="token operator">=</span> n<span class="token punctuation">.</span>oid<span class="token punctuation">)</span>         <span class="token operator">-</span><span class="token operator">></span>  Seq Scan <span class="token keyword">on</span> pg_proc p  <span class="token punctuation">(</span>cost<span class="token operator">=</span><span class="token number">0.00</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token number">182.94</span> <span class="token keyword">rows</span><span class="token operator">=</span><span class="token number">1009</span> width<span class="token operator">=</span><span class="token number">692</span><span class="token punctuation">)</span>               Filter: pg_function_is_visible<span class="token punctuation">(</span>oid<span class="token punctuation">)</span>         <span class="token operator">-</span><span class="token operator">></span>  <span class="token keyword">Hash</span>  <span class="token punctuation">(</span>cost<span class="token operator">=</span><span class="token number">1.14</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token number">1.14</span> <span class="token keyword">rows</span><span class="token operator">=</span><span class="token number">9</span> width<span class="token operator">=</span><span class="token number">117</span><span class="token punctuation">)</span>               <span class="token operator">-</span><span class="token operator">></span>  Seq Scan <span class="token keyword">on</span> pg_namespace n  <span class="token punctuation">(</span>cost<span class="token operator">=</span><span class="token number">0.00</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token number">1.14</span> <span class="token keyword">rows</span><span class="token operator">=</span><span class="token number">9</span> width<span class="token operator">=</span><span class="token number">117</span><span class="token punctuation">)</span>                     Filter: <span class="token punctuation">(</span>nspname <span class="token operator">&lt;></span> <span class="token keyword">ALL</span> <span class="token punctuation">(</span><span class="token string">'{pg_catalog,information_schema}'</span>::name<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token number">9</span> <span class="token keyword">rows</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这个复杂的执行计划输出对初学者来说简直像天书一般。让我们从基础开始，逐步揭开EXPLAIN的神秘面纱。</p><h3 id="PanweiDB的智能之处"><a href="#PanweiDB的智能之处" class="headerlink" title="PanweiDB的智能之处"></a>PanweiDB的智能之处</h3><p>首先需要理解一个关键概念：PanweiDB”知道”你的数据。它会维护详尽的元信息：</p><ul><li>表行数统计</li><li>不同值的分布</li><li>最常见值</li><li>数据分布直方图</li></ul><p>对于大型表，这些统计基于随机抽样，但总体而言，PanweiDB对数据特性的把握相当准确。正是基于这些统计信息，查询规划器才能做出明智的执行计划决策。</p><h3 id="从简单案例开始"><a href="#从简单案例开始" class="headerlink" title="从简单案例开始"></a>从简单案例开始</h3><p>让我们从一个最简单的查询开始：</p><pre class="line-numbers language-sql"><code class="language-sql"><span class="token keyword">EXPLAIN</span> <span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> test <span class="token keyword">WHERE</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-sql"><code class="language-sql">                      QUERY <span class="token keyword">PLAN</span>                      <span class="token comment" spellcheck="true">------------------------------------------------------</span> Seq Scan <span class="token keyword">ON</span> test  <span class="token punctuation">(</span>cost<span class="token operator">=</span><span class="token number">0.00</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token number">40.00</span> <span class="token keyword">ROWS</span><span class="token operator">=</span><span class="token number">12</span> width<span class="token operator">=</span><span class="token number">4</span><span class="token punctuation">)</span>   FILTER: <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token number">2</span> <span class="token keyword">ROWS</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这个执行计划包含几个关键元素：</p><ol><li><strong>操作类型</strong>：这里是顺序扫描(Seq Scan)</li><li><strong>成本估算</strong>：0.00..40.00</li><li><strong>行数估算</strong>：12行</li><li><strong>行宽估算</strong>：4字节</li></ol><h3 id="理解执行计划的结构"><a href="#理解执行计划的结构" class="headerlink" title="理解执行计划的结构"></a>理解执行计划的结构</h3><p>执行计划是一个树形结构，每个节点代表一个操作：</p><ul><li>上层节点依赖下层节点的数据</li><li>每个节点显示其特有的信息</li><li>缩进表示操作间的层级关系</li></ul><p>在我们的简单例子中，只有一个操作节点（顺序扫描）及其过滤条件。</p><h3 id="成本估算的奥秘"><a href="#成本估算的奥秘" class="headerlink" title="成本估算的奥秘"></a>成本估算的奥秘</h3><p>成本估算值(cost)可能是最令人困惑的部分。需要明确几点：</p><ol><li><p>成本不是时间单位，而是一个抽象的相对值</p></li><li><p>基于<code>postgresql.conf</code>中的成本参数计算：</p><pre class="line-numbers language-properties"><code class="language-properties"><span class="token attr-name">seq_page_cost</span> <span class="token punctuation">=</span> <span class="token attr-value">1.0      # 顺序页读取成本</span><span class="token attr-name">random_page_cost</span> <span class="token punctuation">=</span> <span class="token attr-value">4.0   # 随机页读取成本 </span><span class="token attr-name">cpu_tuple_cost</span> <span class="token punctuation">=</span> <span class="token attr-value">0.01    # 处理每行的CPU成本</span><span class="token attr-name">cpu_index_tuple_cost</span> <span class="token punctuation">=</span> <span class="token attr-value">0.005  # 索引扫描的CPU成本</span><span class="token attr-name">cpu_operator_cost</span> <span class="token punctuation">=</span> <span class="token attr-value">0.0025   # 操作符执行的CPU成本</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ol><p>成本值以<code>启动成本..总成本</code>的形式呈现。启动成本是该操作返回第一行前需要的工作量，总成本是返回所有行的总工作量。</p><h3 id="索引使用的决策逻辑"><a href="#索引使用的决策逻辑" class="headerlink" title="索引使用的决策逻辑"></a>索引使用的决策逻辑</h3><p>考虑这个表和查询：</p><pre class="line-numbers language-sql"><code class="language-sql"><span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> t <span class="token punctuation">(</span>    id <span class="token keyword">serial</span> <span class="token keyword">PRIMARY</span> <span class="token keyword">KEY</span><span class="token punctuation">,</span>    some_column <span class="token keyword">integer</span><span class="token punctuation">,</span>    something <span class="token keyword">text</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">CREATE</span> <span class="token keyword">INDEX</span> q <span class="token keyword">ON</span> t<span class="token punctuation">(</span>some_column<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">EXPLAIN</span> <span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> t <span class="token keyword">WHERE</span> some_column <span class="token operator">=</span> <span class="token number">123</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>PanweiDB会根据统计信息决定是否使用索引：</p><ul><li>对于小表（如只有几行），顺序扫描通常更快</li><li>对于大表且匹配行很少的情况，索引扫描更优</li><li>对于大表且匹配行很多的情况，索引扫描反而更慢</li></ul><h3 id="执行计划的三种形态"><a href="#执行计划的三种形态" class="headerlink" title="执行计划的三种形态"></a>执行计划的三种形态</h3><p>让我们观察同一个查询在不同设置下的执行计划变化：</p><p><strong>1.默认情况（使用索引扫描）</strong>：</p><pre class="line-numbers language-sql"><code class="language-sql"><span class="token keyword">EXPLAIN</span> <span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> test <span class="token keyword">WHERE</span> id <span class="token operator">=</span> <span class="token number">50</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-sql"><code class="language-sql">                              QUERY <span class="token keyword">PLAN</span>                               <span class="token comment" spellcheck="true">-----------------------------------------------------------------------</span> <span class="token keyword">INDEX</span> Scan <span class="token keyword">USING</span> test_pkey <span class="token keyword">ON</span> test  <span class="token punctuation">(</span>cost<span class="token operator">=</span><span class="token number">0.28</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token number">8.29</span> <span class="token keyword">ROWS</span><span class="token operator">=</span><span class="token number">1</span> width<span class="token operator">=</span><span class="token number">36</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><strong>2.禁用索引扫描（使用位图扫描）</strong>：</p><pre class="line-numbers language-sql"><code class="language-sql"><span class="token keyword">SET</span> enable_indexscan <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span><span class="token keyword">EXPLAIN</span> <span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> test <span class="token keyword">WHERE</span> id <span class="token operator">=</span> <span class="token number">50</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><pre class="line-numbers language-sql"><code class="language-sql">                               QUERY <span class="token keyword">PLAN</span>                               <span class="token comment" spellcheck="true">------------------------------------------------------------------------</span> Bitmap Heap Scan <span class="token keyword">ON</span> test  <span class="token punctuation">(</span>cost<span class="token operator">=</span><span class="token number">4.28</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token number">8.30</span> <span class="token keyword">ROWS</span><span class="token operator">=</span><span class="token number">1</span> width<span class="token operator">=</span><span class="token number">13</span><span class="token punctuation">)</span>   <span class="token operator">-</span><span class="token operator">></span>  Bitmap <span class="token keyword">INDEX</span> Scan <span class="token keyword">ON</span> test_pkey  <span class="token punctuation">(</span>cost<span class="token operator">=</span><span class="token number">0.00</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token number">4.28</span> <span class="token keyword">ROWS</span><span class="token operator">=</span><span class="token number">1</span> width<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><strong>3. 禁用所有索引相关扫描（退化为顺序扫描）</strong>：</p><pre class="line-numbers language-sql"><code class="language-sql"><span class="token keyword">SET</span> enable_bitmapscan <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span><span class="token keyword">EXPLAIN</span> <span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> test <span class="token keyword">WHERE</span> id <span class="token operator">=</span> <span class="token number">50</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><pre class="line-numbers language-sql"><code class="language-sql">                      QUERY <span class="token keyword">PLAN</span>                      <span class="token comment" spellcheck="true">------------------------------------------------------</span> Seq Scan <span class="token keyword">ON</span> test  <span class="token punctuation">(</span>cost<span class="token operator">=</span><span class="token number">0.00</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token number">18.50</span> <span class="token keyword">ROWS</span><span class="token operator">=</span><span class="token number">1</span> width<span class="token operator">=</span><span class="token number">13</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>比较这三种情况的成本估算，可以清楚地看到为什么PanweiDB默认选择索引扫描——它的总成本最低(8.29)。</p><h3 id="实际执行分析"><a href="#实际执行分析" class="headerlink" title="实际执行分析"></a>实际执行分析</h3><p><code>EXPLAIN ANALYZE</code>会实际执行查询并提供真实数据：</p><pre class="line-numbers language-sql"><code class="language-sql"><span class="token keyword">EXPLAIN</span> <span class="token keyword">ANALYZE</span> <span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> t <span class="token keyword">LIMIT</span> <span class="token number">100</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-sql"><code class="language-sql">                                                  QUERY <span class="token keyword">PLAN</span>                                                  <span class="token comment" spellcheck="true">--------------------------------------------------------------------------------------------------------------</span> <span class="token keyword">LIMIT</span>  <span class="token punctuation">(</span>cost<span class="token operator">=</span><span class="token number">0.00</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token number">9.33</span> <span class="token keyword">ROWS</span><span class="token operator">=</span><span class="token number">100</span> width<span class="token operator">=</span><span class="token number">608</span><span class="token punctuation">)</span> <span class="token punctuation">(</span>actual TIME<span class="token operator">=</span><span class="token number">0.008</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token number">0.152</span> <span class="token keyword">ROWS</span><span class="token operator">=</span><span class="token number">100</span> loops<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">)</span>   <span class="token operator">-</span><span class="token operator">></span>  Seq Scan <span class="token keyword">ON</span> t  <span class="token punctuation">(</span>cost<span class="token operator">=</span><span class="token number">0.00</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token number">93333.86</span> <span class="token keyword">ROWS</span><span class="token operator">=</span><span class="token number">999986</span> width<span class="token operator">=</span><span class="token number">608</span><span class="token punctuation">)</span> <span class="token punctuation">(</span>actual TIME<span class="token operator">=</span><span class="token number">0.007</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token number">0.133</span> <span class="token keyword">ROWS</span><span class="token operator">=</span><span class="token number">100</span> loops<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">)</span> Total runtime: <span class="token number">0.181</span> ms<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这里新增了四组实际数据：</p><ol><li><code>actual time</code>：实际执行时间(启动..完成)</li><li><code>rows</code>：实际返回行数</li><li><code>loops</code>：该操作被执行次数</li><li><code>Total runtime</code>：查询总耗时</li></ol><h3 id="执行计划中的关键陷阱"><a href="#执行计划中的关键陷阱" class="headerlink" title="执行计划中的关键陷阱"></a>执行计划中的关键陷阱</h3><ol><li><strong>多次循环执行</strong>：某些操作可能被执行多次，导致总时间远超单次执行时间。</li><li><strong>行数估算错误</strong>：统计信息不准确会导致糟糕的计划选择。</li><li><strong>函数执行特性</strong>：某些函数(如PL/pgSQL函数)必须完全执行才能返回结果。</li></ol><h2 id="3-7-扫描方式"><a href="#3-7-扫描方式" class="headerlink" title="3.7 扫描方式"></a>3.7 扫描方式</h2><h3 id="3-7-1-顺序扫描-Seq-Scan"><a href="#3-7-1-顺序扫描-Seq-Scan" class="headerlink" title="3.7.1 顺序扫描(Seq Scan)"></a>3.7.1 顺序扫描(Seq Scan)</h3><p><strong>基本工作原理</strong></p><p>顺序扫描是PanweiDB中最基础的表访问方法，其执行方式简单直接：</p><pre class="line-numbers language-sql"><code class="language-sql"><span class="token keyword">EXPLAIN</span> <span class="token keyword">ANALYZE</span> <span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> pg_class<span class="token punctuation">;</span>                                               QUERY <span class="token keyword">PLAN</span>                                                <span class="token comment" spellcheck="true">---------------------------------------------------------------------------------------------------------</span> Seq Scan <span class="token keyword">ON</span> pg_class  <span class="token punctuation">(</span>cost<span class="token operator">=</span><span class="token number">0.00</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token number">10.92</span> <span class="token keyword">ROWS</span><span class="token operator">=</span><span class="token number">292</span> width<span class="token operator">=</span><span class="token number">202</span><span class="token punctuation">)</span>        <span class="token punctuation">(</span>actual TIME<span class="token operator">=</span><span class="token number">0.009</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token number">0.049</span> <span class="token keyword">ROWS</span><span class="token operator">=</span><span class="token number">295</span> loops<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">)</span> Total runtime: <span class="token number">0.249</span> ms<span class="token punctuation">(</span><span class="token number">2</span> <span class="token keyword">ROWS</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>顺序扫描会逐页读取表数据文件，不加筛选地返回所有行（除非有WHERE条件过滤）。它的特点包括：</p><ul><li><strong>无顺序保证</strong>：返回行的顺序不具有任何特定性，既非插入顺序也非更新顺序</li><li><strong>全表遍历</strong>：会读取表中所有数据页</li><li><strong>过滤能力</strong>：可以通过WHERE条件进行行过滤</li></ul><p><strong>带LIMIT的顺序扫描</strong></p><p>当与LIMIT结合时，顺序扫描可以在获取足够行数后提前终止：</p><pre class="line-numbers language-sql"><code class="language-sql"><span class="token keyword">EXPLAIN</span> <span class="token keyword">ANALYZE</span> <span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> pg_class <span class="token keyword">LIMIT</span> <span class="token number">2</span><span class="token punctuation">;</span>                                                 QUERY <span class="token keyword">PLAN</span>                                                  <span class="token comment" spellcheck="true">-------------------------------------------------------------------------------------------------------------</span> <span class="token keyword">LIMIT</span>  <span class="token punctuation">(</span>cost<span class="token operator">=</span><span class="token number">0.00</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token number">0.07</span> <span class="token keyword">ROWS</span><span class="token operator">=</span><span class="token number">2</span> width<span class="token operator">=</span><span class="token number">202</span><span class="token punctuation">)</span> <span class="token punctuation">(</span>actual TIME<span class="token operator">=</span><span class="token number">0.014</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token number">0.014</span> <span class="token keyword">ROWS</span><span class="token operator">=</span><span class="token number">2</span> loops<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">)</span>   <span class="token operator">-</span><span class="token operator">></span>  Seq Scan <span class="token keyword">ON</span> pg_class  <span class="token punctuation">(</span>cost<span class="token operator">=</span><span class="token number">0.00</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token number">10.92</span> <span class="token keyword">ROWS</span><span class="token operator">=</span><span class="token number">292</span> width<span class="token operator">=</span><span class="token number">202</span><span class="token punctuation">)</span>          <span class="token punctuation">(</span>actual TIME<span class="token operator">=</span><span class="token number">0.009</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token number">0.009</span> <span class="token keyword">ROWS</span><span class="token operator">=</span><span class="token number">2</span> loops<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">)</span> Total runtime: <span class="token number">0.132</span> ms<span class="token punctuation">(</span><span class="token number">3</span> <span class="token keyword">ROWS</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>带WHERE条件的顺序扫描</strong></p><p>当添加WHERE条件时，顺序扫描会进行行过滤：</p><pre class="line-numbers language-sql"><code class="language-sql"><span class="token keyword">EXPLAIN</span> <span class="token keyword">ANALYZE</span> <span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> pg_class <span class="token keyword">WHERE</span> relname <span class="token operator">~</span> <span class="token string">'a'</span><span class="token punctuation">;</span>                                               QUERY <span class="token keyword">PLAN</span>                                                <span class="token comment" spellcheck="true">---------------------------------------------------------------------------------------------------------</span> Seq Scan <span class="token keyword">ON</span> pg_class  <span class="token punctuation">(</span>cost<span class="token operator">=</span><span class="token number">0.00</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token number">11.65</span> <span class="token keyword">ROWS</span><span class="token operator">=</span><span class="token number">227</span> width<span class="token operator">=</span><span class="token number">202</span><span class="token punctuation">)</span>        <span class="token punctuation">(</span>actual TIME<span class="token operator">=</span><span class="token number">0.030</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token number">0.294</span> <span class="token keyword">ROWS</span><span class="token operator">=</span><span class="token number">229</span> loops<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">)</span>   FILTER: <span class="token punctuation">(</span>relname <span class="token operator">~</span> <span class="token string">'a'</span>::<span class="token keyword">text</span><span class="token punctuation">)</span>   <span class="token keyword">ROWS</span> Removed <span class="token keyword">BY</span> FILTER: <span class="token number">66</span> Total runtime: <span class="token number">0.379</span> ms<span class="token punctuation">(</span><span class="token number">4</span> <span class="token keyword">ROWS</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>PostgreSQL 9.2+版本会额外显示被过滤掉的行数，这对性能分析很有帮助。</p><h3 id="3-7-2-索引扫描-Index-Scan"><a href="#3-7-2-索引扫描-Index-Scan" class="headerlink" title="3.7.2 索引扫描(Index Scan)"></a>3.7.2 索引扫描(Index Scan)</h3><p><strong>基本索引扫描</strong></p><p>当查询条件能够利用索引时，PanweiDB会优先考虑使用索引扫描：</p><pre class="line-numbers language-sql"><code class="language-sql"><span class="token keyword">EXPLAIN</span> <span class="token keyword">ANALYZE</span> <span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> pg_class <span class="token keyword">WHERE</span> oid <span class="token operator">=</span> <span class="token number">1247</span><span class="token punctuation">;</span>                                                          QUERY <span class="token keyword">PLAN</span>                                                           <span class="token comment" spellcheck="true">-------------------------------------------------------------------------------------------------------------------------------</span> <span class="token keyword">INDEX</span> Scan <span class="token keyword">USING</span> pg_class_oid_index <span class="token keyword">ON</span> pg_class         <span class="token punctuation">(</span>cost<span class="token operator">=</span><span class="token number">0.15</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token number">8.17</span> <span class="token keyword">ROWS</span><span class="token operator">=</span><span class="token number">1</span> width<span class="token operator">=</span><span class="token number">202</span><span class="token punctuation">)</span>        <span class="token punctuation">(</span>actual TIME<span class="token operator">=</span><span class="token number">0.007</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token number">0.007</span> <span class="token keyword">ROWS</span><span class="token operator">=</span><span class="token number">1</span> loops<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">)</span>   <span class="token keyword">INDEX</span> Cond: <span class="token punctuation">(</span>oid <span class="token operator">=</span> <span class="token number">1247</span>::oid<span class="token punctuation">)</span> Total runtime: <span class="token number">0.077</span> ms<span class="token punctuation">(</span><span class="token number">3</span> <span class="token keyword">ROWS</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>索引扫描的工作流程：</strong></p><ol><li>打开相关索引</li><li>在索引中定位符合条件的键值</li><li>通过索引指针访问表数据页</li><li>检查行可见性（考虑MVCC机制）</li><li>返回可见行</li></ol><p><strong>排序优化：利用索引顺序</strong></p><p>索引扫描的一个关键优势是可以避免显式排序：</p><pre class="line-numbers language-sql"><code class="language-sql"><span class="token keyword">EXPLAIN</span> <span class="token keyword">ANALYZE</span> <span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> pg_class <span class="token keyword">ORDER</span> <span class="token keyword">BY</span> oid <span class="token keyword">LIMIT</span> <span class="token number">10</span><span class="token punctuation">;</span>                                                               QUERY <span class="token keyword">PLAN</span>                                                                <span class="token comment" spellcheck="true">-----------------------------------------------------------------------------------------------------------------------------------------</span> <span class="token keyword">LIMIT</span>  <span class="token punctuation">(</span>cost<span class="token operator">=</span><span class="token number">0.15</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token number">1.67</span> <span class="token keyword">ROWS</span><span class="token operator">=</span><span class="token number">10</span> width<span class="token operator">=</span><span class="token number">206</span><span class="token punctuation">)</span> <span class="token punctuation">(</span>actual TIME<span class="token operator">=</span><span class="token number">0.017</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token number">0.029</span> <span class="token keyword">ROWS</span><span class="token operator">=</span><span class="token number">10</span> loops<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">)</span>   <span class="token operator">-</span><span class="token operator">></span>  <span class="token keyword">INDEX</span> Scan <span class="token keyword">USING</span> pg_class_oid_index <span class="token keyword">ON</span> pg_class           <span class="token punctuation">(</span>cost<span class="token operator">=</span><span class="token number">0.15</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token number">44.53</span> <span class="token keyword">ROWS</span><span class="token operator">=</span><span class="token number">292</span> width<span class="token operator">=</span><span class="token number">206</span><span class="token punctuation">)</span>          <span class="token punctuation">(</span>actual TIME<span class="token operator">=</span><span class="token number">0.014</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token number">0.026</span> <span class="token keyword">ROWS</span><span class="token operator">=</span><span class="token number">10</span> loops<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">)</span> Total runtime: <span class="token number">0.145</span> ms<span class="token punctuation">(</span><span class="token number">3</span> <span class="token keyword">ROWS</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>反向索引扫描(Index Scan Backward)</strong></p><p>对于DESC排序，PanweiDB会使用反向索引扫描：</p><pre class="line-numbers language-sql"><code class="language-sql"><span class="token keyword">EXPLAIN</span> <span class="token keyword">ANALYZE</span> <span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> pg_class <span class="token keyword">WHERE</span> oid <span class="token operator">&lt;</span> <span class="token number">1247</span> <span class="token keyword">ORDER</span> <span class="token keyword">BY</span> oid <span class="token keyword">DESC</span> <span class="token keyword">LIMIT</span> <span class="token number">10</span><span class="token punctuation">;</span>                                                                   QUERY <span class="token keyword">PLAN</span>                                                                    <span class="token comment" spellcheck="true">-------------------------------------------------------------------------------------------------------------------------------------------------</span> <span class="token keyword">LIMIT</span>  <span class="token punctuation">(</span>cost<span class="token operator">=</span><span class="token number">0.15</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token number">4.03</span> <span class="token keyword">ROWS</span><span class="token operator">=</span><span class="token number">10</span> width<span class="token operator">=</span><span class="token number">206</span><span class="token punctuation">)</span> <span class="token punctuation">(</span>actual TIME<span class="token operator">=</span><span class="token number">0.012</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token number">0.026</span> <span class="token keyword">ROWS</span><span class="token operator">=</span><span class="token number">10</span> loops<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">)</span>   <span class="token operator">-</span><span class="token operator">></span>  <span class="token keyword">INDEX</span> Scan Backward <span class="token keyword">USING</span> pg_class_oid_index <span class="token keyword">ON</span> pg_class           <span class="token punctuation">(</span>cost<span class="token operator">=</span><span class="token number">0.15</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token number">37.84</span> <span class="token keyword">ROWS</span><span class="token operator">=</span><span class="token number">97</span> width<span class="token operator">=</span><span class="token number">206</span><span class="token punctuation">)</span>          <span class="token punctuation">(</span>actual TIME<span class="token operator">=</span><span class="token number">0.009</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token number">0.022</span> <span class="token keyword">ROWS</span><span class="token operator">=</span><span class="token number">10</span> loops<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">)</span>         <span class="token keyword">INDEX</span> Cond: <span class="token punctuation">(</span>oid <span class="token operator">&lt;</span> <span class="token number">1247</span>::oid<span class="token punctuation">)</span> Total runtime: <span class="token number">0.119</span> ms<span class="token punctuation">(</span><span class="token number">4</span> <span class="token keyword">ROWS</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="3-7-3-仅索引扫描-Index-Only-Scan"><a href="#3-7-3-仅索引扫描-Index-Only-Scan" class="headerlink" title="3.7.3. 仅索引扫描(Index Only Scan)"></a>3.7.3. 仅索引扫描(Index Only Scan)</h3><p><strong>工作原理</strong></p><p>当查询只需返回索引列数据时，可以完全避免访问表数据页：</p><pre><code>-- 创建测试表CREATE TABLE test (id serial PRIMARY KEY, i int4);INSERT INTO test (i) SELECT random() * 1000000000 FROM generate_series(1,100000);VACUUM ANALYZE test;</code></pre><pre class="line-numbers language-sql"><code class="language-sql"><span class="token keyword">EXPLAIN</span> <span class="token keyword">ANALYZE</span> <span class="token keyword">SELECT</span> id <span class="token keyword">FROM</span> test <span class="token keyword">ORDER</span> <span class="token keyword">BY</span> id <span class="token keyword">ASC</span> <span class="token keyword">LIMIT</span> <span class="token number">10</span><span class="token punctuation">;</span>                                                             QUERY <span class="token keyword">PLAN</span>                                                             <span class="token comment" spellcheck="true">------------------------------------------------------------------------------------------------------------------------------------</span> <span class="token keyword">LIMIT</span>  <span class="token punctuation">(</span>cost<span class="token operator">=</span><span class="token number">0.29</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token number">0.55</span> <span class="token keyword">ROWS</span><span class="token operator">=</span><span class="token number">10</span> width<span class="token operator">=</span><span class="token number">4</span><span class="token punctuation">)</span> <span class="token punctuation">(</span>actual TIME<span class="token operator">=</span><span class="token number">0.039</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token number">0.042</span> <span class="token keyword">ROWS</span><span class="token operator">=</span><span class="token number">10</span> loops<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">)</span>   <span class="token operator">-</span><span class="token operator">></span>  <span class="token keyword">INDEX</span> ONLY Scan <span class="token keyword">USING</span> test_pkey <span class="token keyword">ON</span> test           <span class="token punctuation">(</span>cost<span class="token operator">=</span><span class="token number">0.29</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token number">2604.29</span> <span class="token keyword">ROWS</span><span class="token operator">=</span><span class="token number">100000</span> width<span class="token operator">=</span><span class="token number">4</span><span class="token punctuation">)</span>          <span class="token punctuation">(</span>actual TIME<span class="token operator">=</span><span class="token number">0.036</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token number">0.038</span> <span class="token keyword">ROWS</span><span class="token operator">=</span><span class="token number">10</span> loops<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">)</span>         Heap Fetches: <span class="token number">0</span> Total runtime: <span class="token number">0.092</span> ms<span class="token punctuation">(</span><span class="token number">4</span> <span class="token keyword">ROWS</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>关键点：</p><ul><li>仅当查询所需数据全部包含在索引中时可用</li><li>需要确保索引的可见性映射(visibility map)是最新的（通过VACUUM维护）</li><li>“Heap Fetches”显示实际需要访问表数据页的次数（理想情况下为0）</li></ul><h3 id="3-7-4-位图扫描-Bitmap-Scan"><a href="#3-7-4-位图扫描-Bitmap-Scan" class="headerlink" title="3.7.4 位图扫描(Bitmap Scan)"></a>3.7.4 位图扫描(Bitmap Scan)</h3><p><strong>基本位图扫描</strong></p><p>位图扫描结合了顺序扫描和索引扫描的优点，分两个阶段执行：</p><pre class="line-numbers language-sql"><code class="language-sql"><span class="token keyword">CREATE</span> <span class="token keyword">INDEX</span> i1 <span class="token keyword">ON</span> test <span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">EXPLAIN</span> <span class="token keyword">ANALYZE</span> <span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> test <span class="token keyword">WHERE</span> i <span class="token operator">&lt;</span> <span class="token number">100000</span><span class="token punctuation">;</span>                                                 QUERY <span class="token keyword">PLAN</span>                                                  <span class="token comment" spellcheck="true">-------------------------------------------------------------------------------------------------------------</span> Bitmap Heap Scan <span class="token keyword">ON</span> test  <span class="token punctuation">(</span>cost<span class="token operator">=</span><span class="token number">4.37</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token number">39.99</span> <span class="token keyword">ROWS</span><span class="token operator">=</span><span class="token number">10</span> width<span class="token operator">=</span><span class="token number">8</span><span class="token punctuation">)</span>        <span class="token punctuation">(</span>actual TIME<span class="token operator">=</span><span class="token number">0.025</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token number">0.110</span> <span class="token keyword">ROWS</span><span class="token operator">=</span><span class="token number">13</span> loops<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">)</span>   Recheck Cond: <span class="token punctuation">(</span>i <span class="token operator">&lt;</span> <span class="token number">100000</span><span class="token punctuation">)</span>   <span class="token operator">-</span><span class="token operator">></span>  Bitmap <span class="token keyword">INDEX</span> Scan <span class="token keyword">ON</span> i1  <span class="token punctuation">(</span>cost<span class="token operator">=</span><span class="token number">0.00</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token number">4.37</span> <span class="token keyword">ROWS</span><span class="token operator">=</span><span class="token number">10</span> width<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">)</span>          <span class="token punctuation">(</span>actual TIME<span class="token operator">=</span><span class="token number">0.013</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token number">0.013</span> <span class="token keyword">ROWS</span><span class="token operator">=</span><span class="token number">13</span> loops<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">)</span>         <span class="token keyword">INDEX</span> Cond: <span class="token punctuation">(</span>i <span class="token operator">&lt;</span> <span class="token number">100000</span><span class="token punctuation">)</span> Total runtime: <span class="token number">0.154</span> ms<span class="token punctuation">(</span><span class="token number">5</span> <span class="token keyword">ROWS</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>工作流程：</p><ol><li><strong>位图索引扫描</strong>：创建表示可能包含匹配行的数据页的位图</li><li><strong>位图堆扫描</strong>：按物理顺序访问标记的数据页，减少随机I/O</li></ol><p><strong>多条件位图组合</strong></p><p>位图扫描的强大之处在于能够组合多个索引条件：</p><pre class="line-numbers language-sql"><code class="language-sql"><span class="token comment" spellcheck="true">-- 添加更多列和索引</span><span class="token keyword">ALTER</span> <span class="token keyword">TABLE</span> test <span class="token keyword">ADD</span> <span class="token keyword">COLUMN</span> j int4 <span class="token keyword">DEFAULT</span> random<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token number">1000000000</span><span class="token punctuation">;</span><span class="token keyword">ALTER</span> <span class="token keyword">TABLE</span> test <span class="token keyword">ADD</span> <span class="token keyword">COLUMN</span> h int4 <span class="token keyword">DEFAULT</span> random<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token number">1000000000</span><span class="token punctuation">;</span><span class="token keyword">CREATE</span> <span class="token keyword">INDEX</span> i2 <span class="token keyword">ON</span> test <span class="token punctuation">(</span>j<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">CREATE</span> <span class="token keyword">INDEX</span> i3 <span class="token keyword">ON</span> test <span class="token punctuation">(</span>h<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-bash"><code class="language-bash">EXPLAIN ANALYZE SELECT * FROM <span class="token function">test</span> WHERE j <span class="token operator">&lt;</span> 50000000 AND i <span class="token operator">&lt;</span> 50000000 AND h <span class="token operator">></span> 950000000<span class="token punctuation">;</span>                                                       QUERY PLAN                                                       ------------------------------------------------------------------------------------------------------------------------ Bitmap Heap Scan ON <span class="token function">test</span>  <span class="token punctuation">(</span>cost<span class="token operator">=</span>280.76<span class="token punctuation">..</span>323.61 ROWS<span class="token operator">=</span>12 width<span class="token operator">=</span>16<span class="token punctuation">)</span>        <span class="token punctuation">(</span>actual TIME<span class="token operator">=</span>2.295<span class="token punctuation">..</span>2.352 ROWS<span class="token operator">=</span>11 loops<span class="token operator">=</span>1<span class="token punctuation">)</span>   Recheck Cond: <span class="token variable"><span class="token punctuation">((</span>h <span class="token operator">></span> <span class="token number">950000000</span><span class="token punctuation">)</span> AND <span class="token punctuation">(</span>j <span class="token operator">&lt;</span> <span class="token number">50000000</span><span class="token punctuation">)</span> AND <span class="token punctuation">(</span>i <span class="token operator">&lt;</span> <span class="token number">50000000</span><span class="token punctuation">))</span></span>   -<span class="token operator">></span>  BitmapAnd  <span class="token punctuation">(</span>cost<span class="token operator">=</span>280.76<span class="token punctuation">..</span>280.76 ROWS<span class="token operator">=</span>12 width<span class="token operator">=</span>0<span class="token punctuation">)</span>          <span class="token punctuation">(</span>actual TIME<span class="token operator">=</span>2.278<span class="token punctuation">..</span>2.278 ROWS<span class="token operator">=</span>0 loops<span class="token operator">=</span>1<span class="token punctuation">)</span>         -<span class="token operator">></span>  Bitmap INDEX Scan ON i3  <span class="token punctuation">(</span>cost<span class="token operator">=</span>0.00<span class="token punctuation">..</span>92.53 ROWS<span class="token operator">=</span>4832 width<span class="token operator">=</span>0<span class="token punctuation">)</span>                <span class="token punctuation">(</span>actual TIME<span class="token operator">=</span>0.546<span class="token punctuation">..</span>0.546 ROWS<span class="token operator">=</span>4938 loops<span class="token operator">=</span>1<span class="token punctuation">)</span>               INDEX Cond: <span class="token punctuation">(</span>h <span class="token operator">></span> 950000000<span class="token punctuation">)</span>         -<span class="token operator">></span>  Bitmap INDEX Scan ON i2  <span class="token punctuation">(</span>cost<span class="token operator">=</span>0.00<span class="token punctuation">..</span>93.76 ROWS<span class="token operator">=</span>4996 width<span class="token operator">=</span>0<span class="token punctuation">)</span>                <span class="token punctuation">(</span>actual TIME<span class="token operator">=</span>0.783<span class="token punctuation">..</span>0.783 ROWS<span class="token operator">=</span>5021 loops<span class="token operator">=</span>1<span class="token punctuation">)</span>               INDEX Cond: <span class="token punctuation">(</span>j <span class="token operator">&lt;</span> 50000000<span class="token punctuation">)</span>         -<span class="token operator">></span>  Bitmap INDEX Scan ON i1  <span class="token punctuation">(</span>cost<span class="token operator">=</span>0.00<span class="token punctuation">..</span>93.96 ROWS<span class="token operator">=</span>5022 width<span class="token operator">=</span>0<span class="token punctuation">)</span>                <span class="token punctuation">(</span>actual TIME<span class="token operator">=</span>0.798<span class="token punctuation">..</span>0.798 ROWS<span class="token operator">=</span>4998 loops<span class="token operator">=</span>1<span class="token punctuation">)</span>               INDEX Cond: <span class="token punctuation">(</span>i <span class="token operator">&lt;</span> 50000000<span class="token punctuation">)</span> Total runtime: 2.428 ms<span class="token punctuation">(</span>10 ROWS<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>位图扫描支持三种逻辑组合操作：</p><ul><li><strong>BitmapOr</strong>：用于OR条件</li><li><strong>BitmapAnd</strong>：用于AND条件</li><li><strong>BitmapAnd+BitmapOr</strong>：用于复杂条件组合</li></ul><h3 id="3-7-5-扫描类型选择策略"><a href="#3-7-5-扫描类型选择策略" class="headerlink" title="3.7.5 扫描类型选择策略"></a>3.7.5 扫描类型选择策略</h3><p><strong>选择依据</strong></p><p>PanweiDB基于成本模型选择扫描类型，考虑因素包括：</p><ol><li>预计需要读取的数据比例</li><li>索引的选择性</li><li>随机I/O与顺序I/O的成本差异</li><li>内存缓冲区命中率</li></ol><p><strong>一般指导原则</strong></p><ul><li><strong>小表</strong>：优先顺序扫描</li><li><strong>高选择性查询</strong>：优先索引扫描</li><li><strong>中等选择性查询</strong>：考虑位图扫描</li><li><strong>仅索引列查询</strong>：尽可能使用仅索引扫描</li></ul><h2 id="3-8-连接方式"><a href="#3-8-连接方式" class="headerlink" title="3.8 连接方式"></a>3.8 连接方式</h2><h3 id="3-8-1-哈希连接（Hash-Join）"><a href="#3-8-1-哈希连接（Hash-Join）" class="headerlink" title="3.8.1 哈希连接（Hash Join）"></a>3.8.1 <strong>哈希连接（Hash Join）</strong></h3><p>哈希连接用于连接两个数据集，包含两个子操作：一个总是”Hash”操作，另一个是任意操作。</p><p>示例：</p><pre class="line-numbers language-sql"><code class="language-sql"><span class="token keyword">EXPLAIN</span> <span class="token keyword">ANALYZE</span> <span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> pg_class <span class="token number">c</span> <span class="token keyword">JOIN</span> pg_namespace n <span class="token keyword">ON</span> <span class="token number">c</span><span class="token punctuation">.</span>relnamespace <span class="token operator">=</span> n<span class="token punctuation">.</span>oid<span class="token punctuation">;</span>                                                       QUERY <span class="token keyword">PLAN</span><span class="token comment" spellcheck="true">------------------------------------------------------------------------------------------------------------------------</span> <span class="token keyword">Hash</span> <span class="token keyword">Join</span>  <span class="token punctuation">(</span>cost<span class="token operator">=</span><span class="token number">1.25</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token number">20.61</span> <span class="token keyword">rows</span><span class="token operator">=</span><span class="token number">352</span> width<span class="token operator">=</span><span class="token number">339</span><span class="token punctuation">)</span> <span class="token punctuation">(</span>actual time<span class="token operator">=</span><span class="token number">0.028</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token number">0.217</span> <span class="token keyword">rows</span><span class="token operator">=</span><span class="token number">357</span> loops<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">)</span>   <span class="token keyword">Hash</span> Cond: <span class="token punctuation">(</span><span class="token number">c</span><span class="token punctuation">.</span>relnamespace <span class="token operator">=</span> n<span class="token punctuation">.</span>oid<span class="token punctuation">)</span>   <span class="token operator">-</span><span class="token operator">></span>  Seq Scan <span class="token keyword">on</span> pg_class <span class="token number">c</span>  <span class="token punctuation">(</span>cost<span class="token operator">=</span><span class="token number">0.00</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token number">14.52</span> <span class="token keyword">rows</span><span class="token operator">=</span><span class="token number">352</span> width<span class="token operator">=</span><span class="token number">226</span><span class="token punctuation">)</span> <span class="token punctuation">(</span>actual time<span class="token operator">=</span><span class="token number">0.006</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token number">0.037</span> <span class="token keyword">rows</span><span class="token operator">=</span><span class="token number">357</span> loops<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">)</span>   <span class="token operator">-</span><span class="token operator">></span>  <span class="token keyword">Hash</span>  <span class="token punctuation">(</span>cost<span class="token operator">=</span><span class="token number">1.11</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token number">1.11</span> <span class="token keyword">rows</span><span class="token operator">=</span><span class="token number">11</span> width<span class="token operator">=</span><span class="token number">117</span><span class="token punctuation">)</span> <span class="token punctuation">(</span>actual time<span class="token operator">=</span><span class="token number">0.015</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token number">0.015</span> <span class="token keyword">rows</span><span class="token operator">=</span><span class="token number">11</span> loops<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">)</span>         Buckets: <span class="token number">1024</span>  Batches: <span class="token number">1</span>  Memory <span class="token keyword">Usage</span>: 10kB         <span class="token operator">-</span><span class="token operator">></span>  Seq Scan <span class="token keyword">on</span> pg_namespace n  <span class="token punctuation">(</span>cost<span class="token operator">=</span><span class="token number">0.00</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token number">1.11</span> <span class="token keyword">rows</span><span class="token operator">=</span><span class="token number">11</span> width<span class="token operator">=</span><span class="token number">117</span><span class="token punctuation">)</span> <span class="token punctuation">(</span>actual time<span class="token operator">=</span><span class="token number">0.009</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token number">0.011</span> <span class="token keyword">rows</span><span class="token operator">=</span><span class="token number">11</span> loops<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>工作流程：</p><ol><li>先执行Hash子操作构建哈希表</li><li>然后执行另一侧操作，对每行在哈希表中查找匹配</li><li>找到匹配则输出连接结果</li></ol><h3 id="3-8-2-嵌套循环连接（Nested-Loop）"><a href="#3-8-2-嵌套循环连接（Nested-Loop）" class="headerlink" title="3.8.2 嵌套循环连接（Nested Loop）"></a>3.8.2 <strong>嵌套循环连接（Nested Loop）</strong></h3><p>嵌套循环连接有两个子操作，对左侧结果的每一行执行右侧操作。</p><p>示例：</p><pre class="line-numbers language-sql"><code class="language-sql"><span class="token keyword">EXPLAIN</span> <span class="token keyword">ANALYZE</span> <span class="token keyword">SELECT</span> <span class="token number">a</span><span class="token punctuation">.</span><span class="token operator">*</span> <span class="token keyword">FROM</span> pg_class <span class="token number">c</span> <span class="token keyword">JOIN</span> pg_attribute <span class="token number">a</span> <span class="token keyword">ON</span> <span class="token number">c</span><span class="token punctuation">.</span>oid <span class="token operator">=</span> <span class="token number">a</span><span class="token punctuation">.</span>attrelid<span class="token keyword">WHERE</span> <span class="token number">c</span><span class="token punctuation">.</span>relname <span class="token operator">IN</span> <span class="token punctuation">(</span><span class="token string">'pg_class'</span><span class="token punctuation">,</span> <span class="token string">'pg_namespace'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                                                                        QUERY <span class="token keyword">PLAN</span><span class="token comment" spellcheck="true">----------------------------------------------------------------------------------------------------------------------------------------------------------</span> Nested Loop  <span class="token punctuation">(</span>cost<span class="token operator">=</span><span class="token number">8.84</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token number">55.73</span> <span class="token keyword">rows</span><span class="token operator">=</span><span class="token number">15</span> width<span class="token operator">=</span><span class="token number">203</span><span class="token punctuation">)</span> <span class="token punctuation">(</span>actual time<span class="token operator">=</span><span class="token number">0.018</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token number">0.043</span> <span class="token keyword">rows</span><span class="token operator">=</span><span class="token number">48</span> loops<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">)</span>   <span class="token operator">-</span><span class="token operator">></span>  Bitmap Heap Scan <span class="token keyword">on</span> pg_class <span class="token number">c</span>  <span class="token punctuation">(</span>cost<span class="token operator">=</span><span class="token number">8.56</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token number">14.03</span> <span class="token keyword">rows</span><span class="token operator">=</span><span class="token number">2</span> width<span class="token operator">=</span><span class="token number">4</span><span class="token punctuation">)</span> <span class="token punctuation">(</span>actual time<span class="token operator">=</span><span class="token number">0.011</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token number">0.012</span> <span class="token keyword">rows</span><span class="token operator">=</span><span class="token number">2</span> loops<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">)</span>         Recheck Cond: <span class="token punctuation">(</span>relname <span class="token operator">=</span> <span class="token keyword">ANY</span> <span class="token punctuation">(</span><span class="token string">'{pg_class,pg_namespace}'</span>::name<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span>         Heap Blocks: exact<span class="token operator">=</span><span class="token number">2</span>         <span class="token operator">-</span><span class="token operator">></span>  Bitmap <span class="token keyword">Index</span> Scan <span class="token keyword">on</span> pg_class_relname_nsp_index  <span class="token punctuation">(</span>cost<span class="token operator">=</span><span class="token number">0.00</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token number">8.56</span> <span class="token keyword">rows</span><span class="token operator">=</span><span class="token number">2</span> width<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">(</span>actual time<span class="token operator">=</span><span class="token number">0.009</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token number">0.009</span> <span class="token keyword">rows</span><span class="token operator">=</span><span class="token number">2</span> loops<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">)</span>               <span class="token keyword">Index</span> Cond: <span class="token punctuation">(</span>relname <span class="token operator">=</span> <span class="token keyword">ANY</span> <span class="token punctuation">(</span><span class="token string">'{pg_class,pg_namespace}'</span>::name<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span>   <span class="token operator">-</span><span class="token operator">></span>  <span class="token keyword">Index</span> Scan <span class="token keyword">using</span> pg_attribute_relid_attnum_index <span class="token keyword">on</span> pg_attribute <span class="token number">a</span>  <span class="token punctuation">(</span>cost<span class="token operator">=</span><span class="token number">0.28</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token number">20.77</span> <span class="token keyword">rows</span><span class="token operator">=</span><span class="token number">8</span> width<span class="token operator">=</span><span class="token number">203</span><span class="token punctuation">)</span> <span class="token punctuation">(</span>actual time<span class="token operator">=</span><span class="token number">0.004</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token number">0.007</span> <span class="token keyword">rows</span><span class="token operator">=</span><span class="token number">24</span> loops<span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">)</span>         <span class="token keyword">Index</span> Cond: <span class="token punctuation">(</span>attrelid <span class="token operator">=</span> <span class="token number">c</span><span class="token punctuation">.</span>oid<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>注意Index Scan的<code>loops=2</code>表示该操作执行了两次。</p><h3 id="3-8-3-合并连接（Merge-Join）"><a href="#3-8-3-合并连接（Merge-Join）" class="headerlink" title="3.8.3 合并连接（Merge Join）"></a>3.8.3 <strong>合并连接（Merge Join）</strong></h3><p>当连接的数据集已按连接键排序时使用此方法。</p><p>示例（强制使用排序）：</p><pre class="line-numbers language-sql"><code class="language-sql"><span class="token keyword">EXPLAIN</span> <span class="token keyword">ANALYZE</span> <span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span>    <span class="token punctuation">(</span><span class="token keyword">SELECT</span> oid<span class="token punctuation">,</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> pg_class <span class="token keyword">ORDER</span> <span class="token keyword">BY</span> oid<span class="token punctuation">)</span> <span class="token keyword">AS</span> <span class="token number">c</span>    <span class="token keyword">JOIN</span>    <span class="token punctuation">(</span><span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> pg_attribute <span class="token number">a</span> <span class="token keyword">ORDER</span> <span class="token keyword">BY</span> attrelid<span class="token punctuation">)</span> <span class="token keyword">AS</span> <span class="token number">a</span>    <span class="token keyword">ON</span> <span class="token number">c</span><span class="token punctuation">.</span>oid <span class="token operator">=</span> <span class="token number">a</span><span class="token punctuation">.</span>attrelid<span class="token punctuation">;</span> QUERY <span class="token keyword">PLAN</span><span class="token comment" spellcheck="true">---------------------------------------------------------------------------------------------------------------------------------------------------------------</span><span class="token comment" spellcheck="true">-------</span> <span class="token keyword">Merge</span> <span class="token keyword">Join</span>  <span class="token punctuation">(</span>cost<span class="token operator">=</span><span class="token number">29.69</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token number">352.26</span> <span class="token keyword">rows</span><span class="token operator">=</span><span class="token number">2716</span> width<span class="token operator">=</span><span class="token number">433</span><span class="token punctuation">)</span> <span class="token punctuation">(</span>actual time<span class="token operator">=</span><span class="token number">0.347</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token number">10.218</span> <span class="token keyword">rows</span><span class="token operator">=</span><span class="token number">2749</span> loops<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">)</span>   <span class="token keyword">Merge</span> Cond: <span class="token punctuation">(</span>pg_class<span class="token punctuation">.</span>oid <span class="token operator">=</span> <span class="token number">a</span><span class="token punctuation">.</span>attrelid<span class="token punctuation">)</span>   <span class="token operator">-</span><span class="token operator">></span>  Sort  <span class="token punctuation">(</span>cost<span class="token operator">=</span><span class="token number">29.41</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token number">30.29</span> <span class="token keyword">rows</span><span class="token operator">=</span><span class="token number">352</span> width<span class="token operator">=</span><span class="token number">230</span><span class="token punctuation">)</span> <span class="token punctuation">(</span>actual time<span class="token operator">=</span><span class="token number">0.299</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token number">0.363</span> <span class="token keyword">rows</span><span class="token operator">=</span><span class="token number">357</span> loops<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">)</span>         Sort <span class="token keyword">Key</span>: pg_class<span class="token punctuation">.</span>oid         Sort Method: quicksort  Memory: 119kB         <span class="token operator">-</span><span class="token operator">></span>  Seq Scan <span class="token keyword">on</span> pg_class  <span class="token punctuation">(</span>cost<span class="token operator">=</span><span class="token number">0.00</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token number">14.52</span> <span class="token keyword">rows</span><span class="token operator">=</span><span class="token number">352</span> width<span class="token operator">=</span><span class="token number">230</span><span class="token punctuation">)</span> <span class="token punctuation">(</span>actual time<span class="token operator">=</span><span class="token number">0.014</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token number">0.147</span> <span class="token keyword">rows</span><span class="token operator">=</span><span class="token number">357</span> loops<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">)</span>   <span class="token operator">-</span><span class="token operator">></span>  Materialize  <span class="token punctuation">(</span>cost<span class="token operator">=</span><span class="token number">0.28</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token number">283.62</span> <span class="token keyword">rows</span><span class="token operator">=</span><span class="token number">2716</span> width<span class="token operator">=</span><span class="token number">203</span><span class="token punctuation">)</span> <span class="token punctuation">(</span>actual time<span class="token operator">=</span><span class="token number">0.017</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token number">8.655</span> <span class="token keyword">rows</span><span class="token operator">=</span><span class="token number">2749</span> loops<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">)</span>         <span class="token operator">-</span><span class="token operator">></span>  <span class="token keyword">Index</span> Scan <span class="token keyword">using</span> pg_attribute_relid_attnum_index <span class="token keyword">on</span> pg_attribute <span class="token number">a</span>  <span class="token punctuation">(</span>cost<span class="token operator">=</span><span class="token number">0.28</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token number">249.67</span> <span class="token keyword">rows</span><span class="token operator">=</span><span class="token number">2716</span> width<span class="token operator">=</span><span class="token number">203</span><span class="token punctuation">)</span> <span class="token punctuation">(</span>actual time<span class="token operator">=</span><span class="token number">0.016</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token number">8.222</span> <span class="token keyword">rows</span><span class="token operator">=</span><span class="token number">2749</span> loops<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>工作流程：</p><ol><li>同时扫描两个已排序的输入集</li><li>比较当前行的连接键</li><li>根据比较结果决定从哪一侧获取下一行</li></ol><h3 id="3-8-4-物化操作（Materialize）"><a href="#3-8-4-物化操作（Materialize）" class="headerlink" title="3.8.4 物化操作（Materialize）"></a>3.8.4 <strong>物化操作（Materialize）</strong></h3><p>物化操作将底层操作的结果存储在内存中，供多次使用。</p><p>示例：</p><pre class="line-numbers language-sql"><code class="language-sql"><span class="token keyword">EXPLAIN</span> <span class="token keyword">ANALYZE</span> \dTS Materialize  <span class="token punctuation">(</span>cost<span class="token operator">=</span><span class="token number">0.00</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token number">1.17</span> <span class="token keyword">rows</span><span class="token operator">=</span><span class="token number">11</span> width<span class="token operator">=</span><span class="token number">68</span><span class="token punctuation">)</span> <span class="token punctuation">(</span>actual time<span class="token operator">=</span><span class="token number">0.000</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token number">0.001</span> <span class="token keyword">rows</span><span class="token operator">=</span><span class="token number">11</span> loops<span class="token operator">=</span><span class="token number">95</span><span class="token punctuation">)</span>               <span class="token operator">-</span><span class="token operator">></span>  Seq Scan <span class="token keyword">on</span> pg_namespace n  <span class="token punctuation">(</span>cost<span class="token operator">=</span><span class="token number">0.00</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token number">1.11</span> <span class="token keyword">rows</span><span class="token operator">=</span><span class="token number">11</span> width<span class="token operator">=</span><span class="token number">68</span><span class="token punctuation">)</span> <span class="token punctuation">(</span>actual time<span class="token operator">=</span><span class="token number">0.004</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token number">0.006</span> <span class="token keyword">rows</span><span class="token operator">=</span><span class="token number">11</span> loops<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>在这个例子中，物化避免了95次表扫描，只需扫描一次并将结果存储在内存中。</p><h3 id="3-8-5-连接操作的变体"><a href="#3-8-5-连接操作的变体" class="headerlink" title="3.8.5 连接操作的变体"></a>3.8.5 <strong>连接操作的变体</strong></h3><p>连接操作有以下变体：</p><ul><li>左/右连接：Hash Left Join, Merge Left Join等</li><li>全连接：Hash Full Join, Merge Full Join</li><li>反连接：Hash Anti Join（用于NOT EXISTS子查询）</li></ul><p>示例（反连接）：</p><pre class="line-numbers language-sql"><code class="language-sql"><span class="token keyword">EXPLAIN</span> <span class="token keyword">ANALYZE</span> <span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> pg_class <span class="token number">c</span> <span class="token keyword">WHERE</span> <span class="token operator">NOT</span> <span class="token keyword">EXISTS</span> <span class="token punctuation">(</span><span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> pg_attribute <span class="token number">a</span> <span class="token keyword">WHERE</span> <span class="token number">a</span><span class="token punctuation">.</span>attrelid <span class="token operator">=</span> <span class="token number">c</span><span class="token punctuation">.</span>oid <span class="token operator">AND</span> <span class="token number">a</span><span class="token punctuation">.</span>attnum <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token keyword">Hash</span> Anti <span class="token keyword">Join</span>  <span class="token punctuation">(</span>cost<span class="token operator">=</span><span class="token number">93.62</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token number">115.69</span> <span class="token keyword">rows</span><span class="token operator">=</span><span class="token number">298</span> width<span class="token operator">=</span><span class="token number">226</span><span class="token punctuation">)</span> <span class="token punctuation">(</span>actual time<span class="token operator">=</span><span class="token number">0.642</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token number">0.851</span> <span class="token keyword">rows</span><span class="token operator">=</span><span class="token number">303</span> loops<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>反连接只返回在另一侧找不到匹配的行。</p><h2 id="3-9-定制执行计划"><a href="#3-9-定制执行计划" class="headerlink" title="3.9 定制执行计划"></a>3.9 定制执行计划</h2>]]></content>
      
      
      <categories>
          
          <category> linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 缓存，索引,分区 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第四章--调优艺术</title>
      <link href="/2026/4.diao-you-yi-zhu/"/>
      <url>/2026/4.diao-you-yi-zhu/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h2 id="4-1-索引术"><a href="#4-1-索引术" class="headerlink" title="4.1 索引术"></a>4.1 索引术</h2><h3 id="4-1-1-常见索引结构"><a href="#4-1-1-常见索引结构" class="headerlink" title="4.1.1 常见索引结构"></a>4.1.1 常见索引结构</h3><p>在数据库表上合理创建索引，可显著提升查询执行效率；若未创建索引，查询过程可能消耗大量时间。需特别说明的是，在特定场景下，全表扫描的效率可能高于索引扫描，相关细节将在本节后续内容中进一步探讨。</p><p>Panweidb 提供多种索引类型及丰富的创建方式。本节将简要介绍 Panweidb 支持的常见索引类型，并结合具体示例，详细说明各类索引的特性与使用方法，为索引的合理选择与应用提供参考。</p><h4 id="B-Tree-Index（B树索引）"><a href="#B-Tree-Index（B树索引）" class="headerlink" title="B-Tree Index（B树索引）"></a>B-Tree Index（B树索引）</h4><p>B-Tree索引是 Panweidb 中的默认索引类型。当执行“CREATE INDEX”语句且未指定索引类型时，系统将自动创建 B树索引。该索引适用于具有排序特性的数据，可高效处理相等查询（如“=”）和范围查询（如“&gt;”“&lt;”“BETWEEN”等）。创建 B树索引的语法如下：</p><pre class="line-numbers language-sql"><code class="language-sql"><span class="token keyword">CREATE</span> <span class="token keyword">INDEX</span> name <span class="token keyword">ON</span> <span class="token keyword">table</span> <span class="token punctuation">(</span><span class="token keyword">column</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">-- 或明确指定索引类型</span><span class="token keyword">CREATE</span> <span class="token keyword">INDEX</span> name <span class="token keyword">ON</span> <span class="token keyword">table</span> <span class="token keyword">USING</span> <span class="token keyword">BTREE</span> <span class="token punctuation">(</span><span class="token keyword">column</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h4 id="Hash-Index（哈希索引）"><a href="#Hash-Index（哈希索引）" class="headerlink" title="Hash Index（哈希索引）"></a>Hash Index（哈希索引）</h4><p>哈希索引仅支持相等运算符（<code>=</code>），仅能用于匹配查询条件完全一致的数据。在部分业务场景中，其性能表现优于 B 树索引，同时具备更高的空间利用率。经过多轮深度优化后，哈希索引的查找速度得到大幅提升，成为一款专用索引，适用于以相等比较为核心查询逻辑的业务场景。创建哈希索引的语法如下：</p><pre class="line-numbers language-sql"><code class="language-sql"><span class="token keyword">CREATE</span> <span class="token keyword">INDEX</span> name <span class="token keyword">ON</span> <span class="token keyword">table</span> <span class="token keyword">USING</span> <span class="token keyword">HASH</span> <span class="token punctuation">(</span><span class="token keyword">column</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="Gist-Index（广义搜索树索引）"><a href="#Gist-Index（广义搜索树索引）" class="headerlink" title="Gist Index（广义搜索树索引）"></a>Gist Index（广义搜索树索引）</h4><p>广义搜索树（Gist）索引适用于索引逻辑复杂的数据场景，尤其是当查询需求超出简单的相等或范围比较（如相邻查找、模式匹配等）时，其优势更为明显。典型应用场景包括几何数据（如点、线、面的空间查询）、网络地址比较、全文搜索等。</p><p>创建 Gist 索引的语法如下：</p><pre class="line-numbers language-sql"><code class="language-sql"><span class="token keyword">CREATE</span> <span class="token keyword">INDEX</span> name <span class="token keyword">ON</span> <span class="token keyword">table</span> <span class="token keyword">USING</span> gist <span class="token punctuation">(</span><span class="token keyword">column</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="SP-Gist-Index"><a href="#SP-Gist-Index" class="headerlink" title="SP-Gist Index"></a>SP-Gist Index</h4><p>SP-Gist（Space-Partitioned GiST，空间分区广义搜索树）是 Gist 索引的扩展，支持分区搜索树结构。该索引可用于开发多种非平衡数据结构，例如四叉树、kd树、基数树（字典树）等。此类数据结构的核心特点是反复将搜索空间划分为大小可不等的分区，对于与分区规则高度匹配的搜索场景，可实现极高的查询效率。</p><p>SP-Gist 索引适用于具有天然分区特性的数据查询，例如地理位置数据的分级检索、字典类数据的前缀匹配等场景。</p><h4 id="Gin-Index"><a href="#Gin-Index" class="headerlink" title="Gin Index"></a>Gin Index</h4><p>广义倒排索引（Gin）主要用于索引单列中包含多个元素的数据类型，例如数组（array）、JSON 文档（jsonb 类型）、文本搜索文档（tsvector 类型）等。其核心优势在于可高效检索多元素字段中的单个或多个目标元素，适用于多值数据的快速匹配查询。</p><p>创建 Gin 索引的语法如下：</p><pre class="line-numbers language-sql"><code class="language-sql"><span class="token keyword">CREATE</span> <span class="token keyword">INDEX</span> name <span class="token keyword">ON</span> <span class="token keyword">table</span> <span class="token keyword">USING</span> gin <span class="token punctuation">(</span><span class="token keyword">column</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>上述内容详细介绍了 Panweidb支持的常见索引结构。接下来，将重点阐述索引的核心特性，这些特性可用于进一步调整和优化索引性能，满足不同业务场景的查询需求。</p><h4 id="多列索引"><a href="#多列索引" class="headerlink" title="多列索引"></a>多列索引</h4><p>Panweidb 支持在多个列上创建联合索引（即多列索引），但最多支持 32 个列的组合，且仅 Btree、Gist、Gin索引类型支持多列索引。多列索引的查询效率与列的排序顺序密切相关，通常应将查询频率最高、选择性最强的列置于索引列的最前面。以下为多列索引的创建示例：</p><p> <img src="/medias/image/image-20260129095148633.png" alt="image-20260129095148633"></p><h4 id="唯一索引"><a href="#唯一索引" class="headerlink" title="唯一索引"></a>唯一索引</h4><p>唯一索引的核心作用是强制索引列（或列组合）中的值具有唯一性，避免出现重复数据。在 Panweidb 中，可在单个列或多个列上创建唯一索引；若为多列创建唯一索引，则通过列值的组合来确保唯一性。需注意的是，仅B树索引支持声明为唯一索引。</p><p> <img src="/medias/image/image-20260129152014673.png" alt="image-20260129152014673"></p><p>多列唯一索引的创建示例如下：</p><p> <img src="/medias/image/image-20260129152035292.png" alt="image-20260129152035292"></p><p>需特别说明的是，NULL 值不被视为相等值，因此在唯一索引列中可插入多个 NULL 值，不会触发索引唯一性违规。</p><p>当为表列声明唯一约束（UNIQUE CONSTRAINT）或主键约束（PRIMARY KEY）时，Panweidb 会自动为该列（或列组合）创建唯一索引，无需手动创建。相关示例如下：</p><p> <img src="/medias/image/image-20260129095621897.png" alt="image-20260129095621897"></p><h4 id="表达式索引"><a href="#表达式索引" class="headerlink" title="表达式索引"></a><strong>表达式索引</strong></h4><p>在 Panweidb 中，可基于表中一列或多列的函数计算结果、标量表达式结果创建索引，此类索引称为表达式索引。由于表达式的计算结果已预先存储在索引中，查询时无需实时计算，可显著提升数据访问效率；但与此同时，数据的插入、更新操作会因需要重新计算表达式并同步更新索引，导致操作代价增加。</p><p>表达式索引适用于查询中频繁使用固定表达式的场景，例如对字符串字段的小写转换查询、日期字段的格式化查询等。以下为表达式索引的示例：</p><p> <img src="/medias/image/image-20260129095737813.png" alt="image-20260129095737813"></p><p>表达式索引的创建与查询效果验证示例如下：</p><p> <img src="/medias/image/image-20260129095856315.png" alt="image-20260129095856315"></p><h4 id="部分索引"><a href="#部分索引" class="headerlink" title="部分索引"></a><strong>部分索引</strong></h4><p>部分索引（Partial Index）是指仅对表中满足特定条件的行建立索引，而非对整个表的数据建立索引。此类索引通过 WHERE 子句指定过滤条件，仅包含符合条件的行数据，因此索引体积远小于全表索引，数据访问速度更快，同时可节省存储空间。</p><p>部分索引适用于查询仅针对表中部分数据的场景，例如仅对“状态为有效”的订单数据建立索引、仅对“金额大于 1000”的交易数据建立索引等。以下为部分索引的示例：</p><p> <img src="/medias/image/image-20260129152049547.png" alt="image-20260129152049547"></p><p>部分索引的创建示例如下：</p><p> <img src="/medias/image/image-20260129152105888.png" alt="image-20260129152105888"></p><h4 id="仅索引扫描"><a href="#仅索引扫描" class="headerlink" title="仅索引扫描"></a><strong>仅索引扫描</strong></h4><p>通常情况下，索引与表数据分开存储，查询时需先通过索引定位数据行的位置，再从表文件中读取具体数据，该过程称为“索引扫描”。而仅索引扫描（Index-Only Scan）是一种优化的扫描方式：若查询语句所需的所有字段均为索引列（即查询字段完全包含在索引中），则无需访问表文件，可直接从索引中读取所需数据，从而进一步提升查询性能。</p><p> <img src="/medias/image/image-20260129100309341.png" alt="image-20260129100309341"></p><p>需注意的是，若查询语句中包含不属于索引列的字段，则无法使用仅索引扫描，系统将自动切换为普通索引扫描或全表扫描。示例如下：</p><p> <img src="/medias/image/image-20260129100340789.png" alt="image-20260129100340789"></p><p>目前，仅 B-tree、Gist、SP-Gist 三种索引类型支持仅索引扫描，Gin、Hash 索引暂不支持该特性。</p><h4 id="覆盖索引"><a href="#覆盖索引" class="headerlink" title="覆盖索引"></a>覆盖索引</h4><p>覆盖索引与仅索引扫描的原理相近，且适用场景更为灵活。当查询所需字段超出索引列范围，但业务仍希望避免访问主表、仅通过索引获取全部数据时，可通过 PanWeiDB 支持的INCLUDE 子句创建覆盖索引。需注意的是，该类型索引仅由 ubtree 索引支持，且仅适配 Ustore 存储引擎；其可在索引中附加非索引列信息，让查询语句所需的所有字段均能直接从索引中读取，以此实现类仅索引扫描的查询优化效果。</p><p> <img src="/medias/image/image-20260129101032668.png" alt="image-20260129101032668"></p><p>需注意的是，若创建索引时未指定 INCLUDE 子句，且查询字段超出索引列范围，则系统无法使用仅索引扫描，将自动采用普通索引扫描。</p><h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>Panweidb 提供多种类型的索引，每种索引均有其独特的适用场景和性能特性。能够灵活选择索引类型是提升数据库查询性能的关键，但该能力需谨慎使用——若选择错误的索引类型、创建不合理的索引（如过度创建索引、索引列选择不当等），不仅无法提升性能，反而可能降低数据库效率。</p><p>索引的核心作用是加速数据检索，但数据库系统需在后台持续执行额外工作，确保索引与表中更新的数据保持同步（如插入、更新、删除数据时同步更新索引），这可能导致索引膨胀、磁盘空间占用增加、写入性能下降等问题。因此，在创建索引时，需结合业务场景，全面考量数据检索需求与数据更新频率，合理规划索引的类型、数量和结构，实现检索性能与写入性能的平衡。</p><h3 id="4-1-2-索引适用场景说明"><a href="#4-1-2-索引适用场景说明" class="headerlink" title="4.1.2 索引适用场景说明"></a>4.1.2 索引适用场景说明</h3><p>结合 4.1.1 节介绍的索引类型特性，以下明确各类索引的核心适用场景，为业务实践中的索引选择提供精准参考：</p><h4 id="B-Tree-索引"><a href="#B-Tree-索引" class="headerlink" title="B-Tree 索引"></a>B-Tree 索引</h4><p>核心适用场景：适用于大多数常规查询场景，尤其是具有排序需求、相等查询或范围查询的场景，是业务中最常用的索引类型。</p><ul><li>典型场景：用户 ID 检索（相等查询）、订单时间范围查询（范围查询）、商品价格排序查询（排序+范围查询）、用户姓名模糊匹配（前缀匹配，如“LIKE ‘张%’”）；</li><li>适配字段类型：数值型（int、bigint、numeric 等）、字符串型（varchar、text 等）、日期时间型（date、timestamp 等）等具有天然排序特性的字段；</li><li>不适用于：多元素字段（如数组、jsonb）、空间几何字段、非前缀匹配的模糊查询（如“LIKE ‘%张%’”）。</li></ul><h4 id="Hash-索引"><a href="#Hash-索引" class="headerlink" title="Hash 索引"></a>Hash 索引</h4><p>核心适用场景：仅适用于“完全相等”的查询场景，且数据更新频率较低、查询频率极高，追求极致的相等匹配效率。</p><ul><li><p>典型场景：字典表精确匹配（如根据字典编码查询字典名称）、用户账号精确检索（如根据账号查询用户信息）、枚举值精确匹配（如根据状态码查询状态描述）；</p></li><li><p>适配字段类型：字符串型、数值型等可进行相等比较的简单字段；</p></li><li><p>不适用于：范围查询、排序查询、模糊查询、多元素字段查询，以及数据写入频繁的场景（写入时索引更新代价较高）。</p></li><li><p>由于各种原因，panwei3.2.1版本之前的哈希索引不被鼓励使用，例如：</p><ul><li>不记录 WAL（Write-Ahead Logging，预写日志），导致数据库崩溃后索引不可靠，可能出现数据不一致；</li><li>由于不记录 WAL，无法用于流复制场景，无法实现主备节点间的索引同步；</li><li>性能表现不佳，索引构建耗时较长（具体耗时取决于表的数据量）。</li></ul><p>不过从panwei3.2.1开始，上述问题已得到全面解决。当前版本的哈希索引具备安全性，可正常同步至备机，</p></li></ul><h4 id="Gist-索引"><a href="#Gist-索引" class="headerlink" title="Gist 索引"></a>Gist 索引</h4><p>核心适用场景：复杂数据类型的查询，尤其是空间数据、全文搜索、模式匹配等超出简单相等/范围比较的场景。</p><ul><li>典型场景：地理位置查询（如查询某一区域内的店铺、两点间距离查询）、全文搜索（如文章内容关键词检索）、网络地址匹配（如 IP 地址段查询）、几何图形匹配（如判断两个图形是否相交）；</li><li>适配字段类型：几何类型（point、line、polygon 等）、网络地址类型（inet、cidr 等）、全文搜索类型（tsvector 等）；</li><li>不适用于：简单字段的常规查询（效率低于 B-Tree 索引）、多元素字段查询。</li></ul><h4 id="SP-Gist-索引"><a href="#SP-Gist-索引" class="headerlink" title="SP-Gist 索引"></a>SP-Gist 索引</h4><p>核心适用场景：具有天然分区特性的数据查询，尤其是非平衡数据结构的检索，追求分区匹配的高效性。</p><ul><li>典型场景：地理位置分级检索（如先按省份分区、再按城市检索）、字典类数据前缀匹配（如拼音首字母检索、英文前缀检索）、kd树/四叉树相关的空间检索；</li><li>适配字段类型：字符串型、几何类型、数值型等可进行分区划分的字段；</li><li>不适用于：无分区特性的常规查询、相等查询（效率低于 B-Tree、Hash 索引）。</li></ul><h4 id="Gin-索引"><a href="#Gin-索引" class="headerlink" title="Gin 索引"></a>Gin 索引</h4><p>核心适用场景：多元素字段的检索，即单个字段包含多个值，需查询该字段中包含某一/多个目标值的场景。</p><ul><li>典型场景：数组字段查询（如查询包含某一标签的文章，标签字段为数组类型）、jsonb 字段查询（如查询某一属性值的 JSON 文档）、多值枚举字段查询（如查询包含多个兴趣爱好的用户）；</li><li>适配字段类型：数组（array）、jsonb、tsvector 等多元素字段；</li><li>不适用于：简单字段的常规查询、范围查询、排序查询。</li></ul><h4 id="特殊索引（多列、唯一、表达式、部分、覆盖）适用场景"><a href="#特殊索引（多列、唯一、表达式、部分、覆盖）适用场景" class="headerlink" title="特殊索引（多列、唯一、表达式、部分、覆盖）适用场景"></a>特殊索引（多列、唯一、表达式、部分、覆盖）适用场景</h4><ul><li>多列索引：适用于查询频繁包含多个字段组合的场景，如“用户 ID + 订单状态”联合查询、“商品分类 + 价格范围”联合查询；需注意列的排序顺序，将查询频率最高、选择性最强的列置于前面。</li><li>唯一索引：适用于需保证数据唯一性的场景，如用户账号、身份证号、订单编号等字段，可通过唯一索引避免重复数据，同时提升查询效率；主键约束自动创建唯一索引，无需手动重复创建。</li><li>表达式索引：适用于查询频繁使用固定表达式的场景，如“小写用户名查询”（LOWER(username) = ‘test’）、“日期格式化查询”（TO_CHAR(create_time, ‘YYYY-MM-DD’) = ‘2024-01-01’），可避免查询时实时计算表达式。</li><li>部分索引：适用于查询仅针对表中部分数据的场景，如仅查询“有效状态”的订单、仅查询“金额大于 1000”的交易，可减少索引体积、提升查询效率、节省存储空间。</li><li>覆盖索引：适用于查询字段超出索引列，但希望避免访问主表的场景，如索引列为“用户 ID”，但查询需返回“用户 ID + 用户名”，可通过 INCLUDE (username) 创建覆盖索引，实现仅索引扫描。</li></ul><h3 id="4-1-2-索引使用注意事项"><a href="#4-1-2-索引使用注意事项" class="headerlink" title="4.1.2 索引使用注意事项"></a>4.1.2 索引使用注意事项</h3><p>索引是提升数据库查询性能的重要手段，但不合理的使用会带来诸多问题，需重点关注以下注意事项，实现索引的高效应用：</p><h4 id="1-避免过度创建索引"><a href="#1-避免过度创建索引" class="headerlink" title="1. 避免过度创建索引"></a>1. 避免过度创建索引</h4><p>索引并非越多越好，每创建一个索引，都会增加数据库的写入负担（插入、更新、删除数据时，需同步更新所有相关索引），同时会占用额外的磁盘空间，可能导致索引膨胀。</p><p>建议：根据业务查询需求，仅创建必要的索引；对于写入频繁、查询极少的表（如日志表、临时表），尽量不创建索引；避免为同一查询场景创建多个功能重复的索引（如同时创建 B-Tree 索引和 Hash 索引用于相等查询）。</p><h4 id="2-合理选择索引列"><a href="#2-合理选择索引列" class="headerlink" title="2. 合理选择索引列"></a>2. 合理选择索引列</h4><ol><li>优先选择选择性高的字段作为索引列：选择性是指字段中唯一值的比例（唯一值越多，选择性越高），如用户 ID、身份证号（选择性接近 100%），适合作为索引列；而性别、状态等字段（选择性极低，通常仅 2-3 个唯一值），不适合作为单独的索引列（索引效率极低，甚至不如全表扫描）。</li><li>避免选择过长的字段作为索引列：索引列的长度越长，索引体积越大，查询时的 I/O 开销越高，索引构建和更新的速度也会变慢。建议：对于字符串字段，可选择前缀索引（如取 varchar(100) 字段的前 20 个字符作为索引列），平衡索引效率和空间占用；优先选择短字段（如 int、smallint 等）作为索引列。</li><li>避免使用 NULL 值过多的字段作为索引列：虽然 Panweidb 支持 NULL 值的索引，但 NULL 值过多的字段（如某字段 90% 以上的值为 NULL），索引的选择性极低，查询效率不佳；同时，NULL 值会增加索引的存储空间。</li><li>多列索引需注意列的排序顺序：多列索引的查询效率与列的顺序密切相关，应将查询频率最高、选择性最强的列置于最前面，后续列的选择性依次降低。例如，查询频繁为“WHERE user_id = ? AND order_status = ?”，应创建 (user_id, order_status) 的多列索引，而非 (order_status, user_id)。</li></ol><h4 id="3-关注索引扫描效率，避免索引失效"><a href="#3-关注索引扫描效率，避免索引失效" class="headerlink" title="3. 关注索引扫描效率，避免索引失效"></a>3. 关注索引扫描效率，避免索引失效</h4><p>即使创建了索引，数据库也可能选择全表扫描（索引失效），导致索引无法发挥作用，需避免以下常见场景：</p><ol><li>查询条件中使用函数或表达式操作索引列：如“WHERE LOWER(username) = ‘test’”（若 username 为索引列，函数操作会导致索引失效），此时应创建表达式索引（LOWER(username)），而非普通索引。</li><li>查询条件中使用不等于（!=、&lt;&gt;）、NOT IN、IS NOT NULL 等操作符：此类操作符可能导致数据库无法使用索引，优先选择全表扫描；若需实现类似查询，可通过业务逻辑优化（如用范围查询替代 NOT IN）。</li><li>模糊查询使用前缀通配符（如“LIKE ‘%张%’”）：此类查询无法使用 B-Tree 索引（仅支持前缀匹配，如“LIKE ‘张%’”）；若需实现后缀或任意位置的模糊查询，可使用 Gist 全文搜索索引。</li><li>查询条件中包含 OR 连接的非索引列：如“WHERE user_id = ? OR age = ?”，若 age 未创建索引，即使 user_id 有索引，数据库也可能选择全表扫描；建议将 OR 拆分为多个 AND 查询，或为所有相关列创建索引。</li><li>数据量过小的表：对于小表（如数据量不足 1 万行），全表扫描的效率可能高于索引扫描（索引查询需额外的 I/O 开销），此时数据库会自动选择全表扫描，索引无法发挥作用，无需创建索引。</li></ol><h4 id="4-关注索引维护与优化"><a href="#4-关注索引维护与优化" class="headerlink" title="4. 关注索引维护与优化"></a>4. 关注索引维护与优化</h4><ol><li>定期清理无效索引：业务迭代过程中，部分查询场景可能被淘汰，对应的索引会成为无效索引（不再被任何查询使用），需定期排查并删除无效索引，释放磁盘空间、减轻写入负担。</li><li>监控索引膨胀：频繁的插入、更新、删除操作会导致索引膨胀（索引中出现大量空洞，空间利用率降低），表现为索引体积过大、查询效率下降。建议定期使用 REINDEX 命令重建索引，清理空洞、优化索引结构；对于大数据量表，可使用 CONCURRENTLY 选项（如 REINDEX INDEX CONCURRENTLY idx_name），避免重建索引时锁定表，影响业务正常运行。</li><li>合理设置索引相关参数：Panweidb 提供了多个与索引相关的参数（如 shared_buffers、work_mem 等），可根据服务器硬件配置、业务场景调整参数，优化索引的构建和查询效率；例如，增大 work_mem 可提升索引构建速度，增大 shared_buffers 可提升索引查询的缓存命中率。</li></ol><h4 id="5-特殊场景索引使用建议"><a href="#5-特殊场景索引使用建议" class="headerlink" title="5. 特殊场景索引使用建议"></a>5. 特殊场景索引使用建议</h4><ol><li>大数据量写入场景（如日志采集、数据同步）：尽量减少索引数量（仅保留核心查询所需索引），避免索引更新占用过多资源；可采用批量写入、延迟创建索引等方式，降低写入压力。</li><li>只读/读写比例极高的场景（如报表查询、数据统计）：可适当增加索引数量，优化查询效率；对于频繁查询的复杂语句，可创建覆盖索引、表达式索引，进一步提升性能。</li></ol><h4 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h4><p>索引的选择与使用需紧密结合业务场景，核心是“适配查询需求、平衡检索与写入性能”。不同类型的索引对应不同的查询场景，需根据字段特性、查询方式、数据量大小，选择合适的索引类型和结构；同时，需规避过度创建索引、索引列选择不当、索引失效等问题，定期进行索引维护与优化，确保索引持续发挥高效作用，提升 Panweidb 数据库的整体性能。</p><h2 id="4-2-缓存术"><a href="#4-2-缓存术" class="headerlink" title="4.2 缓存术"></a>4.2 缓存术</h2><h3 id="4-2-1-双缓存最佳实践"><a href="#4-2-1-双缓存最佳实践" class="headerlink" title="4.2.1 双缓存最佳实践"></a>4.2.1 双缓存最佳实践</h3><p>磐维数据库采用“数据库共享缓存+操作系统缓存”的双层缓存机制，是性能优化的核心环节。本节重点围绕双缓存核心概念、落地最佳实践及关键注意事项展开，为生产环境缓存配置提供可直接参考的实操指南。</p><h4 id="4-2-1-1-双缓存介绍"><a href="#4-2-1-1-双缓存介绍" class="headerlink" title="4.2.1.1 双缓存介绍"></a><strong>4.2.1.1 双缓存介绍</strong></h4><p>磐维数据库的双缓存，指数据库共享缓存（由shared_buffers参数控制）<em>与</em>操作系统缓存协同工作、共同承载数据读写的缓存模式，二者分工互补，本质是通过内存复用降低物理I/O，提升系统吞吐与响应速度。</p><ol><li>双缓存核心架构</li></ol><p>数据读取核心流程：磁盘 → 操作系统缓存 → 磐维数据库共享缓存（shared_buffers）。同一块数据会短暂在两个缓存中同时存在副本，该现象称为“双重缓存（Double Buffering）”，是PG架构天然特性，并非无效开销。</p><ol start="2"><li>两层缓存分工差异</li></ol><ul><li><p><strong>数据库共享缓存</strong>：采用时钟扫描算法，通过0～5的活跃度评分控制缓存淘汰，评分越高的热点数据，被换出的概率越低，可优先保留高频访问、频繁修改的核心业务数据，减少重复刷盘开销。</p></li><li><p><strong>操作系统缓存</strong>：多采用LRU算法，缓存回收机会较少，热数据保护能力弱于数据库共享缓存，但无需承担检查点压力，适合承载非热点、大容量扫描类数据（如全表扫描、VACUUM操作涉及的数据）。</p></li></ul><ol start="3"><li>双缓存设计理念</li></ol><p>与传统数据库“独占大量内存、绕过系统缓存”的思路不同，磐维数据库不建议独占系统大量内存，也不推荐通过强制同步、直接I/O等方式绕过操作系统缓存：</p><ul><li><p>绝大多数读写通过标准操作系统调用完成，充分利用OS缓存的默认优化机制；</p></li><li><p>WAL写入在典型部署中会绕过操作系统缓存，保证日志落盘可靠性；</p></li><li><p>强行禁用OS缓存会破坏数据库元数据的访问优化，引发预期外的性能衰退。</p></li></ul><h4 id="4-2-1-2-最佳实践介绍"><a href="#4-2-1-2-最佳实践介绍" class="headerlink" title="4.2.1.2 最佳实践介绍"></a>4.2.1.2 最佳实践介绍</h4><p>双缓存优化的核心的是“平衡”——平衡共享缓存大小与双缓存冗余、平衡热数据缓存能力与检查点I/O压力，以下为适配磐维数据库的可落地最佳实践，重点围绕shared_buffers参数配置、缓存分工及观测优化展开。</p><ol><li><strong>shared_buffers参数配置最佳实践</strong></li></ol><p>shared_buffers作为数据库共享缓存的大小控制参数，直接决定双缓存协同效果，推荐按场景分层配置：</p><p>（1）通用基线配置（专用数据库服务器）</p><p>优先分配系统总内存的25%作为shared_buffers初始值，该配置具备三大优势：</p><ul><li><p>安全可靠：在绝大多数生产场景下适配性强，不会因双缓存冗余造成严重内存浪费；</p></li><li><p>性能达标：远优于默认小配置（通常≤128MB），可直接提升复杂查询、高并发读写性能；</p></li><li><p>便于微调：以25%为基线，结合业务压测可灵活调整，适配不同负载场景。</p></li></ul><p>（2）分场景精细化配置</p><ul><li><p>大容量内存系统（内存≥8GB）：受缓存内部分区机制影响，不建议盲目设置超过8GB；初始建议2GB，观测性能后再谨慎上调，避免适得其反。</p></li><li><p>写密集型业务（高频更新、高写入）：检查点压力突出，初始值控制在128MB～256MB，优先保证I/O平稳，再逐步提升缓存大小。</p></li><li><p>非专用数据库服务器（与应用、中间件共用主机）：适当降低shared_buffers，依靠OS缓存实现协同复用，避免内存争抢。</p></li></ul><p>（3）最小可用配置底线</p><p>生产环境通用下限建议不低于128MB～256MB，默认安装的偏小配置仅适用于极低负载场景，多数业务在此下限以上可获得明显性能收益。</p><p><strong>2. 双缓存分工最佳策略</strong></p><ul><li><p>高频访问、频繁修改的热点块（如核心业务表、索引块）：优先放入数据库共享缓存，利用时钟扫描算法的热数据保护机制，减少缓存淘汰与重复I/O。</p></li><li><p>非热点、大容量扫描数据（如历史数据表全表扫描、VACUUM操作涉及数据）：交给操作系统缓存承载，避免占用数据库共享缓存空间，减少检查点压力。</p></li></ul><h4 id="4-2-1-3-注意事项"><a href="#4-2-1-3-注意事项" class="headerlink" title="4.2.1.3 注意事项"></a>4.2.1.3 注意事项</h4><p>双缓存配置的核心风险的是“配置失衡”，需重点关注以下注意事项，避免性能衰退或系统不稳定：</p><ol><li>禁止盲目调大shared_buffers</li></ol><p>shared_buffers并非越大越好：调大过高会加剧双缓存冗余，挤占操作系统缓存空间，导致整体缓存效率下降；同时会增加检查点脏页刷盘压力，引发I/O峰值，甚至影响业务正常运行。</p><ol start="2"><li>禁止强行绕过操作系统缓存</li></ol><p>不得通过强制同步、直接I/O等方式禁用或绕过操作系统缓存，否则会破坏数据库元数据的访问优化，导致元数据读写效率下降，引发预期外的性能衰退，甚至出现数据访问异常。</p><ol start="3"><li>需结合业务负载动态微调</li></ol><p>本文给出的配置建议为“初始基线”，实际生产中需结合业务负载（读/写比例、数据量、并发量）动态微调：读密集型业务可适当提高shared_buffers比例，写密集型业务需控制shared_buffers大小，优先保证I/O平稳。</p><ol start="5"><li>非专用服务器需预留足够内存</li></ol><p>若数据库服务器与应用、中间件共用，需为其他应用预留足够内存，不可将过多内存分配给shared_buffers，避免内存争抢，导致数据库与应用同时出现性能下降。</p><ol start="6"><li>定期观测缓存利用效率</li></ol><p>需定期通过pg_buffercache、pg_stat_bgwriter及OS缓存工具观测双缓存利用效率，识别热点数据与缓存瓶颈，及时调整配置，避免缓存资源浪费或热数据未被有效缓存。</p><h4 id="4-2-1-4-总结"><a href="#4-2-1-4-总结" class="headerlink" title="4.2.1.4 总结"></a>4.2.1.4 总结</h4><p>磐维数据库双缓存的核心是“双层协同、平衡优化”：双缓存是架构天然特性，通过数据库共享缓存与操作系统缓存分工互补，降低物理I/O；最佳实践以shared_buffers基线配置为核心，结合场景精细化调整、工具观测优化；注意事项重点规避配置失衡、平台适配不当等风险，确保双缓存发挥最优性能，为数据库整体性能提升提供支撑。</p><p>4.2.2 线程池最佳实践</p><p>线程池介绍<br>最佳实践介绍<br>注意事项</p><p>4.2.3 MOT内存表介绍</p><h2 id="4-3-压缩术"><a href="#4-3-压缩术" class="headerlink" title="4.3 压缩术"></a>4.3 压缩术</h2><p>常见压缩方法</p><p>硬件压缩ZFS/软件压缩有很多种<br>LZ4、ZSTD、punch hole打洞反还</p><p>优劣势对比</p><p>注意事项</p><h2 id="4-4-批量处理术"><a href="#4-4-批量处理术" class="headerlink" title="4.4 批量处理术"></a>4.4 批量处理术</h2><h3 id="4-4-1-业务批量插入最佳实践"><a href="#4-4-1-业务批量插入最佳实践" class="headerlink" title="4.4.1 业务批量插入最佳实践"></a>4.4.1 业务批量插入最佳实践</h3><p>在 PanWeDB 数据库运维中，常需通过单个或最少步骤完成海量数据的导入操作，即批量数据导入，其数据源多为单个或多个大文件。若未采用针对性优化方案，该过程会因各类性能瓶颈导致加载速度极慢，难以满足业务需求。</p><p>造成 PanWeDB 批量插入性能低下的核心原因包括：索引的实时更新开销、触发器的逐行触发执行、外键约束的有效性校验、GUID 主键的生成成本，以及预写日志（WAL）的写入机制等，这些因素会单独或叠加成为数据加载的关键阻碍。</p><p>常规插入过程中，典型的非批量插入操作遵循“准备语句-绑定参数-发送请求-确认插入”的重复模式，每行数据都需要单独循环执行，网络通信和数据库处理的开销会随数据量急剧增加。而批量插入通过整合多组插入操作，可大幅降低这类冗余开销，是海量数据导入的最优选择。</p><h4 id="JDBC-批处理工作原理"><a href="#JDBC-批处理工作原理" class="headerlink" title="JDBC 批处理工作原理"></a>JDBC 批处理工作原理</h4><p>JDBC 批处理的核心是将多个 INSERT 操作分组整合，减少客户端与数据库的网络往返次数，降低语句解析和事务提交的开销。其工作逻辑为：JDBC 驱动在内存中收集多组插入参数，不逐行执行插入，待累积到指定批量大小或手动触发时，将整批操作作为一个请求发送至数据库，实现一次性高效处理。</p><p>需重点注意，PanWeDB 支持开启 <code>reWriteBatchedInserts=true</code> 驱动参数，开启后驱动会自动将批处理操作重写为单条多值 INSERT 语句，进一步提升数据库执行效率。</p><p>实际应用中，建议将批量大小控制在 100-200 行，平衡性能与内存占用——批量过小无法有效降低开销，过大则可能导致客户端内存溢出或数据库请求拥堵；同时可结合事务控制，在单个事务中完成多批插入，既保证数据一致性，又进一步减少事务提交开销。JDBC 批处理适用于程序动态生成数据源的场景，常与后续最佳实践组合使用以最大化性能。</p><h3 id="4-4-2-业务批量插入最佳实践-insert"><a href="#4-4-2-业务批量插入最佳实践-insert" class="headerlink" title="4.4.2 业务批量插入最佳实践(insert)"></a>4.4.2 业务批量插入最佳实践(insert)</h3><p>结合 PanWeDB 原生特性与 JDBC 批处理能力，批量插入的核心优化思路是“导入前禁用非必要开销、导入中高效执行、导入后恢复校验”，以下是经过生产环境验证的核心最佳实践，可根据实际场景组合使用，实现性能最大化。</p><h5 id="1-创建目标表为-UNLOGGED-模式"><a href="#1-创建目标表为-UNLOGGED-模式" class="headerlink" title="1 创建目标表为 UNLOGGED 模式"></a>1 创建目标表为 UNLOGGED 模式</h5><p>UNLOGGED 表可显著提高数据导入速度，核心是跳过预写日志（WAL）的写入操作，适配快速大量插入数据的场景。</p><pre class="line-numbers language-sql"><code class="language-sql"><span class="token keyword">CREATE</span> UNLOGGED <span class="token keyword">TABLE</span> <span class="token operator">&lt;</span>target_table<span class="token operator">></span> <span class="token punctuation">(</span>    <span class="token comment" spellcheck="true">-- 表字段定义，示例：</span>    id <span class="token keyword">SERIAL</span> <span class="token keyword">PRIMARY</span> <span class="token keyword">KEY</span><span class="token punctuation">,</span>    name <span class="token keyword">VARCHAR</span><span class="token punctuation">(</span><span class="token number">50</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    create_time <span class="token keyword">TIMESTAMP</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>重要注意事项</strong>：UNLOGGED 表不支持流复制，主备集群中数据不会同步到备节点，暂时丧失高可用；若加载过程中数据库崩溃、服务器异常，数据无法恢复，重启后 PanWeDB 会自动截断该表，需提前做好风险评估，建议在业务低峰期执行。</p><h5 id="2-删除索引后重新创建"><a href="#2-删除索引后重新创建" class="headerlink" title="2. 删除索引后重新创建"></a>2. 删除索引后重新创建</h5><p>批量导入时索引会逐行更新，产生巨大性能开销（非主键索引尤为明显）。导入前删除非主键索引，加载完成后重建，可临时调整内存参数加速索引创建。</p><pre class="line-numbers language-sql"><code class="language-sql"><span class="token comment" spellcheck="true">-- 1. 查询目标表所有索引，排除主键索引后执行删除</span><span class="token keyword">SELECT</span> indexname <span class="token keyword">FROM</span> pg_indexes <span class="token keyword">WHERE</span> tablename <span class="token operator">=</span> <span class="token string">'&lt;target_table>'</span><span class="token punctuation">;</span><span class="token keyword">DROP</span> <span class="token keyword">INDEX</span> <span class="token operator">&lt;</span>index_name1<span class="token operator">></span><span class="token punctuation">,</span> <span class="token operator">&lt;</span>index_name2<span class="token operator">></span>…<span class="token punctuation">;</span><span class="token comment" spellcheck="true">-- 2. 执行批量插入操作，无索引更新开销</span><span class="token operator">&lt;</span>bulk_data_insert_operations<span class="token operator">></span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">-- 3. 临时调整内存参数，重建索引后恢复默认</span><span class="token keyword">SET</span> maintenance_work_mem <span class="token operator">=</span> <span class="token string">'512MB'</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">-- 根据服务器内存调整，建议256MB-1GB</span><span class="token keyword">CREATE</span> <span class="token keyword">INDEX</span> <span class="token operator">&lt;</span>index_name1<span class="token operator">></span> <span class="token keyword">ON</span> <span class="token operator">&lt;</span>target_table<span class="token operator">></span><span class="token punctuation">(</span>column1<span class="token punctuation">,</span>…<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">CREATE</span> <span class="token keyword">INDEX</span> <span class="token operator">&lt;</span>index_name2<span class="token operator">></span> <span class="token keyword">ON</span> <span class="token operator">&lt;</span>target_table<span class="token operator">></span><span class="token punctuation">(</span>column2<span class="token punctuation">,</span>…<span class="token punctuation">)</span><span class="token punctuation">;</span>RESET maintenance_work_mem<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="3-临时删除外键约束再重建"><a href="#3-临时删除外键约束再重建" class="headerlink" title="3. 临时删除外键约束再重建"></a>3. 临时删除外键约束再重建</h5><p>外键约束会在逐行插入时校验关联数据，海量数据导入时开销急剧累积。临时删除外键约束，单事务完成导入后重建，保证效率与数据一致性。</p><pre class="line-numbers language-sql"><code class="language-sql"><span class="token comment" spellcheck="true">-- 1. 删除目标表外键约束（记录约束名，便于后续重建）</span><span class="token keyword">ALTER</span> <span class="token keyword">TABLE</span> <span class="token operator">&lt;</span>target_table<span class="token operator">></span> <span class="token keyword">DROP</span> <span class="token keyword">CONSTRAINT</span> <span class="token operator">&lt;</span>fk_constraint<span class="token operator">></span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">-- 2. 单事务执行批量插入，减少提交开销并保证一致性</span><span class="token keyword">BEGIN</span> <span class="token keyword">TRANSACTION</span><span class="token punctuation">;</span> <span class="token operator">&lt;</span>bulk_data_insert_operations<span class="token operator">></span><span class="token punctuation">;</span> <span class="token keyword">COMMIT</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">-- 3. 重新创建外键约束，校验数据关联性</span><span class="token keyword">ALTER</span> <span class="token keyword">TABLE</span> <span class="token operator">&lt;</span>target_table<span class="token operator">></span> <span class="token keyword">ADD</span> <span class="token keyword">CONSTRAINT</span> <span class="token operator">&lt;</span>fk_constraint<span class="token operator">></span> <span class="token keyword">FOREIGN</span> <span class="token keyword">KEY</span> <span class="token punctuation">(</span>fk_column<span class="token punctuation">)</span> <span class="token keyword">REFERENCES</span> <span class="token operator">&lt;</span>ref_table<span class="token operator">></span><span class="token punctuation">(</span>ref_column<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="4-禁用所有触发器后启用"><a href="#4-禁用所有触发器后启用" class="headerlink" title="4. 禁用所有触发器后启用"></a>4. 禁用所有触发器后启用</h5><p>业务自定义触发器、外键关联的系统触发器，会在逐行插入时执行，产生大量冗余开销。导入前禁用触发器，加载完成后恢复，也可单独禁用非必需触发器。</p><pre class="line-numbers language-sql"><code class="language-sql"><span class="token comment" spellcheck="true">-- 1. 禁用目标表所有触发器（替换ALL为具体触发器名可单独禁用）</span><span class="token keyword">ALTER</span> <span class="token keyword">TABLE</span> <span class="token operator">&lt;</span>target_table<span class="token operator">></span> <span class="token keyword">DISABLE</span> <span class="token keyword">TRIGGER</span> <span class="token keyword">ALL</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">-- 2. 执行批量插入操作，无需触发任何触发器</span><span class="token operator">&lt;</span>bulk_data_insert_operations<span class="token operator">></span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">-- 3. 启用所有触发器，恢复正常业务逻辑</span><span class="token keyword">ALTER</span> <span class="token keyword">TABLE</span> <span class="token operator">&lt;</span>target_table<span class="token operator">></span> <span class="token keyword">ENABLE</span> <span class="token keyword">TRIGGER</span> <span class="token keyword">ALL</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="5-优先使用-COPY-命令导入"><a href="#5-优先使用-COPY-命令导入" class="headerlink" title="5. 优先使用 COPY 命令导入"></a>5. 优先使用 COPY 命令导入</h5><p>COPY 是 PanWeDB 官方推荐的批量导入命令，专为文件数据源优化，性能远优于普通 INSERT 语句，支持 CSV/TEXT 等格式，适合 GB/TB 级大文件导入。</p><pre class="line-numbers language-sql"><code class="language-sql"><span class="token comment" spellcheck="true">-- 基础用法：导入本地文件，指定列、格式及相关参数</span>COPY <span class="token operator">&lt;</span>target_table<span class="token operator">></span> <span class="token punctuation">[</span><span class="token punctuation">(</span>column1<span class="token punctuation">,</span> column2<span class="token punctuation">,</span>…<span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token keyword">FROM</span> <span class="token string">'&lt;file_path>'</span> <span class="token keyword">WITH</span> <span class="token punctuation">(</span>    FORMAT csv<span class="token punctuation">,</span>      <span class="token comment" spellcheck="true">-- 文件格式，可选csv/text/binary</span>    HEADER <span class="token boolean">true</span><span class="token punctuation">,</span>     <span class="token comment" spellcheck="true">-- 是否包含表头，无表头则设为false</span>    <span class="token keyword">DELIMITER</span> <span class="token string">','</span><span class="token punctuation">,</span>   <span class="token comment" spellcheck="true">-- 字段分隔符，按文件实际情况调整</span>    ENCODING <span class="token string">'UTF8'</span>  <span class="token comment" spellcheck="true">-- 字符编码，避免中文乱码</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>优势</strong>：直接绕开 SQL 解析层，由存储引擎直接读取文件，资源占用低、导入速度快，远程文件（如 S3）开启对应权限后可直接填写远程路径。</p><h5 id="6-采用多值-INSERT-语句"><a href="#6-采用多值-INSERT-语句" class="headerlink" title="6. 采用多值 INSERT 语句"></a>6. 采用多值 INSERT 语句</h5><p>数据源为程序动态生成（无物理文件）时，用多值 INSERT 替代大量单条 INSERT，减少语句解析、网络往返和事务提交开销，单条语句建议控制 500-1000 行。</p><pre class="line-numbers language-sql"><code class="language-sql"><span class="token comment" spellcheck="true">-- 多值INSERT：单条语句插入多行数据，逗号分隔每组值</span><span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> <span class="token operator">&lt;</span>target_table<span class="token operator">></span> <span class="token punctuation">(</span>column1<span class="token punctuation">,</span> column2<span class="token punctuation">,</span> column3<span class="token punctuation">,</span>…<span class="token punctuation">)</span> <span class="token keyword">VALUES</span> <span class="token punctuation">(</span>val1<span class="token punctuation">,</span> val2<span class="token punctuation">,</span> val3<span class="token punctuation">,</span>…<span class="token punctuation">)</span><span class="token punctuation">,</span>        <span class="token punctuation">(</span>val4<span class="token punctuation">,</span> val5<span class="token punctuation">,</span> val6<span class="token punctuation">,</span>…<span class="token punctuation">)</span><span class="token punctuation">,</span>       …       <span class="token punctuation">(</span>valN<span class="token number">-2</span><span class="token punctuation">,</span> valN<span class="token number">-1</span><span class="token punctuation">,</span> valN<span class="token punctuation">,</span>…<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>优化补充</strong>：结合 JDBC 批处理时，开启 <code>reWriteBatchedInserts=true</code> 连接参数，驱动会自动将批处理重写为多值 INSERT，进一步提升效率。</p><h5 id="7-导入后执行-ANALYZE-更新统计"><a href="#7-导入后执行-ANALYZE-更新统计" class="headerlink" title="7. 导入后执行 ANALYZE 更新统计"></a>7. 导入后执行 ANALYZE 更新统计</h5><p>批量插入会导致表的统计信息过时，PanWeDB 查询优化器依赖统计信息生成最优执行计划，导入完成后需立即更新统计信息。</p><pre class="line-numbers language-sql"><code class="language-sql"><span class="token comment" spellcheck="true">-- 方式1：更新单个目标表统计信息（推荐，高效快速）</span><span class="token keyword">ANALYZE</span> <span class="token operator">&lt;</span>target_table<span class="token operator">></span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">-- 方式2：同时更新多个表统计信息（适合多表批量导入场景）</span><span class="token keyword">ANALYZE</span> <span class="token operator">&lt;</span>target_table1<span class="token operator">></span><span class="token punctuation">,</span> <span class="token operator">&lt;</span>target_table2<span class="token operator">></span>…<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>执行时机</strong>：建议在所有批量插入操作完成、索引和约束重建后执行。</p><h5 id="8-核心注意事项与补充说明"><a href="#8-核心注意事项与补充说明" class="headerlink" title="8. 核心注意事项与补充说明"></a>8. 核心注意事项与补充说明</h5><p>上述最佳实践可根据实际场景组合使用（如 UNLOGGED 表 + 删除索引 + COPY 命令，为经典高效组合），同时需严格遵循以下注意事项，避免数据丢失、业务异常：</p><ul><li><p>结构修改类操作前置要求：执行删除索引、外键，禁用触发器，切换 UNLOGGED 模式前，必须对目标表及原有结构做全量备份（建议使用 pg_dump 工具），防止数据丢失或结构损坏；所有表结构修改操作完成后，需及时恢复原有配置，避免影响正常业务。</p></li><li><p>内存配置优化：重建索引、外键时，可临时提高 maintenance_work_mem 参数；多值 INSERT、JDBC 批处理执行时，建议合理设置 effective_cache_size（总 RAM 的 50%）、shared_buffers（总 RAM 的 25%），提升执行效率，操作后恢复默认值。</p></li><li><p>集群与数据完整性要求：主备集群环境下，使用 UNLOGGED 模式后，需重新创建主备复制关系，恢复集群同步；重新创建外键约束后，需校验外键关联性，确保数据完整性；所有批量导入操作完成后，需做全量数据校验（行计数、主键唯一性、非空约束等）。</p></li><li><p>方案选择与测试原则：无通用最优方案，需根据实际场景（数据量、表结构、集群架构）组合使用多种优化技巧；所有优化方案需先在与生产环境规格、配置一致的测试/预发环境验证，测试性能与兼容性后，再应用于生产环境；制定完善的回滚预案，若批量导入过程中出现异常，可快速恢复数据库原有状态。</p></li><li><p>后续性能保障：批量导入后除执行 ANALYZE 外，若表数据量变化极大（超过 50%），可根据实际情况做索引碎片整理（如 REINDEX 命令），提升后续查询性能；记录本次批量导入的优化方案、执行耗时、资源占用等信息，为后续同类操作积累经验。</p></li></ul><h3 id="4-4-2-日志批量落盘最佳实践-checkpoint"><a href="#4-4-2-日志批量落盘最佳实践-checkpoint" class="headerlink" title="4.4.2 日志批量落盘最佳实践(checkpoint)"></a>4.4.2 日志批量落盘最佳实践(checkpoint)</h3><h4 id="1-checkpoint机制介绍"><a href="#1-checkpoint机制介绍" class="headerlink" title="1 checkpoint机制介绍"></a><strong>1 checkpoint机制介绍</strong></h4><p>在高写入量的 PostgreSQL 系统中，检查点调优是实现高性能的核心环节，也是实际配置中易出现混淆和问题的关键点。本文将从<strong>checkpoint 机制介绍</strong>、<strong>最佳实践介绍</strong>、<strong>注意事项</strong>三个核心维度，详解检查点的工作原理、调优方法及实操要点。</p><p><strong>1. 检查点的核心背景</strong></p><p>PanweiDB 基于<strong>预写日志（WAL）</strong> 实现数据持久性，所有数据修改会先写入顺序的 WAL 日志，再在内存中修改数据文件，后续由后台进程异步刷新到磁盘。该机制虽看似增加写入量，却能提升性能：用户仅需等待 WAL 刷盘，而数据文件的写操作被后置，且顺序写的 WAL 远快于随机写的数据文件。</p><p>若没有检查点，数据库崩溃恢复时需重放<strong>全部 WAL 日志</strong>，但生产库每日会产生数TB WAL，长期运行会导致日志存储量剧增、恢复时间极长，无法满足实际业务需求。</p><p><strong>2. 检查点的核心作用</strong></p><p>检查点的本质是<strong>确认某一 WAL 位置前的所有数据修改，均已从内存刷写到数据文件</strong>，并记录该检查点位置。</p><ul><li>恢复层面：崩溃后仅需重放检查点后的 WAL 日志，大幅缩短恢复时间；</li><li>存储层面：可安全清理检查点前的 WAL 日志，减少磁盘空间占用。</li></ul><ol start="3"><li><strong>检查点的核心权衡</strong></li></ol><p>检查点的执行频率直接影响系统性能，存在明显的利弊权衡：</p><ul><li><strong>过于频繁</strong>（如每秒 1 次）：仅需保留少量 WAL，恢复速度极快，但会将数据文件的<strong>异步写转为同步写</strong>，大幅增加 COMMIT 延迟、降低系统吞吐量，严重影响业务性能；</li><li><strong>过于稀疏</strong>：减少对业务写入的影响，但会导致 WAL 日志堆积，恢复时间变长、磁盘占用增加。</li></ul><blockquote><p><strong>核心原则</strong>：让检查点的执行频率足够低，避免影响业务；同时足够高，合理限制恢复时间和磁盘空间消耗。</p></blockquote><p><strong>4. 检查点的触发方式</strong></p><p>PanweiDB 中检查点分为<strong>手动触发</strong>和<strong>自动触发</strong>，实际调优聚焦<strong>自动触发</strong>场景，具体触发条件如下：</p><ol><li><p>手动触发：</p><p>执行<code>CHECKPOINT</code>命令；</p><p>执行<code>pg_start_backup</code>/<code>CREATE DATABASE</code>/<code>pg_ctl stop|restart</code>等强制检查点的命令；</p></li><li><p>自动触发：</p><p>距离上一个检查点达到配置的<strong>时间阈值</strong>；</p><p>从上一个检查点开始，生成的 WAL 日志量达到配置的<strong>大小阈值</strong>。</p></li></ol><p><strong>5. 自动触发的核心配置参数</strong></p><p>自动触发的时间 / 大小阈值由两个基础参数控制，是调优的起点：</p><pre class="line-numbers language-properties"><code class="language-properties"><span class="token comment" spellcheck="true"># 时间阈值：默认15分钟</span><span class="token attr-name">checkpoint_timeout</span> <span class="token punctuation">=</span> <span class="token attr-value">15min</span><span class="token comment" spellcheck="true"># 大小阈值：默认64</span><span class="token attr-name">checkpoint_segments</span> <span class="token punctuation">=</span> <span class="token attr-value">64</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>Panweidb 会在<strong>时间阈值到达</strong>或<strong>WAL 大小接近阈值</strong>时，触发自动检查点，二者满足其一即可。</p><ol start="6"><li><strong>扩展检查点（Extended Checkpoint）</strong></li></ol><p>将检查点的脏数据刷盘操作<strong>分摊到整个检查点周期</strong>，而非一次性执行，让操作系统有时间在后台异步清理脏数据，最终的<code>fsync()</code>操作会更轻量，避免 I/O 阻塞。</p><p>核心步骤不变，仅执行方式优化：</p><ol><li>识别共享缓冲区中的所有脏数据块；</li><li>分批次将脏数据块写入磁盘（文件系统缓存）；</li><li>检查点周期结束时，执行<code>fsync()</code>将文件系统缓存中的数据刷到物理磁盘。</li></ol><p>扩展检查点的核心参数</p><pre><code># 核心参数：默认0.5，表示脏数据刷盘需在检查点周期的50%前完成checkpoint_completion_target = 0.5</code></pre><p>该参数定义<strong>脏数据刷盘完成的时间占检查点周期的比例</strong>，例如<code>checkpoint_timeout=5min</code>、<code>checkpoint_completion_target=0.5</code>时，脏数据需在 2.5 分钟内刷完，剩余 2.5 分钟留给操作系统将缓存中的数据刷到物理磁盘，让最终的<code>fsync()</code>更高效。</p><h4 id="2-最佳实践介绍"><a href="#2-最佳实践介绍" class="headerlink" title="2 最佳实践介绍"></a>2 最佳实践介绍</h4><p>检查点调优的核心目标是<strong>让自动检查点以时间阈值触发为主，大小阈值触发为辅</strong>，核心分为<strong>4 个步骤</strong>，同时需结合系统实际 WAL 生成量做个性化配置。</p><p><strong>1 合理设置 checkpoint_timeout（时间阈值）</strong></p><p>该参数的取值取决于业务的<strong>恢复时间目标（RTO）</strong>（即系统崩溃后可接受的最大恢复时间），需注意：</p><ul><li>该参数是<strong>WAL 生成的时间限制</strong>，并非直接的恢复时间限制（恢复由单进程执行，WAL 生成由多进程执行，恢复速度慢于 WAL 生成速度）；</li><li>生产中<strong>15~30 分钟</strong>是最常见取值，部分高写入量系统可设为 1 小时；</li><li>过低的取值还会因<strong>整页写入</strong>导致<strong>写入放大</strong>，进一步影响性能。</li></ul><p><strong>实操建议</strong>：先基于 RTO 初步设定，例如业务允许 30 分钟内恢复，可设：</p><pre class="line-numbers language-properties"><code class="language-properties"><span class="token attr-name">checkpoint_timeout</span> <span class="token punctuation">=</span> <span class="token attr-value">30min</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>2 优化 checkpoint_completion_target 参数</strong></p><p>让脏数据刷盘完成后，留给操作系统<strong>足够的时间</strong>将缓存中的数据刷到物理磁盘（Linux 系统中，页面缓存的脏数据过期时间由<code>vm.dirty_expire_centisecs</code>控制，默认 30 秒）。</p><p>（1）推荐计算公式</p><p>为避免留给操作系统的时间不足，推荐基于 checkpoint_timeout 计算，预留至少 2 分钟的刷盘时间：</p><pre class="line-numbers language-bash"><code class="language-bash">checkpoint_completion_target <span class="token operator">=</span> <span class="token punctuation">(</span>checkpoint_timeout - 2min<span class="token punctuation">)</span> / checkpoint_timeout<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>示例</strong>：<code>checkpoint_timeout=30min</code>时，<code>checkpoint_completion_target=(30-2)/30≈0.93</code>，生产中建议不超过 0.9，差异可忽略。</p><p>（2）不同配置的取值建议</p><ul><li>低超时（5~10 分钟）：保持默认 0.5，避免因 WAL 大小阈值触发检查点时，留给 OS 的时间不足 30 秒；</li><li>高超时（15<del>60 分钟）：调至 0.85</del>0.93，避免数据库在前半周期高速率刷盘，后半周期无操作，充分利用检查点周期。</li></ul><p><strong>3 调优操作系统内核参数</strong></p><p>Linux 内核的脏数据缓存参数会直接影响扩展检查点的效果，核心调优<strong>vm.dirty_background_bytes</strong>（默认值过高，易导致内核一次性刷新大量脏数据，抵消扩展检查点的优势）。</p><ul><li>作用：定义内核开始异步刷新脏数据到磁盘的<strong>缓存大小阈值</strong>；</li><li>调优原则：根据服务器内存大小合理设置，避免内核积累大量脏数据，建议结合实际业务的写入速率调整，让内核持续、低速地刷新脏数据。</li></ul><h4 id="3-注意事项"><a href="#3-注意事项" class="headerlink" title="3 注意事项"></a>3 注意事项</h4><ol><li><strong>整页写入的影响</strong>：checkpoint_timeout 过短时，会增加整页写入的频率，导致写入放大，即使是低写入量系统，也不建议将该参数设为 5 分钟以下。</li><li><strong>流复制的一致性</strong>：主库的检查点配置会影响备库的恢复效率，备库的 WAL 重放速度慢于主库的 WAL 生成速度，主库的 checkpoint_timeout 不宜设置过大，避免备库重放滞后。</li><li><strong>监控检查点的触发方式</strong>：生产中需持续监控检查点的触发原因（时间阈值 / 大小阈值），若频繁因大小阈值触发，说明<code>checkpoint_segments</code>设置过小，需重新估算 WAL 生成量并调大。</li><li><strong>配置修改后的验证</strong>：修改检查点参数后，需通过<code>pg_stat_bgwriter</code>和服务器日志验证效果，观察检查点的执行频率、WAL 生成量、刷盘耗时等指标，确保符合预期。</li></ol>]]></content>
      
      
      <categories>
          
          <category> linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 缓存，索引,分区 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第六章--监控命令</title>
      <link href="/2026/6.jian-kong-ming-ling/"/>
      <url>/2026/6.jian-kong-ming-ling/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><p>本章介绍Linux环境下系统资源监控的核心命令，重点讲解sar、uptime、mpstat、iostat、ipcs五大高频命令的应用。这些命令分别针对CPU、磁盘I/O、共享内存等关键系统资源，实现快速巡检、性能统计与瓶颈定位，覆盖日常运维及故障排查核心场景，可直接应用于生产环境，助力保障服务器稳定高效运行。</p><span id="more"></span><h2 id="6-1-sar-命令"><a href="#6-1-sar-命令" class="headerlink" title="6.1 sar 命令"></a>6.1 sar 命令</h2><h3 id="6-1-1-sar-工具简介"><a href="#6-1-1-sar-工具简介" class="headerlink" title="6.1.1 sar 工具简介"></a>6.1.1 sar 工具简介</h3><p>System Activity Reporter（sar）是一款功能强大的系统性能分析工具，隶属于 Sysstat 系统资源工具包，是Linux系统管理员必备的系统监控工具之一。它能够全面采集并分析系统各类性能数据，包括 CPU 活动、内存与分页、中断、设备负载、网络状态、进程线程分配及交换空间使用等，所有数据均来源于 /proc 文件系统。</p><p>默认情况下，sar 每小时的固定节点会自动采集一次系统数据，用于后续的历史性能分析与问题排查。本教程将详细讲解 sar 工具在 Linux 系统中的安装、配置方法，并结合常用命令示例，帮助你快速上手使用 sar 监控Linux系统。</p><h3 id="6-1-2-sar-常用命令速查表"><a href="#6-1-2-sar-常用命令速查表" class="headerlink" title="6.1.2 sar 常用命令速查表"></a>6.1.2 sar 常用命令速查表</h3><table><thead><tr><th align="center">监控对象</th><th align="center">sar 命令</th><th align="center">补充说明</th></tr></thead><tbody><tr><td align="center">监控网卡</td><td align="center">sar -n DEV</td><td align="center">查看网卡收发数据包、流量等详细信息</td></tr><tr><td align="center">监控 TCP</td><td align="center">sar -n TCP</td><td align="center">监控 TCP 连接状态、收发数据等指标</td></tr><tr><td align="center">监控 UDP</td><td align="center">sar -n UDP</td><td align="center">查看 UDP 数据包收发情况</td></tr><tr><td align="center">监控 SOCK</td><td align="center">sar -n SOCK</td><td align="center">监控系统 socket 连接总数及状态</td></tr><tr><td align="center">监控 CPU</td><td align="center">sar -u</td><td align="center">查看整体 CPU 使用率（用户态、系统态等）</td></tr><tr><td align="center">监控队列</td><td align="center">sar -q</td><td align="center">监控进程队列长度、系统平均负载等</td></tr><tr><td align="center">监控上下文切换</td><td align="center">sar -w</td><td align="center">查看系统上下文切换频率，反映 CPU 调度情况</td></tr><tr><td align="center">监控内存（分页相关）</td><td align="center">sar -B</td><td align="center">监控内存分页交换情况（页面换入 / 换出速率）</td></tr><tr><td align="center">监控内存（使用情况）</td><td align="center">sar -r</td><td align="center">查看内存空闲、已用、缓存等详细使用状态</td></tr><tr><td align="center">监控 SWAP（交换空间）</td><td align="center">sar -W</td><td align="center">监控交换空间的使用情况及交换速率</td></tr><tr><td align="center">监控磁盘（I/O 吞吐量）</td><td align="center">sar -b</td><td align="center">查看磁盘 I/O 总吞吐量、读写速率等</td></tr><tr><td align="center">监控磁盘（设备负载）</td><td align="center">sar -d</td><td align="center">查看单个磁盘设备的 I/O 负载、响应时间等</td></tr></tbody></table><h3 id="6-1-3-sar-安装与配置"><a href="#6-1-3-sar-安装与配置" class="headerlink" title="6.1.3 sar 安装与配置"></a>6.1.3 sar 安装与配置</h3><p>sar 工具并不默认包含在 Linux 系统中，需通过安装 sysstat 软件包获取。本教程以 <strong>BCLinux 21.10</strong> 系统为例，讲解具体安装与配置步骤。</p><p><strong>安装 sar</strong></p><p>BCLinux 21.10 系统默认使用 dnf 作为包管理器，打开终端，执行以下命令安装 sysstat，安装完成后即可直接使用 sar 命令：</p><pre class="line-numbers language-bash"><code class="language-bash">dnf <span class="token function">install</span> sysstat -y<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>启用 sar 数据采集</strong></p><p>安装完成后，需先启用 sar 的数据采集功能，否则无法自动收集系统历史性能数据。步骤如下：</p><ol><li>打开 sar 的核心配置文件：</li></ol><pre class="line-numbers language-bash"><code class="language-bash">vim /etc/sysconfig/sysstat<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>找到<code>ENABLED</code>项，修改为：<code>ENABLED="true"</code>（注释则先取消），保存退出。</p><pre class="line-numbers language-bash"><code class="language-bash">ENABLED<span class="token operator">=</span><span class="token string">"true"</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ol start="2"><li>启动 sysstat 相关服务并设置开机自启：</li></ol><pre class="line-numbers language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 启动采集+汇总定时器，直接生效</span>systemctl <span class="token function">enable</span> --now sysstat-collect.timer sysstat-summary.timer<span class="token comment" spellcheck="true"># 主服务开机自启</span>systemctl <span class="token function">enable</span> sysstat<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol start="3"><li>验证采集功能是否正常运行：</li></ol><pre class="line-numbers language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 查看定时器状态</span>systemctl list-timers <span class="token operator">|</span> <span class="token function">grep</span> sysstat<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><strong>核心配置修改</strong></p><p>若需自定义采集频率、日志保留时间等，可修改对应文件。</p><pre class="line-numbers language-bash"><code class="language-bash">vim /etc/sysconfig/sysstat<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>修改内容如下：</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 保留30天历史日志（默认7天，按需改）</span>HISTORY<span class="token operator">=</span>30<span class="token comment" spellcheck="true"># 超过10天的日志自动压缩</span>COMPRESSAFTER<span class="token operator">=</span>10<span class="token comment" spellcheck="true"># 日志保存目录（系统默认，无需改）</span>SA_DIR<span class="token operator">=</span>/var/log/sa<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如需采集全量性能指标</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 采集CPU/内存/磁盘/网络等所有指标（默认仅磁盘）</span>SADC_OPTIONS<span class="token operator">=</span><span class="token string">"-S XALL"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>配置修改后<strong>无需重启服务</strong>，下次采集自动生效。</p><p><strong>自定义采集频率</strong></p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 创建配置覆盖目录（自动生效，不修改系统默认文件）</span><span class="token function">mkdir</span> -p /etc/systemd/system/sysstat-collect.timer.d/<span class="token comment" spellcheck="true"># 写入自定义频率配置</span><span class="token function">cat</span> <span class="token operator">></span> /etc/systemd/system/sysstat-collect.timer.d/override.conf <span class="token operator">&lt;&lt;</span> <span class="token string">'EOF'[Timer]OnCalendar=*:0/5  # 每5分钟采集一次，改*:*则每分钟EOF</span><span class="token comment" spellcheck="true"># 重载配置并重启定时器</span>systemctl daemon-reload <span class="token operator">&amp;&amp;</span> systemctl restart sysstat-collect.timer<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>验证数据采集</strong></p><p>配置完成后需等待<strong>第一个采集周期</strong>（如 5/10 分钟），再验证：</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 1. 查看是否生成数据文件（saXX为当月日期，如sa28）</span><span class="token function">ls</span> -l /var/log/sa/<span class="token comment" spellcheck="true"># 2. 查看今日采集的性能数据（直接运行，自动读取当日文件）</span>sar<span class="token comment" spellcheck="true"># 3. 手动触发一次采集（测试用，立即生成数据）</span>/usr/lib64/sa/sa1 1 1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="6-1-5-sar-命令基础使用方法"><a href="#6-1-5-sar-命令基础使用方法" class="headerlink" title="6.1.5 sar 命令基础使用方法"></a>6.1.5 sar 命令基础使用方法</h3><p>sar 命令的使用分为<strong>实时监控</strong>（查看当前系统性能）和<strong>历史查询</strong>（查看已采集的历史数据）两种核心场景，在 BCLinux 系统中的用法与原生 Linux 一致，核心语法如下：</p><p><strong>核心语法</strong></p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 1. 实时监控：无-f选项，直接指定监控参数+采样间隔+采样次数</span>sar <span class="token punctuation">[</span>选项<span class="token punctuation">]</span> <span class="token punctuation">[</span>采样间隔<span class="token punctuation">]</span> <span class="token punctuation">[</span>采样次数<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># 2. 历史查询：使用-f选项指定默认的历史数据文件路径</span>sar <span class="token punctuation">[</span>选项<span class="token punctuation">]</span> -f /var/log/sysstat/saXX<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>参数说明</strong></p><ul><li>采样间隔：每次采集数据的时间间隔（单位：秒）。</li><li>采样次数：需要采集的次数；若不指定，默认采集一次（实时监控）或显示该文件的所有历史数据（历史查询）。</li><li>saXX：历史数据文件名，XX 对应当月日期（如 15 表示当月 15 号的历史数据），文件位于默认的<code>/var/log/sysstat/</code>目录。</li></ul><p><strong>基础示例（查看历史 CPU 数据）</strong></p><p>执行以下命令，查看当月 24 号的 CPU 累计使用情况（需替换 sa24 为你系统中存在的文件名）：</p><pre class="line-numbers language-bash"><code class="language-bash">sar -u -f /var/log/sa/sa28<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>典型输出</strong></p><pre class="line-numbers language-bash"><code class="language-bash">Linux 4.19.90-2107.6.0.0100.oe1.bclinux.x86_64 <span class="token punctuation">(</span>hostname<span class="token punctuation">)</span>     01/28/2026      _x86_64_        <span class="token punctuation">(</span>4 CPU<span class="token punctuation">)</span>09:00:01 AM     CPU     %user     %nice   %system   %iowait    %steal     %idle09:10:01 AM     all      0.25      0.00      0.12      0.03      0.00     99.6009:20:01 AM     all      0.23      0.00      0.11      0.02      0.00     99.64Average:        all      0.24      0.00      0.11      0.02      0.00     99.62<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>输出字段说明</strong></p><ul><li><code>Linux 4.19.90-2107.6.0.0100.oe1.bclinux.x86_64</code>：bclinux系统的内核版本。</li><li><code>hostname</code>：采集数据的主机名。</li><li><code>01/28/2026</code>：数据采集日期。</li><li><code>x86_64</code>：系统架构。</li><li><code>(4 CPU)</code>：系统可用 CPU 核心数。</li><li><code>%user</code>：CPU 在用户态的使用率（运行用户应用程序的时间占比）。</li><li><code>%nice</code>：CPU 在 nice 优先级进程上的使用率（调整过优先级的用户进程）。</li><li><code>%system</code>：CPU 在内核态的使用率（运行系统内核指令的时间占比）。</li><li><code>%iowait</code>：CPU 等待 I/O 操作完成的时间占比（I/O 瓶颈会导致该值升高）。</li><li><code>%steal</code>：被虚拟化环境中其他虚拟机占用的 CPU 时间占比。</li><li><code>%idle</code>：CPU 空闲时间占比（该值过低表示 CPU 负载过高）。</li></ul><h3 id="6-1-6-sar-常用命令详细示例"><a href="#6-1-6-sar-常用命令详细示例" class="headerlink" title="6.1.6 sar 常用命令详细示例"></a>6.1.6 sar 常用命令详细示例</h3><p>结合前面的速查表，以下是 <strong>BCLinux</strong> 系统中各监控场景的详细使用示例，包含实时监控、历史查询及输出说明，以帮助快速排查系统性能问题。</p><p><strong>CPU 监控（sar -u /sar -P）</strong></p><p><strong>查看整体 CPU 使用率</strong></p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 1. 查看当前日期已采集的CPU使用率（默认显示所有历史采样点）</span>sar -u<span class="token comment" spellcheck="true"># 2. 实时监控：每1秒采集一次，共采集3次，快速查看当前CPU负载</span>sar -u 1 3<span class="token comment" spellcheck="true"># 3. 历史查询：查看当月28号的CPU使用率</span>sar -u -f /var/log/sa/sa28<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>查看单个 / 所有 CPU 核心使用率</strong></p><p>当系统存在多个 CPU 核心时，可通过<code>-P</code>选项查看单个 / 所有核心的负载情况，精准定位 CPU 瓶颈：</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 1. 查看所有CPU核心的使用率（当前日期历史数据）</span>sar -P ALL<span class="token comment" spellcheck="true"># 2. 实时监控：每1秒采集一次，共3次，查看所有核心负载</span>sar -P ALL 1 3<span class="token comment" spellcheck="true"># 3. 查看单个核心（如核心1，核心编号从0开始）的使用率</span>sar -P 1<span class="token comment" spellcheck="true"># 4. 历史查询：查看当月28号所有核心的使用率</span>sar -P ALL -f /var/log/sa/sa28<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>内存监控（sar -r /sar -B）</strong></p><p><strong>查看内存使用详情（sar -r）</strong></p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 1. 查看当前日期内存使用情况（空闲、已用、缓存等）</span>sar -r<span class="token comment" spellcheck="true"># 2. 实时监控：每1秒采集一次，共3次</span>sar -r 1 3<span class="token comment" spellcheck="true"># 3. 历史查询：查看当月28号内存使用情况</span>sar -r -f /var/log/sa/sa28<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>典型输出字段说明（单位：KB）</strong></p><ul><li>kbmemfree：系统空闲内存大小。</li><li>kbavail：可直接分配给应用程序的内存大小（包含空闲内存 + 可回收缓存），Linux 系统中该指标为内存剩余的核心参考。</li><li>kbmemused：已使用内存大小（包含缓存、缓冲区，非实际应用占用）。</li><li>% memused：内存使用率（需结合 kbavail 判断，避免被缓存占用误导）。</li><li>kbbuffers：用于内核缓冲区的内存大小（存储磁盘 I/O 临时数据）。</li><li>kbcached：用于页面缓存的内存大小（存储文件内容，可随时回收）。</li></ul><p><strong>查看内存分页交换（sar -B）</strong></p><p>用于监控内存分页（页面换入 / 换出）情况，反映 Linux 系统是否内存不足（频繁分页会导致系统卡顿、应用响应缓慢）：</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 实时监控：每1秒采集一次，共3次，查看分页交换速率</span>sar -B 1 3<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><strong>交换空间监控（sar -W）</strong></p><p>交换空间（SWAP）是 Linux 系统硬盘上的一块虚拟内存区域，当物理内存不足时，系统会将部分内存数据写入 SWAP，<strong>频繁使用 SWAP 会严重降低系统性能</strong>，需重点监控：</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 1. 查看当前日期SWAP使用情况</span>sar -W<span class="token comment" spellcheck="true"># 2. 实时监控：每1秒采集一次，共3次</span>sar -W 1 3<span class="token comment" spellcheck="true"># 3. 历史查询：查看当月28号SWAP使用情况</span>sar -W -f /var/log/sa/sa28<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>输出字段说明</strong></p><ul><li>pswpin/s  # 每秒从交换空间换入物理内存的页面数（pages/秒） </li><li>pswpout/s # 每秒从物理内存换出到交换空间的页面数（pages/秒）</li></ul><p><strong>磁盘 I/O 监控（sar -b /sar -d）</strong></p><p>Linux 系统常用于服务器场景，磁盘 I/O 是性能瓶颈的高频点，通过 sar 可精准监控磁盘吞吐量和单设备负载。</p><p><strong>查看磁盘整体 I/O 吞吐量（sar -b）</strong></p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 1. 查看当前日期磁盘I/O整体情况</span>sar -b<span class="token comment" spellcheck="true"># 2. 实时监控：每1秒采集一次，共3次</span>sar -b 1 3<span class="token comment" spellcheck="true"># 3. 历史查询：查看当月24号磁盘I/O吞吐量</span>sar -b -f /var/log/sa/sa28<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>常用输出字段说明</strong></p><ul><li>tps：每秒磁盘 I/O 请求总数（包含读请求和写请求）。</li><li>rtps：每秒磁盘读请求数。</li><li>wtps：每秒磁盘写请求数。</li><li>bread/s：每秒从磁盘读取的数据量（单位：块 / 秒）。</li><li>bwrtn/s：每秒向磁盘写入的数据量（单位：块 / 秒）。</li></ul><p><strong>查看单个磁盘设备负载（sar -d）</strong></p><p>定位 Linux系统中<strong>具体哪个磁盘设备</strong>存在 I/O 瓶颈（如系统盘、数据盘），精准定位存储问题：</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 实时监控：每1秒采集一次，共3次，查看所有磁盘设备的I/O负载</span>sar -d 1 3<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><strong>网络监控（sar -n）</strong></p><p>sar -n 支持多种网络监控类型，适配linux系统的服务器网络场景，结合速查表，常用示例如下（可快速排查网络丢包、流量过高问题）：</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 1. 监控网卡（DEV）：查看所有网卡收发数据包、流量、丢包率等</span>sar -n DEV 1 3<span class="token comment" spellcheck="true"># 2. 监控TCP连接：查看TCP连接状态（ESTABLISHED、LISTEN等）、收发包数</span>sar -n TCP 1 3<span class="token comment" spellcheck="true"># 3. 监控UDP：查看UDP数据包收发情况、端口使用情况</span>sar -n UDP 1 3<span class="token comment" spellcheck="true"># 4. 监控socket连接：查看系统socket总数及各状态连接数</span>sar -n SOCK 1 3<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>其他常用监控</strong></p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 1. 监控进程队列（sar -q）：查看系统平均负载、进程等待队列长度，反映系统整体繁忙程度</span>sar -q 1 3<span class="token comment" spellcheck="true"># 2. 监控上下文切换（sar -w）：查看CPU上下文切换频率，反映CPU调度压力（频率过高表示进程调度频繁）</span>sar -w 1 3<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="6-1-7-sar命令使用建议"><a href="#6-1-7-sar命令使用建议" class="headerlink" title="6.1.7 sar命令使用建议"></a>6.1.7 sar命令使用建议</h3><p>结合 Linux的系统特性和服务器端的使用场景，给出以下针对性使用建议：</p><ol><li><strong>查看官方手册</strong>：sar 命令的选项和字段较多，可通过执行<code>man sar</code>查看完整手册，同时可通过<code>dnf info sysstat</code>查看 BCLinux系统中 sysstat 包的适配说明。</li><li><strong>结合历史数据排查问题</strong>：BCLinux 服务器出现性能瓶颈（如应用卡顿、服务无响应、负载过高）时，通过<code>sar -f</code>查看对应时间段的历史数据，精准定位问题根源（CPU 负载过高、磁盘 I/O 瓶颈、内存不足、网络流量异常等）。</li><li><strong>适配服务器采集频率</strong>：对于高负载的 BCLinux 生产服务器，可将采集频率调整为 1 分钟一次（修改<code>/etc/cron.d/sysstat</code>中的<code>*/10</code>为<code>*/1</code>），便于更精准地捕捉性能波动；对于低负载服务器，保持默认 10 分钟采集即可，减少系统资源消耗。</li><li><strong>开启全量采集数据</strong>：若 BCLinux  系统用于核心业务监控，将<code>/etc/sysstat/sysstat</code>中的<code>SADC_OPTIONS</code>改为<code>SADC_OPTIONS="-S XALL"</code>，采集 CPU、内存、磁盘、网络、进程、中断等全量指标，为问题排查提供完整数据支撑。</li><li><strong>日志目录权限</strong>：BCLinux 系统中<code>/var/log/sysstat/</code>目录默认归 root 用户所有，普通用户查看历史数据需加<code>sudo</code>，若需开放权限，可通过<code>chmod</code>调整目录权限（不建议生产环境操作）。</li></ol><h2 id="6-2-uptime监控CPU负载"><a href="#6-2-uptime监控CPU负载" class="headerlink" title="6.2 uptime监控CPU负载"></a>6.2 uptime监控CPU负载</h2><p>在系统性能监控中，了解CPU的负载情况至关重要。<code>uptime</code> 命令是一个简洁有效的工具，可以帮助我们获取系统的负载平均值。通过分析这些负载值，我们可以判断系统在不同时间段内的工作状态，从而做出相应的调整和优化。</p><h3 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a><strong>环境准备</strong></h3><p>本教程适用于各种 Unix/Linux 系统，确保您有权限访问终端并运行命令。</p><hr><h3 id="CPU-负载监控"><a href="#CPU-负载监控" class="headerlink" title="CPU 负载监控"></a><strong>CPU 负载监控</strong></h3><h4 id="使用-uptime-监控-CPU-负载"><a href="#使用-uptime-监控-CPU-负载" class="headerlink" title="使用 uptime 监控 CPU 负载"></a><strong>使用 uptime 监控 CPU 负载</strong></h4><p><strong>操作步骤：</strong></p><ol><li><p><strong>打开终端</strong>：在您的服务器或工作站上打开一个终端窗口。</p></li><li><p><strong>执行 uptime 命令</strong>：</p><p>在终端中输入以下命令：</p><pre class="line-numbers language-bash"><code class="language-bash">bashuptime<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>您将看到类似于以下的输出：</p><pre class="line-numbers language-bash"><code class="language-bash">14:29:38 up  3:16,  1 user,  load average: 20.29, 19.10, 18.50<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li></ol><h3 id="输出指标解读"><a href="#输出指标解读" class="headerlink" title="输出指标解读"></a><strong>输出指标解读</strong></h3><p>在上面的输出中，重点关注最后三个数字，它们代表了系统负载在过去1分钟、5分钟和15分钟内的平均值。这些值分别为：</p><ul><li><strong>1分钟平均负载</strong>：20.29</li><li><strong>5分钟平均负载</strong>：19.10</li><li><strong>15分钟平均负载</strong>：18.50</li></ul><p><strong>负载平均值的含义</strong></p><ul><li><strong>负载的概念</strong>：负载平均值并不是简单的数学均值，而是基于指数衰减的累加值。它表示在特定时间段内，系统中处于可运行状态和不可中断等待状态的任务数量。</li><li><strong>任务状态</strong>：<ul><li><strong>可运行状态</strong>：指的是正在等待CPU资源的任务。</li><li><strong>不可中断等待状态</strong>：指的是因I/O操作或锁等待而无法继续执行的任务。</li></ul></li></ul><h3 id="负载趋势分析"><a href="#负载趋势分析" class="headerlink" title="负载趋势分析"></a><strong>负载趋势分析</strong></h3><p>通过比较这三个时间段的平均负载值，可以分析系统负载的变化趋势。例如，在上述例子中，1分钟平均负载值（20.29）高于15分钟平均负载值（18.50），这表明系统的负载在最近1分钟内有所上升。</p><p><strong>判断系统负载是否饱和</strong></p><p>为了评估负载是否过高，可以将平均负载值与CPU核心数进行比较。假设您的系统有16个CPU核心，您可以做如下计算：</p><ul><li><strong>负载比</strong> = 1分钟平均负载 / CPU核心数</li><li><strong>判断</strong>：如果负载比超过1.0，说明系统中的CPU资源可能处于饱和状态。</li></ul><p>在本例中：</p><pre class="line-numbers language-bash"><code class="language-bash">负载比 <span class="token operator">=</span> 20.29 / 16 ≈ 1.27<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这意味着在过去的一分钟内，系统中可用的CPU资源已经不足，任务的排列可能导致响应时间变慢。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h3><p>通过 <code>uptime</code> 命令监控CPU负载，可以帮助您快速评估系统的性能状态。尽管负载平均值提供了一些关于系统负载需求的见解，但请记住，这些值通常仅用于负载趋势分析，而不能直接作为CPU利用率的衡量标准。为了获得更全面的性能分析，建议结合其他工具（如 <code>mpstat</code>、<code>top</code> 等）进行综合评估。</p><h2 id="6-3-mpstat辨认CPU瓶颈"><a href="#6-3-mpstat辨认CPU瓶颈" class="headerlink" title="6.3 mpstat辨认CPU瓶颈"></a>6.3 mpstat辨认CPU瓶颈</h2><p>利用 <code>mpstat</code> 工具，我们可以深入了解系统中每个CPU的使用情况，从而帮助我们识别潜在的性能瓶颈和负载不均衡的问题。以下是如何使用 <code>mpstat</code> 来监控和分析CPU使用率的详细步骤。</p><h3 id="环境准备-1"><a href="#环境准备-1" class="headerlink" title="环境准备"></a><strong>环境准备</strong></h3><p>本教程基于 <strong>BCLinux21.10</strong> 系统，但其他 Unix/Linux 发行版的命令输出可能略有差异。尽管如此，核心原理和指标解读方式基本一致。</p><hr><h3 id="CPU监控"><a href="#CPU监控" class="headerlink" title="CPU监控"></a><strong>CPU监控</strong></h3><h4 id="使用-mpstat-监控-CPU-使用率"><a href="#使用-mpstat-监控-CPU-使用率" class="headerlink" title="使用 mpstat 监控 CPU 使用率"></a><strong>使用 mpstat 监控 CPU 使用率</strong></h4><p><strong>操作步骤：</strong></p><ol><li><p><strong>安装 sysstat 包（如未安装）</strong></p><p>在终端中执行以下命令：</p><pre class="line-numbers language-bash"><code class="language-bash">bashyum <span class="token function">install</span> sysstat -y<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p><strong>执行监控命令：</strong></p><p>使用 <code>mpstat</code> 命令来监控CPU的使用情况：</p><pre class="line-numbers language-bash"><code class="language-bash">bashmpstat -P ALL 1 5<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这条命令将每秒输出一次CPU的使用情况，连续输出5次。</p></li></ol><h3 id="示例输出解析"><a href="#示例输出解析" class="headerlink" title="示例输出解析"></a><strong>示例输出解析</strong></h3><p>运行命令后，您将看到类似以下的输出：</p><pre class="line-numbers language-bash"><code class="language-bash">plaintextLinux 4.19.90-2107.6.0.0100.oe1.bclinux.x86_64 <span class="token punctuation">(</span>panweidb91<span class="token punctuation">)</span>     01/28/2026      _x86_64_        <span class="token punctuation">(</span>4 CPU<span class="token punctuation">)</span>02:05:33 PM  CPU    %usr   %nice    %sys %iowait    %irq   %soft  %steal  %guest  %gnice   %idle02:05:34 PM  all    0.00    0.00    0.00    0.00    0.25    0.00    0.00    0.00    0.00   99.7502:05:34 PM    0    0.00    0.00    0.00    0.00    0.00    0.00    0.00    0.00    0.00  100.0002:05:34 PM    1    0.00    0.00    0.00    0.00    0.97    0.00    0.00    0.00    0.00   99.0302:05:34 PM    2    0.00    0.00    0.00    0.00    0.00    0.00    0.00    0.00    0.00  100.0002:05:34 PM    3    0.00    0.00    0.00    0.00    0.00    0.00    0.00    0.00    0.00  100.00<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>输出指标解读：</strong></p><ul><li><strong>%usr</strong>：表示用户空间进程占用CPU的比例。高值可能意味着应用程序负载较重。</li><li><strong>%sys</strong>：表示内核空间占用CPU的比例。高值通常表明系统调用频繁，或者驱动程序存在问题。</li><li><strong>%iowait</strong>：表示CPU等待I/O操作完成的时间比例。若该值持续较高，可能意味着存储设备的I/O性能不足。</li><li><strong>%idle</strong>：表示CPU空闲的时间比例。若该值低于20%，则可能表示CPU资源紧张，需要考虑优化进程或增加硬件资源。</li></ul><h3 id="常见性能问题判断"><a href="#常见性能问题判断" class="headerlink" title="常见性能问题判断"></a><strong>常见性能问题判断</strong></h3><p>通过分析这些指标，我们可以判断系统的性能状态，例如：</p><ul><li><strong>高 %iowait</strong>：如果 <code>%iowait</code> 持续处于高位，表明可能存在存储I/O瓶颈，需检查磁盘性能。</li><li><strong>低 %idle</strong>：当 <code>%idle</code> 长期低于20%，说明CPU资源紧张，可能需要优化现有进程，或考虑扩容。</li></ul><h3 id="负载均衡问题识别"><a href="#负载均衡问题识别" class="headerlink" title="负载均衡问题识别"></a><strong>负载均衡问题识别</strong></h3><p><code>mpstat</code> 工具每秒钟输出每个CPU的使用数据，可以帮助识别负载不均衡的问题。例如，如果某些CPU的使用率很高，而其他CPU的使用率却很低，可能暗示着以下几种情况：</p><ul><li><strong>应用程序配置不合理</strong>：如应用的线程池、工作进程数配置过小，无法充分调度和利用服务器的所有 CPU 核心，导致业务请求集中在少数核心上处理；</li><li><strong>资源绑定限制</strong>：人为或软件层面将特定进程、容器、服务绑定到部分 CPU 核心上运行，限制了 CPU 资源的调度范围，造成绑定核心负载过高，其余核心闲置；</li><li><strong>软件层面缺陷</strong>：应用程序本身存在代码 bug、逻辑缺陷，或依赖的中间件、底层库存在调度问题，导致业务处理逻辑无法均匀分配到多个 CPU 核心，引发负载倾斜；</li><li><strong>系统调度策略适配问题</strong>：极少数情况下，系统内核的 CPU 调度策略与业务场景不匹配，也会导致核心间负载分配不均。</li></ul><p>若服务器存在上述 CPU 负载均衡问题，即便整体 CPU 使用率未达到阈值，也会因部分核心被占满，导致业务请求处理缓慢、响应延迟增加，最终表现为系统性能瓶颈，因此通过<code>mpstat</code>识别负载均衡问题，是定位 CPU 瓶颈的重要环节。</p><h2 id="6-4-iostat监控磁盘I-x2F-O"><a href="#6-4-iostat监控磁盘I-x2F-O" class="headerlink" title="6.4 iostat监控磁盘I/O"></a>6.4 iostat监控磁盘I/O</h2><p><code>iostat</code> 是 Unix/Linux 系统中一款强大的磁盘 I/O 性能监控工具，通过它可实时获取各磁盘的 I/O 操作统计信息，包括 IOPS（每秒输入输出操作数）、吞吐量、I/O 请求时长及磁盘使用率等关键指标，助力快速定位磁盘性能瓶颈。以下是详细的使用教程，适用于各类 Unix/Linux 系统用户。</p><h3 id="环境准备-2"><a href="#环境准备-2" class="headerlink" title="环境准备"></a>环境准备</h3><p>本教程适配所有 Unix/Linux 发行版（如 CentOS、Ubuntu、Debian 等），只需满足两个条件：</p><ul><li>拥有系统终端访问权限（可通过 SSH 远程连接服务器或直接操作本地工作站）；</li><li>系统已预装 <code>iostat</code>（默认集成在 sysstat 工具包中，若未安装，可通过 <code>yum install sysstat</code> 或 <code>apt install sysstat</code> 命令快速安装）。</li></ul><h3 id="iostat-核心使用方法"><a href="#iostat-核心使用方法" class="headerlink" title="iostat 核心使用方法"></a>iostat 核心使用方法</h3><p><strong>基本命令（常用推荐）</strong></p><p>监控磁盘 I/O 最常用的命令的是带详细参数的实时输出模式，步骤如下：</p><ol><li>打开终端：本地操作直接打开终端窗口，远程服务器通过 SSH 工具（如 Xshell、Putty）连接后进入终端；</li><li>执行核心命令：输入以下命令，启动实时监控并输出详细信息：        <code>iostat -dxz 1</code></li></ol><p>命令参数详细解读（重点必看）：</p><ul><li>-d：仅显示磁盘相关的 I/O 统计信息，屏蔽 CPU 相关统计（聚焦磁盘，避免信息干扰）；</li><li>-x：显示扩展的详细统计列，包含请求时长、队列长度等关键性能指标（默认仅显示基础指标）；</li><li>-z：忽略所有指标为 0 的磁盘设备，仅显示有 I/O 活动的设备（精简输出，提升可读性）；</li><li>1：指定统计信息的输出间隔，单位为秒（此处表示每秒刷新一次，可根据需求修改，如 5 表示每 5 秒刷新）。</li></ul><p>补充说明：若需停止监控，按下键盘 <code>Ctrl + C</code> 即可终止命令运行。</p><p><strong>输出结果解读</strong></p><p>执行上述命令后，终端会持续输出类似以下的统计结果（以两块磁盘 xvda、xvdb 为例）：</p><pre class="line-numbers language-bash"><code class="language-bash">Device          r/s     rkB/s   rrqm/s  %rrqm r_await rareq-sz  w/s     wkB/s   wrqm/s  %wrqm w_await wareq-sz  d/s     dkB/s   drqm/s  %drqm d_await dareq-sz  f/s   f_await  aqu-sz  %utilxvda           150.00   12000.00   5.00    3.33   15.00   80.00   200.00  15000.00  10.00   5.00   20.00  75.00   0.50   20.00   2.00    1.00   25.00   1.50    0.20   100.00   15.00   85.00xvdb           90.00    8000.00    2.00    2.22   30.00   90.00   50.00   4000.00   3.00    6.00   10.00  80.00   1.00   15.00   0.50    0.50   12.00   0.80    0.10   90.00    8.00   70.00<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><strong>关键列含义</strong></p><p>输出列较多，以下是日常性能监控中最常用、最关键的列解读，其余列可根据实际需求参考：</p><ul><li><strong>Device</strong>：磁盘设备名称（如 xvda、xvdb，对应系统中的物理磁盘或虚拟磁盘）；</li><li><strong>r/s</strong>：每秒完成的读请求数（读 IOPS，反映磁盘读操作的频繁程度）；</li><li><strong>rkB/s</strong>：每秒从磁盘读取的数据量（读吞吐量，单位：千字节，直观反映读速度）；</li><li><strong>w/s</strong>：每秒完成的写请求数（写 IOPS，反映磁盘写操作的频繁程度）；</li><li><strong>wkB/s</strong>：每秒向磁盘写入的数据量（写吞吐量，单位：千字节，直观反映写速度）；</li><li><strong>r_await</strong>：平均读请求等待时长（单位：毫秒，包含队列等待时间+磁盘处理时间，数值越小越好）；</li><li><strong>w_await</strong>：平均写请求等待时长（单位：毫秒，解读同 r_await）；</li><li><strong>aqu-sz</strong>：I/O 请求等待队列的平均长度（队列越长，说明磁盘处理能力不足，容易出现阻塞）；</li><li><strong>%util</strong>：磁盘忙于处理 I/O 请求的时间百分比（核心指标，反映磁盘负载情况）。</li></ul><p>补充：d/、f/ 开头的列（如 d/s、f/s）对应设备级、文件系统级的额外统计，日常监控中若无需精细化分析，可暂时忽略。</p><p><strong>性能分析技巧</strong></p><p>通过解读输出指标，可快速判断磁盘 I/O 性能状态，定位瓶颈，以下是最实用的分析方法：</p><ol><li><strong>判断磁盘负载是否过高</strong>：核心看 %util 指标。        <ol><li>若 %util 长期在 80%~100% 之间，说明磁盘处于高负载状态，可能导致 I/O 阻塞；</li><li>若 %util 接近 100%，且 r_await、w_await 数值较大（如超过 20ms），则可确定磁盘 I/O 是系统性能瓶颈。</li></ol></li><li><strong>区分瓶颈类型（读/写瓶颈）</strong>：结合 r/s、w/s、rkB/s、wkB/s 判断。        <ol><li>若 r/s、rkB/s 数值较大，且 r_await 偏高，说明存在读瓶颈（如频繁读取大文件、数据库全表扫描）；</li><li>若 w/s、wkB/s 数值较大，且 w_await 偏高，说明存在写瓶颈（如频繁写入大量小文件、日志刷盘过于频繁）。</li></ol></li><li><strong>排查队列阻塞问题</strong>：看 aqu-sz 指标。若 aqu-sz 长期大于 2，说明 I/O 请求队列过长，磁盘处理速度跟不上请求产生速度，需优化磁盘或业务逻辑。</li><li><strong>定位异常磁盘</strong>：对比多块磁盘的指标，若某一块磁盘的 %util、await 远高于其他磁盘，说明该磁盘存在异常（如磁盘损坏、分区不合理）。</li></ol><h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><p><code>iostat</code> 命令的核心价值的是“简单、高效、精准”，无需复杂配置，通过简单参数即可实时监控磁盘 I/O 状态。日常使用中，记住以下核心要点即可满足大部分监控需求：</p><ul><li>常用命令：<code>iostat -dxz 1</code>（实时、详细、精简输出）；</li><li>核心指标：%util（负载）、r_await/w_await（请求时长）、aqu-sz（队列长度）；</li><li>核心用途：快速定位磁盘 I/O 瓶颈，为系统优化、容量规划、资源调整提供数据支撑。</li></ul><h2 id="6-5-ipcs确认共享内存"><a href="#6-5-ipcs确认共享内存" class="headerlink" title="6.5 ipcs确认共享内存"></a>6.5 ipcs确认共享内存</h2><p>下面是关于如何使用 <code>ipcs</code> 命令查看磐维数据库（Panweidb）使用的共享内存的简单教程。</p><h3 id="6-5-1-使用-ipcs-命令"><a href="#6-5-1-使用-ipcs-命令" class="headerlink" title="6.5.1 使用 ipcs 命令"></a>6.5.1 使用 <code>ipcs</code> 命令</h3><p><code>ipcs</code> 命令用于显示系统中的消息队列、共享内存段和信号量的信息。您可以使用不同的选项来定制输出。</p><h4 id="基本命令"><a href="#基本命令" class="headerlink" title="基本命令"></a><strong>基本命令</strong></h4><pre class="line-numbers language-bash"><code class="language-bash">ipcs<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>此命令将显示所有 IPC 资源的信息，包括消息队列、共享内存和信号量。</p><h3 id="6-5-2-查看共享内存段"><a href="#6-5-2-查看共享内存段" class="headerlink" title="6.5.2 查看共享内存段"></a><strong>6.5.2 查看共享内存段</strong></h3><p>要查看具体的共享内存段，您可以使用以下命令：</p><pre class="line-numbers language-bash"><code class="language-bash">ipcs -m<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>该命令将输出当前系统的所有共享内存段信息，包括每个段的键（key）、标识符（shmid）、拥有者（owner）、权限（perms）、字节数（bytes）、附加次数（nattch）和状态（status）。</p><h4 id="示例输出分析"><a href="#示例输出分析" class="headerlink" title="示例输出分析"></a><strong>示例输出分析</strong></h4><p>输出示例：</p><pre class="line-numbers language-bash"><code class="language-bash">plaintext------ Shared Memory Segments --------key        shmid      owner      perms      bytes      nattch     status0x010e14a1 0          omm        600        815420360  1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><ul><li><strong>key</strong>：共享内存段的唯一标识符。</li><li><strong>shmid</strong>：共享内存段的 ID。</li><li><strong>owner</strong>：创建该共享内存段的用户。</li><li><strong>perms</strong>：访问权限（600 表示可读可写）。</li><li><strong>bytes</strong>：共享内存段的大小（815420360 字节）。</li><li><strong>nattch</strong>：当前附加到该共享内存段的进程数量（1 表示一个进程正在使用它）。</li><li><strong>status</strong>：共享内存的状态。</li></ul><h3 id="6-5-3-查看基本-IPC-资源信息"><a href="#6-5-3-查看基本-IPC-资源信息" class="headerlink" title="6.5.3 查看基本 IPC 资源信息**"></a>6.5.3 查看基本 IPC 资源信息**</h3><p>如果您只想获取简化的 IPC 资源统计信息，可以使用 <code>-b</code> 选项：</p><pre class="line-numbers language-bash"><code class="language-bash">ipcs -b<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>此命令将输出系统中所有 IPC 资源的基础信息，不会显示详细内容，但能快速提供资源使用情况。</p><h4 id="示例输出"><a href="#示例输出" class="headerlink" title="示例输出"></a><strong>示例输出</strong></h4><p>运行 <code>ipcs -b</code> 后，您可能会看到如下输出：</p><pre class="line-numbers language-bash"><code class="language-bash">plaintext------ Message Queues --------key        msqid      owner      perms      used-bytes   messages------ Shared Memory Segments --------key        shmid      owner      perms      bytes      nattch     status------ Semaphore Arrays --------key        semid      owner      perms      nsems<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="6-5-4-实时监控共享内存"><a href="#6-5-4-实时监控共享内存" class="headerlink" title="6.5.4 实时监控共享内存"></a>6.5.4 实时监控共享内存</h3><p>您可以结合使用 <code>watch</code> 命令，实时监控共享内存的使用情况：</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">watch</span> -n 1 ipcs -m<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这将每秒更新一次共享内存段的信息，帮助您及时了解内存使用情况。</p>]]></content>
      
      
      <categories>
          
          <category> linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 性能调优工具 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
