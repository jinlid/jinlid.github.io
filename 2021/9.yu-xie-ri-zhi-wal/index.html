<!DOCTYPE HTML>
<html lang="zh-CN">


<head>
    <meta charset="utf-8">
    <meta name="keywords" content="9 预写日志—WAL, jinlid&#39;s blog">
    <meta name="description" content="事务日志是数据库的重要组成部分，因为所有的数据库管理系统都要求即使发生系统故障也不丢失任何数据。它是数据库系统中所有更改操作的历史日志，以确保没有由于故障（例如电源故障）或其他导致服务器崩溃的服务器故障而丢失数据。由于日志包含有关已执行的每">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <meta name="renderer" content="webkit|ie-stand|ie-comp">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="format-detection" content="telephone=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="referrer" content="no-referrer-when-downgrade">
    <!-- Global site tag (gtag.js) - Google Analytics -->


    <title>9 预写日志—WAL | jinlid&#39;s blog</title>
    <link rel="icon" type="image/png" href="/favicon.png">
    


    <!-- bg-cover style     -->



<link rel="stylesheet" type="text/css" href="/libs/awesome/css/all.min.css">
<link rel="stylesheet" type="text/css" href="/libs/materialize/materialize.min.css">
<link rel="stylesheet" type="text/css" href="/libs/aos/aos.css">
<link rel="stylesheet" type="text/css" href="/libs/animate/animate.min.css">
<link rel="stylesheet" type="text/css" href="/libs/lightGallery/css/lightgallery.min.css">
<link rel="stylesheet" type="text/css" href="/css/matery.css">
<link rel="stylesheet" type="text/css" href="/css/my.css">
<link rel="stylesheet" type="text/css" href="/css/dark.css" media="none" onload="if(media!='all')media='all'">




    <link rel="stylesheet" href="/libs/tocbot/tocbot.css">
    <link rel="stylesheet" href="/css/post.css">




    
        <link rel="stylesheet" type="text/css" href="/css/reward.css">
    



    <script src="/libs/jquery/jquery-3.6.0.min.js"></script>

<meta name="generator" content="Hexo 6.3.0">
<style>.github-emoji { position: relative; display: inline-block; width: 1.2em; min-height: 1.2em; overflow: hidden; vertical-align: top; color: transparent; }  .github-emoji > span { position: relative; z-index: 10; }  .github-emoji img, .github-emoji .fancybox { margin: 0 !important; padding: 0 !important; border: none !important; outline: none !important; text-decoration: none !important; user-select: none !important; cursor: auto !important; }  .github-emoji img { height: 1.2em !important; width: 1.2em !important; position: absolute !important; left: 50% !important; top: 50% !important; transform: translate(-50%, -50%) !important; user-select: none !important; cursor: auto !important; } .github-emoji-fallback { color: inherit; } .github-emoji-fallback img { opacity: 0 !important; }</style>
<link rel="stylesheet" href="/css/prism-tomorrow.css" type="text/css">
<link rel="stylesheet" href="/css/prism-line-numbers.css" type="text/css"></head>


<body>
    <header class="navbar-fixed">
    <nav id="headNav" class="bg-color nav-transparent">
        <div id="navContainer" class="nav-wrapper container">
            <div class="brand-logo">
                <a href="/" class="waves-effect waves-light">
                    
                    <img src="/medias/logo.png" class="logo-img" alt="LOGO">
                    
                    <span class="logo-span">jinlid&#39;s blog</span>
                </a>
            </div>
            

<a href="#" data-target="mobile-nav" class="sidenav-trigger button-collapse"><i class="fas fa-bars"></i></a>
<ul class="right nav-menu">
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/" class="waves-effect waves-light">
      
      <i class="fas fa-home" style="zoom: 0.6;"></i>
      
      <span>首页</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/tags" class="waves-effect waves-light">
      
      <i class="fas fa-tags" style="zoom: 0.6;"></i>
      
      <span>标签</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/categories" class="waves-effect waves-light">
      
      <i class="fas fa-bookmark" style="zoom: 0.6;"></i>
      
      <span>分类</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/archives" class="waves-effect waves-light">
      
      <i class="fas fa-archive" style="zoom: 0.6;"></i>
      
      <span>归档</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/about" class="waves-effect waves-light">
      
      <i class="fas fa-user-circle" style="zoom: 0.6;"></i>
      
      <span>关于</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/contact" class="waves-effect waves-light">
      
      <i class="fas fa-comments" style="zoom: 0.6;"></i>
      
      <span>留言板</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/friends" class="waves-effect waves-light">
      
      <i class="fas fa-address-book" style="zoom: 0.6;"></i>
      
      <span>友情链接</span>
    </a>
    
  </li>
  
  <li>
    <a href="#searchModal" class="modal-trigger waves-effect waves-light">
      <i id="searchIcon" class="fas fa-search" title="搜索" style="zoom: 0.85;"></i>
    </a>
  </li>
  <li>
    <a href="javascript:;" class="waves-effect waves-light" onclick="switchNightMode()" title="深色/浅色模式" >
      <i id="sum-moon-icon" class="fas fa-sun" style="zoom: 0.85;"></i>
    </a>
  </li>
</ul>


<div id="mobile-nav" class="side-nav sidenav">

    <div class="mobile-head bg-color">
        
        <img src="/medias/logo.png" class="logo-img circle responsive-img">
        
        <div class="logo-name">jinlid&#39;s blog</div>
        <div class="logo-desc">
            
            Never really desperate, only the lost of the soul.
            
        </div>
    </div>

    <ul class="menu-list mobile-menu-list">
        
        <li class="m-nav-item">
	  
		<a href="/" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-home"></i>
			
			首页
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/tags" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-tags"></i>
			
			标签
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/categories" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-bookmark"></i>
			
			分类
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/archives" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-archive"></i>
			
			归档
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/about" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-user-circle"></i>
			
			关于
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/contact" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-comments"></i>
			
			留言板
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/friends" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-address-book"></i>
			
			友情链接
		</a>
          
        </li>
        
        
        <li><div class="divider"></div></li>
        <li>
            <a href="https://github.com/blinkfox/hexo-theme-matery" class="waves-effect waves-light" target="_blank">
                <i class="fab fa-github-square fa-fw"></i>Fork Me
            </a>
        </li>
        
    </ul>
</div>


        </div>

        
            <style>
    .nav-transparent .github-corner {
        display: none !important;
    }

    .github-corner {
        position: absolute;
        z-index: 10;
        top: 0;
        right: 0;
        border: 0;
        transform: scale(1.1);
    }

    .github-corner svg {
        color: #0f9d58;
        fill: #fff;
        height: 64px;
        width: 64px;
    }

    .github-corner:hover .octo-arm {
        animation: a 0.56s ease-in-out;
    }

    .github-corner .octo-arm {
        animation: none;
    }

    @keyframes a {
        0%,
        to {
            transform: rotate(0);
        }
        20%,
        60% {
            transform: rotate(-25deg);
        }
        40%,
        80% {
            transform: rotate(10deg);
        }
    }
</style>

<a href="https://github.com/blinkfox/hexo-theme-matery" class="github-corner tooltipped hide-on-med-and-down" target="_blank"
   data-tooltip="Fork Me" data-position="left" data-delay="50">
    <svg viewBox="0 0 250 250" aria-hidden="true">
        <path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path>
        <path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2"
              fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path>
        <path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z"
              fill="currentColor" class="octo-body"></path>
    </svg>
</a>
        
    </nav>

</header>

    



<div class="bg-cover pd-header post-cover" style="background-image: url('/medias/featureimages/12.jpg')">
    <div class="container" style="right: 0px;left: 0px;">
        <div class="row">
            <div class="col s12 m12 l12">
                <div class="brand">
                    <h1 class="description center-align post-title">9 预写日志—WAL</h1>
                </div>
            </div>
        </div>
    </div>
</div>




<main class="post-container content">

    
    <div class="row">
    <div id="main-content" class="col s12 m12 l9">
        <!-- 文章内容详情 -->
<div id="artDetail">
    <div class="card">
        <div class="card-content article-info">
            <div class="row tag-cate">
                <div class="col s7">
                    
                    <div class="article-tag">
                        
                            <a href="/tags/postgresql/">
                                <span class="chip bg-color">postgresql</span>
                            </a>
                        
                    </div>
                    
                </div>
                <div class="col s5 right-align">
                    
                    <div class="post-cate">
                        <i class="fas fa-bookmark fa-fw icon-category"></i>
                        
                            <a href="/categories/postgresql/" class="post-category">
                                postgresql
                            </a>
                        
                    </div>
                    
                </div>
            </div>

            <div class="post-info">
                
                <div class="post-date info-break-policy">
                    <i class="far fa-calendar-minus fa-fw"></i>发布日期:&nbsp;&nbsp;
                    2021-08-13
                </div>
                

                

                

                

                
            </div>
        </div>
        <hr class="clearfix">

        

        

        <div class="card-content article-card-content">
            <div id="articleContent">
                <p><strong>事务日志</strong>是数据库的重要组成部分，因为所有的数据库管理系统都要求即使发生系统故障也不丢失任何数据。它是数据库系统中所有更改操作的历史日志，以确保没有由于故障（例如电源故障）或其他导致服务器崩溃的服务器故障而丢失数据。由于日志包含有关已执行的每个事务的足够信息，因此数据库服务器应该能够通过在服务器崩溃的情况下，重新回放事务日志中的更改操作来恢复数据库集群。</p>
<span id="more"></span>

<p>[TOC]</p>
<p>在计算机科学领域，<strong>WAL</strong>是 <strong>Write Ahead Logging</strong> 的首字母缩写，它是一种将更改操作都写入事务日志的协议或规则，而在PostgreSQL中，WAL是 <strong>Write Ahead Log</strong> 的首字母缩写。</p>
<p>WAL机制在7.1版本中首次实现，以减轻服务器崩溃的影响。这也成为可能的执行点即时恢复（PITR）和流复制（SR），这两者将分别在<a href="https://jinlid.github.io/2021/10-ji-chu-bei-fen-he-shi-jian-dian-hui-fu/">第10</a>和<a href="https://jinlid.github.io/2021/11-liu-fu-zhi/">第11章</a>中介绍。</p>
<p>尽管了解WAL机制对于使用PostgreSQL的系统集成和管理至关重要，但由于该机制的复杂性，无法对其描述进行简要总结。所以对PostgreSQL中WAL的完整解释如下：第一部分已经提供了WAL的整体图，介绍了一些重要的概念和关键词。在随后的部分中，将描述以下主题：</p>
<ul>
<li><p>WAL（事务日志）的逻辑结构和物理结构</p>
</li>
<li><p>WAL数据内部布局</p>
</li>
<li><p>WAL数据的写入</p>
</li>
<li><p>WAL写进程</p>
</li>
<li><p>检查点处理</p>
</li>
<li><p>数据库恢复处理</p>
</li>
<li><p>管理WAL段文件</p>
</li>
<li><p>连续归档</p>
</li>
</ul>
<h2 id="9-1-概述"><a href="#9-1-概述" class="headerlink" title="9.1 概述"></a>9.1 概述</h2><p>我们先来看看WAL机制的概况。为了澄清WAL一直在处理的问题，第一小节显示了如果PostgreSQL没有实现WAL发生崩溃时会发生什么，第二小节介绍了一些关键概念，并展示了本章主要主题的概述、WAL数据的编写和数据库恢复处理。最后一小节完成了WAL的概述，添加了另一个关键概念。</p>
<p>在本节中，为了简化描述，使用了仅包含一页的表TABLE_A。</p>
<h3 id="9-1-1-没有-WAL-的插入操作"><a href="#9-1-1-没有-WAL-的插入操作" class="headerlink" title="9.1.1 没有 WAL 的插入操作"></a>9.1.1 没有 WAL 的插入操作</h3><p>如<a href="https://jinlid.github.io/2021/8.huan-chong-qu-guan-li-qi/">第 8 章</a>所述，为了提供对关系页面的高效访问，每个DBMS都实现了共享缓冲池。</p>
<p>假设我们在没有实现WAL特性的PostgreSQL上的TABLE_A中插入了一些数据元组；这种情况如图 9.1 所示。</p>
<p><img src="/medias/image/fig-9-01.png" alt="图 9.1 没有 WAL 的插入操作"></p>
<p>(1) 发出第一条INSERT语句，PostgreSQL将TABLE_A的页面从数据库集群加载到内存共享缓冲池中，并在页面中插入一个元组。该页面不会立即写入数据库集群。（修改后的页面通常称为<strong>脏页</strong>）</p>
<p>(2) 发出第二条INSERT语句，PostgreSQL在缓冲池上的页中插入一个新元组。此页尚未写入存储。</p>
<p>(3) 如果操作系统或PostgreSQL服务器因停电等任何原因出现故障，所有插入的数据都会丢失。</p>
<p>因此，没有WAL的数据库容易受到系统故障的影响。</p>
<blockquote>
<p>在引入 WAL 之前，PostgreSQL通过在每次更改内存中的页面时发出同步系统调用来同步写入磁盘，以确保持久性。因此，INSERT和UPDATE等修改命令的性能非常差。</p>
</blockquote>
<h3 id="9-1-2-插入操作和数据库恢复"><a href="#9-1-2-插入操作和数据库恢复" class="headerlink" title="9.1.2 插入操作和数据库恢复"></a>9.1.2 插入操作和数据库恢复</h3><p>为了在不影响性能的情况下处理上述系统故障，PostgreSQL支持WAL。</p>
<p>PostgreSQL将所有的修改作为历史数据写入持久存储，为失败做准备。在PostgreSQL中，历史数据被称为<strong>XLOG记录</strong>或<strong>WAL数据</strong>。</p>
<p>XLOG记录通过插入、删除或提交等更改操作写入内存中的<strong>WAL缓冲区</strong>。当事务提交/中止时，它们会立即写入存储上的<strong>WAL段文件</strong>（准确的说，XLOG记录的写入可能在其他情况下发生，具体将在<a href="https://jinlid.github.io/2021/9.yu-xie-ri-zhi-wal#_9.5">9.5 节</a>中描述）。XLOG 记录的<strong>LSN</strong>（日志序列号，LSN用作记录XLOG中的唯一ID）表示其记录在事务日志上的写入位置。</p>
<p>当我们考虑数据库系统如何恢复时，可能会有一个问题；PostgreSQL从什么时候开始恢复？答案是<strong>REDO点</strong>；也就是最近一次<strong>checkpoint</strong>启动时写入XLOG记录的位置（PostgreSQL中的checkpoint在<a href="https://jinlid.github.io/2021/9.yu-xie-ri-zhi-wal#_9.7">9.7节</a>有介绍）。事实上，数据库恢复处理与检查点处理密切相关，这两者是密不可分的。</p>
<blockquote>
<p>WAL和checkpoint进程在7.1版本中同时实现。</p>
</blockquote>
<p>主要关键字和概念的介绍刚刚结束，下面就是用WAL插入元组的说明，参见图9.2和以下说明。（另请参阅<a target="_blank" rel="noopener" href="http://www.slideshare.net/suzuki_hironobu/fig-902">此幻灯片</a>）</p>
<p><img src="/medias/image/fig-9-02.png" alt="图 9.2 使用 WAL 进行插入操作"></p>
<p>符号 <code>TABLE_A's LSN</code> 显示了 TABLE_A 的页头中 <code>pd_lsn</code> 的值，<code>page's LSN</code> 一样。</p>
<p>(1) checkpointer，一个后台进程，周期性地执行checkpoint。每当检查点启动时，它都会将一个名为检查点的XLOG记录写入当前WAL段，该记录包含最新REDO点的位置。</p>
<p>(2) 发出第一条INSERT语句，PostgreSQL将 TABLE_A 的页面加载到共享缓冲池中，在页面中插入一个元组，在位置 <code>LSN_1</code> 处创建并写入这条语句的XLOG记录到WAL缓冲区，并更新 TABLE_A 的 LSN从 <code>LSN_0</code> 到 <code>LSN_1</code>。</p>
<p>在这个例子中，这个XLOG记录的是<strong>一对header-data和完整元组</strong>。</p>
<p>(3) 当这个事务提交时，PostgreSQL会创建这个提交操作的XLOG记录并将其写入WAL缓冲区，然后，将WAL缓冲区上的所有XLOG记录写入 <code>LSN_1</code> 并刷新到WAL段文件。</p>
<p>(4) 发出第二条INSERT语句，PostgreSQL在页面中插入一个新的元组，创建这个元组的XLOG记录并将其写入 <code>LSN_2</code> 处的WAL缓冲区，并将 TABLE_A 的 LSN 从 <code>LSN_1</code> 更新为 <code>LSN_2</code>。</p>
<p>(5) 当这条语句的事务提交时，PostgreSQL以与步骤(3) 中相同的方式进行操作。</p>
<p>(6) 想象一下，什么时候可能发生系统故障。即使共享缓冲池上的所有数据都丢失了，页面的所有修改也已作为历史数据写入WAL段文件。</p>
<p>以下说明显示了如何将我们的数据库集群恢复到崩溃前的状态。不需要做任何特别的事情，因为PostgreSQL会通过重新启动自动进入恢复模式。参见图 9.3（和这张<a target="_blank" rel="noopener" href="http://www.slideshare.net/suzuki_hironobu/fig-903">幻灯片</a>）。PostgreSQL将从REDO点依次读取和重放相应 WAL段文件中的XLOG记录。</p>
<p><img src="/medias/image/fig-9-03.png" alt="图 9.3 使用 WAL 进行数据库恢复"></p>
<p>(1) PostgreSQL从相应的WAL段文件中读取第一个INSERT语句的XLOG记录，将 TABLE_A 的页面从数据库集群加载到共享缓冲池中。</p>
<p>(2) 在尝试重放XLOG记录之前，PostgreSQL会比较XLOG记录的LSN与对应页面的LSN，原因将在<a href="https://jinlid.github.io/2021/9.yu-xie-ri-zhi-wal#_9.8">9.8 节</a>中说明。重放XLOG记录的规则如下所示：</p>
<p>如果XLOG记录的LSN大于页面的LSN，则将XLOG记录的数据部分插入到页面中，并将页面的LSN更新为 XLOG记录的LSN。如果XLOG记录的LSN较小，则读取下一个WAL数据。</p>
<p>在此示例中，由于XLOG记录的LSN ( <code>LSN_1</code> ) 大于 TABLE_A 的LSN ( <code>LSN_0</code> )，因此重放 XLOG记录；然后，TABLE_A 页面更改到<code>LSN_1</code>。</p>
<p>(3) PostgreSQL以同样的方式重放剩余的XLOG记录。</p>
<p>PostgreSQL通过按照这种时间顺序的方式重放WAL段文件的XLOG记录来恢复自身，显然，PostgreSQL的XLOG记录的是<strong>REDO log</strong>。</p>
<blockquote>
<p>PostgreSQL不支持UNDO日志。</p>
<p>虽然写XLOG记录肯定要花费一定的成本，但与写整个修改过的页面相比，这不算什么。</p>
</blockquote>
<h3 id="9-1-3-整页写入"><a href="#9-1-3-整页写入" class="headerlink" title="9.1.3 整页写入"></a>9.1.3 整页写入</h3><p>如果操作系统发生故障，假设存储上 TABLE_A 的页面数据已损坏，而后台写入进程一直在写入脏页面，由于无法在损坏的页面上重放XLOG记录，我们需要一个额外的功能。</p>
<p>PostgreSQL支持称为<strong>整页写入</strong>的功能来处理此类故障。如果启用，PostgreSQL在每个检查点后每个页面的第一次更改期间，写入一对<strong>header-data和整个页面</strong>作为XLOG记录，默认启用。在PostgreSQL中，这样一个包含整个页面的XLOG记录被称为<strong>备份块</strong>。</p>
<p>启用了整页写入，让我们再次描述元组的插入。参见图 9.4 和以下说明。</p>
<p><img src="/medias/image/fig-9-04.png" alt="图 9.4 整页写"></p>
<p>(1) checkpointer启动一个checkpoint进程。</p>
<p>(2) 在第一条INSERT语句的插入中，虽然PostgreSQL的操作方式和上一小节几乎一样，但是这个XLOG记录是这个页面的备份块（即它包含了整个页面），因为这是在最新的检查点之后第一次写入此页面。</p>
<p>(3) 当这个事务提交时，PostgreSQL以与上一小节相同的方式运行。</p>
<p>(4) 在第二条INSERT语句的插入中，由于这条XLOG记录不是备份块，PostgreSQL的操作方式与上一小节相同。</p>
<p>(5) 当这条语句的事务提交时，PostgreSQL以与上一小节相同的方式运行。</p>
<p>(6) 为了证明整页写入的有效性，这时我们考虑在后台写入器一直将脏页面写入硬盘时，由于操作系统发生故障，存储上的 TABLE_A 页面已损坏的情况。</p>
<p>重启PostgreSQL服务器以修复损坏的集群，参见图 9.5 和以下说明。</p>
<p><img src="/medias/image/fig-9-05.png" alt="图 9.5 使用备份块进行数据库恢复"></p>
<p>(1) PostgreSQL读取第一个INSERT语句的XLOG记录，并将损坏的 TABLE_A 页面从数据库集群加载到共享缓冲池中。在这个例子中，XLOG记录是一个备份块，因为按照整页写的写规则，每页的第一个XLOG记录总是它的备份块。</p>
<p>(2) 当一个XLOG记录是它的备份块时，应用另一个重放规则：不管两个LSN的值如何，记录的数据部分（即页面本身）都将被覆盖到页面上，并且页面的LSN更新到XLOG记录的LSN。</p>
<p>在此示例中，PostgreSQL将记录的数据部分覆盖到损坏的页面，并将 TABLE_A 的LSN更新为 <code>LSN_1</code> 。通过这种方式，损坏的页面由其备份块恢复。</p>
<p>(3) 由于第二条XLOG记录是一个非备份块，PostgreSQL的操作方式与上一小节中的指令相同。</p>
<p>即使发生了一些数据写入失败，PostgreSQL也可以恢复（当然，如果发生文件系统或媒体故障，则这不适用）。</p>
<h2 id="9-2-事务日志和WAL段文件"><a href="#9-2-事务日志和WAL段文件" class="headerlink" title="9.2 事务日志和WAL段文件"></a>9.2 事务日志和WAL段文件</h2><p>从逻辑上讲，PostgreSQL将XLOG记录写入事务日志中，事务日志是一个8字节长（16 ExaByte）的虚拟文件。</p>
<p>由于事务日志的容量实际上是无限的，因此可以说8字节的地址空间足够大，我们不可能处理8字节长度的容量的文件。因此，PostgreSQL中的事务日志默认分为16 MB的文件，每个文件称为<strong>WAL段</strong>，参见图 9.6。</p>
<p><strong>WAL段文件大小</strong></p>
<blockquote>
<p>在版本11或更高版本中，当通过initdb命令创建PostgreSQL集群时，可以使用<a target="_blank" rel="noopener" href="https://www.postgresql.org/docs/11/static/app-initdb.html">–wal-segsize</a>选项配置 WAL 段文件的大小。</p>
</blockquote>
<p><img src="/medias/image/fig-9-06.png" alt="图 9.6 事务日志和 WAL 段文件"></p>
<p>WAL段文件名是16进制的 24 位数字，命名规则如下：</p>
<p>WAL segment file name=timelineId+(uint32)LSN−116M∗256+(uint32)(LSN−116M)%256</p>
<p><strong>时间线ID</strong></p>
<p>PostgreSQL的WAL包含<strong>时间线ID</strong>（4 字节无符号整数）的概念，用于<a href="https://jinlid.github.io/2021/10-ji-chu-bei-fen-he-shi-jian-dian-hui-fu/">第 10 章</a> 中描述的时间点恢复（PITR）。</p>
<p>第一个WAL段文件是 00000001 00000000 00000001。如果第一个已被写入XLOG记录，则将提供第二个 00000001 00000000 00000002。后继文件按升序依次使用，00000001 00000000 000000FF填满后，将提供下一个00000001 00000001 00000000。这样，每当最后2位结转时，中间的8位数字就加一，依此类推。</p>
<p><em>pg_xlogfile_name / pg_walfile_name</em></p>
<p>使用内置函数<em>pg_xlogfile_name</em>（版本 9.6 或更早版本）或<em>pg_walfile_name</em>（版本 10 或更高版本），我们可以找到包含指定LSN的WAL段文件名，一个例子如下所示：</p>
<pre class="line-numbers language-bash"><code class="language-bash">testdb<span class="token operator">=</span><span class="token comment" spellcheck="true"># SELECT pg_xlogfile_name('1/00002D3E');  # In version 10 or later, "SELECT pg_walfile_name('1/00002D3E');"</span>
     pg_xlogfile_name     
--------------------------
 000000010000000100000000
<span class="token punctuation">(</span>1 row<span class="token punctuation">)</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="9-3-WAL段内部布局"><a href="#9-3-WAL段内部布局" class="headerlink" title="9.3 WAL段内部布局"></a>9.3 WAL段内部布局</h2><p>默认情况下，WAL段是一个16MB的文件，它在内部被分成8192字节 (8KB) 的页面。第一个页面具有由结构 <em>XLogLongPageHeaderData</em>定义的标题数据，而所有其他页面的标题由结构 <em>XLogPageHeaderData</em> 定义的页面信息。在页头之后，XLOG记录从头开始按降序写入每一页。参见图9.7。</p>
<p><img src="/medias/image/fig-9-07.png" alt="图 9.7 WAL 段文件的内部布局"></p>
<p>结构体 XLogLongPageHeaderData 和XLogPageHeaderData在<a target="_blank" rel="noopener" href="https://github.com/postgres/postgres/blob/master/src/include/access/xlog_internal.h">src/include/access/xlog_internal.h</a>中定义。因为以下介绍中不需要这两种结构，所以省略了对这两种结构的解释。</p>
<h2 id="9-4-XLOG-Record的内部布局"><a href="#9-4-XLOG-Record的内部布局" class="headerlink" title="9.4 XLOG Record的内部布局"></a>9.4 XLOG Record的内部布局</h2><p>XLOG Record包括通用标题部分和每个相关联的数据部分。第一部分描述头结构，剩下的两个小节分别解释了9.4或更早版本和9.5版本中数据部分的结构（数据格式在9.5版本中发生了变化）。</p>
<h3 id="9-4-1-XLOG-Record的头部分"><a href="#9-4-1-XLOG-Record的头部分" class="headerlink" title="9.4.1 XLOG Record的头部分"></a>9.4.1 XLOG Record的头部分</h3><p>所有XLOG记录都有一个由结构体 <code>XLogRecord</code> 定义的通用头部分。在9.4及更早版本的结构体如下所示，在9.5版本中有所更改。</p>
<pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">typedef</span> <span class="token keyword">struct</span> XLogRecord
<span class="token punctuation">{</span>
   uint32          xl_tot_len<span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">/* total len of entire record */</span>
   TransactionId   xl_xid<span class="token punctuation">;</span>       <span class="token comment" spellcheck="true">/* xact id */</span>
   uint32          xl_len<span class="token punctuation">;</span>       <span class="token comment" spellcheck="true">/* total len of rmgr data */</span>
   uint8           xl_info<span class="token punctuation">;</span>      <span class="token comment" spellcheck="true">/* flag bits, see below */</span>
   RmgrId          xl_rmid<span class="token punctuation">;</span>      <span class="token comment" spellcheck="true">/* resource manager for this record */</span>
   <span class="token comment" spellcheck="true">/* 2 bytes of padding here, initialize to zero */</span>
   XLogRecPtr      xl_prev<span class="token punctuation">;</span>      <span class="token comment" spellcheck="true">/* ptr to previous record in log */</span>
   pg_crc32        xl_crc<span class="token punctuation">;</span>       <span class="token comment" spellcheck="true">/* CRC for this record */</span>
<span class="token punctuation">}</span> XLogRecord<span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>除了两个变量，大部分变量都是显而易见的，不需要描述。</p>
<p><strong>xl_rmid</strong>和<strong>xl_info</strong>是相关变量的资源管理器，这是与WAL相关的操作集合的写入及XLOG记录重放功能等。资源管理器的数量随着每个PostgreSQL版本的增加而增加，版本10包含以下内容：</p>
<table>
<thead>
<tr>
<th align="left">Operation</th>
<th align="left">Resource manager</th>
</tr>
</thead>
<tbody><tr>
<td align="left">Heap tuple operations</td>
<td align="left">RM_HEAP, RM_HEAP2</td>
</tr>
<tr>
<td align="left">Index operations</td>
<td align="left">RM_BTREE, RM_HASH, RM_GIN, RM_GIST, RM_SPGIST, RM_BRIN</td>
</tr>
<tr>
<td align="left">Sequence operations</td>
<td align="left">RM_SEQ</td>
</tr>
<tr>
<td align="left">Transaction operations</td>
<td align="left">RM_XACT, RM_MULTIXACT, RM_CLOG, RM_XLOG, RM_COMMIT_TS</td>
</tr>
<tr>
<td align="left">Tablespace operations</td>
<td align="left">RM_SMGR, RM_DBASE, RM_TBLSPC, RM_RELMAP</td>
</tr>
<tr>
<td align="left">replication and hot standby operations</td>
<td align="left">RM_STANDBY, RM_REPLORIGIN, RM_GENERIC_ID, RM_LOGICALMSG_ID</td>
</tr>
</tbody></table>
<p>以下是资源管理器在以下工作方式的一些代表性示例：</p>
<ul>
<li><p>如果发出INSERT语句，则其XLOG记录的头变量 <code>xl_rmid</code> 和 <code>xl_info</code> 分别设置为<code>RM_HEAP</code> 和<code>XLOG_HEAP_INSERT</code>。恢复数据库集群时，根据 <code>xl_info</code> 选择的 <code>RM_HEAP</code> 的函数 <em>heap_xlog_insert()</em> 重放这条XLOG记录。</p>
</li>
<li><p>UPDATE语句类似，但XLOG记录的头变量 <code>xl_info</code> 设置为 <code>XLOG_HEAP_UPDATE</code>，并且 <code>RM_HEAP</code> 的函数 <em>heap_xlog_update()</em> 在数据库恢复时重放其记录。</p>
</li>
<li><p>当事务提交时，其XLOG记录的头变量 <code>xl_rmid</code> 和 <code>xl_info</code> 分别设置为 <code>RM_XACT</code> 和<code>XLOG_XACT_COMMIT</code>。在恢复数据库集群时，函数 <em>xact_redo_commit()</em> 会重放这条记录。</p>
</li>
</ul>
<p>在 9.5 或更高版本中， XLogRecord结构体删除了一个变量 (xl_len) 以优化XLOG记录格式，从而将大小减少了几个字节。</p>
<p>XLogRecord结构体在9.4或更早版本<a target="_blank" rel="noopener" href="https://github.com/postgres/postgres/blob/REL9_4_STABLE/src/include/access/xlog.h">src/include/access/xlog.h</a>中定义，9.5或更高版本在<a target="_blank" rel="noopener" href="https://github.com/postgres/postgres/blob/master/src/include/access/xlogrecord.h">src/include/access/xlogrecord.h</a>中定义。</p>
<p><em>heap_xlog_insert</em> 和 <em>heap_xlog_update</em> 在<a target="_blank" rel="noopener" href="https://github.com/postgres/postgres/blob/master/src/backend/access/heap/heapam.c">src/backend/access/heap/heapam.c </a>中定义；而函数 <em>xact_redo_commit</em> 在<a target="_blank" rel="noopener" href="https://github.com/postgres/postgres/blob/master/src/backend/access/transam/xact.c">src/backend/access/transam/xact.c</a>中定义。</p>
<h3 id="9-4-2-XLOG-Record的数据部分（9-4-或更早版本）"><a href="#9-4-2-XLOG-Record的数据部分（9-4-或更早版本）" class="headerlink" title="9.4.2 XLOG Record的数据部分（9.4 或更早版本）"></a>9.4.2 XLOG Record的数据部分（9.4 或更早版本）</h3><p>XLOG Record的数据部分分为备份块（整页）和非备份块（按不同数据操作）。</p>
<p><img src="/medias/image/fig-9-08.png" alt="图 9.8 XLOG 记录示例（9.4 或更早版本）"></p>
<p>XLOG Record的内部布局在下面使用一些具体示例进行描述。</p>
<h4 id="9-4-2-1-备份块"><a href="#9-4-2-1-备份块" class="headerlink" title="9.4.2.1 备份块"></a>9.4.2.1 备份块</h4><p>备份块如图 9.8(a) 所示。它由两个数据结构和一个数据对象组成，如下所示：</p>
<ol>
<li><p>XLogRecord结构体（头部分）</p>
</li>
<li><p>BkpBlock结构体</p>
</li>
<li><p>除了FSM之外的整个页面</p>
</li>
</ol>
<p>该BkpBlock包含数据库集群中找出这个页面的变量（即包含此页面的关系的<code>relfilenode</code>和叉号，和这个页面的块号），开始位置，这个页面上的可用空间的长度。</p>
<h4 id="9-4-2-2-非备份块"><a href="#9-4-2-2-非备份块" class="headerlink" title="9.4.2.2 非备份块"></a>9.4.2.2 非备份块</h4><p>在非备份块中，数据部分的布局因每个操作而异。这里，以INSERT语句的XLOG记录为例进行说明。见图9.8(b)。在这种情况下，INSERT语句的XLOG记录由两个数据结构和一个数据对象组成，如下所示：</p>
<ol>
<li><p>XLogRecord结构体（头部分）</p>
</li>
<li><p>xl_heap_insert结构体</p>
</li>
<li><p>插入的元组–准确地说，从元组中删除了几个字节</p>
</li>
</ol>
<p>结构体 <code>xl_heap_insert</code> 包含用于标识数据库集群中插入的元组的变量（即包含该元组的表的<em>relfilenode</em>以及该元组的<em>tid</em>），以及该元组的<strong>可见性标志</strong>。</p>
<p>从插入的元组中删除几个字节的原因在<code>xl_heap_header</code>结构体的源代码注释中有描述：</p>
<blockquote>
<p>我们不会在WAL中存储插入或更新的元组的整个固定部分（HeapTupleHeaderData）；我们可以通过重构WAL记录中其他地方可用的字段来节省一些字节，或者可能只是不需要重构。</p>
</blockquote>
<p>Checkpoint记录的XLOG记录很简单，见图 9.8(c)。它由两种数据结构组成，如下所示：</p>
<ol>
<li><p>XLogRecord结构体（头部分）</p>
</li>
<li><p>包含检查点信息的检查点结构（请参阅<a href="https://jinlid.github.io/2021/9.yu-xie-ri-zhi-wal/#_9.7">第 9.7 节</a>中的更多详细信息）</p>
</li>
</ol>
<p><code>xl_heap_header</code>结构体在<a target="_blank" rel="noopener" href="https://github.com/postgres/postgres/blob/master/src/include/access/htup.h">src/include/access/htup.h</a>中定义，而CheckPoint结构体在<a target="_blank" rel="noopener" href="https://github.com/postgres/postgres/blob/master/src/include/catalog/pg_control.h">src/include/catalog/pg_control.h</a>中定义。</p>
<h3 id="9-4-3-XLOG-Record的数据部分（9-5-或更高版本）"><a href="#9-4-3-XLOG-Record的数据部分（9-5-或更高版本）" class="headerlink" title="9.4.3 XLOG Record的数据部分（9.5 或更高版本）"></a>9.4.3 XLOG Record的数据部分（9.5 或更高版本）</h3><p>在 9.4 或更早的版本中，XLOG 记录没有通用的格式，因此每个资源管理器都必须定义自己的格式。在这种情况下，维护源代码和实现与 WAL 相关的新功能变得越来越困难。为了解决这个问题，9.5 版本中引入了一种不依赖于资源管理器的通用结构化格式。</p>
<p>XLOG 记录的数据部分可以分为两部分：头部和数据。见图 9.9。</p>
<p><img src="/medias/image/fig-9-09.png" alt="图 9.9 常见的 XLOG 记录格式"></p>
<p>Header 部分包含零个或多个 <code>XLogRecordBlockHeaders</code> 和零个或一个<code>XLogRecordDataHeaderShort</code>（或 XLogRecordDataHeaderLong）；它必须至少包含其中之一。当其记录存储整页图像（即备份块）时， <code>XLogRecordBlockHeader</code> 包括<code>XLogRecordBlockImageHeader</code>，如果其块被压缩，则还包括 <code>XLogRecordBlockCompressHeader</code>。</p>
<p>数据部分由零个或多个块数据和零个或一个主数据组成，分别对应于 <code>XLogRecordBlockHeader(s)</code> 和 <code>XLogRecordDataHeader</code>。</p>
<p><strong>WAL 压缩</strong></p>
<p>在 9.5 或更高版本中，可以通过设置参数（ <code>wal_compression=enable</code> ）使用 LZ 压缩方法压缩 XLOG 记录中的整页图像。在这种情况下，将添加结构 <code>XLogRecordBlockCompressHeader</code>。</p>
<p>此功能有两个优点和一个缺点。优点是减少写入记录的 I/O 成本并抑制 WAL 段文件的消耗。缺点是需要消耗大量 CPU 资源进行压缩。</p>
<p><img src="/medias/image/fig-9-10.png" alt="图 9.10 XLOG 记录示例（9.5 版或更高版本）"></p>
<p>下面显示了一些具体示例，如上一小节所示。</p>
<h4 id="9-4-3-1-备份块"><a href="#9-4-3-1-备份块" class="headerlink" title="9.4.3.1 备份块"></a>9.4.3.1 备份块</h4><p>INSERT 语句创建的备份块如图 9.10(a)所示。它由四种数据结构和一个数据对象组成，如下所示：</p>
<ol>
<li><p>XLogRecord结构体（头部分）</p>
</li>
<li><p>XLogRecordBlockHeader结构体包括一个 XLogRecordBlockImageHeader</p>
</li>
<li><p>XLogRecordDataHeaderShort结构体</p>
</li>
<li><p>一个备份块（块数据）</p>
</li>
<li><p>xl_heap_insert结构体（主数据）</p>
</li>
</ol>
<p>XLogRecordBlockHeader 包含用于标识数据库集群中的块的变量（relfilenode<em>、</em>分叉号<em>和</em>块号）；XLogRecordImageHeader 包含这个块的长度和偏移量（这两个头结构一起可以存储9.4版本之前使用的BkpBlock的相同数据）。</p>
<p>XLogRecordDataHeaderShort 存储 xl_heap_insert结构体的长度，它是记录的主要数据。</p>
<p>包含整页图像的 XLOG 记录的主要数据，除了在某些特殊情况下（例如在逻辑解码和推测插入中）外不使用。重放这条记录时忽略它，这是冗余数据，将来可能会改进。</p>
<p>此外，备份块记录的主要数据取决于创建它们的语句。例如，UPDATE 语句附加 <code>xl_heap_lock</code>或 <code>xl_heap_updated</code>。</p>
<h4 id="9-4-3-2-非备份块"><a href="#9-4-3-2-非备份块" class="headerlink" title="9.4.3.2 非备份块"></a>9.4.3.2 非备份块</h4><p>接下来，将描述由 INSERT 语句创建的非备份块记录（另请参见图 9.10（b））。它由四种数据结构和一个数据对象组成，如下所示：</p>
<ol>
<li><p>XLogRecord结构体（头部分）</p>
</li>
<li><p>XLogRecordBlockHeader结构体</p>
</li>
<li><p>XLogRecordDataHeaderShort结构体</p>
</li>
<li><p>插入的元组（准确地说，是一个xl_heap_header结构体和一个插入的数据整体）</p>
</li>
<li><p>xl_heap_insert结构体（主数据）</p>
</li>
</ol>
<p>XLogRecordBlockHeader 包含三个值（relfilenode<em>、</em>fork number和block number）来指定插入元组的块，以及插入元组的数据部分的长度。XLogRecordDataHeaderShort 包含新的xl_heap_insert结构体的长度，是这条记录的主要数据。</p>
<p>新的xl_heap_insert只包含两个值：<strong>块内此元组的偏移量</strong>和<strong>可见性标志</strong>；它变得非常简单，因为 XLogRecordBlockHeader 存储了旧数据中包含的大部分数据。</p>
<p>作为最后一个例子，检查点记录如图 9.10(c) 所示。它由三个数据结构组成，如下所示：</p>
<ol>
<li><p>XLogRecord结构体（头部分）</p>
</li>
<li><p>XLogRecordDataHeaderShort结构体包含主数据长度</p>
</li>
<li><p>CheckPoint结构体（主数据）</p>
</li>
</ol>
<p>xl_heap_header结构体定义在<a target="_blank" rel="noopener" href="https://github.com/postgres/postgres/blob/master/src/include/access/htup.h">src/include/access/htup.h</a>中，CheckPoint结构体定义在<a target="_blank" rel="noopener" href="https://github.com/postgres/postgres/blob/master/src/include/catalog/pg_control.h">src/include/catalog/pg_control.h</a>中。</p>
<p>虽然新的格式对我们来说有点复杂，但它是为资源管理器的解析器设计的，而且许多类型的 XLOG 记录的大小通常比以前的要小。主要结构尺寸见图9.8 和 9.10，因此您可以计算这些记录的大小并相互比较（新检查点的大小比前一个大，但包含更多变量）。</p>
<h2 id="9-5-XLOG-记录的编写"><a href="#9-5-XLOG-记录的编写" class="headerlink" title="9.5 XLOG 记录的编写"></a>9.5 XLOG 记录的编写</h2><p>完成了热身练习，现在我们可以开始理解XLOG记录的编写了。因此，我将在本节中尽可能准确地解释它。</p>
<p>首先，发出以下语句来探索PostgreSQL内部：</p>
<pre class="line-numbers language-bash"><code class="language-bash">testdb<span class="token operator">=</span><span class="token comment" spellcheck="true"># INSERT INTO tbl VALUES ('A');</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>通过发出上述语句，调用内部函数 <em>exec_simple_query()<em>；</em>exec_simple_query()</em> 的伪代码如下所示：</p>
<pre class="line-numbers language-c"><code class="language-c"><span class="token function">exec_simple_query</span><span class="token punctuation">(</span><span class="token punctuation">)</span> @postgres<span class="token punctuation">.</span><span class="token function">c</span>

<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token function">ExtendCLOG</span><span class="token punctuation">(</span><span class="token punctuation">)</span> @clog<span class="token punctuation">.</span>c                  <span class="token comment" spellcheck="true">/* Write the state of this transaction
                                           * "IN_PROGRESS" to the CLOG.
                                           */</span>
<span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span> <span class="token function">heap_insert</span><span class="token punctuation">(</span><span class="token punctuation">)</span>@heapam<span class="token punctuation">.</span>c                <span class="token comment" spellcheck="true">/* Insert a tuple, creates a XLOG record,
                                           * and invoke the function XLogInsert.
                                           */</span>
<span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span> <span class="token function">XLogInsert</span><span class="token punctuation">(</span><span class="token punctuation">)</span> @xlog<span class="token punctuation">.</span><span class="token function">c</span> <span class="token punctuation">(</span><span class="token number">9.5</span> or later<span class="token punctuation">,</span> xloginsert<span class="token punctuation">.</span>c<span class="token punctuation">)</span>
                                          <span class="token comment" spellcheck="true">/* Write the XLOG record of the inserted tuple
                                           *  to the WAL buffer, and update page's pd_lsn.
                                           */</span>
<span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span> <span class="token function">finish_xact_command</span><span class="token punctuation">(</span><span class="token punctuation">)</span> @postgres<span class="token punctuation">.</span>c     <span class="token comment" spellcheck="true">/* Invoke commit action.*/</span>   
      <span class="token function">XLogInsert</span><span class="token punctuation">(</span><span class="token punctuation">)</span> @xlog<span class="token punctuation">.</span><span class="token function">c</span>  <span class="token punctuation">(</span><span class="token number">9.5</span> or later<span class="token punctuation">,</span> xloginsert<span class="token punctuation">.</span>c<span class="token punctuation">)</span>
                                          <span class="token comment" spellcheck="true">/* Write a XLOG record of this commit action 
                                           * to the WAL buffer.
                                           */</span>
<span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span> <span class="token function">XLogWrite</span><span class="token punctuation">(</span><span class="token punctuation">)</span> @xlog<span class="token punctuation">.</span>c                   <span class="token comment" spellcheck="true">/* Write and flush all XLOG records on 
                                           * the WAL buffer to WAL segment.
                                           */</span>
<span class="token punctuation">(</span><span class="token number">6</span><span class="token punctuation">)</span> <span class="token function">TransactionIdCommitTree</span><span class="token punctuation">(</span><span class="token punctuation">)</span> @transam<span class="token punctuation">.</span>c  <span class="token comment" spellcheck="true">/* Change the state of this transaction 
                                           * from "IN_PROGRESS" to "COMMITTED" on the CLOG.
                                           */</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>在下面的段落中，将解释每一行伪代码以理解XLOG记录的写入，另请参见图9.11和9.12。</p>
<p>(1) <em>ExtendCLOG()</em> 函数将这个事务<code>IN_PROGRESS</code>的状态写入CLOG（内存中）。</p>
<p>(2) <em>heap_insert()</em> 函数在共享缓冲池上的目标页中插入一个堆元组，创建该页的XLOG记录，并调用 <em>XLogInsert()</em> 函数。</p>
<p>(3) XLogInsert() 函数在 <code>LSN_1</code>写出由 <em>heap_insert()</em> 创建的XLOG记录到WAL缓冲区，然后更新页面的pd_lsn从<code>LSN_0</code>更改为<code>LSN_1</code>。</p>
<p>(4) 调用 <em>finish_xact_command()</em> 函数提交此事务，创建该提交动作的XLOG记录，然后在<code>LSN_2</code> 将 <em>XLogInsert()</em> 函数的记录写入到在WAL缓冲区。</p>
<p><img src="/medias/image/fig-9-11.png" alt="图 9.11 XLOG 记录的写入序列"></p>
<p>这些 XLOG记录的格式为9.4版。</p>
<p>(5) <em>XLogWrite()</em> 函数将WAL缓冲区上的所有XLOG记录写入并刷新到WAL段文件中。</p>
<p>如果参数 <code>wal_sync_method</code>设置为<code>open_sync</code> 或 <code>open_datasync</code>，则记录被同步写入，因为该函数使用 <em>open()</em> 系统调用指定标志<code>O_SYNC</code>或<code>O_DSYNC</code>写入所有记录。如果参数设置为<code>fsync</code>、<code>fsync_writethrough</code>或<code>fdatasync</code>，则相应的系统调用 – *fsync()<em>、</em>fcntl()<em>和 <code>F_FULLFSYNC</code> 选项或</em>fdatasync()*——将被处理。在任何情况下，都确保所有XLOG记录都写入存储。</p>
<p>(6) *TransactionIdCommitTree()*函数将CLOG上的此事务的状态从<code>N_PROGRESS</code>更改为<code>COMMITTED</code>。</p>
<p><img src="/medias/image/fig-9-12.png" alt="图 9.12 XLOG 记录的写入顺序（接图 9.11）"></p>
<p>在上面的例子中，commit动作导致了XLOG记录写入WAL段，但是当发生以下任何一种情况时，也会导致这种写入：</p>
<ol>
<li><p>一个正在运行的事务已提交或已中止。</p>
</li>
<li><p>WAL缓冲区已经填满了许多已写入的元组（WAL缓冲区大小设置为参数<a target="_blank" rel="noopener" href="https://www.postgresql.org/docs/current/static/runtime-config-wal.html#GUC-WAL-BUFFERS">wal_buffers</a>）。</p>
</li>
<li><p>WAL writer进程定期写入。</p>
</li>
</ol>
<p>如果发生上述之一，则WAL缓冲区上的所有WAL记录都将写入WAL段文件，无论它们的事务是否已提交。</p>
<p>DML（数据操作语言）操作写入XLOG记录是理所当然的，但非DML操作也是如此。如上所述，提交操作写入包含已提交事务id的XLOG记录。另一个示例可能是检查点操作，用于写入包含此检查点的基本信息的XLOG记录。此外，SELECT语句在特殊情况下会创建XLOG记录，尽管通常不会创建。例如，如果HOT(Heap Only Tuple)在SELECT语句处理过程中删除了不必要的元组并对页面中的必要元组进行碎片整理，则将修改页面的XLOG记录写入WAL缓冲区。</p>
<h2 id="9-6-WAL写入进程"><a href="#9-6-WAL写入进程" class="headerlink" title="9.6 WAL写入进程"></a>9.6 WAL写入进程</h2><p>WAL writer是一个后台进程，它会定期检查WAL缓冲区并将所有未写入的XLOG记录写入WAL段。这个过程的目的是为了避免XLOG记录的突发写入。如果没有开启这个进程，当一次提交大量数据时，XLOG记录的写入可能会遇到瓶颈。</p>
<p>WAL writer默认工作，不能被禁用。检查间隔设置为配置参数 <code>wal_writer_delay</code>，默认值为200毫秒。</p>
<h2 id="9-7-PostgreSQL中的检查点处理"><a href="#9-7-PostgreSQL中的检查点处理" class="headerlink" title="9.7 PostgreSQL中的检查点处理"></a>9.7 PostgreSQL中的检查点处理</h2><p>在PostgreSQL中，checkpointer（后台）进程执行checkpoint；当以下情况之一发生时，其进程开始：</p>
<ol>
<li><p>参数<code>checkpoint_timeout</code> 设置的间隔时间自上一个检查点已经过去（默认间隔为5 分钟）。</p>
</li>
<li><p>在9.4或更早版本中，参数 <code>checkpoint_segments</code> 设置的WAL段文件的数量（默认数量为 3）自上一个检查点以来已被消耗。</p>
</li>
<li><p>在9.5或更高版本中，pg_xlog中的WAL段文件的总大小已超过参数 <code>max_wal_size</code> 的值（默认值为 1GB）。</p>
</li>
<li><p>PostgreSQL服务器在smart或fast模式下停止。</p>
</li>
<li><p>当超级用户手动发出CHECKPOINT命令时，也会做。</p>
</li>
</ol>
<blockquote>
<p>在9.1或更早版本中（<a href="https://jinlid.github.io/2021/8.huan-chong-qu-guan-li-qi/#_8.6">第 8.6 节</a>中所述），后台写入进程同时执行checkpinting and dirty-page writing。</p>
</blockquote>
<p>在以下小节中，将描述检查点的概要和保存当前检查点元数据的pg_control文件。</p>
<h3 id="9-7-1-检查点处理概要"><a href="#9-7-1-检查点处理概要" class="headerlink" title="9.7.1 检查点处理概要"></a>9.7.1 检查点处理概要</h3><p>Checkpoint进程用在两个方面：数据库恢复的准备，以及共享缓冲池上脏页的清理。本节重点介绍其内部处理。参见图9.13和以下说明。</p>
<p><img src="/medias/image/fig-9-13.png" alt="图 9.13 PostgreSQL 检查点的内部处理"></p>
<p>(1) 一个checkpoint进程开始后，REDO点被存入内存；REDO点是最近一次checkpoint启动时写入XLOG记录的位置，是数据库恢复的起点。</p>
<p>(2) checkpoint记录写入WAL缓冲区。记录的数据部分由结构<a href="void(0)">CheckPoint</a>定义，它包含几个变量，例如在步骤 (1) 中存储的REDO点。此外，写入检查点记录的位置字面上称为<strong>检查点</strong>。</p>
<p>(3) 共享内存中的所有数据（例如<a href="https://jinlid.github.io/2021/5.bing-fa-kong-zhi/5.4.3">clog</a>的内容等）都被刷新到存储中。</p>
<p>(4) 共享缓冲池上的所有脏页被逐渐写入并刷新到存储中。</p>
<p>(5) <strong>pg_control</strong>文件更新。该文件包含检查点的基本信息，例如检查点记录写入的位置。</p>
<p>从数据库恢复的角度总结上面的描述，检查点创建包含REDO点的检查点记录，并将检查点位置等存储到pg_control文件中。因此，PostgreSQL能够通过从pg_control文件提供的REDO点重放WAL数据来恢复自身。</p>
<h3 id="9-7-2-pg-control-文件"><a href="#9-7-2-pg-control-文件" class="headerlink" title="9.7.2 pg_control 文件"></a>9.7.2 pg_control 文件</h3><p>由于pg_control文件包含检查点的基本信息，因此它对于数据库恢复当然是必不可少的。如果损坏或无法读取，将无法获得起点，从而无法启动恢复过程。</p>
<p>pg_control文件存储了40多个条目，下一节中需要的3个项目如下所示：</p>
<ul>
<li><strong>状态</strong>： 最近一次检查点开始时数据库服务器的状态。共有七种状态：<strong>启动</strong>是系统正在启动的状态；<strong>shut down</strong>是系统被shutdown命令正常关闭的状态；<strong>生产中</strong>是系统正在运行的状态，等等。</li>
<li><strong>最新检查点位置</strong>：最新检查点记录的LSN位置。</li>
<li><strong>先前检查点位置</strong>：先前检查点记录的LSN位置。</li>
</ul>
<p>详细信息如下：</p>
<p>一个pg_control文件存放在data-directory下的global子目录中；可以使用<strong>pg_controldata</strong>实用程序查看其内容。</p>
<pre class="line-numbers language-bash"><code class="language-bash">postgres<span class="token operator">></span> pg_controldata  /usr/local/pgsql/data
pg_control version number:            937
Catalog version number:               201405111
Database system identifier:           6035535450242021944
Database cluster state:               <span class="token keyword">in</span> production
pg_control last modified:             Mon Nov 22 15:16:38 2021
Latest checkpoint location:           0/C000F48
Prior checkpoint location:            0/C000E70

<span class="token punctuation">..</span>. snip <span class="token punctuation">..</span>.
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<blockquote>
<p>PostgreSQL 11 中的删除先前检查点，PostgreSQL11或更高版本将只存储包含最新检查点或更新的WAL段；将不会存储包含先前检查点的旧段文件，以减少用于在 pg_xlog(pg_wal) 子目录下保存WAL段文件的磁盘空间。具体信息查看<a target="_blank" rel="noopener" href="http://www.postgresql-archive.org/Remove-secondary-checkpoint-tt5989050.html">此文 </a>。</p>
</blockquote>
<h2 id="9-8-PostgreSQL中的数据库恢复"><a href="#9-8-PostgreSQL中的数据库恢复" class="headerlink" title="9.8 PostgreSQL中的数据库恢复"></a>9.8 PostgreSQL中的数据库恢复</h2><p>PostgreSQL实现了基于重做日志的恢复功能。如果数据库服务器崩溃，PostgreSQL会通过从REDO点顺序重放 WAL段文件中的XLOG记录来恢复数据库集群。</p>
<p>到本节为止，我们已经多次讨论过数据库恢复，我将描述有关恢复的两件事，还没有解释。</p>
<p>首先是PostgreSQL如何开始恢复过程。当PostgreSQL启动时，它首先读取pg_control文件。以下是从该点开始恢复处理的详细信息。参见图 9.14和以下说明。</p>
<p><img src="/medias/image/fig-9-14.png" alt="图 9.14 恢复过程的详细信息"></p>
<p>(1) PostgreSQL在启动时读取pg_control文件的所有项。如果<strong>状态</strong>项在<strong>in production</strong>，PostgreSQL将进入恢复模式，因为这意味着数据库没有正常停止；如果为 <strong>shut down</strong>，它将进入正常启动模式。</p>
<p>(2) PostgreSQL从相应的WAL段文件中读取最新的checkpoint记录，该记录的位置写在pg_control文件中，并从该记录中获取REDO点。如果最新的检查点记录无效，PostgreSQL会读取它之前的记录。如果两个记录都不可读，它会放弃自行恢复。</p>
<p>(3) 数据库从REDO点开始依次读取和重放XLOG记录，直到它们到达最新WAL段的最后一点。当一个XLOG记录被重放时，如果它是一个备份块，它会在相应表的页面上被覆盖，而不管它的LSN是什么。否则，仅当该记录的LSN大于相应页面的 <code>pd_lsn</code> 时，才会重放（非备份块的）XLOG记录。</p>
<p>第二点是关于LSN的比较：为什么要比较非备份块的LSN和对应page的<code>pd_lsn</code>。与前面的示例不同，再次使用特定示例进行解释，需要强调在两个LSN之间进行比较。见图9.15 和 9.16（为了简化描述，省略了WAL缓冲区）。</p>
<p><img src="/medias/image/fig-9-15.png" alt="图 9.15 后台编写器工作期间的插入操作"></p>
<p>(1) PostgreSQL在 TABLE_A 中插入一个元组，并将 <code>LSN_1</code> 写入XLOG记录。</p>
<p>(2) 后台写入进程将 TABLE_A 的页面写入存储。此时，该页面的 <code>pd_lsn</code> 改为 <code>LSN_1</code>。</p>
<p>(3) PostgreSQL在 TABLE_A 中插入一个新元组，并在 <code>LSN_2</code> 处写入一条XLOG记录。修改后的页面还没有写入存储。</p>
<p>与概述中的示例不同，在这种情况下，TABLE_A 的页面已被写入存储。</p>
<p>使用 <code>immediate-mode</code> 关闭，然后启动。</p>
<p><img src="/medias/image/fig-9-16.png" alt="图 9.16 数据库恢复"></p>
<p>(1) PostgreSQL加载第一个XLOG记录和 TABLE_A 的页面，但不重放它，因为该记录的LSN不大于 TABLE_A 的LSN（两个值都是<code>LSN_1</code>）。其实一看就明白了，不需要重播。</p>
<p>(2) 接下来，PostgreSQL重放第二条XLOG记录，因为该记录的LSN ( <code>LSN_2</code> ) 大于当前 TABLE_A 的LSN ( <code>LSN_1</code> )。</p>
<p>从这个例子可以看出，如果非备份块的重放顺序不正确或非备份块重放多次，数据库集群将不再一致。总之，非备份块的重放操作不是幂等的。因此，为了保持正确的重放顺序，当且仅当其LSN大于相应页面的 <code>pd_lsn</code> 时，非备份块记录才应重放。</p>
<p>另一方面，由于备份块的重做操作是幂等的，无论其LSN是多少，备份块都可以重放任意次数。</p>
<h2 id="9-9-WAL段文件管理"><a href="#9-9-WAL段文件管理" class="headerlink" title="9.9 WAL段文件管理"></a>9.9 WAL段文件管理</h2><p>PostgreSQL将XLOG记录写入存储在pg_xlog子目录（在版本10或更高版本中为pg_wal子目录）中的WAL段文件之一，如果旧的已填满，则切换到新的。WAL文件的数量取决于几个配置参数以及服务器活动。此外，他们的管理策略在9.5版本中得到了改进。</p>
<p>在以下小节中，将描述WAL段文件的切换和管理。</p>
<h3 id="9-9-1-WAL段开关"><a href="#9-9-1-WAL段开关" class="headerlink" title="9.9.1 WAL段开关"></a>9.9.1 WAL段开关</h3><p>WAL段切换发生在以下情况之一时：</p>
<ol>
<li><p>WAL段已填满。</p>
</li>
<li><p>函数<em>pg_switch_xlog</em>被执行。</p>
</li>
<li><p><code>archive_mode</code>已启用，并且已超过设置为<code>archive_timeout</code>的时间。</p>
</li>
</ol>
<p>切换后的文件通常会被回收（重命名和重用）以备将来使用，但如果没有必要，它可能会在以后删除。</p>
<h3 id="9-9-2-9-5或更高版本中的WAL段管理"><a href="#9-9-2-9-5或更高版本中的WAL段管理" class="headerlink" title="9.9.2 9.5或更高版本中的WAL段管理"></a>9.9.2 9.5或更高版本中的WAL段管理</h3><p>每当检查点开始时，PostgreSQL都会估计并准备下一个检查点周期所需的WAL段文件的数量。此类估计是根据先前检查点周期中消耗的文件数进行的。它们是从包含先前REDO点的段开始计算的，其值介于 <code>min_wal_size</code>（默认为 80 MB，即5个文件）和 <code>max_wal_size</code>（1 GB，即64个文件）之间。如果检查点启动，必要的文件将被保留或回收，而不必要的文件将被删除。</p>
<p>具体示例如图9.17所示。假设checkpoint开始前有6个文件，WAL_3包含了之前的REDO点（10及之前版本；11及之后版本，REDO点），PostgreSQL估计需要5个文件。在这种情况下，WAL_1将重命名为WAL_7以进行回收，而WAL_2将被删除。</p>
<p>可以删除比包含先前重做点的文件更旧的文件，因为从<a href="https://jinlid.github.io/2021/9.yu-xie-ri-zhi-wal/#_9.8">第 9.8 节</a>中描述的恢复机制中可以清楚地看出，它们永远不会被使用。</p>
<p><img src="/medias/image/fig-9-17.png" alt="图 9.17 在检查点回收和删除 WAL 段文件"></p>
<p>如果由于WAL活动激增而需要更多文件，则将创建新文件，而WAL文件的总大小小于 <code>max_wal_size</code>。例如，在图9.18中，如果WAL_7已被填满，则新创建WAL_8。</p>
<p><img src="/medias/image/fig-9-18.png" alt="图 9.18 创建 WAL 段文件"></p>
<p>WAL文件的数量根据服务器活动自适应地变化。如果WAL数据写入量不断增加，WAL段文件的估计数量以及WAL文件的总大小也会逐渐增加。在相反的情况下（即 WAL 数据写入量减少），这些减少。</p>
<p>如果WAL文件的总大小超过<code>max_wal_size</code>，将启动检查点。图9.19说明了这种情况。通过检查点，将创建一个新的重做点，最后一个重做点将是前一个；然后不必要的旧文件将被回收。这样，PostgreSQL将始终只保存数据库恢复所需的WAL段文件。</p>
<p><img src="/medias/image/fig-9-19.png" alt="图 9.19 检查点和回收 WAL 段文件"></p>
<p>配置参数 <code>wal_keep_segments</code>和<strong>复制槽</strong>功能也会影响WAL段文件的数量。</p>
<h3 id="9-9-3-9-4或更早版本中的WAL段管理"><a href="#9-9-3-9-4或更早版本中的WAL段管理" class="headerlink" title="9.9.3 9.4或更早版本中的WAL段管理"></a>9.9.3 9.4或更早版本中的WAL段管理</h3><p>WAL段文件的数量主要由以下三个参数控制：<code>checkpoint_segments</code>、<code>checkpoint_completion_target</code> 和 <code>wal_keep_segments</code>。它的数量通常超过((2+checkpoint_completion_target)×checkpoint_segments+1)或者 (checkpoint_segments+wal_keep_segments+1)(checkpoint_segments+wal_keep_segments+1) 文件。这个数字可能会暂时达到(3×checkpoint_segments+1)，(3×checkpoint_segments+1) 文件取决于服务器活动。 复制插槽也影响他们的数目。</p>
<p>如<a href="https://jinlid.github.io/2021/9.yu-xie-ri-zhi-wal/#_9.7">第 9.7 节</a>所述，当<code>checkpoint_segments</code>文件的数量已被消耗时，就会发生检查点过程。因此可以保证WAL文件中总是包含两个或更多的REDO点，因为文件的数量总是大于2个checkpoint_segments。 如果超时发生也是如此。因此，PostgreSQL将始终拥有恢复所需的足够的WAL段文件（有时超过必要的）。</p>
<p>在 9.4 或更早版本中，参数 <code>checkpoint_segments</code> 令人头疼。如果设置的小，checkpoint会频繁出现，导致性能下降，而设置的大，WAL文件总是需要巨大的磁盘空间，其中一些并不总是必要的。</p>
<p>在 9.5 版本中，WAL文件的管理策略有所改进，并且<code>checkpoint_segments</code>已过时。因此，上述权衡问题也得到了解决。</p>
<h2 id="9-10-连续归档和归档日志"><a href="#9-10-连续归档和归档日志" class="headerlink" title="9.10 连续归档和归档日志"></a>9.10 连续归档和归档日志</h2><p>连续归档是在WAL段切换时将WAL段文件复制到归档区的功能，由<strong>归档进程</strong>执行。复制的文件称为存档日志。此功能通常用于<a href="https://jinlid.github.io/2021/10-ji-chu-bei-fen-he-shi-jian-dian-hui-fu/">第 10 章</a>所述的物理热备份和PITR（Point-in-Time Recovery）。</p>
<p>归档区的路径设置为配置参数 <code>archive_command</code>。例如，使用以下参数，每次每个段切换时，WAL段文件都会复制到目录 <code>/home/postgres/archives/</code>：</p>
<pre class="line-numbers language-properties"><code class="language-properties"><span class="token attr-name">archive_command</span> <span class="token punctuation">=</span> <span class="token attr-value">'cp %p /home/postgres/archives/%f'</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>其中，占位符<code>%p</code>是复制的WAL段，而<code>%f</code>是存档日志。</p>
<p><img src="/medias/image/fig-9-20.png" alt="图 9.20 持续归档"></p>
<hr>
<p>当 WAL 段文件WAL_7被切换时，该文件被复制到归档区作为Archive log 7。</p>
<p>参数<code>archive_command</code>可以设置任何Unix命令和工具，因此您可以通过设置scp命令或任何文件备份工具代替普通的copy命令将归档日志传输到其他主机。</p>
<p>PostgreSQL不会清理创建的归档日志，因此您在使用此功能时应该正确管理日志。如果您什么都不做，归档日志的数量将继续增加。</p>
<p><a target="_blank" rel="noopener" href="http://www.postgresql.org/docs/current/static/pgarchivecleanup.html">pg_archivecleanup</a> 工具是针对归档日志管理的有效工具之一。</p>
<p>此外，unix 命令<code>find</code>可用于删除存档日志，以下命令删除三天前创建的归档日志。</p>
<pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">find</span> /home/postgres/archives -mtime +3d -exec <span class="token function">rm</span>  -f <span class="token punctuation">{</span><span class="token punctuation">}</span> \<span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

                
            </div>
            <hr/>

            

    <div class="reprint" id="reprint-statement">
        
            <div class="reprint__author">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-user">
                        文章作者:
                    </i>
                </span>
                <span class="reprint-info">
                    <a href="/about" rel="external nofollow noreferrer">JINLID</a>
                </span>
            </div>
            <div class="reprint__type">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-link">
                        文章链接:
                    </i>
                </span>
                <span class="reprint-info">
                    <a href="https://jinlid.github.io/2021/9.yu-xie-ri-zhi-wal/">https://jinlid.github.io/2021/9.yu-xie-ri-zhi-wal/</a>
                </span>
            </div>
            <div class="reprint__notice">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-copyright">
                        版权声明:
                    </i>
                </span>
                <span class="reprint-info">
                    本博客所有文章除特別声明外，均采用
                    <a href="https://creativecommons.org/licenses/by/4.0/deed.zh" rel="external nofollow noreferrer" target="_blank">CC BY 4.0</a>
                    许可协议。转载请注明来源
                    <a href="/about" target="_blank">JINLID</a>
                    !
                </span>
            </div>
        
    </div>

    <script async defer>
      document.addEventListener("copy", function (e) {
        let toastHTML = '<span>复制成功，请遵循本文的转载规则</span><button class="btn-flat toast-action" onclick="navToReprintStatement()" style="font-size: smaller">查看</a>';
        M.toast({html: toastHTML})
      });

      function navToReprintStatement() {
        $("html, body").animate({scrollTop: $("#reprint-statement").offset().top - 80}, 800);
      }
    </script>



            <div class="tag_share" style="display: block;">
                <div class="post-meta__tag-list" style="display: inline-block;">
                    
                        <div class="article-tag">
                            
                                <a href="/tags/postgresql/">
                                    <span class="chip bg-color">postgresql</span>
                                </a>
                            
                        </div>
                    
                </div>
                <div class="post_share" style="zoom: 80%; width: fit-content; display: inline-block; float: right; margin: -0.15rem 0;">
                    <link rel="stylesheet" type="text/css" href="/libs/share/css/share.min.css">
<div id="article-share">

    
    <div class="social-share" data-sites="twitter,facebook,google,qq,qzone,wechat,weibo,douban,linkedin" data-wechat-qrcode-helper="<p>微信扫一扫即可分享！</p>"></div>
    <script src="/libs/share/js/social-share.min.js"></script>
    

    

</div>

                </div>
            </div>
            
                <div id="reward">
    <a href="#rewardModal" class="reward-link modal-trigger btn-floating btn-medium waves-effect waves-light red">赏</a>

    <!-- Modal Structure -->
    <div id="rewardModal" class="modal">
        <div class="modal-content">
            <a class="close modal-close"><i class="fas fa-times"></i></a>
            <h4 class="reward-title">你的赏识是我前进的动力</h4>
            <div class="reward-content">
                <div class="reward-tabs">
                    <ul class="tabs row">
                        <li class="tab col s6 alipay-tab waves-effect waves-light"><a href="#alipay">支付宝</a></li>
                        <li class="tab col s6 wechat-tab waves-effect waves-light"><a href="#wechat">微 信</a></li>
                    </ul>
                    <div id="alipay">
                        <img src="/medias/reward/alipay.jpg" class="reward-img" alt="支付宝打赏二维码">
                    </div>
                    <div id="wechat">
                        <img src="/medias/reward/wechat.png" class="reward-img" alt="微信打赏二维码">
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>

<script>
    $(function () {
        $('.tabs').tabs();
    });
</script>

            
        </div>
    </div>

    

    

    

    

    

    

    

    

    

<article id="prenext-posts" class="prev-next articles">
    <div class="row article-row">
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge left-badge text-color">
                <i class="fas fa-chevron-left"></i>&nbsp;上一篇</div>
            <div class="card">
                <a href="/2021/6.vacuum-jin-cheng/">
                    <div class="card-image">
                        
                        
                        <img src="/medias/featureimages/17.jpg" class="responsive-img" alt="6 vacuum进程">
                        
                        <span class="card-title">6 vacuum进程</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            vacuum进程是一种便于PostgreSQL持久运行的维护过程。它的两个主要任务是删除死元组和冻结事务id。
                        
                    </div>
                    <div class="publish-info">
                        <span class="publish-date">
                            <i class="far fa-clock fa-fw icon-date"></i>2021-08-13
                        </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-bookmark fa-fw icon-category"></i>
                            
                            <a href="/categories/postgresql/" class="post-category">
                                    postgresql
                                </a>
                            
                            
                        </span>
                    </div>
                </div>
                
                <div class="card-action article-tags">
                    
                    <a href="/tags/postgresql/">
                        <span class="chip bg-color">postgresql</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge right-badge text-color">
                下一篇&nbsp;<i class="fas fa-chevron-right"></i>
            </div>
            <div class="card">
                <a href="/2021/5.bing-fa-kong-zhi/">
                    <div class="card-image">
                        
                        
                        <img src="/medias/featureimages/3.jpg" class="responsive-img" alt="5 并发控制">
                        
                        <span class="card-title">5 并发控制</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            并发控制是一种机制，当多个事务在数据库中并发运行时，它保持原子性和隔离性，这是ACID的两个属性。
                        
                    </div>
                    <div class="publish-info">
                            <span class="publish-date">
                                <i class="far fa-clock fa-fw icon-date"></i>2021-08-13
                            </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-bookmark fa-fw icon-category"></i>
                            
                            <a href="/categories/postgresql/" class="post-category">
                                    postgresql
                                </a>
                            
                            
                        </span>
                    </div>
                </div>
                
                <div class="card-action article-tags">
                    
                    <a href="/tags/postgresql/">
                        <span class="chip bg-color">postgresql</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
    </div>
</article>

</div>



<!-- 代码块功能依赖 -->
<script type="text/javascript" src="/libs/codeBlock/codeBlockFuction.js"></script>



<!-- 代码语言 -->

<script type="text/javascript" src="/libs/codeBlock/codeLang.js"></script>


<!-- 代码块复制 -->

<script type="text/javascript" src="/libs/codeBlock/codeCopy.js"></script>


<!-- 代码块收缩 -->

<script type="text/javascript" src="/libs/codeBlock/codeShrink.js"></script>



    </div>
    <div id="toc-aside" class="expanded col l3 hide-on-med-and-down">
        <div class="toc-widget card" style="background-color: white;">
            <div class="toc-title"><i class="far fa-list-alt"></i>&nbsp;&nbsp;目录</div>
            <div id="toc-content"></div>
        </div>
    </div>
</div>

<!-- TOC 悬浮按钮. -->

<div id="floating-toc-btn" class="hide-on-med-and-down">
    <a class="btn-floating btn-large bg-color">
        <i class="fas fa-list-ul"></i>
    </a>
</div>


<script src="/libs/tocbot/tocbot.min.js"></script>
<script>
    $(function () {
        tocbot.init({
            tocSelector: '#toc-content',
            contentSelector: '#articleContent',
            headingsOffset: -($(window).height() * 0.4 - 45),
            collapseDepth: Number('0'),
            headingSelector: 'h2, h3, h4'
        });

        // Set scroll toc fixed.
        let tocHeight = parseInt($(window).height() * 0.4 - 64);
        let $tocWidget = $('.toc-widget');
        $(window).scroll(function () {
            let scroll = $(window).scrollTop();
            /* add post toc fixed. */
            if (scroll > tocHeight) {
                $tocWidget.addClass('toc-fixed');
            } else {
                $tocWidget.removeClass('toc-fixed');
            }
        });

        
        /* 修复文章卡片 div 的宽度. */
        let fixPostCardWidth = function (srcId, targetId) {
            let srcDiv = $('#' + srcId);
            if (srcDiv.length === 0) {
                return;
            }

            let w = srcDiv.width();
            if (w >= 450) {
                w = w + 21;
            } else if (w >= 350 && w < 450) {
                w = w + 18;
            } else if (w >= 300 && w < 350) {
                w = w + 16;
            } else {
                w = w + 14;
            }
            $('#' + targetId).width(w);
        };

        // 切换TOC目录展开收缩的相关操作.
        const expandedClass = 'expanded';
        let $tocAside = $('#toc-aside');
        let $mainContent = $('#main-content');
        $('#floating-toc-btn .btn-floating').click(function () {
            if ($tocAside.hasClass(expandedClass)) {
                $tocAside.removeClass(expandedClass).hide();
                $mainContent.removeClass('l9');
            } else {
                $tocAside.addClass(expandedClass).show();
                $mainContent.addClass('l9');
            }
            fixPostCardWidth('artDetail', 'prenext-posts');
        });
        
    });
</script>

    

</main>




    <footer class="page-footer bg-color">
    

    <div class="container row center-align"
         style="margin-bottom: 0px !important;">
        <div class="col s12 m8 l8 copy-right">
            Copyright&nbsp;&copy;
            
                <span id="year">2019-2025</span>
            
            <a href="/about" target="_blank">JINLID</a>
            |&nbsp;Powered by&nbsp;<a href="https://hexo.io/" target="_blank">Hexo</a>
            |&nbsp;Theme&nbsp;<a href="https://github.com/blinkfox/hexo-theme-matery" target="_blank">Matery</a>
            
            <br>
            
            
            
                
            
            
                <span id="busuanzi_container_site_pv">
                &nbsp;|&nbsp;<i class="far fa-eye"></i>&nbsp;总访问量:&nbsp;
                    <span id="busuanzi_value_site_pv" class="white-color"></span>
            </span>
            
            
                <span id="busuanzi_container_site_uv">
                &nbsp;|&nbsp;<i class="fas fa-users"></i>&nbsp;总访问人数:&nbsp;
                    <span id="busuanzi_value_site_uv" class="white-color"></span>
            </span>
            
            <br>

            <!-- 运行天数提醒. -->
            
            <br>
            
        </div>
        <div class="col s12 m4 l4 social-link social-statis">
    <a href="https://github.com/jinlid" class="tooltipped" target="_blank" data-tooltip="访问我的GitHub" data-position="top" data-delay="50">
        <i class="fab fa-github"></i>
    </a>



    <a href="mailto:845401160@qq.com" class="tooltipped" target="_blank" data-tooltip="邮件联系我" data-position="top" data-delay="50">
        <i class="fas fa-envelope-open"></i>
    </a>







    <a href="tencent://AddContact/?fromId=50&fromSubId=1&subcmd=all&uin=845401160" class="tooltipped" target="_blank" data-tooltip="QQ联系我: 845401160" data-position="top" data-delay="50">
        <i class="fab fa-qq"></i>
    </a>







    <a href="/atom.xml" class="tooltipped" target="_blank" data-tooltip="RSS 订阅" data-position="top" data-delay="50">
        <i class="fas fa-rss"></i>
    </a>

</div>
    </div>
</footer>

<div class="progress-bar"></div>


    <!-- 搜索遮罩框 -->
<div id="searchModal" class="modal">
    <div class="modal-content">
        <div class="search-header">
            <span class="title"><i class="fas fa-search"></i>&nbsp;&nbsp;搜索</span>
            <input type="search" id="searchInput" name="s" placeholder="请输入搜索的关键字"
                   class="search-input">
        </div>
        <div id="searchResult"></div>
    </div>
</div>

<script type="text/javascript">
$(function () {
    var searchFunc = function (path, search_id, content_id) {
        'use strict';
        $.ajax({
            url: path,
            dataType: "xml",
            success: function (xmlResponse) {
                // get the contents from search data
                var datas = $("entry", xmlResponse).map(function () {
                    return {
                        title: $("title", this).text(),
                        content: $("content", this).text(),
                        url: $("url", this).text()
                    };
                }).get();
                var $input = document.getElementById(search_id);
                var $resultContent = document.getElementById(content_id);
                $input.addEventListener('input', function () {
                    var str = '<ul class=\"search-result-list\">';
                    var keywords = this.value.trim().toLowerCase().split(/[\s\-]+/);
                    $resultContent.innerHTML = "";
                    if (this.value.trim().length <= 0) {
                        return;
                    }
                    // perform local searching
                    datas.forEach(function (data) {
                        var isMatch = true;
                        var data_title = data.title.trim().toLowerCase();
                        var data_content = data.content.trim().replace(/<[^>]+>/g, "").toLowerCase();
                        var data_url = data.url;
                        data_url = data_url.indexOf('/') === 0 ? data.url : '/' + data_url;
                        var index_title = -1;
                        var index_content = -1;
                        var first_occur = -1;
                        // only match artiles with not empty titles and contents
                        if (data_title !== '' && data_content !== '') {
                            keywords.forEach(function (keyword, i) {
                                index_title = data_title.indexOf(keyword);
                                index_content = data_content.indexOf(keyword);
                                if (index_title < 0 && index_content < 0) {
                                    isMatch = false;
                                } else {
                                    if (index_content < 0) {
                                        index_content = 0;
                                    }
                                    if (i === 0) {
                                        first_occur = index_content;
                                    }
                                }
                            });
                        }
                        // show search results
                        if (isMatch) {
                            str += "<li><a href='" + data_url + "' class='search-result-title'>" + data_title + "</a>";
                            var content = data.content.trim().replace(/<[^>]+>/g, "");
                            if (first_occur >= 0) {
                                // cut out 100 characters
                                var start = first_occur - 20;
                                var end = first_occur + 80;
                                if (start < 0) {
                                    start = 0;
                                }
                                if (start === 0) {
                                    end = 100;
                                }
                                if (end > content.length) {
                                    end = content.length;
                                }
                                var match_content = content.substr(start, end);
                                // highlight all keywords
                                keywords.forEach(function (keyword) {
                                    var regS = new RegExp(keyword, "gi");
                                    match_content = match_content.replace(regS, "<em class=\"search-keyword\">" + keyword + "</em>");
                                });

                                str += "<p class=\"search-result\">" + match_content + "...</p>"
                            }
                            str += "</li>";
                        }
                    });
                    str += "</ul>";
                    $resultContent.innerHTML = str;
                });
            }
        });
    };

    searchFunc('/search.xml', 'searchInput', 'searchResult');
});
</script>

    <!-- 白天和黑夜主题 -->
<div class="stars-con">
    <div id="stars"></div>
    <div id="stars2"></div>
    <div id="stars3"></div>  
</div>

<script>
    function switchNightMode() {
        $('<div class="Cuteen_DarkSky"><div class="Cuteen_DarkPlanet"></div></div>').appendTo($('body')),
        setTimeout(function () {
            $('body').hasClass('DarkMode') 
            ? ($('body').removeClass('DarkMode'), localStorage.setItem('isDark', '0'), $('#sum-moon-icon').removeClass("fa-sun").addClass('fa-moon')) 
            : ($('body').addClass('DarkMode'), localStorage.setItem('isDark', '1'), $('#sum-moon-icon').addClass("fa-sun").removeClass('fa-moon')),
            
            setTimeout(function () {
            $('.Cuteen_DarkSky').fadeOut(1e3, function () {
                $(this).remove()
            })
            }, 2e3)
        })
    }
</script>

    <!-- 回到顶部按钮 -->
<div id="backTop" class="top-scroll">
    <a class="btn-floating btn-large waves-effect waves-light" href="#!">
        <i class="fas fa-arrow-up"></i>
    </a>
</div>


    <script src="/libs/materialize/materialize.min.js"></script>
    <script src="/libs/masonry/masonry.pkgd.min.js"></script>
    <script src="/libs/aos/aos.js"></script>
    <script src="/libs/scrollprogress/scrollProgress.min.js"></script>
    <script src="/libs/lightGallery/js/lightgallery-all.min.js"></script>
    <script src="/js/matery.js"></script>

    

    
    
    

    <!-- 雪花特效 -->
    

    <!-- 鼠标星星特效 -->
    

     
        <script src="https://ssl.captcha.qq.com/TCaptcha.js"></script>
        <script src="/libs/others/TencentCaptcha.js"></script>
        <button id="TencentCaptcha" data-appid="xxxxxxxxxx" data-cbfn="callback" type="button" hidden></button>
    

    <!-- Baidu Analytics -->

    <!-- Baidu Push -->

<script>
    (function () {
        var bp = document.createElement('script');
        var curProtocol = window.location.protocol.split(':')[0];
        if (curProtocol === 'https') {
            bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
        } else {
            bp.src = 'http://push.zhanzhang.baidu.com/push.js';
        }
        var s = document.getElementsByTagName("script")[0];
        s.parentNode.insertBefore(bp, s);
    })();
</script>

    
    <script src="/libs/others/clicklove.js" async="async"></script>
    
    
    <script async src="/libs/others/busuanzi.pure.mini.js"></script>
    

    

    

    <!--腾讯兔小巢-->
    
    

    

    

    
    <script src="/libs/instantpage/instantpage.js" type="module"></script>
    

</body>

</html>
