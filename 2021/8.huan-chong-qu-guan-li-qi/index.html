<!DOCTYPE HTML>
<html lang="zh-CN">


<head>
    <meta charset="utf-8">
    <meta name="keywords" content="8 缓冲区管理器, jinlid&#39;s blog">
    <meta name="description" content="缓冲区管理器管理着共享内存和持久存储之间的数据传输，它会对 DBMS 的性能有着重要的影响。PostgreSQL 的缓冲区管理器十分高效。


[TOC]
本章介绍了 PostgreSQL 的缓冲区管理器。图8.1展示了缓冲区管理器存储和后">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <meta name="renderer" content="webkit|ie-stand|ie-comp">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="format-detection" content="telephone=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="referrer" content="no-referrer-when-downgrade">
    <!-- Global site tag (gtag.js) - Google Analytics -->


    <title>8 缓冲区管理器 | jinlid&#39;s blog</title>
    <link rel="icon" type="image/png" href="/favicon.png">
    


    <!-- bg-cover style     -->



<link rel="stylesheet" type="text/css" href="/libs/awesome/css/all.min.css">
<link rel="stylesheet" type="text/css" href="/libs/materialize/materialize.min.css">
<link rel="stylesheet" type="text/css" href="/libs/aos/aos.css">
<link rel="stylesheet" type="text/css" href="/libs/animate/animate.min.css">
<link rel="stylesheet" type="text/css" href="/libs/lightGallery/css/lightgallery.min.css">
<link rel="stylesheet" type="text/css" href="/css/matery.css">
<link rel="stylesheet" type="text/css" href="/css/my.css">
<link rel="stylesheet" type="text/css" href="/css/dark.css" media="none" onload="if(media!='all')media='all'">




    <link rel="stylesheet" href="/libs/tocbot/tocbot.css">
    <link rel="stylesheet" href="/css/post.css">




    
        <link rel="stylesheet" type="text/css" href="/css/reward.css">
    



    <script src="/libs/jquery/jquery-3.6.0.min.js"></script>

<meta name="generator" content="Hexo 6.3.0">
<style>.github-emoji { position: relative; display: inline-block; width: 1.2em; min-height: 1.2em; overflow: hidden; vertical-align: top; color: transparent; }  .github-emoji > span { position: relative; z-index: 10; }  .github-emoji img, .github-emoji .fancybox { margin: 0 !important; padding: 0 !important; border: none !important; outline: none !important; text-decoration: none !important; user-select: none !important; cursor: auto !important; }  .github-emoji img { height: 1.2em !important; width: 1.2em !important; position: absolute !important; left: 50% !important; top: 50% !important; transform: translate(-50%, -50%) !important; user-select: none !important; cursor: auto !important; } .github-emoji-fallback { color: inherit; } .github-emoji-fallback img { opacity: 0 !important; }</style>
<link rel="stylesheet" href="/css/prism-tomorrow.css" type="text/css">
<link rel="stylesheet" href="/css/prism-line-numbers.css" type="text/css"></head>


<body>
    <header class="navbar-fixed">
    <nav id="headNav" class="bg-color nav-transparent">
        <div id="navContainer" class="nav-wrapper container">
            <div class="brand-logo">
                <a href="/" class="waves-effect waves-light">
                    
                    <img src="/medias/logo.png" class="logo-img" alt="LOGO">
                    
                    <span class="logo-span">jinlid&#39;s blog</span>
                </a>
            </div>
            

<a href="#" data-target="mobile-nav" class="sidenav-trigger button-collapse"><i class="fas fa-bars"></i></a>
<ul class="right nav-menu">
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/" class="waves-effect waves-light">
      
      <i class="fas fa-home" style="zoom: 0.6;"></i>
      
      <span>首页</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/tags" class="waves-effect waves-light">
      
      <i class="fas fa-tags" style="zoom: 0.6;"></i>
      
      <span>标签</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/categories" class="waves-effect waves-light">
      
      <i class="fas fa-bookmark" style="zoom: 0.6;"></i>
      
      <span>分类</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/archives" class="waves-effect waves-light">
      
      <i class="fas fa-archive" style="zoom: 0.6;"></i>
      
      <span>归档</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/about" class="waves-effect waves-light">
      
      <i class="fas fa-user-circle" style="zoom: 0.6;"></i>
      
      <span>关于</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/contact" class="waves-effect waves-light">
      
      <i class="fas fa-comments" style="zoom: 0.6;"></i>
      
      <span>留言板</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/friends" class="waves-effect waves-light">
      
      <i class="fas fa-address-book" style="zoom: 0.6;"></i>
      
      <span>友情链接</span>
    </a>
    
  </li>
  
  <li>
    <a href="#searchModal" class="modal-trigger waves-effect waves-light">
      <i id="searchIcon" class="fas fa-search" title="搜索" style="zoom: 0.85;"></i>
    </a>
  </li>
  <li>
    <a href="javascript:;" class="waves-effect waves-light" onclick="switchNightMode()" title="深色/浅色模式" >
      <i id="sum-moon-icon" class="fas fa-sun" style="zoom: 0.85;"></i>
    </a>
  </li>
</ul>


<div id="mobile-nav" class="side-nav sidenav">

    <div class="mobile-head bg-color">
        
        <img src="/medias/logo.png" class="logo-img circle responsive-img">
        
        <div class="logo-name">jinlid&#39;s blog</div>
        <div class="logo-desc">
            
            Never really desperate, only the lost of the soul.
            
        </div>
    </div>

    <ul class="menu-list mobile-menu-list">
        
        <li class="m-nav-item">
	  
		<a href="/" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-home"></i>
			
			首页
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/tags" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-tags"></i>
			
			标签
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/categories" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-bookmark"></i>
			
			分类
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/archives" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-archive"></i>
			
			归档
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/about" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-user-circle"></i>
			
			关于
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/contact" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-comments"></i>
			
			留言板
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/friends" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-address-book"></i>
			
			友情链接
		</a>
          
        </li>
        
        
        <li><div class="divider"></div></li>
        <li>
            <a href="https://github.com/blinkfox/hexo-theme-matery" class="waves-effect waves-light" target="_blank">
                <i class="fab fa-github-square fa-fw"></i>Fork Me
            </a>
        </li>
        
    </ul>
</div>


        </div>

        
            <style>
    .nav-transparent .github-corner {
        display: none !important;
    }

    .github-corner {
        position: absolute;
        z-index: 10;
        top: 0;
        right: 0;
        border: 0;
        transform: scale(1.1);
    }

    .github-corner svg {
        color: #0f9d58;
        fill: #fff;
        height: 64px;
        width: 64px;
    }

    .github-corner:hover .octo-arm {
        animation: a 0.56s ease-in-out;
    }

    .github-corner .octo-arm {
        animation: none;
    }

    @keyframes a {
        0%,
        to {
            transform: rotate(0);
        }
        20%,
        60% {
            transform: rotate(-25deg);
        }
        40%,
        80% {
            transform: rotate(10deg);
        }
    }
</style>

<a href="https://github.com/blinkfox/hexo-theme-matery" class="github-corner tooltipped hide-on-med-and-down" target="_blank"
   data-tooltip="Fork Me" data-position="left" data-delay="50">
    <svg viewBox="0 0 250 250" aria-hidden="true">
        <path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path>
        <path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2"
              fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path>
        <path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z"
              fill="currentColor" class="octo-body"></path>
    </svg>
</a>
        
    </nav>

</header>

    



<div class="bg-cover pd-header post-cover" style="background-image: url('/medias/featureimages/8.jpg')">
    <div class="container" style="right: 0px;left: 0px;">
        <div class="row">
            <div class="col s12 m12 l12">
                <div class="brand">
                    <h1 class="description center-align post-title">8 缓冲区管理器</h1>
                </div>
            </div>
        </div>
    </div>
</div>




<main class="post-container content">

    
    <div class="row">
    <div id="main-content" class="col s12 m12 l9">
        <!-- 文章内容详情 -->
<div id="artDetail">
    <div class="card">
        <div class="card-content article-info">
            <div class="row tag-cate">
                <div class="col s7">
                    
                    <div class="article-tag">
                        
                            <a href="/tags/postgresql/">
                                <span class="chip bg-color">postgresql</span>
                            </a>
                        
                    </div>
                    
                </div>
                <div class="col s5 right-align">
                    
                    <div class="post-cate">
                        <i class="fas fa-bookmark fa-fw icon-category"></i>
                        
                            <a href="/categories/postgresql/" class="post-category">
                                postgresql
                            </a>
                        
                    </div>
                    
                </div>
            </div>

            <div class="post-info">
                
                <div class="post-date info-break-policy">
                    <i class="far fa-calendar-minus fa-fw"></i>发布日期:&nbsp;&nbsp;
                    2021-08-13
                </div>
                

                

                

                

                
            </div>
        </div>
        <hr class="clearfix">

        

        

        <div class="card-content article-card-content">
            <div id="articleContent">
                <p>缓冲区管理器管理着共享内存和持久存储之间的数据传输，它会对 DBMS 的性能有着重要的影响。PostgreSQL 的缓冲区管理器十分高效。</p>
<span id="more"></span>

<p>[TOC]</p>
<p>本章介绍了 PostgreSQL 的缓冲区管理器。图8.1展示了缓冲区管理器存储和后端进程之间的关系，后续部分描述以下内容：</p>
<ul>
<li>缓冲区管理器的结构</li>
<li>缓冲区管理器的锁</li>
<li>缓冲区管理器的工作原理</li>
<li>环形缓冲区</li>
<li>脏页刷盘</li>
</ul>
<p><img src="/medias/image/fig-8-01.png" alt="图8.1 缓冲区管理器存储和后端进程之间的关系"></p>
<h2 id="8-1-概览"><a href="#8-1-概览" class="headerlink" title="8.1 概览"></a>8.1 概览</h2><p>本节介绍了为理解后续章节所需的关键概念。</p>
<h3 id="8-1-1-缓冲区管理器的结构"><a href="#8-1-1-缓冲区管理器的结构" class="headerlink" title="8.1.1 缓冲区管理器的结构"></a>8.1.1 缓冲区管理器的结构</h3><p>PostgreSQL缓冲区管理器由缓冲表、缓冲区描述符和缓冲池组成，这些将在下一节中介绍。缓冲池层存储数据着数据文件页面，如表</p>
<p>页和索引页，以及相应的<a href="https://jinlid.github.io/2021/8.huan-chong-qu-guan-li-qi/#_5.3.4">自由空间映射</a>和<a href="https://jinlid.github.io/2021/6.vacuum-jin-cheng/#_6.2">可见性映射</a>的页面。缓冲池是一个数组，数据的每个槽中存储数据文件的一页。缓冲池数组的序</p>
<p>号索引称为<strong>buffer_id</strong>。第<a href="https://jinlid.github.io/2021/8.huan-chong-qu-guan-li-qi/#8.2">8.2</a>、<a href="https://jinlid.github.io/2021/8.huan-chong-qu-guan-li-qi/#8.3">8.3节</a>描述了缓冲区管理器的内部细节。</p>
<h3 id="8-1-2-缓冲区标签（Buffer-Tag）"><a href="#8-1-2-缓冲区标签（Buffer-Tag）" class="headerlink" title="8.1.2 缓冲区标签（Buffer Tag）"></a>8.1.2 缓冲区标签（Buffer Tag）</h3><p>PostgreSQL中的每个数据文件页面都可以分配唯一的标签，即<strong>缓冲区标签</strong>。当缓冲区管理器收到请求时，PostgreSQL会用到</p>
<p>目标页面的缓冲区标签。</p>
<p>缓冲区标签有五个值：</p>
<ul>
<li>specOid：包含目标页的关系所属表空间的OID。</li>
<li>dbOid：包含目标页面的关系所属数据库的OID。</li>
<li>relNumber：包含目标页面的关系文件的编号。</li>
<li>blockNum：关系中目标页的块号。</li>
<li>forkNum：页面所属关系的分支。表、自由空间映射和可见性映射的分支分别定义为 0、1 和 2。</li>
</ul>
<p>例如，缓冲区标签 ‘{16821, 16384, 37721, 0, 7}’ 标识位于表的第7号页面，其中OID和分叉号分别为37721和0。该表包含在OID为 16384</p>
<p>的数据库中，位于OID为16821的表空间下。</p>
<p>类似地，缓冲区标签 ‘{16821, 16384, 37721, 1, 3}’ 标识位于自由空间映射的第3号页面，其OID和分支分别为37721和1。</p>
<h3 id="8-1-3-后端进程如何读取数据页"><a href="#8-1-3-后端进程如何读取数据页" class="headerlink" title="8.1.3 后端进程如何读取数据页"></a>8.1.3 后端进程如何读取数据页</h3><p>本小节描述了后端进程如何从缓冲区管理器中读取数据页（图 8.2）。</p>
<p><img src="/medias/image/fig-8-02.png" alt="图8.2 后端如何从缓冲区管理器读取页面"></p>
<ol>
<li>当读取表或索引页时，后端进程向缓冲区管理器发送请求，请求中带有目标页面的 <code>buffer_tag</code> 。</li>
<li>缓冲区管理器会根据 <code>buffer_tag</code> 返回一个 <code>buffer_id</code>，即目标页面存储在数组中的槽位的序号。如果请求的页面没有存储在缓冲池中，那么缓冲管理器会将页面从持久存储位置加载到其中一个缓冲池槽位中，然后再返回该槽位的 <code>buffer_ID</code>。</li>
<li>后端进程访问 <code>buffer_ID</code> 的槽位（以读取需要的页面）。</li>
</ol>
<p>当后端进程修改缓冲池中的页面时（例如向页面插入元组），这种尚未刷新到持久存储，但已被修改的页面被称为<strong>脏页</strong>。</p>
<p>第<a href="https://jinlid.github.io/2021/8.huan-chong-qu-guan-li-qi/#_8.4.">8.4 节</a>描述了缓冲区管理器的工作原理。</p>
<h3 id="8-1-4-页面置换算法"><a href="#8-1-4-页面置换算法" class="headerlink" title="8.1.4 页面置换算法"></a>8.1.4 页面置换算法</h3><p>当所有缓冲池槽位都被占用，并且未包含所请求的页面时，缓冲管理器必须在缓冲池中选择一个页面逐出，用于放置被请求的页面。在计</p>
<p>算机科学领域，选择页面的算法被称为<strong>页面置换算法</strong>，并且所选择的页面被称为<strong>受害者页面</strong>。</p>
<p>自计算机科学出现以来，针对页面置换算法的研究一直在进行。许多置换算法被提出，PostgreSQL从8.1版本开始使用<strong>时钟扫描</strong>算法。比</p>
<p>起以前版本中使用的 LRU 算法更简单高效。</p>
<p><a href="https://jinlid.github.io/2021/8.huan-chong-qu-guan-li-qi/#_8.4.4">8.4.4 节</a>将描述时钟扫描的细节。</p>
<h3 id="8-1-5-脏页刷盘"><a href="#8-1-5-脏页刷盘" class="headerlink" title="8.1.5 脏页刷盘"></a>8.1.5 脏页刷盘</h3><p>脏页最终应该被刷新到存储中，然而缓冲区管理器需要额外帮助才能执行此任务。在PostgreSQL中，<strong>checkpointer</strong>和</p>
<p><strong>background writer</strong>这两个后台进程负责此任务。</p>
<p>第<a href="https://jinlid.github.io/2021/8.huan-chong-qu-guan-li-qi/#_8.6">8.6 节</a>描述了checkpointer和background writer。</p>
<blockquote>
<p>PostgreSQL版本15及更早版本不支持直接I/O，尽管已经对此进行了讨论。请参阅<a target="_blank" rel="noopener" href="http://www.postgresql.org/message-id/529E267F.4050700@agliodbs.com">这篇</a>关于pgsql-ML的文章和<a target="_blank" rel="noopener" href="http://lwn.net/Articles/580542/">这篇文章</a>。</p>
<p>在版本 16 中，添加了<a target="_blank" rel="noopener" href="https://www.postgresql.org/docs/16/runtime-config-developer.html#GUC-DEBUG-IO-DIRECT">debug-io-direct选项</a>。该选项供开发人员改进PostgreSQL中直接I/O的使用。如果开发顺利的话，Direct I/O将在不久的将来正式支持。</p>
</blockquote>
<h2 id="8-2-缓冲区管理器的结构"><a href="#8-2-缓冲区管理器的结构" class="headerlink" title="8.2 缓冲区管理器的结构"></a>8.2 缓冲区管理器的结构</h2><p>PostgreSQL缓冲管理器由三层组成，即<strong>缓冲表层</strong>、<strong>缓冲区描述符层</strong>和<strong>缓冲池层</strong>（图 8.3）。</p>
<ul>
<li><p><strong>缓冲表层</strong>：是一个散列表，它存储着页面的 <code>buffer_tags</code> 与描述符的 <code>buffer_id</code> 之间的映射关系。</p>
</li>
<li><p><strong>缓冲区描述符层</strong>：是一个由缓冲区描述符组成的数组。每个描述符与缓冲池槽一一对应，并保存着相应槽的元数据。请注意，为了方便起见，采用术语“缓冲区描述符层”，并且仅在本文档中使用。</p>
</li>
<li><p><strong>缓冲池层</strong>：是一个数组，每个槽都存储一个数据文件页。数组槽的索引称为<strong>buffer_id</strong>。</p>
</li>
</ul>
<p><img src="/medias/image/fig-8-03.png" alt="图8.3 缓冲区管理器的三层结构"></p>
<p>这些层将在以下小节中详细描述。</p>
<h3 id="8-2-1-缓冲表"><a href="#8-2-1-缓冲表" class="headerlink" title="8.2.1 缓冲表"></a>8.2.1 缓冲表</h3><p>缓冲区表在逻辑上可以分为三个部分：散列函数、散列桶槽和数据项（图 8.4）。</p>
<p>内置的散列函数将 <code>buffer_tag</code> 映射到散列桶槽。即使散列桶槽数大于缓冲池槽数，也可能发生冲突。因此，缓冲表使用<strong>链表的分离链</strong></p>
<p><strong>接</strong>方法来解决冲突。当数据项映射到同一个桶槽时，该方法将这些数据项存储在同一个链表中，如图8.4所示。</p>
<p><img src="/medias/image/fig-8-04.png" alt="图8.4 缓冲表"></p>
<p>数据项包含两个值：页面的 <code>buffer_tag</code> 和包含页面元数据的描述符的 <code>buffer_id</code>。例如，数据项 Tag_A, id=1 表示 buffer_id=1对应的</p>
<p>缓冲区描述符中，存储着页面 Tag_A 的元数据。</p>
<blockquote>
<p> 散列函数</p>
<p>散列函数是由<a target="_blank" rel="noopener" href="https://doxygen.postgresql.org/dynahash_8c.html#ae802f2654df749ae0e0aadf4b5c5bcbd">calc_bucket()</a>和 <a target="_blank" rel="noopener" href="https://doxygen.postgresql.org/rege__dfa_8c.html#a6aa3a27e7a0fc6793f3329670ac3b0cb">hash()</a>组合而成。 以下是用伪函数的表示的形式。</p>
<pre class="line-numbers language-c"><code class="language-c">uint32 bucket_slot <span class="token operator">=</span> <span class="token function">calc_bucket</span><span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token function">hash</span><span class="token punctuation">(</span>BufferTag buffer_tag<span class="token punctuation">)</span><span class="token punctuation">,</span> uint32 bucket_size<span class="token punctuation">)</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
</blockquote>
<p>暂时还没有对数据项的查找、插入和删除进行解释。这些常见的操作将在以下部分进行详细说明。</p>
<h3 id="8-2-2-缓冲区描述符"><a href="#8-2-2-缓冲区描述符" class="headerlink" title="8.2.2 缓冲区描述符"></a>8.2.2 缓冲区描述符</h3><p>本节介绍缓冲区描述符的结构，下一节介绍缓冲区描述符层。</p>
<p>缓冲区描述符存储着页面的元数据，这些与缓冲区描述符相应的页面保存在缓冲池槽中。缓冲区描述符的结构由BufferDesc结构定义。主</p>
<p>要字段如下所示：</p>
<ul>
<li><p><strong>tag</strong> 保存着目标页面的buffer_tag，该页面存储在相应的缓冲池槽中，缓冲区标签在第 8.1节中给出 。</p>
</li>
<li><p><strong>buffer_id</strong> 标识了缓冲区描述符，相当于对应缓冲池槽的buffer_id。</p>
</li>
<li><p>**refcount **保存当前访问相关页面的 PostgreSQL 进程数。它也称为钉数。当 PostgreSQL 进程访问相应页面时，其引用计数必须加1（refcount++）。访问页面结束后，其引用计数必须减1（refcount–）。当引用计数为零时，即页面当前并未被访问时，则该页将取钉；否则它会被钉住。</p>
</li>
<li><p>**usage_count **保存着相应页面加载至相应缓冲池槽后的访问次数。usage_count 会在页面置换算法中被用到，见第8.4.4节。</p>
</li>
<li><p><strong>context_lock</strong>和<strong>io_in_progress_lock</strong> 是轻量级锁，用于控制对相关页面的访问。这些字段将在第 8.3.2 节中描述。</p>
</li>
<li><p>flags 用于保存相关页面的状态，主要状态如下：</p>
<ul>
<li><strong>脏位</strong> 指明相应页面是否为脏页。</li>
<li><strong>有效位</strong> 指明相应页面是否可以被读写（有效）。例如，如果该位被设置为 <code>valid</code>， 那就意味着对应的缓冲池槽中存储着一个页面，而该描述符中保存着该页面的元数据，因而可以对该页面进行读写。反之如果有效位被设置为 <code>invalid</code>，那就意味着该描述符中并没有保存任何元数据，即对应的页面无法读写，缓冲区管理器可能正在将该页面换出。</li>
<li>**io进行标记位 **指明缓冲区管理器是否正在从存储读/写相应页面。换句话说，该位指示是否有一个进程持有该描述符上的 io_in_progress_lock。</li>
</ul>
</li>
<li><p><strong>freeNext</strong> 是一个指针，指向下一个描述符，并以此构成一个空闲列表（freelist），这将在下一小节中描述。</p>
</li>
</ul>
<p>结构<code>BufferDesc</code>在<a target="_blank" rel="noopener" href="https://github.com/postgres/postgres/blob/master/src/include/storage/buf_internals.h">src/include/storage/buf_internals.h </a>中定义。</p>
<p>为了简化后续章节的描述，这里定义了三个描述符状态：</p>
<ul>
<li><strong>空</strong>：当相应的缓冲池槽不存储页面，即 <code>refcount</code>和 <code>usage_count</code>都是0，该描述符的状态为空。</li>
<li><strong>钉住</strong>：当相应的缓冲池槽中存储着页面，且有PostgreSQL进程正在访问的相应页面（即 <code>refcount</code>和 <code>usage_count</code>都大于或等于1），该缓冲区描述符的钉住。</li>
<li><strong>未钉住</strong>：当对应的缓冲池槽存储页面，但没有PostgreSQL进程访问相应页面时（即 <code>usage_count</code>大于等于1，但 <code>refcount</code>为0），这个缓冲区描述符的状态为未钉住。</li>
</ul>
<p>每个描述符都处于上述状态之一。描述符的状态会根据特定条件而变化，这将在下一小节中描述。</p>
<p>缓冲区描述符的状态由彩色框表示。</p>
<ul>
<li>（白色）<em>空</em></li>
<li>（蓝色）<em>钉住</em></li>
<li>（水蓝色）未钉住</li>
</ul>
<p>此外，脏页用 <strong>X</strong>表示。例如，未钉住的脏描述符由 X 表示。</p>
<h3 id="8-2-3-缓冲区描述符层"><a href="#8-2-3-缓冲区描述符层" class="headerlink" title="8.2.3 缓冲区描述符层"></a>8.2.3 缓冲区描述符层</h3><p>缓冲区描述符的集合构成一个数组。在本文档中，该数组被称为<strong>缓冲区描述符层</strong>。</p>
<p>当 PostgreSQL 服务器启动时，所有缓冲区描述符的状态都为空。在 PostgreSQL 中，这些描述符构成了一个名为<strong>freelist</strong>的链表，缓冲</p>
<p>区管理器的初始化状态如图 8.5所示。</p>
<p><img src="/medias/image/fig-8-05.png" alt="图8.5 缓冲区管理器初始化状态"></p>
<blockquote>
<p>注意，在PostgreSQL中的 freelist 是从完全不同于Oracle中的 freelist 的概念。PostgreSQL 的 freelist 只是空缓冲区描述符的链</p>
<p>表。在<a target="_blank" rel="noopener" href="http://www.interdb.jp/pg/pgsql05.html#_5.3.4.">5.3.4 节</a>中已描述，PostgreSQL中与Oracle中的freelist相对应的对象是空闲空间映射（FSM）。</p>
</blockquote>
<p>图 8.6 展示了第一个页面是如何加载的。</p>
<ol>
<li>从 <code>freelist</code> 的头部取一个空描述符，并将其钉住，即将refcount和usage_count增加1。</li>
<li>在缓冲表中插入新项，该缓冲表项保存了页面 buffer_tag 与所获描述符 buffer_id 之间的关系。</li>
<li>将新页面从存储器加载至相应的缓冲池槽中。</li>
<li>将新页面的元数据保存至所获取的描述符中。</li>
</ol>
<p>第二页和后续页面的加载方式类似。第 8.4.2 节提供了其他详细信息。</p>
<p><img src="/medias/image/fig-8-06.png" alt="图8.6 加载第一页"></p>
<p>从 freelist 中摘出的描述符始终保存着页面的元数据。换句话说，仍然在使用的非空描述符不会返还到 freelist 中。但当发生以下任一情</p>
<p>况时，描述符状态变为“空”，并被重新添加至 freelist  中：</p>
<ol>
<li>相关表或索引已被删除。</li>
<li>相关数据库已被删除。</li>
<li>相关表或索引已经被 VACUUM FULL 命令清理。</li>
</ol>
<blockquote>
<p> 为什么使用 freelist 来维护空描述符？</p>
<p>保留 freelist 的原因是为了立即获取第一个描述符。这是内存动态分配的常见做法。请参阅<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Free_list">此说明</a>。</p>
</blockquote>
<p>缓冲区描述符层包含一个32 位无符号的整数变量，即<strong>nextVictimBuffer</strong>。该变量用于第 8.4.4 节中描述的页面置换算法。</p>
<h3 id="8-2-4-缓冲池"><a href="#8-2-4-缓冲池" class="headerlink" title="8.2.4 缓冲池"></a>8.2.4 缓冲池</h3><p>缓冲池只是一个用于存储关系数据文件（例如表和索引）页面的简单数组。缓冲池数组的序号索引也就是 <code>buffer_id</code>。</p>
<p>缓冲池槽的大小为8KB，等于一个页面的大小。因此，每个槽都能存储整个页面。</p>
<h2 id="8-3-缓冲区管理器锁"><a href="#8-3-缓冲区管理器锁" class="headerlink" title="8.3 缓冲区管理器锁"></a>8.3 缓冲区管理器锁</h2><p>缓冲区管理器会出于不同的目的使用各式各样的锁，本节将介绍后续章节中所必备的一些锁。</p>
<blockquote>
<p>注意，本节中描述的锁是缓冲区管理器同步机制的一部分。它们与SQL语句和SQL操作中的锁没有任何关系。</p>
</blockquote>
<h3 id="8-3-1-缓冲表锁"><a href="#8-3-1-缓冲表锁" class="headerlink" title="8.3.1 缓冲表锁"></a>8.3.1 缓冲表锁</h3><p><strong>BufMappingLock</strong>保护整个缓冲表的数据完整性。它是一种轻量级的锁，有共享模式和独占模式。在缓冲区表中搜索条目时，后端进</p>
<p>程会持有共享的 BufMappingLock。插入或删除条目时，后端进程持有独占的 BufMappingLock。</p>
<p>BufMappingLock 会被分成多个分区，以减少缓冲表中的争用（默认为 128 个分区）。每个 BufMappingLock 分区都保护着一部分相应</p>
<p>的散列桶槽。</p>
<p>图 8.7 是一个典型的 BufMappingLock 分区示例。两个后端进程可以同时持有各自分区的 BufMappingLock 独占锁，以便插入新的数据</p>
<p>项。如果 BufMappingLock 是系统级的锁，那么其中一个进程就需要等待另一个进程完成处理。</p>
<p><img src="/medias/image/fig-8-07.png" alt="图8.7 两个进程同时获取相应分区的 BufMappingLock独占锁，以插入新数据项"></p>
<p>缓冲表也需要许多其他锁。例如，在缓冲表内部使用自旋锁（spin lock）来删除数据项。然而，本章不需要这些锁的其他相关知识，因此</p>
<p>这里省略了对其他锁的介绍。</p>
<blockquote>
<p>在 9.4 版本之前，BufMappingLock 默认被拆分为 16 个独立的锁。</p>
</blockquote>
<h3 id="8-3-2-缓冲区描述符相关的锁"><a href="#8-3-2-缓冲区描述符相关的锁" class="headerlink" title="8.3.2 缓冲区描述符相关的锁"></a>8.3.2 缓冲区描述符相关的锁</h3><p>每个缓冲区描述符都会用到内容锁（<strong>content_lock</strong>）与IO进行锁（<strong>io_in_progress_lock</strong>）这两个轻量级锁，以控制对相应缓冲池槽页</p>
<p>面的访问。当检查或更改描述符本身字段的值时，就会用到自旋锁。</p>
<h4 id="8-3-2-1-内容锁"><a href="#8-3-2-1-内容锁" class="headerlink" title="8.3.2.1 内容锁"></a>8.3.2.1 内容锁</h4><p>内容锁（content_lock）是一个典型的强制限制访问的锁。它有共享和独占两种模式。当读取页面时，后端进程以共享模式获取页面相应</p>
<p>缓冲区描述符中的 content lock。执行下列操作之一时，则会获取独占模式的 content lock。</p>
<p>但是，在执行以下操作之一时会获得一个独占的 content_lock：</p>
<ul>
<li><p>将行（即元组）插入页面，或更改页面中元组的  t_xmin/t_xmax 字段（t_xmin 和 t_xmax 在第 5.2 节中介绍，简单地说，这些字段</p>
<p>会在相关元组被删除或更新行时发生更改） 。</p>
</li>
<li><p>物理移除元组，或压紧页面上的空闲空间（由清理过程和HOT执行，分别在第6章和第7章中有介绍过）。</p>
</li>
<li><p>冻结页面中的元组（冻结过程在第 5.10.1节和第 6.3节中有过介绍）。</p>
</li>
</ul>
<p>官方<a target="_blank" rel="noopener" href="https://github.com/postgres/postgres/blob/master/src/backend/storage/buffer/README">README</a> 文件包含了更多的细节。</p>
<h4 id="8-3-2-2-IO进行锁"><a href="#8-3-2-2-IO进行锁" class="headerlink" title="8.3.2.2 IO进行锁"></a>8.3.2.2 IO进行锁</h4><p>IO进行锁（io_in_progress_lock） 用于等待缓冲区上的 I/O 完成。当 PostgreSQL 进程加载/写入页面数据时，该进程在访问页面期间持</p>
<p>有相应描述符上独占的 io_in_progress_lock。</p>
<h4 id="8-3-2-3-自旋锁"><a href="#8-3-2-3-自旋锁" class="headerlink" title="8.3.2.3 自旋锁"></a>8.3.2.3 自旋锁</h4><p>当检查或更改标记字段或其他字段时，例如 refcount 和 usage_count，会使用自旋锁。下面是两个使用自旋锁的具体例子：</p>
<ol>
<li><p>钉住缓冲区描述符.</p>
<p>获取缓冲区描述符上的自旋锁。</p>
<p>将其 refcount 和 usage_count 的值加1。</p>
<p>释放自旋锁。</p>
<pre class="line-numbers language-c-monosp"><code class="language-c-monosp">LockBufHdr(bufferdesc);    /* Acquire a spinlock */
bufferdesc->refcont++;
bufferdesc->usage_count++;
UnlockBufHdr(bufferdesc); /* Release the spinlock */
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li><p>将脏位设置为”1“。</p>
<p>获取缓冲区描述符上的自旋锁。</p>
<p>使用位操作将脏位置设置为“1”。</p>
<p>释放自旋锁。</p>
<pre class="line-numbers language-c"><code class="language-c"><span class="token macro property">#<span class="token directive keyword">define</span> BM_DIRTY             (1 &lt;&lt; 0)    </span><span class="token comment" spellcheck="true">/* 数据需要回写 */</span>
<span class="token macro property">#<span class="token directive keyword">define</span> BM_VALID             (1 &lt;&lt; 1)    </span><span class="token comment" spellcheck="true">/* 数据有效 */</span>
<span class="token macro property">#<span class="token directive keyword">define</span> BM_TAG_VALID         (1 &lt;&lt; 2)    </span><span class="token comment" spellcheck="true">/* 已经分配了TAG */</span>
<span class="token macro property">#<span class="token directive keyword">define</span> BM_IO_IN_PROGRESS    (1 &lt;&lt; 3)    </span><span class="token comment" spellcheck="true">/* 正在进行读写 */</span>
<span class="token macro property">#<span class="token directive keyword">define</span> BM_JUST_DIRTIED      (1 &lt;&lt; 5)    </span><span class="token comment" spellcheck="true">/* 开始写之后数据刚被修改 */</span>

<span class="token function">LockBufHdr</span><span class="token punctuation">(</span>bufferdesc<span class="token punctuation">)</span><span class="token punctuation">;</span>
bufferdesc<span class="token operator">-></span>flags <span class="token operator">|</span><span class="token operator">=</span> BM_DIRTY<span class="token punctuation">;</span>
<span class="token function">UnlockBufHdr</span><span class="token punctuation">(</span>bufferdesc<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>其他标记位也是通过相同的方式来设置的。</p>
</li>
</ol>
<blockquote>
<p>用原子操作替换缓冲区管理器的自旋锁</p>
<p>在 9.6 版本中，缓冲区管理器的自旋锁将被替换为原子操作。可以参考<a target="_blank" rel="noopener" href="https://commitfest.postgresql.org/9/408/">commitfest </a>中提交日志的内容。如果想了解详细信息，请参</p>
<p>阅<a target="_blank" rel="noopener" href="http://www.postgresql.org/message-id/flat/2400449.GjM57CE0Yg@dinodell#2400449.GjM57CE0Yg@dinodell">此讨论</a>。</p>
</blockquote>
<h2 id="8-4-缓冲区管理器的工作原理"><a href="#8-4-缓冲区管理器的工作原理" class="headerlink" title="8.4 缓冲区管理器的工作原理"></a>8.4 缓冲区管理器的工作原理</h2><p>本节介绍缓冲区管理器的工作原理。当后端进程想要访问所需页面时，它会调用 <em>ReadBufferExtended</em> 函数。</p>
<p>函数 <em>ReadBufferExtended</em> 的行为因场景而异，在逻辑上具体可以分为三种情况。每种情况都将用一小节介绍。第8.4.4节将介绍</p>
<p>PostgreSOL中基于时钟扫描的页面置换算法。</p>
<h3 id="8-4-1-访问存储在缓冲池中的页面"><a href="#8-4-1-访问存储在缓冲池中的页面" class="headerlink" title="8.4.1 访问存储在缓冲池中的页面"></a>8.4.1 访问存储在缓冲池中的页面</h3><p>当从缓冲池槽中的页面里读取行时，PostgreSQL 进程获取相应缓冲区描述符的共享 content_lock，因而缓冲池槽可以同时被多个进程读</p>
<p>取。</p>
<p>当向页面插入（及更新、删除）行时，该 postgres 后端进程获取相应缓冲区描述符的独占 content_lock （注意，这里必须将相应页面的脏位置设为”1”）。</p>
<p>访问完页面后，相应缓冲区描述符的引用计数值减1。</p>
<p>图8.8是访问存储在缓冲池中的页面示意图。</p>
<p><img src="/medias/image/fig-8-08.png" alt="图8.8 访问存储在缓冲池中的页面"></p>
<p>我们来介绍最简单的情况，即所需页面已经存储在缓冲池中。在这种情况下，缓冲区管理器会执行以下步骤：</p>
<ol>
<li>创建所需页面的 buffer_tag（在本例中 buffer_tag 是’Tag_C’），并使用散列函数计算与描述符相对应的散列桶槽。</li>
<li>获取相应散列桶槽分区上的 <em>BufMappingLock</em> 共享锁。</li>
<li>查找标签为’Tag_C’的条目，并从条目中获取buffer_id。本例中buffer_id为2。</li>
<li>将buffer_id=2的缓冲区描述符钉住，即将描述符的 refcount 和usage_count增加1。</li>
<li>释放 BufMappingLock。</li>
<li>访问 bufferid=2 的缓冲池槽。</li>
</ol>
<h3 id="8-4-2-将页面从存储加载到空槽"><a href="#8-4-2-将页面从存储加载到空槽" class="headerlink" title="8.4.2 将页面从存储加载到空槽"></a>8.4.2 将页面从存储加载到空槽</h3><p>图 8.9 是将页面从存储加载到空槽的示意图。</p>
<p><img src="/medias/image/fig-8-09.png" alt="图8.9 将页面从存储加载到空槽"></p>
<p>在第二种情况下，假设所需页面不在缓冲池中，且 freelist 中有空闲元素（空描述符）。</p>
<p>这时，缓冲区管理器将执行以下步骤：</p>
<ol>
<li><p>查找缓冲区表（本节假设页面不存在，找不到对应页面）。</p>
<p>第一，创建所需页面的buffer_tag（本例中buffer_tag 为’Tag_E’）并计算其散列桶槽。</p>
<p>第二，以共享模式获取相应分区上的 BufMappingLock。</p>
<p>第三，查找缓冲区表（根据假设，这里没找到）。</p>
<p>第四，释放 BufMappingLock。</p>
</li>
<li><p>从 freelist 中获取空缓冲区描述符，并将其钉住。在本例中所获的描述符 buffer_id=4。</p>
</li>
<li><p>以独占模式获取相应分区的 BufMappingLock （此锁将在步骤(6)中被释放）。</p>
</li>
<li><p>创建一条新的缓冲表数据项：buffer_tag=’Tag_E，buffer id=4，并将其插入缓冲区表中。</p>
</li>
<li><p>将页面数据从存储加载至 buffer_id=4 的缓冲池槽中，如下所示:</p>
<p>第一，以排他模式获取相应描述符的 io_in_progress_lock。</p>
<p>第二，将相应描述符的 IO_IN_PROGRESS 标记位设置为1，以防其他进程访问。</p>
<p>第三，将所需的页面数据从存储加载到缓冲池插槽中。</p>
<p>第四，更改相应描述符的状态，将 IO_IN_PROGRESS 标记位设置为”0”，且VALID标记位设置为”1”。</p>
<p>第五，释放 io_in_progress_lock。</p>
</li>
<li><p>释放相应分区的 BufMappingLock。</p>
</li>
<li><p>访问 bufferid=4 的缓冲池槽。</p>
</li>
</ol>
<h3 id="8-4-3-将页面从存储加载到受害者缓冲池槽"><a href="#8-4-3-将页面从存储加载到受害者缓冲池槽" class="headerlink" title="8.4.3 将页面从存储加载到受害者缓冲池槽"></a>8.4.3 将页面从存储加载到受害者缓冲池槽</h3><p>在这种情况下，假设所有缓冲池槽位都被页面占用，且未存储所需的页面。图 8.10、图8.11是将页面从存储加载到受害者缓冲池槽的示意</p>
<p>图。</p>
<p><img src="/medias/image/fig-8-10.png" alt="图8.10 将页面从存储加载到受害者缓冲池槽"></p>
<p><img src="/medias/image/fig-8-11.png" alt="图8.11 将页面从存储加载到受害者缓冲池槽（接图8.10）"></p>
<p>缓冲区管理器将执行以下步骤：</p>
<ol>
<li><p>创建所需页面的 buffer_tag 并查找缓冲表。在本例中假设 buffer_tag 是’Tag_M’（且相应的页面在缓冲区中找不到）。</p>
</li>
<li><p>使用时钟扫描算法选择一个受害者缓冲池槽位，从缓冲表中获取包含着受害者槽位 buffer_id 的旧表项，并在缓冲区描述符层将受害</p>
<p>者槽位的缓冲区描述符钉住。本例中受害者槽的 buffer_id=5，旧表项为 ‘Tag_F’，id = 5。时钟扫描将在下一节介绍。</p>
</li>
<li><p>如果受害者页面是脏页，则将其刷盘（write &amp; fsnc），否则进入步骤4。</p>
<p>在使用新数据覆盖脏页之前，必须将脏页写入存储中。脏页的刷盘步骤如下:</p>
<p>第一，获取 buffer_id=5 描述符上的共享 content_lock 和独占 io_in_progress_lock 。</p>
<p>第二，更改相应描述符的状态：相应 IO_IN_PROCESS 位设置为”1”，JUST_DIRTIED 位设置为”0”。</p>
<p>第三,根据具体情况，调用 <em>XLogFlush()</em> 函数将WAL缓冲区上的 WAL数据写入当前 WAL段文件（WAL和XLogFlush函数将在第9章中介绍）。</p>
<p>第四，将受害者页面的数据刷盘至存储中。</p>
<p>第五，更改相应描述符的状态：将 IO_IN_PROCESS 位设置为”0,将VALID位设置为”1”。</p>
<p>第六，释放 io_in_progress_lock 和 content_lock。</p>
</li>
<li><p>以排他模式获取缓冲区表中旧表项所在分区上的 BufMappingLock。</p>
</li>
<li><p>获取新表项所在分区上的 BufMappingLock，并将新表项插入缓冲表：</p>
<p>第一，创建新表项：由 buffer_tag=’Tag M’与受害者的 buffer_id 组成的新表项。</p>
<p>第二，以独占模式获取新表项所在分区上的 BufMappingLock。</p>
<p>第三，将新表项插入缓冲区表中。</p>
</li>
<li><p>从缓冲表中删除旧表项，并释放旧表项所在分区的 BufMappingLock。</p>
</li>
<li><p>将目标页面数据从存储加载至受害者槽位，然后用 buffer_id=5 更新描述符的标识字段，将脏位设置为0，并按流程初始化其他标记</p>
<p>位。</p>
</li>
<li><p>释放新表项所在分区上的 BufMappingLock。</p>
</li>
<li><p>访问 buffer_id=5 对应的缓冲区槽位。</p>
</li>
</ol>
<h3 id="8-4-4-页替换算法：时钟扫描"><a href="#8-4-4-页替换算法：时钟扫描" class="headerlink" title="8.4.4 页替换算法：时钟扫描"></a>8.4.4 页替换算法：时钟扫描</h3><p>本节的其余部分介绍了 <strong>时钟扫描</strong>算法。该算法是NFU（Not Frequently Used）算法的变体，开销较低，能高效地选出较少使用的页面。</p>
<p>我们将缓冲区描述符想象为一个循环列表，如图8.12所示。缓冲区描述符为黑色或灰色的方框，框中的数字显示每个描述符的 </p>
<p>usage_count。而 nextVictimBuffer 是一个32位的无符号整型变量，它总是指向某个缓冲区描述符并按顺时针顺序旋转。</p>
<p><img src="/medias/image/fig-8-12.png" alt="图8.12 时钟扫描 "></p>
<p>伪代码：时钟扫描<br>WHILE true</p>
<ol>
<li><p>获取 nextVictimBuffer 指向的候选缓冲区描述符。</p>
</li>
<li><p>如果候选描述符未被钉住，则进入步骤3，否则进入步骤4。</p>
</li>
<li><p>如果候选描述符的 usage_count 为0，则选择该描述符对应的槽作为受害者，并进入步骤5，否则将此描述符的 usage_count 减1，</p>
<p>并继续执行步骤4。</p>
</li>
<li><p>将 nextVictimBuffer 迭代至下一个描述符（如果到末尾则回绕至头部）并返回步骤1，重复直到找到受害者。</p>
</li>
<li><p>返回受害者的 buffer_id。</p>
</li>
</ol>
<p>该算法的伪代码与算法描述如下：</p>
<ol>
<li><p>nextVictimBuffer 指向第一个描述符(buffer_id=1)，但因为该描述符被钉住了，所以跳过。</p>
</li>
<li><p>nextVictimBuffer 指向第二个描述符(buffer_id=2)，该描述符未被钉住，但其 usage_count 为2，因此该描述符的 usage_count 将减</p>
<p>1,而nextVictimBuffer 选代至第三个候选描述符。</p>
</li>
<li><p>nextVictimBuffer 指向第三个描述符(buffer_id=3)，该描述符未被钉住，但其 usage_count=0，因而成为本轮的受害者。</p>
</li>
<li><p>当 nextVictimBuffer 扫过未钉住的描述符时，其 usage_count 会减1。因此只要缓冲池中存在未钉住的描述符，该算法总能在旋转若于次 nextVictimBuffer 后，找到一个 usage_count 为0的受害者。</p>
</li>
</ol>
<h2 id="8-5-环形缓冲器"><a href="#8-5-环形缓冲器" class="headerlink" title="8.5 环形缓冲器"></a>8.5 环形缓冲器</h2><p>在读取或写入大表时，PostgreSQL会使用<strong>环形缓冲区</strong>而不是缓冲池。环形缓冲器是一个很小的临时缓冲区域。当满足下列任一条件时，</p>
<p>PostgreSQL 将在共享内存中分配一个环形缓冲区。</p>
<ol>
<li><p>批量读取，当扫描关系读取数据的大小超过缓冲池的四分之一时，环形缓冲区的大小为256 KB。</p>
</li>
<li><p>批量写入，当执行下列的 SQL 命令时。环形缓冲区大小为16 MB。</p>
<p>COPY FROM</p>
<p>CREATE TABLE AS</p>
<p>CREATE MATERIALIZED VIEW 或 REFRESH MATERIALIZED VIEW 命令</p>
<p>ALTER TABLE</p>
</li>
<li><p>清理过程，当自动清理守护进程执行清理过程时，环形缓冲区的大小为256 KB。</p>
</li>
</ol>
<p>分配的环形缓冲区将在使用后立即释放。环形缓冲区的好处显而易见，如果后端进程在不使用环形缓冲区的情况下读取大表，则所有存储</p>
<p>在缓冲池中的页面都会被移除，这会导致缓存命中率降低。环形缓冲区可以避免此问题。</p>
<blockquote>
<p>为什么批量读取和清理过程的默认环形缓冲区大小为256KB</p>
<p>源代码中缓冲区管理器目录下的 <a target="_blank" rel="noopener" href="https://github.com/postgres/postgres/blob/master/src/backend/storage/buffer/README">README</a>中解释了这个问题。</p>
<p>顺序扫描使用 256KB的环形缓冲区，它足够小，因而能放入L2缓存中，从而使得操作系统缓存到共享缓冲区的页面传输变得高效。</p>
<p>通常更小一点也可以，但环形缓冲区需要足够大到能同时容纳扫描中被钉住的所有页面。</p>
</blockquote>
<h2 id="8-6-脏页刷盘"><a href="#8-6-脏页刷盘" class="headerlink" title="8.6 脏页刷盘"></a>8.6 脏页刷盘</h2><p>除了置换受害者页面之外，检查点进程和后台写入器进程也会将脏页刷盘至存储中。尽管两个进程都具有相同的功能（脏页刷盘），但是</p>
<p>它们有着不同的角色和行为。</p>
<p>检查点进程将检查点记录写入WAL段文件，并在检查点开始时进行脏页刷盘。第9.7节介绍了检查点和检查点开始的时机。</p>
<p>后台写入器的目的是通过少量多次的脏页刷盘，减少检查点带来的密集写入的影响。后台写入器会一点点地将脏页落盘，尽可能减少对数</p>
<p>据库活动造成的影响。在默认情况下，后台写入器每 200ms被唤醒一次（由参数 <code>bgwriter_delay</code> 定义），且最多刷写 </p>
<p><code>bgwriter_lrumaxpages</code> 个页面（默认为100个页面）。</p>
<blockquote>
<p>为什么检查点进程与后台写入器相分离</p>
<p>在 9.1及更低版本中，后台写入器会规律性地执行检查点进程。在 9.2 版本中，检查点进程从后台写入被单独剥离出来。原因在一篇</p>
<p>题为“将检查点进程与后台写入器相分离”的提案中有介绍。下面是一些摘录：</p>
<p>当前（在 2011 年）后台写入器进程既执行后台写入，又负责检查点，还处理一些其他的职责。这意味着我们没法在不停止后台写入</p>
<p>的情况下执行检查点最终的 fsync。因此，在同一个进程中做两件事会有负面的性能影响。</p>
<p>此外，在9.2版本中，我们的一个目标是通过将轮询循环替换为锁存器，从而降低功耗。bgwriter 中的循环复杂度太高了，以至于无</p>
<p>法找到一种简单的使用锁存器的方法。</p>
</blockquote>

                
            </div>
            <hr/>

            

    <div class="reprint" id="reprint-statement">
        
            <div class="reprint__author">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-user">
                        文章作者:
                    </i>
                </span>
                <span class="reprint-info">
                    <a href="/about" rel="external nofollow noreferrer">JINLID</a>
                </span>
            </div>
            <div class="reprint__type">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-link">
                        文章链接:
                    </i>
                </span>
                <span class="reprint-info">
                    <a href="https://jinlid.github.io/2021/8.huan-chong-qu-guan-li-qi/">https://jinlid.github.io/2021/8.huan-chong-qu-guan-li-qi/</a>
                </span>
            </div>
            <div class="reprint__notice">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-copyright">
                        版权声明:
                    </i>
                </span>
                <span class="reprint-info">
                    本博客所有文章除特別声明外，均采用
                    <a href="https://creativecommons.org/licenses/by/4.0/deed.zh" rel="external nofollow noreferrer" target="_blank">CC BY 4.0</a>
                    许可协议。转载请注明来源
                    <a href="/about" target="_blank">JINLID</a>
                    !
                </span>
            </div>
        
    </div>

    <script async defer>
      document.addEventListener("copy", function (e) {
        let toastHTML = '<span>复制成功，请遵循本文的转载规则</span><button class="btn-flat toast-action" onclick="navToReprintStatement()" style="font-size: smaller">查看</a>';
        M.toast({html: toastHTML})
      });

      function navToReprintStatement() {
        $("html, body").animate({scrollTop: $("#reprint-statement").offset().top - 80}, 800);
      }
    </script>



            <div class="tag_share" style="display: block;">
                <div class="post-meta__tag-list" style="display: inline-block;">
                    
                        <div class="article-tag">
                            
                                <a href="/tags/postgresql/">
                                    <span class="chip bg-color">postgresql</span>
                                </a>
                            
                        </div>
                    
                </div>
                <div class="post_share" style="zoom: 80%; width: fit-content; display: inline-block; float: right; margin: -0.15rem 0;">
                    <link rel="stylesheet" type="text/css" href="/libs/share/css/share.min.css">
<div id="article-share">

    
    <div class="social-share" data-sites="twitter,facebook,google,qq,qzone,wechat,weibo,douban,linkedin" data-wechat-qrcode-helper="<p>微信扫一扫即可分享！</p>"></div>
    <script src="/libs/share/js/social-share.min.js"></script>
    

    

</div>

                </div>
            </div>
            
                <div id="reward">
    <a href="#rewardModal" class="reward-link modal-trigger btn-floating btn-medium waves-effect waves-light red">赏</a>

    <!-- Modal Structure -->
    <div id="rewardModal" class="modal">
        <div class="modal-content">
            <a class="close modal-close"><i class="fas fa-times"></i></a>
            <h4 class="reward-title">你的赏识是我前进的动力</h4>
            <div class="reward-content">
                <div class="reward-tabs">
                    <ul class="tabs row">
                        <li class="tab col s6 alipay-tab waves-effect waves-light"><a href="#alipay">支付宝</a></li>
                        <li class="tab col s6 wechat-tab waves-effect waves-light"><a href="#wechat">微 信</a></li>
                    </ul>
                    <div id="alipay">
                        <img src="/medias/reward/alipay.jpg" class="reward-img" alt="支付宝打赏二维码">
                    </div>
                    <div id="wechat">
                        <img src="/medias/reward/wechat.png" class="reward-img" alt="微信打赏二维码">
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>

<script>
    $(function () {
        $('.tabs').tabs();
    });
</script>

            
        </div>
    </div>

    

    

    

    

    

    

    

    

    

<article id="prenext-posts" class="prev-next articles">
    <div class="row article-row">
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge left-badge text-color">
                <i class="fas fa-chevron-left"></i>&nbsp;上一篇</div>
            <div class="card">
                <a href="/2021/7.jin-dui-yuan-zu-he-jin-suo-yin-sao-miao/">
                    <div class="card-image">
                        
                        
                        <img src="/medias/featureimages/13.jpg" class="responsive-img" alt="7 仅堆元组和仅索引扫描">
                        
                        <span class="card-title">7 仅堆元组和仅索引扫描</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            本章描述了与索引扫描相关的两个特性，它们是仅堆元组和仅索引扫描。
                        
                    </div>
                    <div class="publish-info">
                        <span class="publish-date">
                            <i class="far fa-clock fa-fw icon-date"></i>2021-08-13
                        </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-bookmark fa-fw icon-category"></i>
                            
                            <a href="/categories/postgresql/" class="post-category">
                                    postgresql
                                </a>
                            
                            
                        </span>
                    </div>
                </div>
                
                <div class="card-action article-tags">
                    
                    <a href="/tags/postgresql/">
                        <span class="chip bg-color">postgresql</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge right-badge text-color">
                下一篇&nbsp;<i class="fas fa-chevron-right"></i>
            </div>
            <div class="card">
                <a href="/2021/9.yu-xie-ri-zhi-wal/">
                    <div class="card-image">
                        
                        
                        <img src="/medias/featureimages/12.jpg" class="responsive-img" alt="9 预写日志—WAL">
                        
                        <span class="card-title">9 预写日志—WAL</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            事务日志是数据库的重要组成部分，因为所有的数据库管理系统都要求即使发生系统故障也不丢失任何数据。它是数据库系统中所有更改操作的历史日志，以确保没有由于故障（例如电源故障）或其他导致服务器崩溃的服务器故障而丢失数据。由于日志包含有关已执行的每
                        
                    </div>
                    <div class="publish-info">
                            <span class="publish-date">
                                <i class="far fa-clock fa-fw icon-date"></i>2021-08-13
                            </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-bookmark fa-fw icon-category"></i>
                            
                            <a href="/categories/postgresql/" class="post-category">
                                    postgresql
                                </a>
                            
                            
                        </span>
                    </div>
                </div>
                
                <div class="card-action article-tags">
                    
                    <a href="/tags/postgresql/">
                        <span class="chip bg-color">postgresql</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
    </div>
</article>

</div>



<!-- 代码块功能依赖 -->
<script type="text/javascript" src="/libs/codeBlock/codeBlockFuction.js"></script>



<!-- 代码语言 -->

<script type="text/javascript" src="/libs/codeBlock/codeLang.js"></script>


<!-- 代码块复制 -->

<script type="text/javascript" src="/libs/codeBlock/codeCopy.js"></script>


<!-- 代码块收缩 -->

<script type="text/javascript" src="/libs/codeBlock/codeShrink.js"></script>



    </div>
    <div id="toc-aside" class="expanded col l3 hide-on-med-and-down">
        <div class="toc-widget card" style="background-color: white;">
            <div class="toc-title"><i class="far fa-list-alt"></i>&nbsp;&nbsp;目录</div>
            <div id="toc-content"></div>
        </div>
    </div>
</div>

<!-- TOC 悬浮按钮. -->

<div id="floating-toc-btn" class="hide-on-med-and-down">
    <a class="btn-floating btn-large bg-color">
        <i class="fas fa-list-ul"></i>
    </a>
</div>


<script src="/libs/tocbot/tocbot.min.js"></script>
<script>
    $(function () {
        tocbot.init({
            tocSelector: '#toc-content',
            contentSelector: '#articleContent',
            headingsOffset: -($(window).height() * 0.4 - 45),
            collapseDepth: Number('0'),
            headingSelector: 'h2, h3, h4'
        });

        // Set scroll toc fixed.
        let tocHeight = parseInt($(window).height() * 0.4 - 64);
        let $tocWidget = $('.toc-widget');
        $(window).scroll(function () {
            let scroll = $(window).scrollTop();
            /* add post toc fixed. */
            if (scroll > tocHeight) {
                $tocWidget.addClass('toc-fixed');
            } else {
                $tocWidget.removeClass('toc-fixed');
            }
        });

        
        /* 修复文章卡片 div 的宽度. */
        let fixPostCardWidth = function (srcId, targetId) {
            let srcDiv = $('#' + srcId);
            if (srcDiv.length === 0) {
                return;
            }

            let w = srcDiv.width();
            if (w >= 450) {
                w = w + 21;
            } else if (w >= 350 && w < 450) {
                w = w + 18;
            } else if (w >= 300 && w < 350) {
                w = w + 16;
            } else {
                w = w + 14;
            }
            $('#' + targetId).width(w);
        };

        // 切换TOC目录展开收缩的相关操作.
        const expandedClass = 'expanded';
        let $tocAside = $('#toc-aside');
        let $mainContent = $('#main-content');
        $('#floating-toc-btn .btn-floating').click(function () {
            if ($tocAside.hasClass(expandedClass)) {
                $tocAside.removeClass(expandedClass).hide();
                $mainContent.removeClass('l9');
            } else {
                $tocAside.addClass(expandedClass).show();
                $mainContent.addClass('l9');
            }
            fixPostCardWidth('artDetail', 'prenext-posts');
        });
        
    });
</script>

    

</main>




    <footer class="page-footer bg-color">
    

    <div class="container row center-align"
         style="margin-bottom: 0px !important;">
        <div class="col s12 m8 l8 copy-right">
            Copyright&nbsp;&copy;
            
                <span id="year">2019-2025</span>
            
            <a href="/about" target="_blank">JINLID</a>
            |&nbsp;Powered by&nbsp;<a href="https://hexo.io/" target="_blank">Hexo</a>
            |&nbsp;Theme&nbsp;<a href="https://github.com/blinkfox/hexo-theme-matery" target="_blank">Matery</a>
            
            <br>
            
            
            
                
            
            
                <span id="busuanzi_container_site_pv">
                &nbsp;|&nbsp;<i class="far fa-eye"></i>&nbsp;总访问量:&nbsp;
                    <span id="busuanzi_value_site_pv" class="white-color"></span>
            </span>
            
            
                <span id="busuanzi_container_site_uv">
                &nbsp;|&nbsp;<i class="fas fa-users"></i>&nbsp;总访问人数:&nbsp;
                    <span id="busuanzi_value_site_uv" class="white-color"></span>
            </span>
            
            <br>

            <!-- 运行天数提醒. -->
            
            <br>
            
        </div>
        <div class="col s12 m4 l4 social-link social-statis">
    <a href="https://github.com/jinlid" class="tooltipped" target="_blank" data-tooltip="访问我的GitHub" data-position="top" data-delay="50">
        <i class="fab fa-github"></i>
    </a>



    <a href="mailto:845401160@qq.com" class="tooltipped" target="_blank" data-tooltip="邮件联系我" data-position="top" data-delay="50">
        <i class="fas fa-envelope-open"></i>
    </a>







    <a href="tencent://AddContact/?fromId=50&fromSubId=1&subcmd=all&uin=845401160" class="tooltipped" target="_blank" data-tooltip="QQ联系我: 845401160" data-position="top" data-delay="50">
        <i class="fab fa-qq"></i>
    </a>







    <a href="/atom.xml" class="tooltipped" target="_blank" data-tooltip="RSS 订阅" data-position="top" data-delay="50">
        <i class="fas fa-rss"></i>
    </a>

</div>
    </div>
</footer>

<div class="progress-bar"></div>


    <!-- 搜索遮罩框 -->
<div id="searchModal" class="modal">
    <div class="modal-content">
        <div class="search-header">
            <span class="title"><i class="fas fa-search"></i>&nbsp;&nbsp;搜索</span>
            <input type="search" id="searchInput" name="s" placeholder="请输入搜索的关键字"
                   class="search-input">
        </div>
        <div id="searchResult"></div>
    </div>
</div>

<script type="text/javascript">
$(function () {
    var searchFunc = function (path, search_id, content_id) {
        'use strict';
        $.ajax({
            url: path,
            dataType: "xml",
            success: function (xmlResponse) {
                // get the contents from search data
                var datas = $("entry", xmlResponse).map(function () {
                    return {
                        title: $("title", this).text(),
                        content: $("content", this).text(),
                        url: $("url", this).text()
                    };
                }).get();
                var $input = document.getElementById(search_id);
                var $resultContent = document.getElementById(content_id);
                $input.addEventListener('input', function () {
                    var str = '<ul class=\"search-result-list\">';
                    var keywords = this.value.trim().toLowerCase().split(/[\s\-]+/);
                    $resultContent.innerHTML = "";
                    if (this.value.trim().length <= 0) {
                        return;
                    }
                    // perform local searching
                    datas.forEach(function (data) {
                        var isMatch = true;
                        var data_title = data.title.trim().toLowerCase();
                        var data_content = data.content.trim().replace(/<[^>]+>/g, "").toLowerCase();
                        var data_url = data.url;
                        data_url = data_url.indexOf('/') === 0 ? data.url : '/' + data_url;
                        var index_title = -1;
                        var index_content = -1;
                        var first_occur = -1;
                        // only match artiles with not empty titles and contents
                        if (data_title !== '' && data_content !== '') {
                            keywords.forEach(function (keyword, i) {
                                index_title = data_title.indexOf(keyword);
                                index_content = data_content.indexOf(keyword);
                                if (index_title < 0 && index_content < 0) {
                                    isMatch = false;
                                } else {
                                    if (index_content < 0) {
                                        index_content = 0;
                                    }
                                    if (i === 0) {
                                        first_occur = index_content;
                                    }
                                }
                            });
                        }
                        // show search results
                        if (isMatch) {
                            str += "<li><a href='" + data_url + "' class='search-result-title'>" + data_title + "</a>";
                            var content = data.content.trim().replace(/<[^>]+>/g, "");
                            if (first_occur >= 0) {
                                // cut out 100 characters
                                var start = first_occur - 20;
                                var end = first_occur + 80;
                                if (start < 0) {
                                    start = 0;
                                }
                                if (start === 0) {
                                    end = 100;
                                }
                                if (end > content.length) {
                                    end = content.length;
                                }
                                var match_content = content.substr(start, end);
                                // highlight all keywords
                                keywords.forEach(function (keyword) {
                                    var regS = new RegExp(keyword, "gi");
                                    match_content = match_content.replace(regS, "<em class=\"search-keyword\">" + keyword + "</em>");
                                });

                                str += "<p class=\"search-result\">" + match_content + "...</p>"
                            }
                            str += "</li>";
                        }
                    });
                    str += "</ul>";
                    $resultContent.innerHTML = str;
                });
            }
        });
    };

    searchFunc('/search.xml', 'searchInput', 'searchResult');
});
</script>

    <!-- 白天和黑夜主题 -->
<div class="stars-con">
    <div id="stars"></div>
    <div id="stars2"></div>
    <div id="stars3"></div>  
</div>

<script>
    function switchNightMode() {
        $('<div class="Cuteen_DarkSky"><div class="Cuteen_DarkPlanet"></div></div>').appendTo($('body')),
        setTimeout(function () {
            $('body').hasClass('DarkMode') 
            ? ($('body').removeClass('DarkMode'), localStorage.setItem('isDark', '0'), $('#sum-moon-icon').removeClass("fa-sun").addClass('fa-moon')) 
            : ($('body').addClass('DarkMode'), localStorage.setItem('isDark', '1'), $('#sum-moon-icon').addClass("fa-sun").removeClass('fa-moon')),
            
            setTimeout(function () {
            $('.Cuteen_DarkSky').fadeOut(1e3, function () {
                $(this).remove()
            })
            }, 2e3)
        })
    }
</script>

    <!-- 回到顶部按钮 -->
<div id="backTop" class="top-scroll">
    <a class="btn-floating btn-large waves-effect waves-light" href="#!">
        <i class="fas fa-arrow-up"></i>
    </a>
</div>


    <script src="/libs/materialize/materialize.min.js"></script>
    <script src="/libs/masonry/masonry.pkgd.min.js"></script>
    <script src="/libs/aos/aos.js"></script>
    <script src="/libs/scrollprogress/scrollProgress.min.js"></script>
    <script src="/libs/lightGallery/js/lightgallery-all.min.js"></script>
    <script src="/js/matery.js"></script>

    

    
    
    

    <!-- 雪花特效 -->
    

    <!-- 鼠标星星特效 -->
    

     
        <script src="https://ssl.captcha.qq.com/TCaptcha.js"></script>
        <script src="/libs/others/TencentCaptcha.js"></script>
        <button id="TencentCaptcha" data-appid="xxxxxxxxxx" data-cbfn="callback" type="button" hidden></button>
    

    <!-- Baidu Analytics -->

    <!-- Baidu Push -->

<script>
    (function () {
        var bp = document.createElement('script');
        var curProtocol = window.location.protocol.split(':')[0];
        if (curProtocol === 'https') {
            bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
        } else {
            bp.src = 'http://push.zhanzhang.baidu.com/push.js';
        }
        var s = document.getElementsByTagName("script")[0];
        s.parentNode.insertBefore(bp, s);
    })();
</script>

    
    <script src="/libs/others/clicklove.js" async="async"></script>
    
    
    <script async src="/libs/others/busuanzi.pure.mini.js"></script>
    

    

    

    <!--腾讯兔小巢-->
    
    

    

    

    
    <script src="/libs/instantpage/instantpage.js" type="module"></script>
    

</body>

</html>
